# Generated by Haxe 4.0.5
# coding: utf-8
import sys

import math as python_lib_Math
import math as Math
from os import path as python_lib_os_Path
import inspect as python_lib_Inspect
import os as python_lib_Os
import functools as python_lib_Functools
import timeit as python_lib_Timeit
import re as python_lib_Re
import sys as python_lib_Sys
import builtins as python_lib_Builtins
import json as python_lib_Json
import random as python_lib_Random
import subprocess as python_lib_Subprocess
from datetime import datetime as python_lib_datetime_Datetime
from datetime import timezone as python_lib_datetime_Timezone
from io import StringIO as python_lib_io_StringIO
import urllib.parse as python_lib_urllib_Parse

class _hx_AnonObject:
    _hx_disable_getattr = False
    def __init__(self, fields):
        self.__dict__ = fields
    def __repr__(self):
        return repr(self.__dict__)
    def __getattr__(self, name):
        if (self._hx_disable_getattr):
            raise AttributeError('field does not exist')
        else:
            return None
    def _hx_hasattr(self,field):
        self._hx_disable_getattr = True
        try:
            getattr(self, field)
            self._hx_disable_getattr = False
            return True
        except AttributeError:
            self._hx_disable_getattr = False
            return False



_hx_classes = {}


class Enum:
    _hx_class_name = "Enum"
    _hx_is_interface = "False"
    __slots__ = ("tag", "index", "params")
    _hx_fields = ["tag", "index", "params"]
    _hx_methods = ["__str__"]

    def __init__(self,tag,index,params):
        self.tag = tag
        self.index = index
        self.params = params

    def __str__(self):
        if (self.params is None):
            return self.tag
        else:
            return self.tag + '(' + (', '.join(str(v) for v in self.params)) + ')'

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.tag = None
        _hx_o.index = None
        _hx_o.params = None
Enum._hx_class = Enum
_hx_classes["Enum"] = Enum


class Class: pass


class Date:
    _hx_class_name = "Date"
    _hx_is_interface = "False"
    __slots__ = ("date", "dateUTC")
    _hx_fields = ["date", "dateUTC"]
    _hx_methods = ["toString"]
    _hx_statics = ["now", "fromTime", "makeLocal", "fromString"]

    def __init__(self,year,month,day,hour,_hx_min,sec):
        self.dateUTC = None
        if (year < python_lib_datetime_Datetime.min.year):
            year = python_lib_datetime_Datetime.min.year
        if (day == 0):
            day = 1
        self.date = Date.makeLocal(python_lib_datetime_Datetime(year,(month + 1),day,hour,_hx_min,sec,0))
        self.dateUTC = self.date.astimezone(python_lib_datetime_Timezone.utc)

    def toString(self):
        return self.date.strftime("%Y-%m-%d %H:%M:%S")

    @staticmethod
    def now():
        d = Date(2000,0,1,0,0,0)
        d.date = Date.makeLocal(python_lib_datetime_Datetime.now())
        d.dateUTC = d.date.astimezone(python_lib_datetime_Timezone.utc)
        return d

    @staticmethod
    def fromTime(t):
        d = Date(2000,0,1,0,0,0)
        d.date = Date.makeLocal(python_lib_datetime_Datetime.fromtimestamp((t / 1000.0)))
        d.dateUTC = d.date.astimezone(python_lib_datetime_Timezone.utc)
        return d

    @staticmethod
    def makeLocal(date):
        try:
            return date.astimezone()
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            tzinfo = python_lib_datetime_Datetime.now(python_lib_datetime_Timezone.utc).astimezone().tzinfo
            return date.replace(**python__KwArgs_KwArgs_Impl_.fromT(_hx_AnonObject({'tzinfo': tzinfo})))

    @staticmethod
    def fromString(s):
        _g = len(s)
        if (_g == 8):
            k = s.split(":")
            return Date.fromTime((((Std.parseInt((k[0] if 0 < len(k) else None)) * 3600000.) + ((Std.parseInt((k[1] if 1 < len(k) else None)) * 60000.))) + ((Std.parseInt((k[2] if 2 < len(k) else None)) * 1000.))))
        elif (_g == 10):
            k1 = s.split("-")
            return Date(Std.parseInt((k1[0] if 0 < len(k1) else None)),(Std.parseInt((k1[1] if 1 < len(k1) else None)) - 1),Std.parseInt((k1[2] if 2 < len(k1) else None)),0,0,0)
        elif (_g == 19):
            k2 = s.split(" ")
            _this = (k2[0] if 0 < len(k2) else None)
            y = _this.split("-")
            _this1 = (k2[1] if 1 < len(k2) else None)
            t = _this1.split(":")
            return Date(Std.parseInt((y[0] if 0 < len(y) else None)),(Std.parseInt((y[1] if 1 < len(y) else None)) - 1),Std.parseInt((y[2] if 2 < len(y) else None)),Std.parseInt((t[0] if 0 < len(t) else None)),Std.parseInt((t[1] if 1 < len(t) else None)),Std.parseInt((t[2] if 2 < len(t) else None)))
        else:
            raise _HxException(("Invalid date format : " + ("null" if s is None else s)))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.date = None
        _hx_o.dateUTC = None
Date._hx_class = Date
_hx_classes["Date"] = Date


class EReg:
    _hx_class_name = "EReg"
    _hx_is_interface = "False"
    __slots__ = ("pattern", "matchObj", "_hx_global")
    _hx_fields = ["pattern", "matchObj", "global"]
    _hx_methods = ["matchSub", "replace", "map"]

    def __init__(self,r,opt):
        self.matchObj = None
        self._hx_global = False
        options = 0
        _g = 0
        _g1 = len(opt)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            c = (-1 if ((i >= len(opt))) else ord(opt[i]))
            if (c == 109):
                options = (options | python_lib_Re.M)
            if (c == 105):
                options = (options | python_lib_Re.I)
            if (c == 115):
                options = (options | python_lib_Re.S)
            if (c == 117):
                options = (options | python_lib_Re.U)
            if (c == 103):
                self._hx_global = True
        self.pattern = python_lib_Re.compile(r,options)

    def matchSub(self,s,pos,_hx_len = None):
        if (_hx_len is None):
            _hx_len = -1
        if (_hx_len != -1):
            self.matchObj = self.pattern.search(s,pos,(pos + _hx_len))
        else:
            self.matchObj = self.pattern.search(s,pos)
        return (self.matchObj is not None)

    def replace(self,s,by):
        _this = by.split("$$")
        by1 = "_hx_#repl#__".join([python_Boot.toString1(x1,'') for x1 in _this])
        def _hx_local_0(x):
            res = by1
            g = x.groups()
            _g = 0
            _g1 = len(g)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                gs = g[i]
                if (gs is None):
                    continue
                delimiter = ("$" + HxOverrides.stringOrNull(str((i + 1))))
                _this1 = (list(res) if ((delimiter == "")) else res.split(delimiter))
                res = gs.join([python_Boot.toString1(x1,'') for x1 in _this1])
            _this2 = res.split("_hx_#repl#__")
            res = "$".join([python_Boot.toString1(x1,'') for x1 in _this2])
            return res
        replace = _hx_local_0
        return python_lib_Re.sub(self.pattern,replace,s,(0 if (self._hx_global) else 1))

    def map(self,s,f):
        buf_b = python_lib_io_StringIO()
        pos = 0
        right = s
        cur = self
        while (pos < len(s)):
            if (self.matchObj is None):
                self.matchObj = python_lib_Re.search(self.pattern,s)
            else:
                self.matchObj = self.matchObj.re.search(s,pos)
            if (self.matchObj is None):
                break
            pos1 = self.matchObj.end()
            curPos_pos = cur.matchObj.start()
            curPos_len = (cur.matchObj.end() - cur.matchObj.start())
            buf_b.write(Std.string(HxString.substr(HxString.substr(cur.matchObj.string,0,cur.matchObj.start()),pos,None)))
            buf_b.write(Std.string(f(cur)))
            right = HxString.substr(cur.matchObj.string,cur.matchObj.end(),None)
            if (not self._hx_global):
                buf_b.write(Std.string(right))
                return buf_b.getvalue()
            if (curPos_len == 0):
                buf_b.write(Std.string(("" if (((pos1 < 0) or ((pos1 >= len(s))))) else s[pos1])))
                right = HxString.substr(right,1,None)
                pos = (pos1 + 1)
            else:
                pos = pos1
        buf_b.write(Std.string(right))
        return buf_b.getvalue()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.pattern = None
        _hx_o.matchObj = None
        _hx_o._hx_global = None
EReg._hx_class = EReg
_hx_classes["EReg"] = EReg


class Frame:
    _hx_class_name = "Frame"
    _hx_is_interface = "False"
    __slots__ = ("pose",)
    _hx_fields = ["pose"]

    def __init__(self,data):
        dataSplit = data.split(" ")
        self.pose = list()
        i = 0
        while (i < len(dataSplit)):
            _this = self.pose
            x = [Std.parseFloat((dataSplit[i] if i >= 0 and i < len(dataSplit) else None)), Std.parseFloat(python_internal_ArrayImpl._get(dataSplit, (i + 1))), Std.parseFloat(python_internal_ArrayImpl._get(dataSplit, (i + 2)))]
            _this.append(x)
            i = (i + 3)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.pose = None
Frame._hx_class = Frame
_hx_classes["Frame"] = Frame


class Lambda:
    _hx_class_name = "Lambda"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["array"]

    @staticmethod
    def array(it):
        a = list()
        i = HxOverrides.iterator(it)
        while i.hasNext():
            i1 = i.next()
            a.append(i1)
        return a
Lambda._hx_class = Lambda
_hx_classes["Lambda"] = Lambda


class h3d_IDrawable:
    _hx_class_name = "h3d.IDrawable"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_methods = ["render"]
h3d_IDrawable._hx_class = h3d_IDrawable
_hx_classes["h3d.IDrawable"] = h3d_IDrawable


class hxd_App:
    _hx_class_name = "hxd.App"
    _hx_is_interface = "False"
    __slots__ = ("engine", "s3d", "s2d", "sevents", "isDisposed")
    _hx_fields = ["engine", "s3d", "s2d", "sevents", "isDisposed"]
    _hx_methods = ["onResize", "setScene", "setCurrent", "setScene2D", "setScene3D", "render", "setup", "dispose", "loadAssets", "init", "mainLoop", "update"]
    _hx_statics = ["staticHandler"]
    _hx_interfaces = [h3d_IDrawable]

    def __init__(self):
        self.isDisposed = None
        self.sevents = None
        self.s2d = None
        self.s3d = None
        self.engine = None
        _gthis = self
        engine = h3d_Engine.CURRENT
        if (engine is not None):
            self.engine = engine
            engine.onReady = self.setup
            haxe_Timer.delay(self.setup,0)
        else:
            def _hx_local_0():
                nonlocal engine
                engine = h3d_Engine()
                _gthis.engine = engine
                engine.onReady = _gthis.setup
                engine.init()
            hxd_System.start(_hx_local_0)

    def onResize(self):
        pass

    def setScene(self,scene,disposePrevious = None):
        if (disposePrevious is None):
            disposePrevious = True
        new2D = Std.downcast(scene,h2d_Scene)
        new3D = Std.downcast(scene,h3d_scene_Scene)
        if (new2D is not None):
            self.sevents.removeScene(self.s2d)
            self.sevents.addScene(scene,0)
        else:
            if (new3D is not None):
                self.sevents.removeScene(self.s3d)
            self.sevents.addScene(scene)
        if disposePrevious:
            if (new2D is not None):
                self.s2d.dispose()
            elif (new3D is not None):
                self.s3d.dispose()
            else:
                raise _HxException("Can't dispose previous scene")
        if (new2D is not None):
            self.s2d = new2D
        if (new3D is not None):
            self.s3d = new3D

    def setCurrent(self):
        _gthis = self
        self.engine = h3d_Engine.CURRENT
        self.isDisposed = False
        self.engine.onReady = hxd_App.staticHandler
        def _hx_local_0():
            if (_gthis.s2d is None):
                return
            _gthis.s2d.checkResize()
            _gthis.onResize()
        self.engine.onResized = _hx_local_0
        hxd_System.setLoop(self.mainLoop)

    def setScene2D(self,s2d,disposePrevious = None):
        if (disposePrevious is None):
            disposePrevious = True
        self.sevents.removeScene(self.s2d)
        self.sevents.addScene(s2d,0)
        if disposePrevious:
            self.s2d.dispose()
        self.s2d = s2d

    def setScene3D(self,s3d,disposePrevious = None):
        if (disposePrevious is None):
            disposePrevious = True
        self.sevents.removeScene(self.s3d)
        self.sevents.addScene(s3d)
        if disposePrevious:
            self.s3d.dispose()
        self.s3d = s3d

    def render(self,e):
        self.s3d.render(e)
        self.s2d.render(e)

    def setup(self):
        _gthis = self
        initDone = False
        self.engine.onReady = hxd_App.staticHandler
        def _hx_local_0():
            if (_gthis.s2d is None):
                return
            _gthis.s2d.checkResize()
            if initDone:
                _gthis.onResize()
        self.engine.onResized = _hx_local_0
        self.s3d = h3d_scene_Scene()
        self.s2d = h2d_Scene()
        self.sevents = hxd_SceneEvents()
        self.sevents.addScene(self.s2d)
        self.sevents.addScene(self.s3d)
        def _hx_local_1():
            nonlocal initDone
            initDone = True
            _gthis.init()
            hxd_Timer.skip()
            _gthis.mainLoop()
            hxd_System.setLoop(_gthis.mainLoop)
            hxd_Key.initialize()
        self.loadAssets(_hx_local_1)

    def dispose(self):
        self.engine.onResized = hxd_App.staticHandler
        self.engine.onContextLost = hxd_App.staticHandler
        self.isDisposed = True
        self.s2d.dispose()
        self.s3d.dispose()
        self.sevents.dispose()

    def loadAssets(self,onLoaded):
        onLoaded()

    def init(self):
        pass

    def mainLoop(self):
        hxd_Timer.update()
        self.sevents.checkEvents()
        if self.isDisposed:
            return
        self.update(hxd_Timer.dt)
        if self.isDisposed:
            return
        dt = hxd_Timer.dt
        if (self.s2d is not None):
            self.s2d.setElapsedTime(dt)
        if (self.s3d is not None):
            self.s3d.setElapsedTime(dt)
        self.engine.render(self)

    def update(self,dt):
        pass

    @staticmethod
    def staticHandler():
        pass

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.engine = None
        _hx_o.s3d = None
        _hx_o.s2d = None
        _hx_o.sevents = None
        _hx_o.isDisposed = None
hxd_App._hx_class = hxd_App
_hx_classes["hxd.App"] = hxd_App


class Main(hxd_App):
    _hx_class_name = "Main"
    _hx_is_interface = "False"
    __slots__ = ("boneData", "skeleton", "animation", "frameIdx")
    _hx_fields = ["boneData", "skeleton", "animation", "frameIdx"]
    _hx_methods = ["init", "update"]
    _hx_statics = ["main"]
    _hx_interfaces = []
    _hx_super = hxd_App


    def __init__(self):
        self.animation = None
        self.skeleton = None
        self.frameIdx = 0
        self.boneData = [[0.000, 1.011, 0.000], [0.008, 1.124, 0.016], [0.009, 1.216, 0.035], [0.008, 1.299, 0.053], [0.004, 1.382, 0.072], [-0.004, 1.502, 0.101], [-0.003, 1.580, 0.144], [-0.032, 1.448, 0.086], [-0.190, 1.427, 0.080], [-0.274, 1.200, 0.025], [-0.330, 1.009, -0.037], [0.031, 1.451, 0.090], [0.189, 1.428, 0.096], [0.207, 1.182, 0.073], [0.206, 0.974, 0.097], [-0.095, 1.020, 0.004], [-0.149, 0.472, 0.141], [-0.212, 0.068, 0.081], [-0.179, -0.004, 0.256], [0.096, 1.007, -0.003], [0.036, 0.444, -0.006], [0.045, 0.150, -0.297], [-0.120, 0.056, -0.277]]
        super().__init__()

    def init(self):
        super().init()
        self.skeleton = Skeleton(self)
        self.animation = SkeletonAnimation()
        h3d_scene_fwd_DirLight(h3d_Vector(0.3,-0.4,-0.9),self.s3d)
        _this = self.s3d.lightSystem.ambientLight
        _this.x = 0.564705882352941169
        _this.y = 0.564705882352941169
        _this.z = 0.564705882352941169
        _this.w = 0.
        h3d_scene_CameraController(None,self.s3d).loadFromCamera()

    def update(self,dt):
        if self.animation.ready:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.frameIdx
            _hx_local_0.frameIdx = (_hx_local_1 + 1)
            _hx_local_0.frameIdx
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.frameIdx
            _hx_local_2.frameIdx = HxOverrides.mod(_hx_local_3, len(self.animation.frames))
            _hx_local_2.frameIdx
            self.skeleton.setPose(python_internal_ArrayImpl._get(self.animation.frames, self.frameIdx).pose)

    @staticmethod
    def main():
        hxd_Res.set_loader(hxd_res_Loader(hxd_fs_EmbedFileSystem(haxe_Unserializer.run("og"))))
        Main()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.boneData = None
        _hx_o.skeleton = None
        _hx_o.animation = None
        _hx_o.frameIdx = None
Main._hx_class = Main
_hx_classes["Main"] = Main


class Reflect:
    _hx_class_name = "Reflect"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["field", "setField", "callMethod", "isFunction", "compare", "compareMethods", "isObject", "isEnumValue", "deleteField"]

    @staticmethod
    def field(o,field):
        return python_Boot.field(o,field)

    @staticmethod
    def setField(o,field,value):
        setattr(o,(("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field)),value)

    @staticmethod
    def callMethod(o,func,args):
        if callable(func):
            return func(*args)
        else:
            return None

    @staticmethod
    def isFunction(f):
        if (not ((python_lib_Inspect.isfunction(f) or python_lib_Inspect.ismethod(f)))):
            return python_Boot.hasField(f,"func_code")
        else:
            return True

    @staticmethod
    def compare(a,b):
        if ((a is None) and ((b is None))):
            return 0
        if (a is None):
            return 1
        elif (b is None):
            return -1
        elif HxOverrides.eq(a,b):
            return 0
        elif (a > b):
            return 1
        else:
            return -1

    @staticmethod
    def compareMethods(f1,f2):
        if HxOverrides.eq(f1,f2):
            return True
        if (isinstance(f1,python_internal_MethodClosure) and isinstance(f2,python_internal_MethodClosure)):
            m1 = f1
            m2 = f2
            if HxOverrides.eq(m1.obj,m2.obj):
                return (m1.func == m2.func)
            else:
                return False
        if ((not Reflect.isFunction(f1)) or (not Reflect.isFunction(f2))):
            return False
        return False

    @staticmethod
    def isObject(v):
        _g = Type.typeof(v)
        tmp = _g.index
        if (tmp == 4):
            return True
        elif (tmp == 6):
            _g1 = _g.params[0]
            return True
        else:
            return False

    @staticmethod
    def isEnumValue(v):
        if not HxOverrides.eq(v,Enum):
            return isinstance(v,Enum)
        else:
            return False

    @staticmethod
    def deleteField(o,field):
        field = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
        if (not python_Boot.hasField(o,field)):
            return False
        o.__delattr__(field)
        return True
Reflect._hx_class = Reflect
_hx_classes["Reflect"] = Reflect


class Skeleton:
    _hx_class_name = "Skeleton"
    _hx_is_interface = "False"
    __slots__ = ("boneIndices", "boneWidth", "bones")
    _hx_fields = ["boneIndices", "boneWidth", "bones"]
    _hx_methods = ["draw", "ground", "bone", "setBonePose", "setPose"]

    def __init__(self,main):
        self.bones = None
        self.boneWidth = 0.04
        self.boneIndices = [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [4, 7], [7, 8], [8, 9], [9, 10], [4, 11], [11, 12], [12, 13], [13, 14], [0, 15], [15, 16], [16, 17], [17, 18], [0, 19], [19, 20], [20, 21], [21, 22]]
        self.draw(main)

    def draw(self,main):
        self.ground(main)
        self.bones = list()
        _g = 0
        _g1 = len(self.boneIndices)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _this = self.bones
            x = self.bone(main)
            _this.append(x)

    def ground(self,main):
        prim = h3d_prim_Cube(4,4,0.01,True)
        prim.unindex()
        prim.addNormals()
        prim.addUVs()
        ground = h3d_scene_Mesh(prim,None,main.s3d)
        _this = ground.material.mshader.color__
        _this.x = 0.137254901960784326
        _this.y = 0.588235294117647078
        _this.z = 0.137254901960784326
        _this.w = 0.
        _this1 = ground.material
        _this1.set_castShadows(False)
        _this1.set_receiveShadows(False)

    def bone(self,main):
        bonePrim = h3d_prim_Cube(1,self.boneWidth,self.boneWidth)
        bonePrim.translate(0,(-self.boneWidth / 2),(-self.boneWidth / 2))
        bonePrim.unindex()
        bonePrim.addNormals()
        bonePrim.addUVs()
        bone = h3d_scene_Mesh(bonePrim,None,main.s3d)
        _this = bone.material.mshader.color__
        _this.x = 0.588235294117647078
        _this.y = 0.137254901960784326
        _this.z = 0.137254901960784326
        _this.w = 0.
        _this1 = bone.material
        _this1.set_castShadows(False)
        _this1.set_receiveShadows(False)
        return bone

    def setBonePose(self,bone,start,end):
        dir = h3d_Vector((end.x - start.x),(end.y - start.y),(end.z - start.z),(end.w - start.w))
        x = start.x
        y = start.y
        z = start.z
        bone.x = x
        f = 1
        b = True
        if b:
            bone.flags = (bone.flags | f)
        else:
            bone.flags = (bone.flags & ~f)
        bone.y = y
        f1 = 1
        b1 = True
        if b1:
            bone.flags = (bone.flags | f1)
        else:
            bone.flags = (bone.flags & ~f1)
        bone.z = z
        f2 = 1
        b2 = True
        if b2:
            bone.flags = (bone.flags | f2)
        else:
            bone.flags = (bone.flags & ~f2)
        f3 = 1
        b3 = True
        if b3:
            bone.flags = (bone.flags | f3)
        else:
            bone.flags = (bone.flags & ~f3)
        bone.setDirection(dir)
        f4 = (((dir.x * dir.x) + ((dir.y * dir.y))) + ((dir.z * dir.z)))
        v = (Math.NaN if ((f4 < 0)) else python_lib_Math.sqrt(f4))
        bone.scaleX = v
        f5 = 1
        b4 = True
        if b4:
            bone.flags = (bone.flags | f5)
        else:
            bone.flags = (bone.flags & ~f5)

    def setPose(self,pose):
        _g = 0
        _g1 = len(self.bones)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            s = python_internal_ArrayImpl._get(pose, python_internal_ArrayImpl._get((self.boneIndices[i] if i >= 0 and i < len(self.boneIndices) else None), 0))
            start = h3d_Vector((s[0] if 0 < len(s) else None),(s[2] if 2 < len(s) else None),(s[1] if 1 < len(s) else None))
            s = python_internal_ArrayImpl._get(pose, python_internal_ArrayImpl._get((self.boneIndices[i] if i >= 0 and i < len(self.boneIndices) else None), 1))
            end = h3d_Vector((s[0] if 0 < len(s) else None),(s[2] if 2 < len(s) else None),(s[1] if 1 < len(s) else None))
            self.setBonePose((self.bones[i] if i >= 0 and i < len(self.bones) else None),start,end)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.boneIndices = None
        _hx_o.boneWidth = None
        _hx_o.bones = None
Skeleton._hx_class = Skeleton
_hx_classes["Skeleton"] = Skeleton


class SkeletonAnimation:
    _hx_class_name = "SkeletonAnimation"
    _hx_is_interface = "False"
    __slots__ = ("frames", "ready")
    _hx_fields = ["frames", "ready"]
    _hx_methods = ["read"]

    def __init__(self):
        self.frames = None
        self.ready = False
        self.read()

    def read(self):
        self.frames = list()
        _this = sys_io_File.getContent("animation.txt")
        content = _this.split("\n")
        _g = 0
        _g1 = len(content)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _this1 = self.frames
            x = Frame((content[i] if i >= 0 and i < len(content) else None))
            _this1.append(x)
        self.ready = True

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.frames = None
        _hx_o.ready = None
SkeletonAnimation._hx_class = SkeletonAnimation
_hx_classes["SkeletonAnimation"] = SkeletonAnimation


class Std:
    _hx_class_name = "Std"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["downcast", "is", "string", "parseInt", "shortenPossibleNumber", "parseFloat"]

    @staticmethod
    def downcast(value,c):
        try:
            tmp = None
            if (not isinstance(value,c)):
                if c._hx_is_interface:
                    cls = c
                    loop = None
                    def _hx_local_1(intf):
                        f = (intf._hx_interfaces if (hasattr(intf,"_hx_interfaces")) else [])
                        if (f is not None):
                            _g = 0
                            while (_g < len(f)):
                                i = (f[_g] if _g >= 0 and _g < len(f) else None)
                                _g = (_g + 1)
                                if (i == cls):
                                    return True
                                else:
                                    l = loop(i)
                                    if l:
                                        return True
                            return False
                        else:
                            return False
                    loop = _hx_local_1
                    currentClass = value.__class__
                    result = False
                    while (currentClass is not None):
                        if loop(currentClass):
                            result = True
                            break
                        currentClass = python_Boot.getSuperClass(currentClass)
                    tmp = result
                else:
                    tmp = False
            else:
                tmp = True
            if tmp:
                return value
            else:
                return None
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            return None

    @staticmethod
    def _hx_is(v,t):
        if ((v is None) and ((t is None))):
            return False
        if (t is None):
            return False
        if (t == Dynamic):
            return (v is not None)
        isBool = isinstance(v,bool)
        if ((t == Bool) and isBool):
            return True
        if ((((not isBool) and (not (t == Bool))) and (t == Int)) and isinstance(v,int)):
            return True
        vIsFloat = isinstance(v,float)
        tmp = None
        tmp1 = None
        if (((not isBool) and vIsFloat) and (t == Int)):
            f = v
            tmp1 = (((f != Math.POSITIVE_INFINITY) and ((f != Math.NEGATIVE_INFINITY))) and (not python_lib_Math.isnan(f)))
        else:
            tmp1 = False
        if tmp1:
            tmp2 = None
            try:
                tmp2 = int(v)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                tmp2 = None
            tmp = (v == tmp2)
        else:
            tmp = False
        if ((tmp and ((v <= 2147483647))) and ((v >= -2147483648))):
            return True
        if (((not isBool) and (t == Float)) and isinstance(v,(float, int))):
            return True
        if (t == str):
            return isinstance(v,str)
        isEnumType = (t == Enum)
        if ((isEnumType and python_lib_Inspect.isclass(v)) and hasattr(v,"_hx_constructs")):
            return True
        if isEnumType:
            return False
        isClassType = (t == Class)
        if ((((isClassType and (not isinstance(v,Enum))) and python_lib_Inspect.isclass(v)) and hasattr(v,"_hx_class_name")) and (not hasattr(v,"_hx_constructs"))):
            return True
        if isClassType:
            return False
        tmp3 = None
        try:
            tmp3 = isinstance(v,t)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e1 = _hx_e1
            tmp3 = False
        if tmp3:
            return True
        if python_lib_Inspect.isclass(t):
            cls = t
            loop = None
            def _hx_local_1(intf):
                f1 = (intf._hx_interfaces if (hasattr(intf,"_hx_interfaces")) else [])
                if (f1 is not None):
                    _g = 0
                    while (_g < len(f1)):
                        i = (f1[_g] if _g >= 0 and _g < len(f1) else None)
                        _g = (_g + 1)
                        if (i == cls):
                            return True
                        else:
                            l = loop(i)
                            if l:
                                return True
                    return False
                else:
                    return False
            loop = _hx_local_1
            currentClass = v.__class__
            result = False
            while (currentClass is not None):
                if loop(currentClass):
                    result = True
                    break
                currentClass = python_Boot.getSuperClass(currentClass)
            return result
        else:
            return False

    @staticmethod
    def string(s):
        return python_Boot.toString1(s,"")

    @staticmethod
    def parseInt(x):
        if (x is None):
            return None
        try:
            return int(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            base = 10
            _hx_len = len(x)
            foundCount = 0
            sign = 0
            firstDigitIndex = 0
            lastDigitIndex = -1
            previous = 0
            _g = 0
            _g1 = _hx_len
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                c = (-1 if ((i >= len(x))) else ord(x[i]))
                if (((c > 8) and ((c < 14))) or ((c == 32))):
                    if (foundCount > 0):
                        return None
                    continue
                else:
                    c1 = c
                    if (c1 == 43):
                        if (foundCount == 0):
                            sign = 1
                        elif (not (((48 <= c) and ((c <= 57))))):
                            if (not (((base == 16) and ((((97 <= c) and ((c <= 122))) or (((65 <= c) and ((c <= 90))))))))):
                                break
                    elif (c1 == 45):
                        if (foundCount == 0):
                            sign = -1
                        elif (not (((48 <= c) and ((c <= 57))))):
                            if (not (((base == 16) and ((((97 <= c) and ((c <= 122))) or (((65 <= c) and ((c <= 90))))))))):
                                break
                    elif (c1 == 48):
                        if (not (((foundCount == 0) or (((foundCount == 1) and ((sign != 0))))))):
                            if (not (((48 <= c) and ((c <= 57))))):
                                if (not (((base == 16) and ((((97 <= c) and ((c <= 122))) or (((65 <= c) and ((c <= 90))))))))):
                                    break
                    elif ((c1 == 120) or ((c1 == 88))):
                        if ((previous == 48) and ((((foundCount == 1) and ((sign == 0))) or (((foundCount == 2) and ((sign != 0))))))):
                            base = 16
                        elif (not (((48 <= c) and ((c <= 57))))):
                            if (not (((base == 16) and ((((97 <= c) and ((c <= 122))) or (((65 <= c) and ((c <= 90))))))))):
                                break
                    elif (not (((48 <= c) and ((c <= 57))))):
                        if (not (((base == 16) and ((((97 <= c) and ((c <= 122))) or (((65 <= c) and ((c <= 90))))))))):
                            break
                if (((foundCount == 0) and ((sign == 0))) or (((foundCount == 1) and ((sign != 0))))):
                    firstDigitIndex = i
                foundCount = (foundCount + 1)
                lastDigitIndex = i
                previous = c
            if (firstDigitIndex <= lastDigitIndex):
                digits = HxString.substring(x,firstDigitIndex,(lastDigitIndex + 1))
                try:
                    return (((-1 if ((sign == -1)) else 1)) * int(digits,base))
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e1 = _hx_e1
                    return None
            return None

    @staticmethod
    def shortenPossibleNumber(x):
        r = ""
        _g = 0
        _g1 = len(x)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            c = ("" if (((i < 0) or ((i >= len(x))))) else x[i])
            _g2 = HxString.charCodeAt(c,0)
            if (_g2 is None):
                break
            else:
                _g3 = _g2
                if (((((((((((_g3 == 57) or ((_g3 == 56))) or ((_g3 == 55))) or ((_g3 == 54))) or ((_g3 == 53))) or ((_g3 == 52))) or ((_g3 == 51))) or ((_g3 == 50))) or ((_g3 == 49))) or ((_g3 == 48))) or ((_g3 == 46))):
                    r = (("null" if r is None else r) + ("null" if c is None else c))
                else:
                    break
        return r

    @staticmethod
    def parseFloat(x):
        try:
            return float(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            if (x is not None):
                r1 = Std.shortenPossibleNumber(x)
                if (r1 != x):
                    return Std.parseFloat(r1)
            return Math.NaN
Std._hx_class = Std
_hx_classes["Std"] = Std


class Float: pass


class Int: pass


class Bool: pass


class Dynamic: pass


class StringBuf:
    _hx_class_name = "StringBuf"
    _hx_is_interface = "False"
    __slots__ = ("b",)
    _hx_fields = ["b"]
    _hx_methods = ["get_length"]

    def __init__(self):
        self.b = python_lib_io_StringIO()

    def get_length(self):
        pos = self.b.tell()
        self.b.seek(0,2)
        _hx_len = self.b.tell()
        self.b.seek(pos,0)
        return _hx_len

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.b = None
StringBuf._hx_class = StringBuf
_hx_classes["StringBuf"] = StringBuf


class StringTools:
    _hx_class_name = "StringTools"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["htmlEscape", "isSpace", "ltrim", "rtrim", "trim", "lpad", "hex"]

    @staticmethod
    def htmlEscape(s,quotes = None):
        buf_b = python_lib_io_StringIO()
        _g_offset = 0
        _g_s = s
        while (_g_offset < len(_g_s)):
            s1 = _g_s
            index = _g_offset
            _g_offset = (_g_offset + 1)
            code = (-1 if ((index >= len(s1))) else ord(s1[index]))
            code1 = code
            if (code1 == 34):
                if quotes:
                    buf_b.write("&quot;")
                else:
                    buf_b.write("".join(map(chr,[code])))
            elif (code1 == 38):
                buf_b.write("&amp;")
            elif (code1 == 39):
                if quotes:
                    buf_b.write("&#039;")
                else:
                    buf_b.write("".join(map(chr,[code])))
            elif (code1 == 60):
                buf_b.write("&lt;")
            elif (code1 == 62):
                buf_b.write("&gt;")
            else:
                buf_b.write("".join(map(chr,[code])))
        return buf_b.getvalue()

    @staticmethod
    def isSpace(s,pos):
        if (((len(s) == 0) or ((pos < 0))) or ((pos >= len(s)))):
            return False
        c = HxString.charCodeAt(s,pos)
        if (not (((c > 8) and ((c < 14))))):
            return (c == 32)
        else:
            return True

    @staticmethod
    def ltrim(s):
        l = len(s)
        r = 0
        while ((r < l) and StringTools.isSpace(s,r)):
            r = (r + 1)
        if (r > 0):
            return HxString.substr(s,r,(l - r))
        else:
            return s

    @staticmethod
    def rtrim(s):
        l = len(s)
        r = 0
        while ((r < l) and StringTools.isSpace(s,((l - r) - 1))):
            r = (r + 1)
        if (r > 0):
            return HxString.substr(s,0,(l - r))
        else:
            return s

    @staticmethod
    def trim(s):
        return StringTools.ltrim(StringTools.rtrim(s))

    @staticmethod
    def lpad(s,c,l):
        if (len(c) <= 0):
            return s
        buf = StringBuf()
        l = (l - len(s))
        while (buf.get_length() < l):
            s1 = Std.string(c)
            buf.b.write(s1)
        s2 = Std.string(s)
        buf.b.write(s2)
        return buf.b.getvalue()

    @staticmethod
    def hex(n,digits = None):
        s = ""
        hexChars = "0123456789ABCDEF"
        while True:
            index = (n & 15)
            s = (HxOverrides.stringOrNull((("" if (((index < 0) or ((index >= len(hexChars))))) else hexChars[index]))) + ("null" if s is None else s))
            n = HxOverrides.rshift(n, 4)
            if (not ((n > 0))):
                break
        if ((digits is not None) and ((len(s) < digits))):
            diff = (digits - len(s))
            _g = 0
            _g1 = diff
            while (_g < _g1):
                _ = _g
                _g = (_g + 1)
                s = ("0" + ("null" if s is None else s))
        return s
StringTools._hx_class = StringTools
_hx_classes["StringTools"] = StringTools


class sys_FileSystem:
    _hx_class_name = "sys.FileSystem"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["exists", "stat", "fullPath", "isDirectory", "createDirectory", "deleteFile", "readDirectory"]

    @staticmethod
    def exists(path):
        return python_lib_os_Path.exists(path)

    @staticmethod
    def stat(path):
        s = python_lib_Os.stat(path)
        return _hx_AnonObject({'gid': s.st_gid, 'uid': s.st_uid, 'atime': Date.fromTime((1000 * s.st_atime)), 'mtime': Date.fromTime((1000 * s.st_mtime)), 'ctime': Date.fromTime((1000 * s.st_ctime)), 'size': s.st_size, 'dev': s.st_dev, 'ino': s.st_ino, 'nlink': s.st_nlink, 'rdev': getattr(s,"st_rdev",0), 'mode': s.st_mode})

    @staticmethod
    def fullPath(relPath):
        return python_lib_os_Path.realpath(relPath)

    @staticmethod
    def isDirectory(path):
        return python_lib_os_Path.isdir(path)

    @staticmethod
    def createDirectory(path):
        python_lib_Os.makedirs(path,511,True)

    @staticmethod
    def deleteFile(path):
        python_lib_Os.remove(path)

    @staticmethod
    def readDirectory(path):
        return python_lib_Os.listdir(path)
sys_FileSystem._hx_class = sys_FileSystem
_hx_classes["sys.FileSystem"] = sys_FileSystem


class haxe_IMap:
    _hx_class_name = "haxe.IMap"
    _hx_is_interface = "True"
    __slots__ = ()
haxe_IMap._hx_class = haxe_IMap
_hx_classes["haxe.IMap"] = haxe_IMap


class haxe_ds_StringMap:
    _hx_class_name = "haxe.ds.StringMap"
    _hx_is_interface = "False"
    __slots__ = ("h",)
    _hx_fields = ["h"]
    _hx_methods = ["remove", "keys", "iterator"]
    _hx_interfaces = [haxe_IMap]

    def __init__(self):
        self.h = dict()

    def remove(self,key):
        has = (key in self.h)
        if has:
            del self.h[key]
        return has

    def keys(self):
        return python_HaxeIterator(iter(self.h.keys()))

    def iterator(self):
        return python_HaxeIterator(iter(self.h.values()))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.h = None
haxe_ds_StringMap._hx_class = haxe_ds_StringMap
_hx_classes["haxe.ds.StringMap"] = haxe_ds_StringMap


class python_HaxeIterator:
    _hx_class_name = "python.HaxeIterator"
    _hx_is_interface = "False"
    __slots__ = ("it", "x", "has", "checked")
    _hx_fields = ["it", "x", "has", "checked"]
    _hx_methods = ["next", "hasNext"]

    def __init__(self,it):
        self.checked = False
        self.has = False
        self.x = None
        self.it = it

    def next(self):
        if (not self.checked):
            self.hasNext()
        self.checked = False
        return self.x

    def hasNext(self):
        if (not self.checked):
            try:
                self.x = self.it.__next__()
                self.has = True
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                if isinstance(_hx_e1, StopIteration):
                    s = _hx_e1
                    self.has = False
                    self.x = None
                else:
                    raise _hx_e
            self.checked = True
        return self.has

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.it = None
        _hx_o.x = None
        _hx_o.has = None
        _hx_o.checked = None
python_HaxeIterator._hx_class = python_HaxeIterator
_hx_classes["python.HaxeIterator"] = python_HaxeIterator


class Sys:
    _hx_class_name = "Sys"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["environ", "getEnv", "systemName", "command", "_programPath", "programPath"]

    @staticmethod
    def getEnv(s):
        return Sys.environ.h.get(s,None)

    @staticmethod
    def systemName():
        _g = python_lib_Sys.platform
        x = _g
        if x.startswith("linux"):
            return "Linux"
        else:
            _g1 = _g
            _hx_local_0 = len(_g1)
            if (_hx_local_0 == 5):
                if (_g1 == "win32"):
                    return "Windows"
                else:
                    raise _HxException("not supported platform")
            elif (_hx_local_0 == 6):
                if (_g1 == "cygwin"):
                    return "Windows"
                elif (_g1 == "darwin"):
                    return "Mac"
                else:
                    raise _HxException("not supported platform")
            else:
                raise _HxException("not supported platform")

    @staticmethod
    def command(cmd,args = None):
        if (args is None):
            return python_lib_Subprocess.call(cmd,**python__KwArgs_KwArgs_Impl_.fromT(_hx_AnonObject({'shell': True})))
        else:
            return python_lib_Subprocess.call(([cmd] + args))

    @staticmethod
    def programPath():
        return Sys._programPath
Sys._hx_class = Sys
_hx_classes["Sys"] = Sys

class ValueType(Enum):
    __slots__ = ()
    _hx_class_name = "ValueType"
    _hx_constructs = ["TNull", "TInt", "TFloat", "TBool", "TObject", "TFunction", "TClass", "TEnum", "TUnknown"]

    @staticmethod
    def TClass(c):
        return ValueType("TClass", 6, (c,))

    @staticmethod
    def TEnum(e):
        return ValueType("TEnum", 7, (e,))
ValueType.TNull = ValueType("TNull", 0, ())
ValueType.TInt = ValueType("TInt", 1, ())
ValueType.TFloat = ValueType("TFloat", 2, ())
ValueType.TBool = ValueType("TBool", 3, ())
ValueType.TObject = ValueType("TObject", 4, ())
ValueType.TFunction = ValueType("TFunction", 5, ())
ValueType.TUnknown = ValueType("TUnknown", 8, ())
ValueType._hx_class = ValueType
_hx_classes["ValueType"] = ValueType


class Type:
    _hx_class_name = "Type"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["getClass", "getSuperClass", "getClassName", "getEnumName", "resolveClass", "resolveEnum", "createEmptyInstance", "createEnum", "createEnumIndex", "getEnumConstructs", "typeof", "enumEq", "allEnums"]

    @staticmethod
    def getClass(o):
        if (o is None):
            return None
        o1 = o
        if ((o1 is not None) and ((HxOverrides.eq(o1,str) or python_lib_Inspect.isclass(o1)))):
            return None
        if isinstance(o,_hx_AnonObject):
            return None
        if hasattr(o,"_hx_class"):
            return o._hx_class
        if hasattr(o,"__class__"):
            return o.__class__
        else:
            return None

    @staticmethod
    def getSuperClass(c):
        return python_Boot.getSuperClass(c)

    @staticmethod
    def getClassName(c):
        if hasattr(c,"_hx_class_name"):
            return c._hx_class_name
        else:
            if (c == list):
                return "Array"
            if (c == Math):
                return "Math"
            if (c == str):
                return "String"
            try:
                return c.__name__
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                return None

    @staticmethod
    def getEnumName(e):
        return e._hx_class_name

    @staticmethod
    def resolveClass(name):
        if (name == "Array"):
            return list
        if (name == "Math"):
            return Math
        if (name == "String"):
            return str
        cl = _hx_classes.get(name,None)
        tmp = None
        if (cl is not None):
            o = cl
            tmp = (not (((o is not None) and ((HxOverrides.eq(o,str) or python_lib_Inspect.isclass(o))))))
        else:
            tmp = True
        if tmp:
            return None
        return cl

    @staticmethod
    def resolveEnum(name):
        if (name == "Bool"):
            return Bool
        o = Type.resolveClass(name)
        if hasattr(o,"_hx_constructs"):
            return o
        else:
            return None

    @staticmethod
    def createEmptyInstance(cl):
        i = cl.__new__(cl)
        callInit = None
        def _hx_local_0(cl1):
            sc = Type.getSuperClass(cl1)
            if (sc is not None):
                callInit(sc)
            if hasattr(cl1,"_hx_empty_init"):
                cl1._hx_empty_init(i)
        callInit = _hx_local_0
        callInit(cl)
        return i

    @staticmethod
    def createEnum(e,constr,params = None):
        f = Reflect.field(e,constr)
        if (f is None):
            raise _HxException(("No such constructor " + ("null" if constr is None else constr)))
        if Reflect.isFunction(f):
            if (params is None):
                raise _HxException((("Constructor " + ("null" if constr is None else constr)) + " need parameters"))
            return Reflect.callMethod(e,f,params)
        if ((params is not None) and ((len(params) != 0))):
            raise _HxException((("Constructor " + ("null" if constr is None else constr)) + " does not need parameters"))
        return f

    @staticmethod
    def createEnumIndex(e,index,params = None):
        c = python_internal_ArrayImpl._get(e._hx_constructs, index)
        if (c is None):
            raise _HxException((Std.string(index) + " is not a valid enum constructor index"))
        return Type.createEnum(e,c,params)

    @staticmethod
    def getEnumConstructs(e):
        if hasattr(e,"_hx_constructs"):
            x = e._hx_constructs
            return list(x)
        else:
            return []

    @staticmethod
    def typeof(v):
        if (v is None):
            return ValueType.TNull
        elif isinstance(v,bool):
            return ValueType.TBool
        elif isinstance(v,int):
            return ValueType.TInt
        elif isinstance(v,float):
            return ValueType.TFloat
        elif isinstance(v,str):
            return ValueType.TClass(str)
        elif isinstance(v,list):
            return ValueType.TClass(list)
        elif (isinstance(v,_hx_AnonObject) or python_lib_Inspect.isclass(v)):
            return ValueType.TObject
        elif isinstance(v,Enum):
            return ValueType.TEnum(v.__class__)
        elif (isinstance(v,type) or hasattr(v,"_hx_class")):
            return ValueType.TClass(v.__class__)
        elif callable(v):
            return ValueType.TFunction
        else:
            return ValueType.TUnknown

    @staticmethod
    def enumEq(a,b):
        if HxOverrides.eq(a,b):
            return True
        try:
            if ((b is None) and (not HxOverrides.eq(a,b))):
                return False
            if (a.tag != b.tag):
                return False
            p1 = a.params
            p2 = b.params
            if (len(p1) != len(p2)):
                return False
            _g = 0
            _g1 = len(p1)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                if (not Type.enumEq(p1[i],p2[i])):
                    return False
            if (a._hx_class != b._hx_class):
                return False
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            return False
        return True

    @staticmethod
    def allEnums(e):
        ctors = Type.getEnumConstructs(e)
        ret = []
        _g = 0
        while (_g < len(ctors)):
            ctor = (ctors[_g] if _g >= 0 and _g < len(ctors) else None)
            _g = (_g + 1)
            v = Reflect.field(e,ctor)
            if Std._hx_is(v,e):
                ret.append(v)
        return ret
Type._hx_class = Type
_hx_classes["Type"] = Type


class _Xml_XmlType_Impl_:
    _hx_class_name = "_Xml.XmlType_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["toString"]

    @staticmethod
    def toString(this1):
        _g = this1
        if (_g == 0):
            return "Element"
        elif (_g == 1):
            return "PCData"
        elif (_g == 2):
            return "CData"
        elif (_g == 3):
            return "Comment"
        elif (_g == 4):
            return "DocType"
        elif (_g == 5):
            return "ProcessingInstruction"
        elif (_g == 6):
            return "Document"
        else:
            pass
_Xml_XmlType_Impl_._hx_class = _Xml_XmlType_Impl_
_hx_classes["_Xml.XmlType_Impl_"] = _Xml_XmlType_Impl_


class Xml:
    _hx_class_name = "Xml"
    _hx_is_interface = "False"
    __slots__ = ("nodeType", "nodeName", "nodeValue", "parent", "children", "attributeMap")
    _hx_fields = ["nodeType", "nodeName", "nodeValue", "parent", "children", "attributeMap"]
    _hx_methods = ["get", "set", "exists", "attributes", "elements", "elementsNamed", "firstElement", "addChild", "removeChild", "toString"]
    _hx_statics = ["Element", "PCData", "CData", "Comment", "DocType", "ProcessingInstruction", "Document", "parse", "createElement", "createPCData", "createCData", "createComment", "createDocType", "createProcessingInstruction", "createDocument"]

    def __init__(self,nodeType):
        self.parent = None
        self.nodeValue = None
        self.nodeName = None
        self.nodeType = nodeType
        self.children = []
        self.attributeMap = haxe_ds_StringMap()

    def get(self,att):
        if (self.nodeType != Xml.Element):
            raise _HxException(("Bad node type, expected Element but found " + HxOverrides.stringOrNull(_Xml_XmlType_Impl_.toString(self.nodeType))))
        return self.attributeMap.h.get(att,None)

    def set(self,att,value):
        if (self.nodeType != Xml.Element):
            raise _HxException(("Bad node type, expected Element but found " + HxOverrides.stringOrNull(_Xml_XmlType_Impl_.toString(self.nodeType))))
        self.attributeMap.h[att] = value

    def exists(self,att):
        if (self.nodeType != Xml.Element):
            raise _HxException(("Bad node type, expected Element but found " + HxOverrides.stringOrNull(_Xml_XmlType_Impl_.toString(self.nodeType))))
        return (att in self.attributeMap.h)

    def attributes(self):
        if (self.nodeType != Xml.Element):
            raise _HxException(("Bad node type, expected Element but found " + HxOverrides.stringOrNull(_Xml_XmlType_Impl_.toString(self.nodeType))))
        return self.attributeMap.keys()

    def elements(self):
        if ((self.nodeType != Xml.Document) and ((self.nodeType != Xml.Element))):
            raise _HxException(("Bad node type, expected Element or Document but found " + HxOverrides.stringOrNull(_Xml_XmlType_Impl_.toString(self.nodeType))))
        _g = []
        _g1 = 0
        _g2 = self.children
        while (_g1 < len(_g2)):
            child = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
            _g1 = (_g1 + 1)
            if (child.nodeType == Xml.Element):
                _g.append(child)
        ret = _g
        return python_HaxeIterator(ret.__iter__())

    def elementsNamed(self,name):
        if ((self.nodeType != Xml.Document) and ((self.nodeType != Xml.Element))):
            raise _HxException(("Bad node type, expected Element or Document but found " + HxOverrides.stringOrNull(_Xml_XmlType_Impl_.toString(self.nodeType))))
        _g = []
        _g1 = 0
        _g2 = self.children
        while (_g1 < len(_g2)):
            child = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
            _g1 = (_g1 + 1)
            tmp = None
            if (child.nodeType == Xml.Element):
                if (child.nodeType != Xml.Element):
                    raise _HxException(("Bad node type, expected Element but found " + HxOverrides.stringOrNull(_Xml_XmlType_Impl_.toString(child.nodeType))))
                tmp = (child.nodeName == name)
            else:
                tmp = False
            if tmp:
                _g.append(child)
        ret = _g
        return python_HaxeIterator(ret.__iter__())

    def firstElement(self):
        if ((self.nodeType != Xml.Document) and ((self.nodeType != Xml.Element))):
            raise _HxException(("Bad node type, expected Element or Document but found " + HxOverrides.stringOrNull(_Xml_XmlType_Impl_.toString(self.nodeType))))
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            child = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (child.nodeType == Xml.Element):
                return child
        return None

    def addChild(self,x):
        if ((self.nodeType != Xml.Document) and ((self.nodeType != Xml.Element))):
            raise _HxException(("Bad node type, expected Element or Document but found " + HxOverrides.stringOrNull(_Xml_XmlType_Impl_.toString(self.nodeType))))
        if (x.parent is not None):
            x.parent.removeChild(x)
        _this = self.children
        _this.append(x)
        x.parent = self

    def removeChild(self,x):
        if ((self.nodeType != Xml.Document) and ((self.nodeType != Xml.Element))):
            raise _HxException(("Bad node type, expected Element or Document but found " + HxOverrides.stringOrNull(_Xml_XmlType_Impl_.toString(self.nodeType))))
        if python_internal_ArrayImpl.remove(self.children,x):
            x.parent = None
            return True
        return False

    def toString(self):
        return haxe_xml_Printer.print(self)

    @staticmethod
    def parse(_hx_str):
        return haxe_xml_Parser.parse(_hx_str)

    @staticmethod
    def createElement(name):
        xml = Xml(Xml.Element)
        if (xml.nodeType != Xml.Element):
            raise _HxException(("Bad node type, expected Element but found " + HxOverrides.stringOrNull(_Xml_XmlType_Impl_.toString(xml.nodeType))))
        xml.nodeName = name
        return xml

    @staticmethod
    def createPCData(data):
        xml = Xml(Xml.PCData)
        if ((xml.nodeType == Xml.Document) or ((xml.nodeType == Xml.Element))):
            raise _HxException(("Bad node type, unexpected " + HxOverrides.stringOrNull(_Xml_XmlType_Impl_.toString(xml.nodeType))))
        xml.nodeValue = data
        return xml

    @staticmethod
    def createCData(data):
        xml = Xml(Xml.CData)
        if ((xml.nodeType == Xml.Document) or ((xml.nodeType == Xml.Element))):
            raise _HxException(("Bad node type, unexpected " + HxOverrides.stringOrNull(_Xml_XmlType_Impl_.toString(xml.nodeType))))
        xml.nodeValue = data
        return xml

    @staticmethod
    def createComment(data):
        xml = Xml(Xml.Comment)
        if ((xml.nodeType == Xml.Document) or ((xml.nodeType == Xml.Element))):
            raise _HxException(("Bad node type, unexpected " + HxOverrides.stringOrNull(_Xml_XmlType_Impl_.toString(xml.nodeType))))
        xml.nodeValue = data
        return xml

    @staticmethod
    def createDocType(data):
        xml = Xml(Xml.DocType)
        if ((xml.nodeType == Xml.Document) or ((xml.nodeType == Xml.Element))):
            raise _HxException(("Bad node type, unexpected " + HxOverrides.stringOrNull(_Xml_XmlType_Impl_.toString(xml.nodeType))))
        xml.nodeValue = data
        return xml

    @staticmethod
    def createProcessingInstruction(data):
        xml = Xml(Xml.ProcessingInstruction)
        if ((xml.nodeType == Xml.Document) or ((xml.nodeType == Xml.Element))):
            raise _HxException(("Bad node type, unexpected " + HxOverrides.stringOrNull(_Xml_XmlType_Impl_.toString(xml.nodeType))))
        xml.nodeValue = data
        return xml

    @staticmethod
    def createDocument():
        return Xml(Xml.Document)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.nodeType = None
        _hx_o.nodeName = None
        _hx_o.nodeValue = None
        _hx_o.parent = None
        _hx_o.children = None
        _hx_o.attributeMap = None
Xml._hx_class = Xml
_hx_classes["Xml"] = Xml

class format_gif_Block(Enum):
    __slots__ = ()
    _hx_class_name = "format.gif.Block"
    _hx_constructs = ["BFrame", "BExtension", "BEOF"]

    @staticmethod
    def BFrame(frame):
        return format_gif_Block("BFrame", 0, (frame,))

    @staticmethod
    def BExtension(extension):
        return format_gif_Block("BExtension", 1, (extension,))
format_gif_Block.BEOF = format_gif_Block("BEOF", 2, ())
format_gif_Block._hx_class = format_gif_Block
_hx_classes["format.gif.Block"] = format_gif_Block

class format_gif_Extension(Enum):
    __slots__ = ()
    _hx_class_name = "format.gif.Extension"
    _hx_constructs = ["EGraphicControl", "EComment", "EText", "EApplicationExtension", "EUnknown"]

    @staticmethod
    def EGraphicControl(gce):
        return format_gif_Extension("EGraphicControl", 0, (gce,))

    @staticmethod
    def EComment(text):
        return format_gif_Extension("EComment", 1, (text,))

    @staticmethod
    def EText(pte):
        return format_gif_Extension("EText", 2, (pte,))

    @staticmethod
    def EApplicationExtension(ext):
        return format_gif_Extension("EApplicationExtension", 3, (ext,))

    @staticmethod
    def EUnknown(id,data):
        return format_gif_Extension("EUnknown", 4, (id,data))
format_gif_Extension._hx_class = format_gif_Extension
_hx_classes["format.gif.Extension"] = format_gif_Extension

class format_gif_ApplicationExtension(Enum):
    __slots__ = ()
    _hx_class_name = "format.gif.ApplicationExtension"
    _hx_constructs = ["AENetscapeLooping", "AEUnknown"]

    @staticmethod
    def AENetscapeLooping(loops):
        return format_gif_ApplicationExtension("AENetscapeLooping", 0, (loops,))

    @staticmethod
    def AEUnknown(name,version,data):
        return format_gif_ApplicationExtension("AEUnknown", 1, (name,version,data))
format_gif_ApplicationExtension._hx_class = format_gif_ApplicationExtension
_hx_classes["format.gif.ApplicationExtension"] = format_gif_ApplicationExtension

class format_gif_Version(Enum):
    __slots__ = ()
    _hx_class_name = "format.gif.Version"
    _hx_constructs = ["GIF87a", "GIF89a", "Unknown"]

    @staticmethod
    def Unknown(version):
        return format_gif_Version("Unknown", 2, (version,))
format_gif_Version.GIF87a = format_gif_Version("GIF87a", 0, ())
format_gif_Version.GIF89a = format_gif_Version("GIF89a", 1, ())
format_gif_Version._hx_class = format_gif_Version
_hx_classes["format.gif.Version"] = format_gif_Version

class format_gif_DisposalMethod(Enum):
    __slots__ = ()
    _hx_class_name = "format.gif.DisposalMethod"
    _hx_constructs = ["UNSPECIFIED", "NO_ACTION", "FILL_BACKGROUND", "RENDER_PREVIOUS", "UNDEFINED"]

    @staticmethod
    def UNDEFINED(index):
        return format_gif_DisposalMethod("UNDEFINED", 4, (index,))
format_gif_DisposalMethod.UNSPECIFIED = format_gif_DisposalMethod("UNSPECIFIED", 0, ())
format_gif_DisposalMethod.NO_ACTION = format_gif_DisposalMethod("NO_ACTION", 1, ())
format_gif_DisposalMethod.FILL_BACKGROUND = format_gif_DisposalMethod("FILL_BACKGROUND", 2, ())
format_gif_DisposalMethod.RENDER_PREVIOUS = format_gif_DisposalMethod("RENDER_PREVIOUS", 3, ())
format_gif_DisposalMethod._hx_class = format_gif_DisposalMethod
_hx_classes["format.gif.DisposalMethod"] = format_gif_DisposalMethod


class format_gif_Reader:
    _hx_class_name = "format.gif.Reader"
    _hx_is_interface = "False"
    __slots__ = ("i",)
    _hx_fields = ["i"]
    _hx_methods = ["read", "readBlock", "readImage", "readPixels", "deinterlace", "readExtension", "readApplicationExtension", "readBlocks", "readColorTable"]

    def __init__(self,i):
        self.i = i
        i.set_bigEndian(False)

    def read(self):
        b = 71
        if (self.i.readByte() != b):
            raise _HxException("Invalid header")
        b1 = 73
        if (self.i.readByte() != b1):
            raise _HxException("Invalid header")
        b2 = 70
        if (self.i.readByte() != b2):
            raise _HxException("Invalid header")
        gifVer = self.i.readString(3)
        version = format_gif_Version.GIF89a
        gifVer1 = gifVer
        if (gifVer1 == "87a"):
            version = format_gif_Version.GIF87a
        elif (gifVer1 == "89a"):
            version = format_gif_Version.GIF89a
        else:
            version = format_gif_Version.Unknown(gifVer)
        width = self.i.readUInt16()
        height = self.i.readUInt16()
        packedField = self.i.readByte()
        bgIndex = self.i.readByte()
        pixelAspectRatio = self.i.readByte()
        if (pixelAspectRatio != 0):
            pixelAspectRatio = (((pixelAspectRatio + 15)) / 64)
        else:
            pixelAspectRatio = 1
        lsd = _hx_AnonObject({'width': width, 'height': height, 'hasGlobalColorTable': (((packedField & 128)) == 128), 'colorResolution': HxOverrides.rshift(((packedField & 112)), 4), 'sorted': (((packedField & 8)) == 8), 'globalColorTableSize': (2 << ((packedField & 7))), 'backgroundColorIndex': bgIndex, 'pixelAspectRatio': pixelAspectRatio})
        gct = None
        if lsd.hasGlobalColorTable:
            gct = self.readColorTable(lsd.globalColorTableSize)
        blocks = haxe_ds_List()
        while True:
            b3 = self.readBlock()
            blocks.add(b3)
            if (b3 == format_gif_Block.BEOF):
                break
        return _hx_AnonObject({'version': version, 'logicalScreenDescriptor': lsd, 'globalColorTable': gct, 'blocks': blocks})

    def readBlock(self):
        blockID = self.i.readByte()
        blockID1 = blockID
        if (blockID1 == 33):
            return self.readExtension()
        elif (blockID1 == 44):
            return self.readImage()
        elif (blockID1 == 59):
            return format_gif_Block.BEOF
        else:
            pass
        return format_gif_Block.BEOF

    def readImage(self):
        x = self.i.readUInt16()
        y = self.i.readUInt16()
        width = self.i.readUInt16()
        height = self.i.readUInt16()
        packed = self.i.readByte()
        localColorTable = (((packed & 128)) == 128)
        interlaced = (((packed & 64)) == 64)
        sorted = (((packed & 32)) == 32)
        localColorTableSize = (2 << ((packed & 7)))
        lct = None
        if localColorTable:
            lct = self.readColorTable(localColorTableSize)
        return format_gif_Block.BFrame(_hx_AnonObject({'x': x, 'y': y, 'width': width, 'height': height, 'localColorTable': localColorTable, 'interlaced': interlaced, 'sorted': sorted, 'localColorTableSize': localColorTableSize, 'pixels': self.readPixels(width,height,interlaced), 'colorTable': lct}))

    def readPixels(self,width,height,interlaced):
        input = self.i
        pixelsCount = (width * height)
        pixels = haxe_io_Bytes.alloc(pixelsCount)
        minCodeSize = input.readByte()
        blockSize = (input.readByte() - 1)
        bits = input.readByte()
        bitsCount = 8
        clearCode = (1 << minCodeSize)
        eoiCode = (clearCode + 1)
        codeSize = (minCodeSize + 1)
        codeSizeLimit = (1 << codeSize)
        codeMask = (codeSizeLimit - 1)
        baseDict = list()
        _g = 0
        _g1 = clearCode
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            python_internal_ArrayImpl._set(baseDict, i, [i])
        _hx_dict = list()
        dictLen = (clearCode + 2)
        newRecord = None
        i1 = 0
        code = 0
        last = None
        while (i1 < pixelsCount):
            last = code
            while (bitsCount < codeSize):
                if (blockSize == 0):
                    break
                bits = (bits | ((input.readByte() << bitsCount)))
                bitsCount = (bitsCount + 8)
                blockSize = (blockSize - 1)
                if (blockSize == 0):
                    blockSize = input.readByte()
            code = (bits & codeMask)
            bits = (bits >> codeSize)
            bitsCount = (bitsCount - codeSize)
            if (code == clearCode):
                _hx_dict = list(baseDict)
                dictLen = (clearCode + 2)
                codeSize = (minCodeSize + 1)
                codeSizeLimit = (1 << codeSize)
                codeMask = (codeSizeLimit - 1)
                continue
            if (code == eoiCode):
                break
            if (code < dictLen):
                if (last != clearCode):
                    newRecord = list((_hx_dict[last] if last >= 0 and last < len(_hx_dict) else None))
                    newRecord.append(python_internal_ArrayImpl._get((_hx_dict[code] if code >= 0 and code < len(_hx_dict) else None), 0))
                    tmp = dictLen
                    dictLen = (dictLen + 1)
                    python_internal_ArrayImpl._set(_hx_dict, tmp, newRecord)
            else:
                if (code != dictLen):
                    raise _HxException(((("Invalid LZW code. Excepted: " + Std.string(dictLen)) + ", got: ") + Std.string(code)))
                newRecord = list((_hx_dict[last] if last >= 0 and last < len(_hx_dict) else None))
                newRecord.append((newRecord[0] if 0 < len(newRecord) else None))
                tmp1 = dictLen
                dictLen = (dictLen + 1)
                python_internal_ArrayImpl._set(_hx_dict, tmp1, newRecord)
            newRecord = (_hx_dict[code] if code >= 0 and code < len(_hx_dict) else None)
            _g2 = 0
            while (_g2 < len(newRecord)):
                item = (newRecord[_g2] if _g2 >= 0 and _g2 < len(newRecord) else None)
                _g2 = (_g2 + 1)
                pos = i1
                i1 = (i1 + 1)
                pixels.b[pos] = (item & 255)
            if ((dictLen == codeSizeLimit) and ((codeSize < 12))):
                codeSize = (codeSize + 1)
                codeSizeLimit = (1 << codeSize)
                codeMask = (codeSizeLimit - 1)
        while (blockSize > 0):
            input.readByte()
            blockSize = (blockSize - 1)
            if (blockSize == 0):
                blockSize = input.readByte()
        while (i1 < pixelsCount):
            pos1 = i1
            i1 = (i1 + 1)
            pixels.b[pos1] = 0
        if interlaced:
            buffer = haxe_io_Bytes.alloc(pixelsCount)
            offset = self.deinterlace(pixels,buffer,8,0,0,width,height)
            offset = self.deinterlace(pixels,buffer,8,4,offset,width,height)
            offset = self.deinterlace(pixels,buffer,4,2,offset,width,height)
            self.deinterlace(pixels,buffer,2,1,offset,width,height)
            pixels = buffer
        return pixels

    def deinterlace(self,input,output,step,y,offset,width,height):
        while (y < height):
            output.blit((y * width),input,offset,width)
            offset = (offset + width)
            y = (y + step)
        return offset

    def readExtension(self):
        subId = self.i.readByte()
        subId1 = subId
        if (subId1 == 1):
            if (self.i.readByte() != 12):
                raise _HxException("Incorrect size of Plain Text Extension introducer block.")
            tmp = self.i.readUInt16()
            tmp1 = self.i.readUInt16()
            tmp2 = self.i.readUInt16()
            tmp3 = self.i.readUInt16()
            tmp4 = self.i.readByte()
            tmp5 = self.i.readByte()
            tmp6 = self.i.readByte()
            tmp7 = self.i.readByte()
            buffer = haxe_io_BytesOutput()
            _hx_bytes = haxe_io_Bytes.alloc(255)
            _hx_len = self.i.readByte()
            while (_hx_len != 0):
                self.i.readBytes(_hx_bytes,0,_hx_len)
                buffer.writeBytes(_hx_bytes,0,_hx_len)
                _hx_len = self.i.readByte()
            buffer.flush()
            _hx_bytes = buffer.getBytes()
            buffer.close()
            return format_gif_Block.BExtension(format_gif_Extension.EText(_hx_AnonObject({'textGridX': tmp, 'textGridY': tmp1, 'textGridWidth': tmp2, 'textGridHeight': tmp3, 'charCellWidth': tmp4, 'charCellHeight': tmp5, 'textForegroundColorIndex': tmp6, 'textBackgroundColorIndex': tmp7, 'text': _hx_bytes.toString()})))
        elif (subId1 == 249):
            if (self.i.readByte() != 4):
                raise _HxException("Incorrect Graphic Control Extension block size!")
            packed = self.i.readByte()
            disposalMethod = None
            _g = (((packed & 28)) >> 2)
            if (_g == 0):
                disposalMethod = format_gif_DisposalMethod.UNSPECIFIED
            elif (_g == 1):
                disposalMethod = format_gif_DisposalMethod.NO_ACTION
            elif (_g == 2):
                disposalMethod = format_gif_DisposalMethod.FILL_BACKGROUND
            elif (_g == 3):
                disposalMethod = format_gif_DisposalMethod.RENDER_PREVIOUS
            else:
                disposalMethod = format_gif_DisposalMethod.UNDEFINED((((packed & 28)) >> 2))
            b = format_gif_Block.BExtension(format_gif_Extension.EGraphicControl(_hx_AnonObject({'disposalMethod': disposalMethod, 'userInput': (((packed & 2)) == 2), 'hasTransparentColor': (((packed & 1)) == 1), 'delay': self.i.readUInt16(), 'transparentIndex': self.i.readByte()})))
            self.i.readByte()
            return b
        elif (subId1 == 254):
            buffer1 = haxe_io_BytesOutput()
            bytes1 = haxe_io_Bytes.alloc(255)
            len1 = self.i.readByte()
            while (len1 != 0):
                self.i.readBytes(bytes1,0,len1)
                buffer1.writeBytes(bytes1,0,len1)
                len1 = self.i.readByte()
            buffer1.flush()
            bytes1 = buffer1.getBytes()
            buffer1.close()
            return format_gif_Block.BExtension(format_gif_Extension.EComment(bytes1.toString()))
        elif (subId1 == 255):
            return self.readApplicationExtension()
        else:
            buffer2 = haxe_io_BytesOutput()
            bytes2 = haxe_io_Bytes.alloc(255)
            len2 = self.i.readByte()
            while (len2 != 0):
                self.i.readBytes(bytes2,0,len2)
                buffer2.writeBytes(bytes2,0,len2)
                len2 = self.i.readByte()
            buffer2.flush()
            bytes2 = buffer2.getBytes()
            buffer2.close()
            return format_gif_Block.BExtension(format_gif_Extension.EUnknown(subId,bytes2))

    def readApplicationExtension(self):
        if (self.i.readByte() != 11):
            raise _HxException("Incorrect size of Application Extension introducer block.")
        name = self.i.readString(8)
        version = self.i.readString(3)
        buffer = haxe_io_BytesOutput()
        _hx_bytes = haxe_io_Bytes.alloc(255)
        _hx_len = self.i.readByte()
        while (_hx_len != 0):
            self.i.readBytes(_hx_bytes,0,_hx_len)
            buffer.writeBytes(_hx_bytes,0,_hx_len)
            _hx_len = self.i.readByte()
        buffer.flush()
        _hx_bytes = buffer.getBytes()
        buffer.close()
        data = _hx_bytes
        if (((name == "NETSCAPE") and ((version == "2.0"))) and ((data.b[0] == 1))):
            return format_gif_Block.BExtension(format_gif_Extension.EApplicationExtension(format_gif_ApplicationExtension.AENetscapeLooping((data.b[1] | ((data.b[2] << 8))))))
        return format_gif_Block.BExtension(format_gif_Extension.EApplicationExtension(format_gif_ApplicationExtension.AEUnknown(name,version,data)))

    def readBlocks(self):
        buffer = haxe_io_BytesOutput()
        _hx_bytes = haxe_io_Bytes.alloc(255)
        _hx_len = self.i.readByte()
        while (_hx_len != 0):
            self.i.readBytes(_hx_bytes,0,_hx_len)
            buffer.writeBytes(_hx_bytes,0,_hx_len)
            _hx_len = self.i.readByte()
        buffer.flush()
        _hx_bytes = buffer.getBytes()
        buffer.close()
        return _hx_bytes

    def readColorTable(self,size):
        size = (size * 3)
        output = haxe_io_Bytes.alloc(size)
        c = 0
        while (c < size):
            v = self.i.readByte()
            output.b[c] = (v & 255)
            v1 = self.i.readByte()
            output.b[(c + 1)] = (v1 & 255)
            v2 = self.i.readByte()
            output.b[(c + 2)] = (v2 & 255)
            c = (c + 3)
        return output

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.i = None
format_gif_Reader._hx_class = format_gif_Reader
_hx_classes["format.gif.Reader"] = format_gif_Reader


class format_gif_Tools:
    _hx_class_name = "format.gif.Tools"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["framesCount", "frame", "graphicControl", "extractBGRA", "extractRGBA", "extractFullBGRA", "extractFullRGBA", "loopCount", "LN2", "log2"]

    @staticmethod
    def framesCount(data):
        frames = 0
        _g_head = data.blocks.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            block = val
            if (block.index == 0):
                _g = block.params[0]
                frames = (frames + 1)
        return frames

    @staticmethod
    def frame(data,frameIndex):
        counter = 0
        _g_head = data.blocks.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            block = val
            if (block.index == 0):
                frame = block.params[0]
                if (counter == frameIndex):
                    return frame
                counter = (counter + 1)
        return None

    @staticmethod
    def graphicControl(data,frameIndex):
        counter = 0
        gce = None
        _g_head = data.blocks.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            block = val
            tmp = block.index
            if (tmp == 0):
                frame = block.params[0]
                if (counter == frameIndex):
                    return gce
                gce = None
                counter = (counter + 1)
            elif (tmp == 1):
                _g1 = block.params[0]
                if (_g1.index == 0):
                    g = _g1.params[0]
                    gce = g
            else:
                pass
        return None

    @staticmethod
    def extractBGRA(data,frameIndex):
        gce = None
        frameCaret = 0
        _g_head = data.blocks.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            block = val
            tmp = block.index
            if (tmp == 0):
                frame = block.params[0]
                if (frameCaret == frameIndex):
                    _hx_bytes = haxe_io_Bytes.alloc(((frame.width * frame.height) * 4))
                    ct = (frame.colorTable if (frame.localColorTable) else Reflect.field(data,"globalColorTable"))
                    if (ct is None):
                        raise _HxException("Frame does not have a color table!")
                    transparentIndex = ((gce.transparentIndex * 3) if (((gce is not None) and gce.hasTransparentColor)) else -1)
                    writeCaret = 0
                    _g = 0
                    _g1 = frame.pixels.length
                    while (_g < _g1):
                        i = _g
                        _g = (_g + 1)
                        index = (frame.pixels.b[i] * 3)
                        v = ct.b[(index + 2)]
                        _hx_bytes.b[writeCaret] = (v & 255)
                        v1 = ct.b[(index + 1)]
                        _hx_bytes.b[(writeCaret + 1)] = (v1 & 255)
                        v2 = ct.b[index]
                        _hx_bytes.b[(writeCaret + 2)] = (v2 & 255)
                        if (transparentIndex == index):
                            _hx_bytes.b[(writeCaret + 3)] = 0
                        else:
                            _hx_bytes.b[(writeCaret + 3)] = 255
                        writeCaret = (writeCaret + 4)
                    return _hx_bytes
                frameCaret = (frameCaret + 1)
                gce = None
            elif (tmp == 1):
                ext = block.params[0]
                if (ext.index == 0):
                    g = ext.params[0]
                    gce = g
            else:
                pass
        return None

    @staticmethod
    def extractRGBA(data,frameIndex):
        gce = None
        frameCaret = 0
        _g_head = data.blocks.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            block = val
            tmp = block.index
            if (tmp == 0):
                frame = block.params[0]
                if (frameCaret == frameIndex):
                    _hx_bytes = haxe_io_Bytes.alloc(((frame.width * frame.height) * 4))
                    ct = (frame.colorTable if (frame.localColorTable) else Reflect.field(data,"globalColorTable"))
                    if (ct is None):
                        raise _HxException("Frame does not have a color table!")
                    transparentIndex = ((gce.transparentIndex * 3) if (((gce is not None) and gce.hasTransparentColor)) else -1)
                    writeCaret = 0
                    _g = 0
                    _g1 = frame.pixels.length
                    while (_g < _g1):
                        i = _g
                        _g = (_g + 1)
                        index = (frame.pixels.b[i] * 3)
                        v = ct.b[index]
                        _hx_bytes.b[writeCaret] = (v & 255)
                        v1 = ct.b[(index + 1)]
                        _hx_bytes.b[(writeCaret + 1)] = (v1 & 255)
                        v2 = ct.b[(index + 2)]
                        _hx_bytes.b[(writeCaret + 2)] = (v2 & 255)
                        if (transparentIndex == index):
                            _hx_bytes.b[(writeCaret + 3)] = 0
                        else:
                            _hx_bytes.b[(writeCaret + 3)] = 255
                        writeCaret = (writeCaret + 4)
                    return _hx_bytes
                frameCaret = (frameCaret + 1)
                gce = None
            elif (tmp == 1):
                ext = block.params[0]
                if (ext.index == 0):
                    g = ext.params[0]
                    gce = g
            else:
                pass
        return None

    @staticmethod
    def extractFullBGRA(data,frameIndex):
        gce = None
        frameCaret = 0
        _hx_bytes = haxe_io_Bytes.alloc(((data.logicalScreenDescriptor.width * data.logicalScreenDescriptor.height) * 4))
        _g_head = data.blocks.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            block = val
            tmp = block.index
            if (tmp == 0):
                frame = block.params[0]
                ct = (frame.colorTable if (frame.localColorTable) else Reflect.field(data,"globalColorTable"))
                if (ct is None):
                    raise _HxException("Frame does not have a color table!")
                transparentIndex = ((gce.transparentIndex * 3) if (((gce is not None) and gce.hasTransparentColor)) else -1)
                pixels = frame.pixels
                x = 0
                writeCaret = ((((frame.y * data.logicalScreenDescriptor.width) + frame.x)) * 4)
                lineSkip = ((((data.logicalScreenDescriptor.width - frame.width)) * 4) + 4)
                disposalMethod = (gce.disposalMethod if (((frameCaret != frameIndex) and ((gce is not None)))) else format_gif_DisposalMethod.NO_ACTION)
                tmp1 = disposalMethod.index
                if (tmp1 == 2):
                    _g = 0
                    _g1 = pixels.length
                    while (_g < _g1):
                        i = _g
                        _g = (_g + 1)
                        _hx_bytes.b[writeCaret] = 0
                        _hx_bytes.b[(writeCaret + 1)] = 0
                        _hx_bytes.b[(writeCaret + 2)] = 0
                        _hx_bytes.b[(writeCaret + 3)] = 0
                        x = (x + 1)
                        tmp2 = x
                        if (tmp2 == frame.width):
                            x = 0
                            writeCaret = (writeCaret + lineSkip)
                        else:
                            writeCaret = (writeCaret + 4)
                elif (tmp1 == 3):
                    pass
                else:
                    _g2 = 0
                    _g11 = pixels.length
                    while (_g2 < _g11):
                        i1 = _g2
                        _g2 = (_g2 + 1)
                        index = (pixels.b[i1] * 3)
                        if (transparentIndex != index):
                            v = ct.b[(index + 2)]
                            _hx_bytes.b[writeCaret] = (v & 255)
                            v1 = ct.b[(index + 1)]
                            _hx_bytes.b[(writeCaret + 1)] = (v1 & 255)
                            v2 = ct.b[index]
                            _hx_bytes.b[(writeCaret + 2)] = (v2 & 255)
                            _hx_bytes.b[(writeCaret + 3)] = 255
                        x = (x + 1)
                        tmp3 = x
                        if (tmp3 == frame.width):
                            x = 0
                            writeCaret = (writeCaret + lineSkip)
                        else:
                            writeCaret = (writeCaret + 4)
                if (frameCaret == frameIndex):
                    return _hx_bytes
                frameCaret = (frameCaret + 1)
                gce = None
            elif (tmp == 1):
                ext = block.params[0]
                if (ext.index == 0):
                    g = ext.params[0]
                    gce = g
            else:
                pass
        return _hx_bytes

    @staticmethod
    def extractFullRGBA(data,frameIndex):
        gce = None
        frameCaret = 0
        _hx_bytes = haxe_io_Bytes.alloc(((data.logicalScreenDescriptor.width * data.logicalScreenDescriptor.height) * 4))
        _g_head = data.blocks.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            block = val
            tmp = block.index
            if (tmp == 0):
                frame = block.params[0]
                ct = (frame.colorTable if (frame.localColorTable) else Reflect.field(data,"globalColorTable"))
                if (ct is None):
                    raise _HxException("Frame does not have a color table!")
                transparentIndex = ((gce.transparentIndex * 3) if (((gce is not None) and gce.hasTransparentColor)) else -1)
                pixels = frame.pixels
                x = 0
                writeCaret = ((((frame.y * data.logicalScreenDescriptor.width) + frame.x)) * 4)
                lineSkip = ((((data.logicalScreenDescriptor.width - frame.width)) * 4) + 4)
                disposalMethod = (gce.disposalMethod if (((frameCaret != frameIndex) and ((gce is not None)))) else format_gif_DisposalMethod.NO_ACTION)
                tmp1 = disposalMethod.index
                if (tmp1 == 2):
                    _g = 0
                    _g1 = pixels.length
                    while (_g < _g1):
                        i = _g
                        _g = (_g + 1)
                        _hx_bytes.b[writeCaret] = 0
                        _hx_bytes.b[(writeCaret + 1)] = 0
                        _hx_bytes.b[(writeCaret + 2)] = 0
                        _hx_bytes.b[(writeCaret + 3)] = 0
                        x = (x + 1)
                        tmp2 = x
                        if (tmp2 == frame.width):
                            x = 0
                            writeCaret = (writeCaret + lineSkip)
                        else:
                            writeCaret = (writeCaret + 4)
                elif (tmp1 == 3):
                    pass
                else:
                    _g2 = 0
                    _g11 = pixels.length
                    while (_g2 < _g11):
                        i1 = _g2
                        _g2 = (_g2 + 1)
                        index = (pixels.b[i1] * 3)
                        if (transparentIndex != index):
                            v = ct.b[index]
                            _hx_bytes.b[writeCaret] = (v & 255)
                            v1 = ct.b[(index + 1)]
                            _hx_bytes.b[(writeCaret + 1)] = (v1 & 255)
                            v2 = ct.b[(index + 2)]
                            _hx_bytes.b[(writeCaret + 2)] = (v2 & 255)
                            _hx_bytes.b[(writeCaret + 3)] = 255
                        x = (x + 1)
                        tmp3 = x
                        if (tmp3 == frame.width):
                            x = 0
                            writeCaret = (writeCaret + lineSkip)
                        else:
                            writeCaret = (writeCaret + 4)
                if (frameCaret == frameIndex):
                    return _hx_bytes
                frameCaret = (frameCaret + 1)
                gce = None
            elif (tmp == 1):
                ext = block.params[0]
                if (ext.index == 0):
                    g = ext.params[0]
                    gce = g
            else:
                pass
        return _hx_bytes

    @staticmethod
    def loopCount(data):
        _g_head = data.blocks.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            block = val
            if (block.index == 1):
                _g = block.params[0]
                if (_g.index == 3):
                    _g1 = _g.params[0]
                    if (_g1.index == 0):
                        loops = _g1.params[0]
                        return loops
        return 1

    @staticmethod
    def log2(val):
        return (((Math.NEGATIVE_INFINITY if ((val == 0.0)) else (Math.NaN if ((val < 0.0)) else python_lib_Math.log(val)))) / format_gif_Tools.LN2)
format_gif_Tools._hx_class = format_gif_Tools
_hx_classes["format.gif.Tools"] = format_gif_Tools

class format_mp3_SamplingRate(Enum):
    __slots__ = ()
    _hx_class_name = "format.mp3.SamplingRate"
    _hx_constructs = ["SR_8000", "SR_11025", "SR_12000", "SR_22050", "SR_24000", "SR_32000", "SR_44100", "SR_48000", "SR_Bad"]
format_mp3_SamplingRate.SR_8000 = format_mp3_SamplingRate("SR_8000", 0, ())
format_mp3_SamplingRate.SR_11025 = format_mp3_SamplingRate("SR_11025", 1, ())
format_mp3_SamplingRate.SR_12000 = format_mp3_SamplingRate("SR_12000", 2, ())
format_mp3_SamplingRate.SR_22050 = format_mp3_SamplingRate("SR_22050", 3, ())
format_mp3_SamplingRate.SR_24000 = format_mp3_SamplingRate("SR_24000", 4, ())
format_mp3_SamplingRate.SR_32000 = format_mp3_SamplingRate("SR_32000", 5, ())
format_mp3_SamplingRate.SR_44100 = format_mp3_SamplingRate("SR_44100", 6, ())
format_mp3_SamplingRate.SR_48000 = format_mp3_SamplingRate("SR_48000", 7, ())
format_mp3_SamplingRate.SR_Bad = format_mp3_SamplingRate("SR_Bad", 8, ())
format_mp3_SamplingRate._hx_class = format_mp3_SamplingRate
_hx_classes["format.mp3.SamplingRate"] = format_mp3_SamplingRate

class format_mp3_Bitrate(Enum):
    __slots__ = ()
    _hx_class_name = "format.mp3.Bitrate"
    _hx_constructs = ["BR_8", "BR_16", "BR_24", "BR_32", "BR_40", "BR_48", "BR_56", "BR_64", "BR_80", "BR_96", "BR_112", "BR_128", "BR_144", "BR_160", "BR_176", "BR_192", "BR_224", "BR_256", "BR_288", "BR_320", "BR_352", "BR_384", "BR_416", "BR_448", "BR_Free", "BR_Bad"]
format_mp3_Bitrate.BR_8 = format_mp3_Bitrate("BR_8", 0, ())
format_mp3_Bitrate.BR_16 = format_mp3_Bitrate("BR_16", 1, ())
format_mp3_Bitrate.BR_24 = format_mp3_Bitrate("BR_24", 2, ())
format_mp3_Bitrate.BR_32 = format_mp3_Bitrate("BR_32", 3, ())
format_mp3_Bitrate.BR_40 = format_mp3_Bitrate("BR_40", 4, ())
format_mp3_Bitrate.BR_48 = format_mp3_Bitrate("BR_48", 5, ())
format_mp3_Bitrate.BR_56 = format_mp3_Bitrate("BR_56", 6, ())
format_mp3_Bitrate.BR_64 = format_mp3_Bitrate("BR_64", 7, ())
format_mp3_Bitrate.BR_80 = format_mp3_Bitrate("BR_80", 8, ())
format_mp3_Bitrate.BR_96 = format_mp3_Bitrate("BR_96", 9, ())
format_mp3_Bitrate.BR_112 = format_mp3_Bitrate("BR_112", 10, ())
format_mp3_Bitrate.BR_128 = format_mp3_Bitrate("BR_128", 11, ())
format_mp3_Bitrate.BR_144 = format_mp3_Bitrate("BR_144", 12, ())
format_mp3_Bitrate.BR_160 = format_mp3_Bitrate("BR_160", 13, ())
format_mp3_Bitrate.BR_176 = format_mp3_Bitrate("BR_176", 14, ())
format_mp3_Bitrate.BR_192 = format_mp3_Bitrate("BR_192", 15, ())
format_mp3_Bitrate.BR_224 = format_mp3_Bitrate("BR_224", 16, ())
format_mp3_Bitrate.BR_256 = format_mp3_Bitrate("BR_256", 17, ())
format_mp3_Bitrate.BR_288 = format_mp3_Bitrate("BR_288", 18, ())
format_mp3_Bitrate.BR_320 = format_mp3_Bitrate("BR_320", 19, ())
format_mp3_Bitrate.BR_352 = format_mp3_Bitrate("BR_352", 20, ())
format_mp3_Bitrate.BR_384 = format_mp3_Bitrate("BR_384", 21, ())
format_mp3_Bitrate.BR_416 = format_mp3_Bitrate("BR_416", 22, ())
format_mp3_Bitrate.BR_448 = format_mp3_Bitrate("BR_448", 23, ())
format_mp3_Bitrate.BR_Free = format_mp3_Bitrate("BR_Free", 24, ())
format_mp3_Bitrate.BR_Bad = format_mp3_Bitrate("BR_Bad", 25, ())
format_mp3_Bitrate._hx_class = format_mp3_Bitrate
_hx_classes["format.mp3.Bitrate"] = format_mp3_Bitrate


class format_mp3_MPEG:
    _hx_class_name = "format.mp3.MPEG"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["V1", "V2", "V25", "Reserved", "enum2Num", "num2Enum", "V1_Bitrates", "V2_Bitrates", "SamplingRates", "srNum2Enum", "srEnum2Num", "getBitrateIdx", "getSamplingRateIdx", "bitrateEnum2Num", "bitrateNum2Enum"]

    @staticmethod
    def enum2Num(m):
        tmp = m.index
        if (tmp == 0):
            return 3
        elif (tmp == 1):
            return 2
        elif (tmp == 2):
            return 0
        elif (tmp == 3):
            return format_mp3_MPEG.Reserved
        else:
            pass

    @staticmethod
    def num2Enum(m):
        m1 = m
        if (m1 == 0):
            return format_mp3_MPEGVersion.MPEG_V25
        elif (m1 == 2):
            return format_mp3_MPEGVersion.MPEG_V2
        elif (m1 == 3):
            return format_mp3_MPEGVersion.MPEG_V1
        else:
            return format_mp3_MPEGVersion.MPEG_Reserved

    @staticmethod
    def srNum2Enum(sr):
        sr1 = sr
        if (sr1 == 8000):
            return format_mp3_SamplingRate.SR_8000
        elif (sr1 == 11025):
            return format_mp3_SamplingRate.SR_11025
        elif (sr1 == 12000):
            return format_mp3_SamplingRate.SR_12000
        elif (sr1 == 22050):
            return format_mp3_SamplingRate.SR_22050
        elif (sr1 == 24000):
            return format_mp3_SamplingRate.SR_24000
        elif (sr1 == 32000):
            return format_mp3_SamplingRate.SR_32000
        elif (sr1 == 44100):
            return format_mp3_SamplingRate.SR_44100
        elif (sr1 == 48000):
            return format_mp3_SamplingRate.SR_48000
        else:
            return format_mp3_SamplingRate.SR_Bad

    @staticmethod
    def srEnum2Num(sr):
        tmp = sr.index
        if (tmp == 0):
            return 8000
        elif (tmp == 1):
            return 11025
        elif (tmp == 2):
            return 12000
        elif (tmp == 3):
            return 22050
        elif (tmp == 4):
            return 24000
        elif (tmp == 5):
            return 32000
        elif (tmp == 6):
            return 44100
        elif (tmp == 7):
            return 48000
        elif (tmp == 8):
            return -1
        else:
            pass

    @staticmethod
    def getBitrateIdx(br,mpeg,layer):
        arr = python_internal_ArrayImpl._get(((format_mp3_MPEG.V1_Bitrates if ((mpeg == format_mp3_MPEGVersion.MPEG_V1)) else format_mp3_MPEG.V2_Bitrates)), format_mp3_CLayer.enum2Num(layer))
        if ((arr[0] if 0 < len(arr) else None) == br):
            return 0
        if ((arr[1] if 1 < len(arr) else None) == br):
            return 1
        if ((arr[2] if 2 < len(arr) else None) == br):
            return 2
        if ((arr[3] if 3 < len(arr) else None) == br):
            return 3
        if ((arr[4] if 4 < len(arr) else None) == br):
            return 4
        if ((arr[5] if 5 < len(arr) else None) == br):
            return 5
        if ((arr[6] if 6 < len(arr) else None) == br):
            return 6
        if ((arr[7] if 7 < len(arr) else None) == br):
            return 7
        if ((arr[8] if 8 < len(arr) else None) == br):
            return 8
        if ((arr[9] if 9 < len(arr) else None) == br):
            return 9
        if ((arr[10] if 10 < len(arr) else None) == br):
            return 10
        if ((arr[11] if 11 < len(arr) else None) == br):
            return 11
        if ((arr[12] if 12 < len(arr) else None) == br):
            return 12
        if ((arr[13] if 13 < len(arr) else None) == br):
            return 13
        if ((arr[14] if 14 < len(arr) else None) == br):
            return 14
        if ((arr[15] if 15 < len(arr) else None) == br):
            return 15
        raise _HxException("Bitrate index not found")

    @staticmethod
    def getSamplingRateIdx(sr,mpeg):
        arr = python_internal_ArrayImpl._get(format_mp3_MPEG.SamplingRates, format_mp3_MPEG.enum2Num(mpeg))
        if ((arr[0] if 0 < len(arr) else None) == sr):
            return 0
        if ((arr[1] if 1 < len(arr) else None) == sr):
            return 1
        if ((arr[2] if 2 < len(arr) else None) == sr):
            return 2
        if ((arr[3] if 3 < len(arr) else None) == sr):
            return 3
        raise _HxException("Sampling rate index not found")

    @staticmethod
    def bitrateEnum2Num(br):
        tmp = br.index
        if (tmp == 0):
            return 8
        elif (tmp == 1):
            return 16
        elif (tmp == 2):
            return 24
        elif (tmp == 3):
            return 32
        elif (tmp == 4):
            return 40
        elif (tmp == 5):
            return 48
        elif (tmp == 6):
            return 56
        elif (tmp == 7):
            return 64
        elif (tmp == 8):
            return 80
        elif (tmp == 9):
            return 96
        elif (tmp == 10):
            return 112
        elif (tmp == 11):
            return 128
        elif (tmp == 12):
            return 144
        elif (tmp == 13):
            return 160
        elif (tmp == 14):
            return 176
        elif (tmp == 15):
            return 192
        elif (tmp == 16):
            return 224
        elif (tmp == 17):
            return 256
        elif (tmp == 18):
            return 288
        elif (tmp == 19):
            return 320
        elif (tmp == 20):
            return 352
        elif (tmp == 21):
            return 384
        elif (tmp == 22):
            return 416
        elif (tmp == 23):
            return 448
        elif (tmp == 24):
            return 0
        elif (tmp == 25):
            return -1
        else:
            pass

    @staticmethod
    def bitrateNum2Enum(br):
        br1 = br
        if (br1 == 0):
            return format_mp3_Bitrate.BR_Free
        elif (br1 == 8):
            return format_mp3_Bitrate.BR_8
        elif (br1 == 16):
            return format_mp3_Bitrate.BR_16
        elif (br1 == 24):
            return format_mp3_Bitrate.BR_24
        elif (br1 == 32):
            return format_mp3_Bitrate.BR_32
        elif (br1 == 40):
            return format_mp3_Bitrate.BR_40
        elif (br1 == 48):
            return format_mp3_Bitrate.BR_48
        elif (br1 == 56):
            return format_mp3_Bitrate.BR_56
        elif (br1 == 64):
            return format_mp3_Bitrate.BR_64
        elif (br1 == 80):
            return format_mp3_Bitrate.BR_80
        elif (br1 == 96):
            return format_mp3_Bitrate.BR_96
        elif (br1 == 112):
            return format_mp3_Bitrate.BR_112
        elif (br1 == 128):
            return format_mp3_Bitrate.BR_128
        elif (br1 == 144):
            return format_mp3_Bitrate.BR_144
        elif (br1 == 160):
            return format_mp3_Bitrate.BR_160
        elif (br1 == 176):
            return format_mp3_Bitrate.BR_176
        elif (br1 == 192):
            return format_mp3_Bitrate.BR_192
        elif (br1 == 224):
            return format_mp3_Bitrate.BR_224
        elif (br1 == 256):
            return format_mp3_Bitrate.BR_256
        elif (br1 == 288):
            return format_mp3_Bitrate.BR_288
        elif (br1 == 320):
            return format_mp3_Bitrate.BR_320
        elif (br1 == 352):
            return format_mp3_Bitrate.BR_352
        elif (br1 == 384):
            return format_mp3_Bitrate.BR_384
        elif (br1 == 416):
            return format_mp3_Bitrate.BR_416
        elif (br1 == 448):
            return format_mp3_Bitrate.BR_448
        else:
            return format_mp3_Bitrate.BR_Bad
format_mp3_MPEG._hx_class = format_mp3_MPEG
_hx_classes["format.mp3.MPEG"] = format_mp3_MPEG


class format_mp3_CLayer:
    _hx_class_name = "format.mp3.CLayer"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["LReserved", "LLayer3", "LLayer2", "LLayer1", "enum2Num", "num2Enum"]

    @staticmethod
    def enum2Num(l):
        tmp = l.index
        if (tmp == 0):
            return format_mp3_CLayer.LReserved
        elif (tmp == 1):
            return format_mp3_CLayer.LLayer3
        elif (tmp == 2):
            return format_mp3_CLayer.LLayer2
        elif (tmp == 3):
            return format_mp3_CLayer.LLayer1
        else:
            pass

    @staticmethod
    def num2Enum(l):
        l1 = l
        if (l1 == 1):
            return format_mp3_Layer.Layer3
        elif (l1 == 2):
            return format_mp3_Layer.Layer2
        elif (l1 == 3):
            return format_mp3_Layer.Layer1
        else:
            return format_mp3_Layer.LayerReserved
format_mp3_CLayer._hx_class = format_mp3_CLayer
_hx_classes["format.mp3.CLayer"] = format_mp3_CLayer


class format_mp3_CChannelMode:
    _hx_class_name = "format.mp3.CChannelMode"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["CStereo", "CJointStereo", "CDualChannel", "CMono", "enum2Num", "num2Enum"]

    @staticmethod
    def enum2Num(c):
        tmp = c.index
        if (tmp == 0):
            return 0
        elif (tmp == 1):
            return 1
        elif (tmp == 2):
            return 2
        elif (tmp == 3):
            return 3
        else:
            pass

    @staticmethod
    def num2Enum(c):
        c1 = c
        if (c1 == 0):
            return format_mp3_ChannelMode.Stereo
        elif (c1 == 1):
            return format_mp3_ChannelMode.JointStereo
        elif (c1 == 2):
            return format_mp3_ChannelMode.DualChannel
        elif (c1 == 3):
            return format_mp3_ChannelMode.Mono
        else:
            raise _HxException("assert")
format_mp3_CChannelMode._hx_class = format_mp3_CChannelMode
_hx_classes["format.mp3.CChannelMode"] = format_mp3_CChannelMode


class format_mp3_CEmphasis:
    _hx_class_name = "format.mp3.CEmphasis"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["ENone", "EMs50_15", "EReserved", "ECCIT_J17", "enum2Num", "num2Enum"]

    @staticmethod
    def enum2Num(c):
        tmp = c.index
        if (tmp == 0):
            return 0
        elif (tmp == 1):
            return 1
        elif (tmp == 2):
            return 3
        elif (tmp == 3):
            return 2
        else:
            pass

    @staticmethod
    def num2Enum(c):
        c1 = c
        if (c1 == 0):
            return format_mp3_Emphasis.NoEmphasis
        elif (c1 == 1):
            return format_mp3_Emphasis.Ms50_15
        elif (c1 == 2):
            return format_mp3_Emphasis.InvalidEmphasis
        elif (c1 == 3):
            return format_mp3_Emphasis.CCIT_J17
        else:
            raise _HxException("assert")
format_mp3_CEmphasis._hx_class = format_mp3_CEmphasis
_hx_classes["format.mp3.CEmphasis"] = format_mp3_CEmphasis

class format_mp3_MPEGVersion(Enum):
    __slots__ = ()
    _hx_class_name = "format.mp3.MPEGVersion"
    _hx_constructs = ["MPEG_V1", "MPEG_V2", "MPEG_V25", "MPEG_Reserved"]
format_mp3_MPEGVersion.MPEG_V1 = format_mp3_MPEGVersion("MPEG_V1", 0, ())
format_mp3_MPEGVersion.MPEG_V2 = format_mp3_MPEGVersion("MPEG_V2", 1, ())
format_mp3_MPEGVersion.MPEG_V25 = format_mp3_MPEGVersion("MPEG_V25", 2, ())
format_mp3_MPEGVersion.MPEG_Reserved = format_mp3_MPEGVersion("MPEG_Reserved", 3, ())
format_mp3_MPEGVersion._hx_class = format_mp3_MPEGVersion
_hx_classes["format.mp3.MPEGVersion"] = format_mp3_MPEGVersion

class format_mp3_Layer(Enum):
    __slots__ = ()
    _hx_class_name = "format.mp3.Layer"
    _hx_constructs = ["LayerReserved", "Layer3", "Layer2", "Layer1"]
format_mp3_Layer.LayerReserved = format_mp3_Layer("LayerReserved", 0, ())
format_mp3_Layer.Layer3 = format_mp3_Layer("Layer3", 1, ())
format_mp3_Layer.Layer2 = format_mp3_Layer("Layer2", 2, ())
format_mp3_Layer.Layer1 = format_mp3_Layer("Layer1", 3, ())
format_mp3_Layer._hx_class = format_mp3_Layer
_hx_classes["format.mp3.Layer"] = format_mp3_Layer

class format_mp3_ChannelMode(Enum):
    __slots__ = ()
    _hx_class_name = "format.mp3.ChannelMode"
    _hx_constructs = ["Stereo", "JointStereo", "DualChannel", "Mono"]
format_mp3_ChannelMode.Stereo = format_mp3_ChannelMode("Stereo", 0, ())
format_mp3_ChannelMode.JointStereo = format_mp3_ChannelMode("JointStereo", 1, ())
format_mp3_ChannelMode.DualChannel = format_mp3_ChannelMode("DualChannel", 2, ())
format_mp3_ChannelMode.Mono = format_mp3_ChannelMode("Mono", 3, ())
format_mp3_ChannelMode._hx_class = format_mp3_ChannelMode
_hx_classes["format.mp3.ChannelMode"] = format_mp3_ChannelMode

class format_mp3_Emphasis(Enum):
    __slots__ = ()
    _hx_class_name = "format.mp3.Emphasis"
    _hx_constructs = ["NoEmphasis", "Ms50_15", "CCIT_J17", "InvalidEmphasis"]
format_mp3_Emphasis.NoEmphasis = format_mp3_Emphasis("NoEmphasis", 0, ())
format_mp3_Emphasis.Ms50_15 = format_mp3_Emphasis("Ms50_15", 1, ())
format_mp3_Emphasis.CCIT_J17 = format_mp3_Emphasis("CCIT_J17", 2, ())
format_mp3_Emphasis.InvalidEmphasis = format_mp3_Emphasis("InvalidEmphasis", 3, ())
format_mp3_Emphasis._hx_class = format_mp3_Emphasis
_hx_classes["format.mp3.Emphasis"] = format_mp3_Emphasis

class format_mp3_FrameType(Enum):
    __slots__ = ()
    _hx_class_name = "format.mp3.FrameType"
    _hx_constructs = ["FT_MP3", "FT_NONE"]
format_mp3_FrameType.FT_MP3 = format_mp3_FrameType("FT_MP3", 0, ())
format_mp3_FrameType.FT_NONE = format_mp3_FrameType("FT_NONE", 1, ())
format_mp3_FrameType._hx_class = format_mp3_FrameType
_hx_classes["format.mp3.FrameType"] = format_mp3_FrameType


class format_mp3_Reader:
    _hx_class_name = "format.mp3.Reader"
    _hx_is_interface = "False"
    __slots__ = ("i", "bits", "version", "samples", "sampleSize", "any_read", "id3v2_data", "id3v2_version", "id3v2_flags")
    _hx_fields = ["i", "bits", "version", "samples", "sampleSize", "any_read", "id3v2_data", "id3v2_version", "id3v2_flags"]
    _hx_methods = ["skipID3v2", "seekFrame", "readFrames", "readFrameHeader", "readFrame", "read"]

    def __init__(self,i):
        self.id3v2_flags = None
        self.id3v2_version = None
        self.id3v2_data = None
        self.version = None
        self.i = i
        i.set_bigEndian(True)
        self.bits = format_tools_BitsInput(i)
        self.samples = 0
        self.sampleSize = 0
        self.any_read = False

    def skipID3v2(self):
        self.id3v2_version = self.i.readUInt16()
        self.id3v2_flags = self.i.readByte()
        size = (self.i.readByte() & 127)
        size = ((size << 7) | ((self.i.readByte() & 127)))
        size = ((size << 7) | ((self.i.readByte() & 127)))
        size = ((size << 7) | ((self.i.readByte() & 127)))
        self.id3v2_data = self.i.read(size)

    def seekFrame(self):
        found = False
        try:
            b = None
            while True:
                b = self.i.readByte()
                if (not self.any_read):
                    self.any_read = True
                    if (b == 73):
                        b = self.i.readByte()
                        if (b == 68):
                            b = self.i.readByte()
                            if (b == 51):
                                self.skipID3v2()
                if (b == 255):
                    self.bits.nbits = 0
                    b = self.bits.readBits(3)
                    if (b == 7):
                        return format_mp3_FrameType.FT_MP3
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            if isinstance(_hx_e1, haxe_io_Eof):
                ex = _hx_e1
                return format_mp3_FrameType.FT_NONE
            else:
                raise _hx_e

    def readFrames(self):
        frames = list()
        ft = None
        while True:
            ft = self.seekFrame()
            if (not ((ft != format_mp3_FrameType.FT_NONE))):
                break
            tmp = ft.index
            if (tmp == 0):
                f = self.readFrame()
                if (f is not None):
                    frames.append(f)
            elif (tmp == 1):
                pass
            else:
                pass
        return frames

    def readFrameHeader(self):
        version = self.bits.readBits(2)
        layer = self.bits.readBits(2)
        hasCrc = (not self.bits.readBit())
        if ((version == format_mp3_MPEG.Reserved) or ((layer == format_mp3_CLayer.LReserved))):
            return None
        bitrateIdx = self.bits.readBits(4)
        bitrate = format_mp3_Tools.getBitrate(version,layer,bitrateIdx)
        samplingRateIdx = self.bits.readBits(2)
        samplingRate = format_mp3_Tools.getSamplingRate(version,samplingRateIdx)
        isPadded = self.bits.readBit()
        privateBit = self.bits.readBit()
        if (((bitrate == format_mp3_Bitrate.BR_Bad) or ((bitrate == format_mp3_Bitrate.BR_Free))) or ((samplingRate == format_mp3_SamplingRate.SR_Bad))):
            return None
        channelMode = self.bits.readBits(2)
        isIntensityStereo = self.bits.readBit()
        isMSStereo = self.bits.readBit()
        isCopyrighted = self.bits.readBit()
        isOriginal = self.bits.readBit()
        emphasis = self.bits.readBits(2)
        crc16 = 0
        if hasCrc:
            crc16 = self.i.readUInt16()
        return _hx_AnonObject({'version': format_mp3_MPEG.num2Enum(version), 'layer': format_mp3_CLayer.num2Enum(layer), 'hasCrc': hasCrc, 'crc16': crc16, 'bitrate': bitrate, 'samplingRate': samplingRate, 'isPadded': isPadded, 'privateBit': privateBit, 'channelMode': format_mp3_CChannelMode.num2Enum(channelMode), 'isIntensityStereo': isIntensityStereo, 'isMSStereo': isMSStereo, 'isCopyrighted': isCopyrighted, 'isOriginal': isOriginal, 'emphasis': format_mp3_CEmphasis.num2Enum(emphasis)})

    def readFrame(self):
        header = self.readFrameHeader()
        if ((header is None) or format_mp3_Tools.isInvalidFrameHeader(header)):
            return None
        try:
            data = self.i.read(format_mp3_Tools.getSampleDataSizeHdr(header))
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.samples
            _hx_local_0.samples = (_hx_local_1 + format_mp3_Tools.getSampleCountHdr(header))
            _hx_local_0.samples
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.sampleSize
            _hx_local_2.sampleSize = (_hx_local_3 + data.length)
            _hx_local_2.sampleSize
            return _hx_AnonObject({'header': header, 'data': data})
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            if isinstance(_hx_e1, haxe_io_Eof):
                e = _hx_e1
                return None
            else:
                raise _hx_e

    def read(self):
        fs = self.readFrames()
        return _hx_AnonObject({'frames': fs, 'sampleCount': self.samples, 'sampleSize': self.sampleSize, 'id3v2': (None if ((self.id3v2_data is None)) else _hx_AnonObject({'versionBytes': self.id3v2_version, 'flagByte': self.id3v2_flags, 'data': self.id3v2_data}))})

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.i = None
        _hx_o.bits = None
        _hx_o.version = None
        _hx_o.samples = None
        _hx_o.sampleSize = None
        _hx_o.any_read = None
        _hx_o.id3v2_data = None
        _hx_o.id3v2_version = None
        _hx_o.id3v2_flags = None
format_mp3_Reader._hx_class = format_mp3_Reader
_hx_classes["format.mp3.Reader"] = format_mp3_Reader


class format_mp3_Tools:
    _hx_class_name = "format.mp3.Tools"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["getBitrate", "getSamplingRate", "isInvalidFrameHeader", "getSampleDataSize", "getSampleDataSizeHdr", "getSampleCount", "getSampleCountHdr", "getFrameInfo"]

    @staticmethod
    def getBitrate(mpegVersion,layerIdx,bitrateIdx):
        if ((mpegVersion == format_mp3_MPEG.Reserved) or ((layerIdx == format_mp3_CLayer.LReserved))):
            return format_mp3_Bitrate.BR_Bad
        return python_internal_ArrayImpl._get(python_internal_ArrayImpl._get(((format_mp3_MPEG.V1_Bitrates if ((mpegVersion == 3)) else format_mp3_MPEG.V2_Bitrates)), layerIdx), bitrateIdx)

    @staticmethod
    def getSamplingRate(mpegVersion,samplingRateIdx):
        return python_internal_ArrayImpl._get(python_internal_ArrayImpl._get(format_mp3_MPEG.SamplingRates, mpegVersion), samplingRateIdx)

    @staticmethod
    def isInvalidFrameHeader(hdr):
        if (not (((((hdr.version == format_mp3_MPEGVersion.MPEG_Reserved) or ((hdr.layer == format_mp3_Layer.LayerReserved))) or ((hdr.bitrate == format_mp3_Bitrate.BR_Bad))) or ((hdr.bitrate == format_mp3_Bitrate.BR_Free))))):
            return (hdr.samplingRate == format_mp3_SamplingRate.SR_Bad)
        else:
            return True

    @staticmethod
    def getSampleDataSize(mpegVersion,bitrate,samplingRate,isPadded,hasCrc):
        tmp = None
        try:
            tmp = int((((((144 if ((mpegVersion == 3)) else 72)) * bitrate) * 1000) / samplingRate))
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            tmp = None
        return (((tmp + ((1 if isPadded else 0))) - ((2 if hasCrc else 0))) - 4)

    @staticmethod
    def getSampleDataSizeHdr(hdr):
        return format_mp3_Tools.getSampleDataSize(format_mp3_MPEG.enum2Num(hdr.version),format_mp3_MPEG.bitrateEnum2Num(hdr.bitrate),format_mp3_MPEG.srEnum2Num(hdr.samplingRate),hdr.isPadded,hdr.hasCrc)

    @staticmethod
    def getSampleCount(mpegVersion):
        if (mpegVersion == 3):
            return 1152
        else:
            return 576

    @staticmethod
    def getSampleCountHdr(hdr):
        return format_mp3_Tools.getSampleCount(format_mp3_MPEG.enum2Num(hdr.version))

    @staticmethod
    def getFrameInfo(fr):
        return ((((((((((((((((((Std.string(fr.header.version) + ", ") + Std.string(fr.header.layer)) + ", ") + Std.string(fr.header.channelMode)) + ", ") + Std.string(fr.header.samplingRate)) + " Hz, ") + Std.string(fr.header.bitrate)) + " kbps ") + "Emphasis: ") + Std.string(fr.header.emphasis)) + ", ") + HxOverrides.stringOrNull((("(CRC) " if (fr.header.hasCrc) else "")))) + HxOverrides.stringOrNull((("(Padded) " if (fr.header.isPadded) else "")))) + HxOverrides.stringOrNull((("(Intensity Stereo) " if (fr.header.isIntensityStereo) else "")))) + HxOverrides.stringOrNull((("(MS Stereo) " if (fr.header.isMSStereo) else "")))) + HxOverrides.stringOrNull((("(Copyrighted) " if (fr.header.isCopyrighted) else "")))) + HxOverrides.stringOrNull((("(Original) " if (fr.header.isOriginal) else ""))))
format_mp3_Tools._hx_class = format_mp3_Tools
_hx_classes["format.mp3.Tools"] = format_mp3_Tools

class format_png_Color(Enum):
    __slots__ = ()
    _hx_class_name = "format.png.Color"
    _hx_constructs = ["ColGrey", "ColTrue", "ColIndexed"]

    @staticmethod
    def ColGrey(alpha):
        return format_png_Color("ColGrey", 0, (alpha,))

    @staticmethod
    def ColTrue(alpha):
        return format_png_Color("ColTrue", 1, (alpha,))
format_png_Color.ColIndexed = format_png_Color("ColIndexed", 2, ())
format_png_Color._hx_class = format_png_Color
_hx_classes["format.png.Color"] = format_png_Color

class format_png_Chunk(Enum):
    __slots__ = ()
    _hx_class_name = "format.png.Chunk"
    _hx_constructs = ["CEnd", "CHeader", "CData", "CPalette", "CUnknown"]

    @staticmethod
    def CHeader(h):
        return format_png_Chunk("CHeader", 1, (h,))

    @staticmethod
    def CData(b):
        return format_png_Chunk("CData", 2, (b,))

    @staticmethod
    def CPalette(b):
        return format_png_Chunk("CPalette", 3, (b,))

    @staticmethod
    def CUnknown(id,data):
        return format_png_Chunk("CUnknown", 4, (id,data))
format_png_Chunk.CEnd = format_png_Chunk("CEnd", 0, ())
format_png_Chunk._hx_class = format_png_Chunk
_hx_classes["format.png.Chunk"] = format_png_Chunk


class format_png_Reader:
    _hx_class_name = "format.png.Reader"
    _hx_is_interface = "False"
    __slots__ = ("i", "checkCRC")
    _hx_fields = ["i", "checkCRC"]
    _hx_methods = ["read", "readHeader", "readChunk"]

    def __init__(self,i):
        self.i = i
        i.set_bigEndian(True)
        self.checkCRC = True

    def read(self):
        b = 137
        if (self.i.readByte() != b):
            raise _HxException("Invalid header")
        b1 = 80
        if (self.i.readByte() != b1):
            raise _HxException("Invalid header")
        b2 = 78
        if (self.i.readByte() != b2):
            raise _HxException("Invalid header")
        b3 = 71
        if (self.i.readByte() != b3):
            raise _HxException("Invalid header")
        b4 = 13
        if (self.i.readByte() != b4):
            raise _HxException("Invalid header")
        b5 = 10
        if (self.i.readByte() != b5):
            raise _HxException("Invalid header")
        b6 = 26
        if (self.i.readByte() != b6):
            raise _HxException("Invalid header")
        b7 = 10
        if (self.i.readByte() != b7):
            raise _HxException("Invalid header")
        l = haxe_ds_List()
        while True:
            c = self.readChunk()
            l.add(c)
            if (c == format_png_Chunk.CEnd):
                break
        return l

    def readHeader(self,i):
        i.set_bigEndian(True)
        width = i.readInt32()
        height = i.readInt32()
        colbits = i.readByte()
        color = i.readByte()
        color1 = None
        color2 = color
        if (color2 == 0):
            color1 = format_png_Color.ColGrey(False)
        elif (color2 == 2):
            color1 = format_png_Color.ColTrue(False)
        elif (color2 == 3):
            color1 = format_png_Color.ColIndexed
        elif (color2 == 4):
            color1 = format_png_Color.ColGrey(True)
        elif (color2 == 6):
            color1 = format_png_Color.ColTrue(True)
        else:
            raise _HxException(((("Unknown color model " + Std.string(color)) + ":") + Std.string(colbits)))
        compress = i.readByte()
        _hx_filter = i.readByte()
        if ((compress != 0) or ((_hx_filter != 0))):
            raise _HxException("Invalid header")
        interlace = i.readByte()
        if ((interlace != 0) and ((interlace != 1))):
            raise _HxException("Invalid header")
        return _hx_AnonObject({'width': width, 'height': height, 'colbits': colbits, 'color': color1, 'interlaced': (interlace == 1)})

    def readChunk(self):
        dataLen = self.i.readInt32()
        id = self.i.readString(4)
        data = self.i.read(dataLen)
        crc = self.i.readInt32()
        if self.checkCRC:
            c_crc = -1
            tmp = (((c_crc ^ HxString.charCodeAt(id,0))) & 255)
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
            c_crc = (HxOverrides.rshift(c_crc, 8) ^ tmp)
            tmp1 = (((c_crc ^ HxString.charCodeAt(id,1))) & 255)
            tmp1 = (HxOverrides.rshift(tmp1, 1) ^ ((-((tmp1 & 1)) & -306674912)))
            tmp1 = (HxOverrides.rshift(tmp1, 1) ^ ((-((tmp1 & 1)) & -306674912)))
            tmp1 = (HxOverrides.rshift(tmp1, 1) ^ ((-((tmp1 & 1)) & -306674912)))
            tmp1 = (HxOverrides.rshift(tmp1, 1) ^ ((-((tmp1 & 1)) & -306674912)))
            tmp1 = (HxOverrides.rshift(tmp1, 1) ^ ((-((tmp1 & 1)) & -306674912)))
            tmp1 = (HxOverrides.rshift(tmp1, 1) ^ ((-((tmp1 & 1)) & -306674912)))
            tmp1 = (HxOverrides.rshift(tmp1, 1) ^ ((-((tmp1 & 1)) & -306674912)))
            tmp1 = (HxOverrides.rshift(tmp1, 1) ^ ((-((tmp1 & 1)) & -306674912)))
            c_crc = (HxOverrides.rshift(c_crc, 8) ^ tmp1)
            tmp2 = (((c_crc ^ HxString.charCodeAt(id,2))) & 255)
            tmp2 = (HxOverrides.rshift(tmp2, 1) ^ ((-((tmp2 & 1)) & -306674912)))
            tmp2 = (HxOverrides.rshift(tmp2, 1) ^ ((-((tmp2 & 1)) & -306674912)))
            tmp2 = (HxOverrides.rshift(tmp2, 1) ^ ((-((tmp2 & 1)) & -306674912)))
            tmp2 = (HxOverrides.rshift(tmp2, 1) ^ ((-((tmp2 & 1)) & -306674912)))
            tmp2 = (HxOverrides.rshift(tmp2, 1) ^ ((-((tmp2 & 1)) & -306674912)))
            tmp2 = (HxOverrides.rshift(tmp2, 1) ^ ((-((tmp2 & 1)) & -306674912)))
            tmp2 = (HxOverrides.rshift(tmp2, 1) ^ ((-((tmp2 & 1)) & -306674912)))
            tmp2 = (HxOverrides.rshift(tmp2, 1) ^ ((-((tmp2 & 1)) & -306674912)))
            c_crc = (HxOverrides.rshift(c_crc, 8) ^ tmp2)
            tmp3 = (((c_crc ^ HxString.charCodeAt(id,3))) & 255)
            tmp3 = (HxOverrides.rshift(tmp3, 1) ^ ((-((tmp3 & 1)) & -306674912)))
            tmp3 = (HxOverrides.rshift(tmp3, 1) ^ ((-((tmp3 & 1)) & -306674912)))
            tmp3 = (HxOverrides.rshift(tmp3, 1) ^ ((-((tmp3 & 1)) & -306674912)))
            tmp3 = (HxOverrides.rshift(tmp3, 1) ^ ((-((tmp3 & 1)) & -306674912)))
            tmp3 = (HxOverrides.rshift(tmp3, 1) ^ ((-((tmp3 & 1)) & -306674912)))
            tmp3 = (HxOverrides.rshift(tmp3, 1) ^ ((-((tmp3 & 1)) & -306674912)))
            tmp3 = (HxOverrides.rshift(tmp3, 1) ^ ((-((tmp3 & 1)) & -306674912)))
            tmp3 = (HxOverrides.rshift(tmp3, 1) ^ ((-((tmp3 & 1)) & -306674912)))
            c_crc = (HxOverrides.rshift(c_crc, 8) ^ tmp3)
            b = data.b
            _g = 0
            _g1 = data.length
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                tmp4 = (((c_crc ^ b[i])) & 255)
                tmp4 = (HxOverrides.rshift(tmp4, 1) ^ ((-((tmp4 & 1)) & -306674912)))
                tmp4 = (HxOverrides.rshift(tmp4, 1) ^ ((-((tmp4 & 1)) & -306674912)))
                tmp4 = (HxOverrides.rshift(tmp4, 1) ^ ((-((tmp4 & 1)) & -306674912)))
                tmp4 = (HxOverrides.rshift(tmp4, 1) ^ ((-((tmp4 & 1)) & -306674912)))
                tmp4 = (HxOverrides.rshift(tmp4, 1) ^ ((-((tmp4 & 1)) & -306674912)))
                tmp4 = (HxOverrides.rshift(tmp4, 1) ^ ((-((tmp4 & 1)) & -306674912)))
                tmp4 = (HxOverrides.rshift(tmp4, 1) ^ ((-((tmp4 & 1)) & -306674912)))
                tmp4 = (HxOverrides.rshift(tmp4, 1) ^ ((-((tmp4 & 1)) & -306674912)))
                c_crc = (HxOverrides.rshift(c_crc, 8) ^ tmp4)
            if (((c_crc ^ -1)) != crc):
                raise _HxException("CRC check failure")
        id1 = id
        if (id1 == "IDAT"):
            return format_png_Chunk.CData(data)
        elif (id1 == "IEND"):
            return format_png_Chunk.CEnd
        elif (id1 == "IHDR"):
            return format_png_Chunk.CHeader(self.readHeader(haxe_io_BytesInput(data)))
        elif (id1 == "PLTE"):
            return format_png_Chunk.CPalette(data)
        else:
            return format_png_Chunk.CUnknown(id,data)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.i = None
        _hx_o.checkCRC = None
format_png_Reader._hx_class = format_png_Reader
_hx_classes["format.png.Reader"] = format_png_Reader


class format_png_Tools:
    _hx_class_name = "format.png.Tools"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["getHeader", "getPalette", "filter", "reverseBytes", "extractGrey", "extract32", "buildGrey", "buildIndexed", "buildRGB", "build32ARGB", "build32BGRA"]

    @staticmethod
    def getHeader(d):
        _g_head = d.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            c = val
            if (c.index == 1):
                h = c.params[0]
                return h
        raise _HxException("Header not found")

    @staticmethod
    def getPalette(d):
        _g_head = d.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            c = val
            if (c.index == 3):
                b = c.params[0]
                return b
        return None

    @staticmethod
    def filter(data,x,y,stride,prev,p,numChannels = None):
        if (numChannels is None):
            numChannels = 4
        b = (0 if ((y == 0)) else data.b[(p - stride)])
        c = (0 if (((x == 0) or ((y == 0)))) else data.b[((p - stride) - numChannels)])
        k = ((prev + b) - c)
        pa = (k - prev)
        if (pa < 0):
            pa = -pa
        pb = (k - b)
        if (pb < 0):
            pb = -pb
        pc = (k - c)
        if (pc < 0):
            pc = -pc
        if ((pa <= pb) and ((pa <= pc))):
            return prev
        elif (pb <= pc):
            return b
        else:
            return c

    @staticmethod
    def reverseBytes(b):
        p = 0
        _g = 0
        _g1 = (b.length >> 2)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            b1 = b.b[p]
            g = b.b[(p + 1)]
            r = b.b[(p + 2)]
            a = b.b[(p + 3)]
            p1 = p
            p = (p + 1)
            b.b[p1] = (a & 255)
            p2 = p
            p = (p + 1)
            b.b[p2] = (r & 255)
            p3 = p
            p = (p + 1)
            b.b[p3] = (g & 255)
            p4 = p
            p = (p + 1)
            b.b[p4] = (b1 & 255)

    @staticmethod
    def extractGrey(d):
        h = format_png_Tools.getHeader(d)
        grey = haxe_io_Bytes.alloc((h.width * h.height))
        data = None
        fullData = None
        _g_head = d.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            c = val
            if (c.index == 2):
                b = c.params[0]
                if (fullData is not None):
                    fullData.b.extend(b.b)
                elif (data is None):
                    data = b
                else:
                    fullData = haxe_io_BytesBuffer()
                    fullData.b.extend(data.b)
                    fullData.b.extend(b.b)
                    data = None
        if (fullData is not None):
            data = fullData.getBytes()
        if (data is None):
            raise _HxException("Data not found")
        data = format_tools_Inflate.run(data)
        r = 0
        w = 0
        _g1 = h.color
        if (_g1.index == 0):
            alpha = _g1.params[0]
            if (h.colbits != 8):
                raise _HxException("Unsupported color mode")
            width = h.width
            stride = ((((2 if alpha else 1)) * width) + 1)
            if (data.length < ((h.height * stride))):
                raise _HxException("Not enough data")
            rinc = (2 if alpha else 1)
            _g11 = 0
            _g2 = h.height
            while (_g11 < _g2):
                y = _g11
                _g11 = (_g11 + 1)
                pos = r
                r = (r + 1)
                f = data.b[pos]
                f1 = f
                if (f1 == 0):
                    _g12 = 0
                    _g21 = width
                    while (_g12 < _g21):
                        x = _g12
                        _g12 = (_g12 + 1)
                        v = data.b[r]
                        r = (r + rinc)
                        pos1 = w
                        w = (w + 1)
                        grey.b[pos1] = (v & 255)
                elif (f1 == 1):
                    cv = 0
                    _g13 = 0
                    _g22 = width
                    while (_g13 < _g22):
                        x1 = _g13
                        _g13 = (_g13 + 1)
                        cv = (cv + data.b[r])
                        r = (r + rinc)
                        pos2 = w
                        w = (w + 1)
                        grey.b[pos2] = (cv & 255)
                elif (f1 == 2):
                    stride1 = (0 if ((y == 0)) else width)
                    _g14 = 0
                    _g23 = width
                    while (_g14 < _g23):
                        x2 = _g14
                        _g14 = (_g14 + 1)
                        v1 = (data.b[r] + grey.b[(w - stride1)])
                        r = (r + rinc)
                        pos3 = w
                        w = (w + 1)
                        grey.b[pos3] = (v1 & 255)
                elif (f1 == 3):
                    cv1 = 0
                    stride2 = (0 if ((y == 0)) else width)
                    _g15 = 0
                    _g24 = width
                    while (_g15 < _g24):
                        x3 = _g15
                        _g15 = (_g15 + 1)
                        cv1 = ((data.b[r] + (((cv1 + grey.b[(w - stride2)]) >> 1))) & 255)
                        r = (r + rinc)
                        pos4 = w
                        w = (w + 1)
                        grey.b[pos4] = (cv1 & 255)
                elif (f1 == 4):
                    stride3 = width
                    cv2 = 0
                    _g16 = 0
                    _g25 = width
                    while (_g16 < _g25):
                        x4 = _g16
                        _g16 = (_g16 + 1)
                        numChannels = 1
                        if (numChannels is None):
                            numChannels = 4
                        b1 = (0 if ((y == 0)) else grey.b[(w - stride3)])
                        c1 = (0 if (((x4 == 0) or ((y == 0)))) else grey.b[((w - stride3) - numChannels)])
                        k = ((cv2 + b1) - c1)
                        pa = (k - cv2)
                        if (pa < 0):
                            pa = -pa
                        pb = (k - b1)
                        if (pb < 0):
                            pb = -pb
                        pc = (k - c1)
                        if (pc < 0):
                            pc = -pc
                        cv2 = ((((cv2 if (((pa <= pb) and ((pa <= pc)))) else (b1 if ((pb <= pc)) else c1))) + data.b[r]) & 255)
                        r = (r + rinc)
                        pos5 = w
                        w = (w + 1)
                        grey.b[pos5] = (cv2 & 255)
                else:
                    raise _HxException(("Invalid filter " + Std.string(f)))
        else:
            raise _HxException("Unsupported color mode")
        return grey

    @staticmethod
    def extract32(d,_hx_bytes = None,flipY = None):
        h = format_png_Tools.getHeader(d)
        bgra = (haxe_io_Bytes.alloc(((h.width * h.height) * 4)) if ((_hx_bytes is None)) else _hx_bytes)
        data = None
        fullData = None
        _g_head = d.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            c = val
            if (c.index == 2):
                b = c.params[0]
                if (fullData is not None):
                    fullData.b.extend(b.b)
                elif (data is None):
                    data = b
                else:
                    fullData = haxe_io_BytesBuffer()
                    fullData.b.extend(data.b)
                    fullData.b.extend(b.b)
                    data = None
        if (fullData is not None):
            data = fullData.getBytes()
        if (data is None):
            raise _HxException("Data not found")
        data = format_tools_Inflate.run(data)
        r = 0
        w = 0
        lineDelta = 0
        if flipY:
            lineDelta = (-h.width * 8)
            w = (((h.height - 1)) * ((h.width * 4)))
        flipY1 = (-1 if flipY else 1)
        _g1 = h.color
        tmp = _g1.index
        if (tmp == 0):
            alpha = _g1.params[0]
            if (h.colbits != 8):
                raise _HxException("Unsupported color mode")
            width = h.width
            stride = ((((2 if alpha else 1)) * width) + 1)
            if (data.length < ((h.height * stride))):
                raise _HxException("Not enough data")
            alphvaIdx = -1
            if (not alpha):
                _g1_head = d.h
                while (_g1_head is not None):
                    val1 = _g1_head.item
                    _g1_head = _g1_head.next
                    t = val1
                    if (t.index == 4):
                        if (t.params[0] == "tRNS"):
                            data1 = t.params[1]
                            if (data1.length >= 2):
                                alphvaIdx = data1.b[1]
                            break
            _g11 = 0
            _g2 = h.height
            while (_g11 < _g2):
                y = _g11
                _g11 = (_g11 + 1)
                pos = r
                r = (r + 1)
                f = data.b[pos]
                f1 = f
                if (f1 == 0):
                    if alpha:
                        _g12 = 0
                        _g21 = width
                        while (_g12 < _g21):
                            x = _g12
                            _g12 = (_g12 + 1)
                            pos1 = r
                            r = (r + 1)
                            v = data.b[pos1]
                            pos2 = w
                            w = (w + 1)
                            bgra.b[pos2] = (v & 255)
                            pos3 = w
                            w = (w + 1)
                            bgra.b[pos3] = (v & 255)
                            pos4 = w
                            w = (w + 1)
                            bgra.b[pos4] = (v & 255)
                            pos5 = w
                            w = (w + 1)
                            pos6 = r
                            r = (r + 1)
                            v1 = data.b[pos6]
                            bgra.b[pos5] = (v1 & 255)
                    else:
                        _g13 = 0
                        _g22 = width
                        while (_g13 < _g22):
                            x1 = _g13
                            _g13 = (_g13 + 1)
                            pos7 = r
                            r = (r + 1)
                            v2 = data.b[pos7]
                            pos8 = w
                            w = (w + 1)
                            bgra.b[pos8] = (v2 & 255)
                            pos9 = w
                            w = (w + 1)
                            bgra.b[pos9] = (v2 & 255)
                            pos10 = w
                            w = (w + 1)
                            bgra.b[pos10] = (v2 & 255)
                            pos11 = w
                            w = (w + 1)
                            bgra.b[pos11] = (((0 if ((v2 == alphvaIdx)) else 255)) & 255)
                elif (f1 == 1):
                    cv = 0
                    ca = 0
                    if alpha:
                        _g14 = 0
                        _g23 = width
                        while (_g14 < _g23):
                            x2 = _g14
                            _g14 = (_g14 + 1)
                            pos12 = r
                            r = (r + 1)
                            cv = (cv + data.b[pos12])
                            pos13 = w
                            w = (w + 1)
                            bgra.b[pos13] = (cv & 255)
                            pos14 = w
                            w = (w + 1)
                            bgra.b[pos14] = (cv & 255)
                            pos15 = w
                            w = (w + 1)
                            bgra.b[pos15] = (cv & 255)
                            pos16 = r
                            r = (r + 1)
                            ca = (ca + data.b[pos16])
                            pos17 = w
                            w = (w + 1)
                            bgra.b[pos17] = (ca & 255)
                    else:
                        _g15 = 0
                        _g24 = width
                        while (_g15 < _g24):
                            x3 = _g15
                            _g15 = (_g15 + 1)
                            pos18 = r
                            r = (r + 1)
                            cv = (cv + data.b[pos18])
                            pos19 = w
                            w = (w + 1)
                            bgra.b[pos19] = (cv & 255)
                            pos20 = w
                            w = (w + 1)
                            bgra.b[pos20] = (cv & 255)
                            pos21 = w
                            w = (w + 1)
                            bgra.b[pos21] = (cv & 255)
                            pos22 = w
                            w = (w + 1)
                            bgra.b[pos22] = (((0 if ((cv == alphvaIdx)) else 255)) & 255)
                elif (f1 == 2):
                    stride1 = (0 if ((y == 0)) else ((width * 4) * flipY1))
                    if alpha:
                        _g16 = 0
                        _g25 = width
                        while (_g16 < _g25):
                            x4 = _g16
                            _g16 = (_g16 + 1)
                            pos23 = r
                            r = (r + 1)
                            v3 = (data.b[pos23] + bgra.b[(w - stride1)])
                            pos24 = w
                            w = (w + 1)
                            bgra.b[pos24] = (v3 & 255)
                            pos25 = w
                            w = (w + 1)
                            bgra.b[pos25] = (v3 & 255)
                            pos26 = w
                            w = (w + 1)
                            bgra.b[pos26] = (v3 & 255)
                            pos27 = w
                            w = (w + 1)
                            pos28 = r
                            r = (r + 1)
                            v4 = (data.b[pos28] + bgra.b[(w - stride1)])
                            bgra.b[pos27] = (v4 & 255)
                    else:
                        _g17 = 0
                        _g26 = width
                        while (_g17 < _g26):
                            x5 = _g17
                            _g17 = (_g17 + 1)
                            pos29 = r
                            r = (r + 1)
                            v5 = (data.b[pos29] + bgra.b[(w - stride1)])
                            pos30 = w
                            w = (w + 1)
                            bgra.b[pos30] = (v5 & 255)
                            pos31 = w
                            w = (w + 1)
                            bgra.b[pos31] = (v5 & 255)
                            pos32 = w
                            w = (w + 1)
                            bgra.b[pos32] = (v5 & 255)
                            pos33 = w
                            w = (w + 1)
                            bgra.b[pos33] = (((0 if ((v5 == alphvaIdx)) else 255)) & 255)
                elif (f1 == 3):
                    cv1 = 0
                    ca1 = 0
                    stride2 = (0 if ((y == 0)) else ((width * 4) * flipY1))
                    if alpha:
                        _g18 = 0
                        _g27 = width
                        while (_g18 < _g27):
                            x6 = _g18
                            _g18 = (_g18 + 1)
                            pos34 = r
                            r = (r + 1)
                            cv1 = ((data.b[pos34] + (((cv1 + bgra.b[(w - stride2)]) >> 1))) & 255)
                            pos35 = w
                            w = (w + 1)
                            bgra.b[pos35] = (cv1 & 255)
                            pos36 = w
                            w = (w + 1)
                            bgra.b[pos36] = (cv1 & 255)
                            pos37 = w
                            w = (w + 1)
                            bgra.b[pos37] = (cv1 & 255)
                            pos38 = r
                            r = (r + 1)
                            ca1 = ((data.b[pos38] + (((ca1 + bgra.b[(w - stride2)]) >> 1))) & 255)
                            pos39 = w
                            w = (w + 1)
                            bgra.b[pos39] = (ca1 & 255)
                    else:
                        _g19 = 0
                        _g28 = width
                        while (_g19 < _g28):
                            x7 = _g19
                            _g19 = (_g19 + 1)
                            pos40 = r
                            r = (r + 1)
                            cv1 = ((data.b[pos40] + (((cv1 + bgra.b[(w - stride2)]) >> 1))) & 255)
                            pos41 = w
                            w = (w + 1)
                            bgra.b[pos41] = (cv1 & 255)
                            pos42 = w
                            w = (w + 1)
                            bgra.b[pos42] = (cv1 & 255)
                            pos43 = w
                            w = (w + 1)
                            bgra.b[pos43] = (cv1 & 255)
                            pos44 = w
                            w = (w + 1)
                            bgra.b[pos44] = (((0 if ((cv1 == alphvaIdx)) else 255)) & 255)
                elif (f1 == 4):
                    stride3 = ((width * 4) * flipY1)
                    cv2 = 0
                    ca2 = 0
                    if alpha:
                        _g110 = 0
                        _g29 = width
                        while (_g110 < _g29):
                            x8 = _g110
                            _g110 = (_g110 + 1)
                            b1 = (0 if ((y == 0)) else bgra.b[(w - stride3)])
                            c1 = (0 if (((x8 == 0) or ((y == 0)))) else bgra.b[((w - stride3) - 4)])
                            k = ((cv2 + b1) - c1)
                            pa = (k - cv2)
                            if (pa < 0):
                                pa = -pa
                            pb = (k - b1)
                            if (pb < 0):
                                pb = -pb
                            pc = (k - c1)
                            if (pc < 0):
                                pc = -pc
                            pos45 = r
                            r = (r + 1)
                            cv2 = ((((cv2 if (((pa <= pb) and ((pa <= pc)))) else (b1 if ((pb <= pc)) else c1))) + data.b[pos45]) & 255)
                            pos46 = w
                            w = (w + 1)
                            bgra.b[pos46] = (cv2 & 255)
                            pos47 = w
                            w = (w + 1)
                            bgra.b[pos47] = (cv2 & 255)
                            pos48 = w
                            w = (w + 1)
                            bgra.b[pos48] = (cv2 & 255)
                            b2 = (0 if ((y == 0)) else bgra.b[(w - stride3)])
                            c2 = (0 if (((x8 == 0) or ((y == 0)))) else bgra.b[((w - stride3) - 4)])
                            k1 = ((ca2 + b2) - c2)
                            pa1 = (k1 - ca2)
                            if (pa1 < 0):
                                pa1 = -pa1
                            pb1 = (k1 - b2)
                            if (pb1 < 0):
                                pb1 = -pb1
                            pc1 = (k1 - c2)
                            if (pc1 < 0):
                                pc1 = -pc1
                            pos49 = r
                            r = (r + 1)
                            ca2 = ((((ca2 if (((pa1 <= pb1) and ((pa1 <= pc1)))) else (b2 if ((pb1 <= pc1)) else c2))) + data.b[pos49]) & 255)
                            pos50 = w
                            w = (w + 1)
                            bgra.b[pos50] = (ca2 & 255)
                    else:
                        _g111 = 0
                        _g210 = width
                        while (_g111 < _g210):
                            x9 = _g111
                            _g111 = (_g111 + 1)
                            b3 = (0 if ((y == 0)) else bgra.b[(w - stride3)])
                            c3 = (0 if (((x9 == 0) or ((y == 0)))) else bgra.b[((w - stride3) - 4)])
                            k2 = ((cv2 + b3) - c3)
                            pa2 = (k2 - cv2)
                            if (pa2 < 0):
                                pa2 = -pa2
                            pb2 = (k2 - b3)
                            if (pb2 < 0):
                                pb2 = -pb2
                            pc2 = (k2 - c3)
                            if (pc2 < 0):
                                pc2 = -pc2
                            pos51 = r
                            r = (r + 1)
                            cv2 = ((((cv2 if (((pa2 <= pb2) and ((pa2 <= pc2)))) else (b3 if ((pb2 <= pc2)) else c3))) + data.b[pos51]) & 255)
                            pos52 = w
                            w = (w + 1)
                            bgra.b[pos52] = (cv2 & 255)
                            pos53 = w
                            w = (w + 1)
                            bgra.b[pos53] = (cv2 & 255)
                            pos54 = w
                            w = (w + 1)
                            bgra.b[pos54] = (cv2 & 255)
                            pos55 = w
                            w = (w + 1)
                            bgra.b[pos55] = (((0 if ((cv2 == alphvaIdx)) else 255)) & 255)
                else:
                    raise _HxException(("Invalid filter " + Std.string(f)))
                w = (w + lineDelta)
        elif (tmp == 1):
            alpha1 = _g1.params[0]
            if (h.colbits != 8):
                raise _HxException("Unsupported color mode")
            width1 = h.width
            stride4 = ((((4 if alpha1 else 3)) * width1) + 1)
            if (data.length < ((h.height * stride4))):
                raise _HxException("Not enough data")
            alphaRed = -1
            alphaGreen = -1
            alphaBlue = -1
            if (not alpha1):
                _g1_head1 = d.h
                while (_g1_head1 is not None):
                    val2 = _g1_head1.item
                    _g1_head1 = _g1_head1.next
                    t1 = val2
                    if (t1.index == 4):
                        if (t1.params[0] == "tRNS"):
                            data2 = t1.params[1]
                            if (data2.length >= 6):
                                alphaRed = data2.b[1]
                                alphaGreen = data2.b[3]
                                alphaBlue = data2.b[5]
                            break
            cr = 0
            cg = 0
            cb = 0
            ca3 = 0
            _g112 = 0
            _g211 = h.height
            while (_g112 < _g211):
                y1 = _g112
                _g112 = (_g112 + 1)
                pos56 = r
                r = (r + 1)
                f2 = data.b[pos56]
                f3 = f2
                if (f3 == 0):
                    if alpha1:
                        _g113 = 0
                        _g212 = width1
                        while (_g113 < _g212):
                            x10 = _g113
                            _g113 = (_g113 + 1)
                            pos57 = w
                            w = (w + 1)
                            v6 = data.b[(r + 2)]
                            bgra.b[pos57] = (v6 & 255)
                            pos58 = w
                            w = (w + 1)
                            v7 = data.b[(r + 1)]
                            bgra.b[pos58] = (v7 & 255)
                            pos59 = w
                            w = (w + 1)
                            v8 = data.b[r]
                            bgra.b[pos59] = (v8 & 255)
                            pos60 = w
                            w = (w + 1)
                            v9 = data.b[(r + 3)]
                            bgra.b[pos60] = (v9 & 255)
                            r = (r + 4)
                    else:
                        _g114 = 0
                        _g213 = width1
                        while (_g114 < _g213):
                            x11 = _g114
                            _g114 = (_g114 + 1)
                            pos61 = w
                            w = (w + 1)
                            cb = data.b[(r + 2)]
                            bgra.b[pos61] = (cb & 255)
                            pos62 = w
                            w = (w + 1)
                            cg = data.b[(r + 1)]
                            bgra.b[pos62] = (cg & 255)
                            pos63 = w
                            w = (w + 1)
                            cr = data.b[r]
                            bgra.b[pos63] = (cr & 255)
                            pos64 = w
                            w = (w + 1)
                            bgra.b[pos64] = (((0 if ((((cr == alphaRed) and ((cg == alphaGreen))) and ((cb == alphaBlue)))) else 255)) & 255)
                            r = (r + 3)
                elif (f3 == 1):
                    ca3 = 0
                    cb = ca3
                    cg = cb
                    cr = cg
                    if alpha1:
                        _g115 = 0
                        _g214 = width1
                        while (_g115 < _g214):
                            x12 = _g115
                            _g115 = (_g115 + 1)
                            cb = (cb + data.b[(r + 2)])
                            pos65 = w
                            w = (w + 1)
                            bgra.b[pos65] = (cb & 255)
                            cg = (cg + data.b[(r + 1)])
                            pos66 = w
                            w = (w + 1)
                            bgra.b[pos66] = (cg & 255)
                            cr = (cr + data.b[r])
                            pos67 = w
                            w = (w + 1)
                            bgra.b[pos67] = (cr & 255)
                            ca3 = (ca3 + data.b[(r + 3)])
                            pos68 = w
                            w = (w + 1)
                            bgra.b[pos68] = (ca3 & 255)
                            r = (r + 4)
                    else:
                        _g116 = 0
                        _g215 = width1
                        while (_g116 < _g215):
                            x13 = _g116
                            _g116 = (_g116 + 1)
                            cb = (cb + data.b[(r + 2)])
                            pos69 = w
                            w = (w + 1)
                            bgra.b[pos69] = (cb & 255)
                            cg = (cg + data.b[(r + 1)])
                            pos70 = w
                            w = (w + 1)
                            bgra.b[pos70] = (cg & 255)
                            cr = (cr + data.b[r])
                            pos71 = w
                            w = (w + 1)
                            bgra.b[pos71] = (cr & 255)
                            pos72 = w
                            w = (w + 1)
                            bgra.b[pos72] = (((0 if ((((cr == alphaRed) and ((cg == alphaGreen))) and ((cb == alphaBlue)))) else 255)) & 255)
                            r = (r + 3)
                elif (f3 == 2):
                    stride5 = (0 if ((y1 == 0)) else ((width1 * 4) * flipY1))
                    if alpha1:
                        _g117 = 0
                        _g216 = width1
                        while (_g117 < _g216):
                            x14 = _g117
                            _g117 = (_g117 + 1)
                            v10 = (data.b[(r + 2)] + bgra.b[(w - stride5)])
                            bgra.b[w] = (v10 & 255)
                            w = (w + 1)
                            v11 = (data.b[(r + 1)] + bgra.b[(w - stride5)])
                            bgra.b[w] = (v11 & 255)
                            w = (w + 1)
                            v12 = (data.b[r] + bgra.b[(w - stride5)])
                            bgra.b[w] = (v12 & 255)
                            w = (w + 1)
                            v13 = (data.b[(r + 3)] + bgra.b[(w - stride5)])
                            bgra.b[w] = (v13 & 255)
                            w = (w + 1)
                            r = (r + 4)
                    else:
                        _g118 = 0
                        _g217 = width1
                        while (_g118 < _g217):
                            x15 = _g118
                            _g118 = (_g118 + 1)
                            cb = (data.b[(r + 2)] + bgra.b[(w - stride5)])
                            bgra.b[w] = (cb & 255)
                            w = (w + 1)
                            cg = (data.b[(r + 1)] + bgra.b[(w - stride5)])
                            bgra.b[w] = (cg & 255)
                            w = (w + 1)
                            cr = (data.b[r] + bgra.b[(w - stride5)])
                            bgra.b[w] = (cr & 255)
                            w = (w + 1)
                            pos73 = w
                            w = (w + 1)
                            bgra.b[pos73] = (((0 if ((((cr == alphaRed) and ((cg == alphaGreen))) and ((cb == alphaBlue)))) else 255)) & 255)
                            r = (r + 3)
                elif (f3 == 3):
                    ca3 = 0
                    cb = ca3
                    cg = cb
                    cr = cg
                    stride6 = (0 if ((y1 == 0)) else ((width1 * 4) * flipY1))
                    if alpha1:
                        _g119 = 0
                        _g218 = width1
                        while (_g119 < _g218):
                            x16 = _g119
                            _g119 = (_g119 + 1)
                            cb = ((data.b[(r + 2)] + (((cb + bgra.b[(w - stride6)]) >> 1))) & 255)
                            pos74 = w
                            w = (w + 1)
                            bgra.b[pos74] = (cb & 255)
                            cg = ((data.b[(r + 1)] + (((cg + bgra.b[(w - stride6)]) >> 1))) & 255)
                            pos75 = w
                            w = (w + 1)
                            bgra.b[pos75] = (cg & 255)
                            cr = ((data.b[r] + (((cr + bgra.b[(w - stride6)]) >> 1))) & 255)
                            pos76 = w
                            w = (w + 1)
                            bgra.b[pos76] = (cr & 255)
                            ca3 = ((data.b[(r + 3)] + (((ca3 + bgra.b[(w - stride6)]) >> 1))) & 255)
                            pos77 = w
                            w = (w + 1)
                            bgra.b[pos77] = (ca3 & 255)
                            r = (r + 4)
                    else:
                        _g120 = 0
                        _g219 = width1
                        while (_g120 < _g219):
                            x17 = _g120
                            _g120 = (_g120 + 1)
                            cb = ((data.b[(r + 2)] + (((cb + bgra.b[(w - stride6)]) >> 1))) & 255)
                            pos78 = w
                            w = (w + 1)
                            bgra.b[pos78] = (cb & 255)
                            cg = ((data.b[(r + 1)] + (((cg + bgra.b[(w - stride6)]) >> 1))) & 255)
                            pos79 = w
                            w = (w + 1)
                            bgra.b[pos79] = (cg & 255)
                            cr = ((data.b[r] + (((cr + bgra.b[(w - stride6)]) >> 1))) & 255)
                            pos80 = w
                            w = (w + 1)
                            bgra.b[pos80] = (cr & 255)
                            pos81 = w
                            w = (w + 1)
                            bgra.b[pos81] = (((0 if ((((cr == alphaRed) and ((cg == alphaGreen))) and ((cb == alphaBlue)))) else 255)) & 255)
                            r = (r + 3)
                elif (f3 == 4):
                    stride7 = ((width1 * 4) * flipY1)
                    ca3 = 0
                    cb = ca3
                    cg = cb
                    cr = cg
                    if alpha1:
                        _g121 = 0
                        _g220 = width1
                        while (_g121 < _g220):
                            x18 = _g121
                            _g121 = (_g121 + 1)
                            b4 = (0 if ((y1 == 0)) else bgra.b[(w - stride7)])
                            c4 = (0 if (((x18 == 0) or ((y1 == 0)))) else bgra.b[((w - stride7) - 4)])
                            k3 = ((cb + b4) - c4)
                            pa3 = (k3 - cb)
                            if (pa3 < 0):
                                pa3 = -pa3
                            pb3 = (k3 - b4)
                            if (pb3 < 0):
                                pb3 = -pb3
                            pc3 = (k3 - c4)
                            if (pc3 < 0):
                                pc3 = -pc3
                            cb = ((((cb if (((pa3 <= pb3) and ((pa3 <= pc3)))) else (b4 if ((pb3 <= pc3)) else c4))) + data.b[(r + 2)]) & 255)
                            pos82 = w
                            w = (w + 1)
                            bgra.b[pos82] = (cb & 255)
                            b5 = (0 if ((y1 == 0)) else bgra.b[(w - stride7)])
                            c5 = (0 if (((x18 == 0) or ((y1 == 0)))) else bgra.b[((w - stride7) - 4)])
                            k4 = ((cg + b5) - c5)
                            pa4 = (k4 - cg)
                            if (pa4 < 0):
                                pa4 = -pa4
                            pb4 = (k4 - b5)
                            if (pb4 < 0):
                                pb4 = -pb4
                            pc4 = (k4 - c5)
                            if (pc4 < 0):
                                pc4 = -pc4
                            cg = ((((cg if (((pa4 <= pb4) and ((pa4 <= pc4)))) else (b5 if ((pb4 <= pc4)) else c5))) + data.b[(r + 1)]) & 255)
                            pos83 = w
                            w = (w + 1)
                            bgra.b[pos83] = (cg & 255)
                            b6 = (0 if ((y1 == 0)) else bgra.b[(w - stride7)])
                            c6 = (0 if (((x18 == 0) or ((y1 == 0)))) else bgra.b[((w - stride7) - 4)])
                            k5 = ((cr + b6) - c6)
                            pa5 = (k5 - cr)
                            if (pa5 < 0):
                                pa5 = -pa5
                            pb5 = (k5 - b6)
                            if (pb5 < 0):
                                pb5 = -pb5
                            pc5 = (k5 - c6)
                            if (pc5 < 0):
                                pc5 = -pc5
                            cr = ((((cr if (((pa5 <= pb5) and ((pa5 <= pc5)))) else (b6 if ((pb5 <= pc5)) else c6))) + data.b[r]) & 255)
                            pos84 = w
                            w = (w + 1)
                            bgra.b[pos84] = (cr & 255)
                            b7 = (0 if ((y1 == 0)) else bgra.b[(w - stride7)])
                            c7 = (0 if (((x18 == 0) or ((y1 == 0)))) else bgra.b[((w - stride7) - 4)])
                            k6 = ((ca3 + b7) - c7)
                            pa6 = (k6 - ca3)
                            if (pa6 < 0):
                                pa6 = -pa6
                            pb6 = (k6 - b7)
                            if (pb6 < 0):
                                pb6 = -pb6
                            pc6 = (k6 - c7)
                            if (pc6 < 0):
                                pc6 = -pc6
                            ca3 = ((((ca3 if (((pa6 <= pb6) and ((pa6 <= pc6)))) else (b7 if ((pb6 <= pc6)) else c7))) + data.b[(r + 3)]) & 255)
                            pos85 = w
                            w = (w + 1)
                            bgra.b[pos85] = (ca3 & 255)
                            r = (r + 4)
                    else:
                        _g122 = 0
                        _g221 = width1
                        while (_g122 < _g221):
                            x19 = _g122
                            _g122 = (_g122 + 1)
                            b8 = (0 if ((y1 == 0)) else bgra.b[(w - stride7)])
                            c8 = (0 if (((x19 == 0) or ((y1 == 0)))) else bgra.b[((w - stride7) - 4)])
                            k7 = ((cb + b8) - c8)
                            pa7 = (k7 - cb)
                            if (pa7 < 0):
                                pa7 = -pa7
                            pb7 = (k7 - b8)
                            if (pb7 < 0):
                                pb7 = -pb7
                            pc7 = (k7 - c8)
                            if (pc7 < 0):
                                pc7 = -pc7
                            cb = ((((cb if (((pa7 <= pb7) and ((pa7 <= pc7)))) else (b8 if ((pb7 <= pc7)) else c8))) + data.b[(r + 2)]) & 255)
                            pos86 = w
                            w = (w + 1)
                            bgra.b[pos86] = (cb & 255)
                            b9 = (0 if ((y1 == 0)) else bgra.b[(w - stride7)])
                            c9 = (0 if (((x19 == 0) or ((y1 == 0)))) else bgra.b[((w - stride7) - 4)])
                            k8 = ((cg + b9) - c9)
                            pa8 = (k8 - cg)
                            if (pa8 < 0):
                                pa8 = -pa8
                            pb8 = (k8 - b9)
                            if (pb8 < 0):
                                pb8 = -pb8
                            pc8 = (k8 - c9)
                            if (pc8 < 0):
                                pc8 = -pc8
                            cg = ((((cg if (((pa8 <= pb8) and ((pa8 <= pc8)))) else (b9 if ((pb8 <= pc8)) else c9))) + data.b[(r + 1)]) & 255)
                            pos87 = w
                            w = (w + 1)
                            bgra.b[pos87] = (cg & 255)
                            b10 = (0 if ((y1 == 0)) else bgra.b[(w - stride7)])
                            c10 = (0 if (((x19 == 0) or ((y1 == 0)))) else bgra.b[((w - stride7) - 4)])
                            k9 = ((cr + b10) - c10)
                            pa9 = (k9 - cr)
                            if (pa9 < 0):
                                pa9 = -pa9
                            pb9 = (k9 - b10)
                            if (pb9 < 0):
                                pb9 = -pb9
                            pc9 = (k9 - c10)
                            if (pc9 < 0):
                                pc9 = -pc9
                            cr = ((((cr if (((pa9 <= pb9) and ((pa9 <= pc9)))) else (b10 if ((pb9 <= pc9)) else c10))) + data.b[r]) & 255)
                            pos88 = w
                            w = (w + 1)
                            bgra.b[pos88] = (cr & 255)
                            pos89 = w
                            w = (w + 1)
                            bgra.b[pos89] = (((0 if ((((cr == alphaRed) and ((cg == alphaGreen))) and ((cb == alphaBlue)))) else 255)) & 255)
                            r = (r + 3)
                else:
                    raise _HxException(("Invalid filter " + Std.string(f2)))
                w = (w + lineDelta)
        elif (tmp == 2):
            pal = format_png_Tools.getPalette(d)
            if (pal is None):
                raise _HxException("PNG Palette is missing")
            alpha2 = None
            _g1_head2 = d.h
            while (_g1_head2 is not None):
                val3 = _g1_head2.item
                _g1_head2 = _g1_head2.next
                t2 = val3
                if (t2.index == 4):
                    if (t2.params[0] == "tRNS"):
                        data3 = t2.params[1]
                        alpha2 = data3
                        break
            if ((alpha2 is not None) and ((alpha2.length < ((1 << h.colbits))))):
                alpha21 = haxe_io_Bytes.alloc((1 << h.colbits))
                alpha21.blit(0,alpha2,0,alpha2.length)
                alpha21.fill(alpha2.length,(alpha21.length - alpha2.length),255)
                alpha2 = alpha21
            width2 = h.width
            stride8 = (Math.ceil(((width2 * h.colbits) / 8)) + 1)
            if (data.length < ((h.height * stride8))):
                raise _HxException("Not enough data")
            tmp1 = (h.width * h.colbits)
            rline = (tmp1 >> 3)
            _g222 = 0
            _g3 = h.height
            while (_g222 < _g3):
                y2 = _g222
                _g222 = (_g222 + 1)
                pos90 = r
                r = (r + 1)
                f4 = data.b[pos90]
                if (f4 == 0):
                    r = (r + rline)
                    continue
                f5 = f4
                if (f5 == 1):
                    c11 = 0
                    _g223 = 0
                    _g31 = width2
                    while (_g223 < _g31):
                        x20 = _g223
                        _g223 = (_g223 + 1)
                        v14 = data.b[r]
                        c11 = (c11 + v14)
                        pos91 = r
                        r = (r + 1)
                        data.b[pos91] = ((c11 & 255) & 255)
                elif (f5 == 2):
                    stride9 = (0 if ((y2 == 0)) else (rline + 1))
                    _g224 = 0
                    _g32 = width2
                    while (_g224 < _g32):
                        x21 = _g224
                        _g224 = (_g224 + 1)
                        v15 = data.b[r]
                        v16 = (v15 + data.b[(r - stride9)])
                        data.b[r] = (v16 & 255)
                        r = (r + 1)
                elif (f5 == 3):
                    c12 = 0
                    stride10 = (0 if ((y2 == 0)) else (rline + 1))
                    _g225 = 0
                    _g33 = width2
                    while (_g225 < _g33):
                        x22 = _g225
                        _g225 = (_g225 + 1)
                        v17 = data.b[r]
                        c12 = ((v17 + (((c12 + data.b[(r - stride10)]) >> 1))) & 255)
                        pos92 = r
                        r = (r + 1)
                        data.b[pos92] = (c12 & 255)
                elif (f5 == 4):
                    stride11 = (rline + 1)
                    c13 = 0
                    _g226 = 0
                    _g34 = width2
                    while (_g226 < _g34):
                        x23 = _g226
                        _g226 = (_g226 + 1)
                        v18 = data.b[r]
                        numChannels = 1
                        if (numChannels is None):
                            numChannels = 4
                        b11 = (0 if ((y2 == 0)) else data.b[(r - stride11)])
                        c14 = (0 if (((x23 == 0) or ((y2 == 0)))) else data.b[((r - stride11) - numChannels)])
                        k10 = ((c13 + b11) - c14)
                        pa10 = (k10 - c13)
                        if (pa10 < 0):
                            pa10 = -pa10
                        pb10 = (k10 - b11)
                        if (pb10 < 0):
                            pb10 = -pb10
                        pc10 = (k10 - c14)
                        if (pc10 < 0):
                            pc10 = -pc10
                        c13 = ((((c13 if (((pa10 <= pb10) and ((pa10 <= pc10)))) else (b11 if ((pb10 <= pc10)) else c14))) + v18) & 255)
                        pos93 = r
                        r = (r + 1)
                        data.b[pos93] = (c13 & 255)
                else:
                    raise _HxException(("Invalid filter " + Std.string(f4)))
            r1 = 0
            if (h.colbits == 8):
                _g4 = 0
                _g5 = h.height
                while (_g4 < _g5):
                    y3 = _g4
                    _g4 = (_g4 + 1)
                    r1 = (r1 + 1)
                    _g41 = 0
                    _g51 = h.width
                    while (_g41 < _g51):
                        x24 = _g41
                        _g41 = (_g41 + 1)
                        pos94 = r1
                        r1 = (r1 + 1)
                        c15 = data.b[pos94]
                        pos95 = w
                        w = (w + 1)
                        v19 = pal.b[((c15 * 3) + 2)]
                        bgra.b[pos95] = (v19 & 255)
                        pos96 = w
                        w = (w + 1)
                        v20 = pal.b[((c15 * 3) + 1)]
                        bgra.b[pos96] = (v20 & 255)
                        pos97 = w
                        w = (w + 1)
                        v21 = pal.b[(c15 * 3)]
                        bgra.b[pos97] = (v21 & 255)
                        pos98 = w
                        w = (w + 1)
                        v22 = (alpha2.b[c15] if ((alpha2 is not None)) else 255)
                        bgra.b[pos98] = (v22 & 255)
                    w = (w + lineDelta)
            elif (h.colbits < 8):
                req = h.colbits
                mask = (((1 << req)) - 1)
                _g42 = 0
                _g52 = h.height
                while (_g42 < _g52):
                    y4 = _g42
                    _g42 = (_g42 + 1)
                    r1 = (r1 + 1)
                    bits = 0
                    nbits = 0
                    _g43 = 0
                    _g53 = h.width
                    while (_g43 < _g53):
                        x25 = _g43
                        _g43 = (_g43 + 1)
                        if (nbits < req):
                            pos99 = r1
                            r1 = (r1 + 1)
                            bits = ((bits << 8) | data.b[pos99])
                            nbits = (nbits + 8)
                        c16 = (HxOverrides.rshift(bits, ((nbits - req))) & mask)
                        nbits = (nbits - req)
                        pos100 = w
                        w = (w + 1)
                        v23 = pal.b[((c16 * 3) + 2)]
                        bgra.b[pos100] = (v23 & 255)
                        pos101 = w
                        w = (w + 1)
                        v24 = pal.b[((c16 * 3) + 1)]
                        bgra.b[pos101] = (v24 & 255)
                        pos102 = w
                        w = (w + 1)
                        v25 = pal.b[(c16 * 3)]
                        bgra.b[pos102] = (v25 & 255)
                        pos103 = w
                        w = (w + 1)
                        v26 = (alpha2.b[c16] if ((alpha2 is not None)) else 255)
                        bgra.b[pos103] = (v26 & 255)
                    w = (w + lineDelta)
            else:
                raise _HxException((Std.string(h.colbits) + " indexed bits per pixel not supported"))
        else:
            pass
        return bgra

    @staticmethod
    def buildGrey(width,height,data,level = None):
        if (level is None):
            level = 9
        rgb = haxe_io_Bytes.alloc(((width * height) + height))
        w = 0
        r = 0
        _g = 0
        _g1 = height
        while (_g < _g1):
            y = _g
            _g = (_g + 1)
            pos = w
            w = (w + 1)
            rgb.b[pos] = 0
            _g2 = 0
            _g11 = width
            while (_g2 < _g11):
                x = _g2
                _g2 = (_g2 + 1)
                pos1 = w
                w = (w + 1)
                pos2 = r
                r = (r + 1)
                v = data.b[pos2]
                rgb.b[pos1] = (v & 255)
        l = haxe_ds_List()
        l.add(format_png_Chunk.CHeader(_hx_AnonObject({'width': width, 'height': height, 'colbits': 8, 'color': format_png_Color.ColGrey(False), 'interlaced': False})))
        l.add(format_png_Chunk.CData(format_tools_Deflate.run(rgb,level)))
        l.add(format_png_Chunk.CEnd)
        return l

    @staticmethod
    def buildIndexed(width,height,data,palette,level = None):
        if (level is None):
            level = 9
        rgb = haxe_io_Bytes.alloc(((width * height) + height))
        w = 0
        r = 0
        _g = 0
        _g1 = height
        while (_g < _g1):
            y = _g
            _g = (_g + 1)
            pos = w
            w = (w + 1)
            rgb.b[pos] = 0
            _g2 = 0
            _g11 = width
            while (_g2 < _g11):
                x = _g2
                _g2 = (_g2 + 1)
                pos1 = w
                w = (w + 1)
                pos2 = r
                r = (r + 1)
                v = data.b[pos2]
                rgb.b[pos1] = (v & 255)
        l = haxe_ds_List()
        l.add(format_png_Chunk.CHeader(_hx_AnonObject({'width': width, 'height': height, 'colbits': 8, 'color': format_png_Color.ColIndexed, 'interlaced': False})))
        l.add(format_png_Chunk.CPalette(palette))
        l.add(format_png_Chunk.CData(format_tools_Deflate.run(rgb,level)))
        l.add(format_png_Chunk.CEnd)
        return l

    @staticmethod
    def buildRGB(width,height,data,level = None):
        if (level is None):
            level = 9
        rgb = haxe_io_Bytes.alloc((((width * height) * 3) + height))
        w = 0
        r = 0
        _g = 0
        _g1 = height
        while (_g < _g1):
            y = _g
            _g = (_g + 1)
            pos = w
            w = (w + 1)
            rgb.b[pos] = 0
            _g2 = 0
            _g11 = width
            while (_g2 < _g11):
                x = _g2
                _g2 = (_g2 + 1)
                pos1 = w
                w = (w + 1)
                v = data.b[(r + 2)]
                rgb.b[pos1] = (v & 255)
                pos2 = w
                w = (w + 1)
                v1 = data.b[(r + 1)]
                rgb.b[pos2] = (v1 & 255)
                pos3 = w
                w = (w + 1)
                v2 = data.b[r]
                rgb.b[pos3] = (v2 & 255)
                r = (r + 3)
        l = haxe_ds_List()
        l.add(format_png_Chunk.CHeader(_hx_AnonObject({'width': width, 'height': height, 'colbits': 8, 'color': format_png_Color.ColTrue(False), 'interlaced': False})))
        l.add(format_png_Chunk.CData(format_tools_Deflate.run(rgb,level)))
        l.add(format_png_Chunk.CEnd)
        return l

    @staticmethod
    def build32ARGB(width,height,data,level = None):
        if (level is None):
            level = 9
        rgba = haxe_io_Bytes.alloc((((width * height) * 4) + height))
        w = 0
        r = 0
        _g = 0
        _g1 = height
        while (_g < _g1):
            y = _g
            _g = (_g + 1)
            pos = w
            w = (w + 1)
            rgba.b[pos] = 0
            _g2 = 0
            _g11 = width
            while (_g2 < _g11):
                x = _g2
                _g2 = (_g2 + 1)
                pos1 = w
                w = (w + 1)
                v = data.b[(r + 1)]
                rgba.b[pos1] = (v & 255)
                pos2 = w
                w = (w + 1)
                v1 = data.b[(r + 2)]
                rgba.b[pos2] = (v1 & 255)
                pos3 = w
                w = (w + 1)
                v2 = data.b[(r + 3)]
                rgba.b[pos3] = (v2 & 255)
                pos4 = w
                w = (w + 1)
                v3 = data.b[r]
                rgba.b[pos4] = (v3 & 255)
                r = (r + 4)
        l = haxe_ds_List()
        l.add(format_png_Chunk.CHeader(_hx_AnonObject({'width': width, 'height': height, 'colbits': 8, 'color': format_png_Color.ColTrue(True), 'interlaced': False})))
        l.add(format_png_Chunk.CData(format_tools_Deflate.run(rgba,level)))
        l.add(format_png_Chunk.CEnd)
        return l

    @staticmethod
    def build32BGRA(width,height,data,level = None):
        if (level is None):
            level = 9
        rgba = haxe_io_Bytes.alloc((((width * height) * 4) + height))
        w = 0
        r = 0
        _g = 0
        _g1 = height
        while (_g < _g1):
            y = _g
            _g = (_g + 1)
            pos = w
            w = (w + 1)
            rgba.b[pos] = 0
            _g2 = 0
            _g11 = width
            while (_g2 < _g11):
                x = _g2
                _g2 = (_g2 + 1)
                pos1 = w
                w = (w + 1)
                v = data.b[(r + 2)]
                rgba.b[pos1] = (v & 255)
                pos2 = w
                w = (w + 1)
                v1 = data.b[(r + 1)]
                rgba.b[pos2] = (v1 & 255)
                pos3 = w
                w = (w + 1)
                v2 = data.b[r]
                rgba.b[pos3] = (v2 & 255)
                pos4 = w
                w = (w + 1)
                v3 = data.b[(r + 3)]
                rgba.b[pos4] = (v3 & 255)
                r = (r + 4)
        l = haxe_ds_List()
        l.add(format_png_Chunk.CHeader(_hx_AnonObject({'width': width, 'height': height, 'colbits': 8, 'color': format_png_Color.ColTrue(True), 'interlaced': False})))
        l.add(format_png_Chunk.CData(format_tools_Deflate.run(rgba,level)))
        l.add(format_png_Chunk.CEnd)
        return l
format_png_Tools._hx_class = format_png_Tools
_hx_classes["format.png.Tools"] = format_png_Tools


class format_png_Writer:
    _hx_class_name = "format.png.Writer"
    _hx_is_interface = "False"
    __slots__ = ("o",)
    _hx_fields = ["o"]
    _hx_methods = ["write", "writeChunk"]

    def __init__(self,o):
        self.o = o
        o.set_bigEndian(True)

    def write(self,png):
        b = 137
        self.o.writeByte(b)
        b1 = 80
        self.o.writeByte(b1)
        b2 = 78
        self.o.writeByte(b2)
        b3 = 71
        self.o.writeByte(b3)
        b4 = 13
        self.o.writeByte(b4)
        b5 = 10
        self.o.writeByte(b5)
        b6 = 26
        self.o.writeByte(b6)
        b7 = 10
        self.o.writeByte(b7)
        _g_head = png.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            c = val
            tmp = c.index
            if (tmp == 0):
                self.writeChunk("IEND",haxe_io_Bytes.alloc(0))
            elif (tmp == 1):
                h = c.params[0]
                b8 = haxe_io_BytesOutput()
                b8.set_bigEndian(True)
                b8.writeInt32(h.width)
                b8.writeInt32(h.height)
                b8.writeByte(h.colbits)
                _g = h.color
                tmp1 = None
                tmp2 = _g.index
                if (tmp2 == 0):
                    alpha = _g.params[0]
                    tmp1 = (4 if alpha else 0)
                elif (tmp2 == 1):
                    alpha1 = _g.params[0]
                    tmp1 = (6 if alpha1 else 2)
                elif (tmp2 == 2):
                    tmp1 = 3
                else:
                    pass
                b8.writeByte(tmp1)
                b8.writeByte(0)
                b8.writeByte(0)
                b8.writeByte((1 if (h.interlaced) else 0))
                self.writeChunk("IHDR",b8.getBytes())
            elif (tmp == 2):
                d = c.params[0]
                self.writeChunk("IDAT",d)
            elif (tmp == 3):
                b9 = c.params[0]
                self.writeChunk("PLTE",b9)
            elif (tmp == 4):
                data = c.params[1]
                id = c.params[0]
                self.writeChunk(id,data)
            else:
                pass

    def writeChunk(self,id,data):
        self.o.writeInt32(data.length)
        self.o.writeString(id)
        self.o.write(data)
        crc_crc = -1
        tmp = (((crc_crc ^ HxString.charCodeAt(id,0))) & 255)
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        tmp = (HxOverrides.rshift(tmp, 1) ^ ((-((tmp & 1)) & -306674912)))
        crc_crc = (HxOverrides.rshift(crc_crc, 8) ^ tmp)
        tmp1 = (((crc_crc ^ HxString.charCodeAt(id,1))) & 255)
        tmp1 = (HxOverrides.rshift(tmp1, 1) ^ ((-((tmp1 & 1)) & -306674912)))
        tmp1 = (HxOverrides.rshift(tmp1, 1) ^ ((-((tmp1 & 1)) & -306674912)))
        tmp1 = (HxOverrides.rshift(tmp1, 1) ^ ((-((tmp1 & 1)) & -306674912)))
        tmp1 = (HxOverrides.rshift(tmp1, 1) ^ ((-((tmp1 & 1)) & -306674912)))
        tmp1 = (HxOverrides.rshift(tmp1, 1) ^ ((-((tmp1 & 1)) & -306674912)))
        tmp1 = (HxOverrides.rshift(tmp1, 1) ^ ((-((tmp1 & 1)) & -306674912)))
        tmp1 = (HxOverrides.rshift(tmp1, 1) ^ ((-((tmp1 & 1)) & -306674912)))
        tmp1 = (HxOverrides.rshift(tmp1, 1) ^ ((-((tmp1 & 1)) & -306674912)))
        crc_crc = (HxOverrides.rshift(crc_crc, 8) ^ tmp1)
        tmp2 = (((crc_crc ^ HxString.charCodeAt(id,2))) & 255)
        tmp2 = (HxOverrides.rshift(tmp2, 1) ^ ((-((tmp2 & 1)) & -306674912)))
        tmp2 = (HxOverrides.rshift(tmp2, 1) ^ ((-((tmp2 & 1)) & -306674912)))
        tmp2 = (HxOverrides.rshift(tmp2, 1) ^ ((-((tmp2 & 1)) & -306674912)))
        tmp2 = (HxOverrides.rshift(tmp2, 1) ^ ((-((tmp2 & 1)) & -306674912)))
        tmp2 = (HxOverrides.rshift(tmp2, 1) ^ ((-((tmp2 & 1)) & -306674912)))
        tmp2 = (HxOverrides.rshift(tmp2, 1) ^ ((-((tmp2 & 1)) & -306674912)))
        tmp2 = (HxOverrides.rshift(tmp2, 1) ^ ((-((tmp2 & 1)) & -306674912)))
        tmp2 = (HxOverrides.rshift(tmp2, 1) ^ ((-((tmp2 & 1)) & -306674912)))
        crc_crc = (HxOverrides.rshift(crc_crc, 8) ^ tmp2)
        tmp3 = (((crc_crc ^ HxString.charCodeAt(id,3))) & 255)
        tmp3 = (HxOverrides.rshift(tmp3, 1) ^ ((-((tmp3 & 1)) & -306674912)))
        tmp3 = (HxOverrides.rshift(tmp3, 1) ^ ((-((tmp3 & 1)) & -306674912)))
        tmp3 = (HxOverrides.rshift(tmp3, 1) ^ ((-((tmp3 & 1)) & -306674912)))
        tmp3 = (HxOverrides.rshift(tmp3, 1) ^ ((-((tmp3 & 1)) & -306674912)))
        tmp3 = (HxOverrides.rshift(tmp3, 1) ^ ((-((tmp3 & 1)) & -306674912)))
        tmp3 = (HxOverrides.rshift(tmp3, 1) ^ ((-((tmp3 & 1)) & -306674912)))
        tmp3 = (HxOverrides.rshift(tmp3, 1) ^ ((-((tmp3 & 1)) & -306674912)))
        tmp3 = (HxOverrides.rshift(tmp3, 1) ^ ((-((tmp3 & 1)) & -306674912)))
        crc_crc = (HxOverrides.rshift(crc_crc, 8) ^ tmp3)
        b = data.b
        _g = 0
        _g1 = data.length
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            tmp4 = (((crc_crc ^ b[i])) & 255)
            tmp4 = (HxOverrides.rshift(tmp4, 1) ^ ((-((tmp4 & 1)) & -306674912)))
            tmp4 = (HxOverrides.rshift(tmp4, 1) ^ ((-((tmp4 & 1)) & -306674912)))
            tmp4 = (HxOverrides.rshift(tmp4, 1) ^ ((-((tmp4 & 1)) & -306674912)))
            tmp4 = (HxOverrides.rshift(tmp4, 1) ^ ((-((tmp4 & 1)) & -306674912)))
            tmp4 = (HxOverrides.rshift(tmp4, 1) ^ ((-((tmp4 & 1)) & -306674912)))
            tmp4 = (HxOverrides.rshift(tmp4, 1) ^ ((-((tmp4 & 1)) & -306674912)))
            tmp4 = (HxOverrides.rshift(tmp4, 1) ^ ((-((tmp4 & 1)) & -306674912)))
            tmp4 = (HxOverrides.rshift(tmp4, 1) ^ ((-((tmp4 & 1)) & -306674912)))
            crc_crc = (HxOverrides.rshift(crc_crc, 8) ^ tmp4)
        self.o.writeInt32((crc_crc ^ -1))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.o = None
format_png_Writer._hx_class = format_png_Writer
_hx_classes["format.png.Writer"] = format_png_Writer

class format_tga_ImageOrigin(Enum):
    __slots__ = ()
    _hx_class_name = "format.tga.ImageOrigin"
    _hx_constructs = ["BottomLeft", "BottomRight", "TopLeft", "TopRight"]
format_tga_ImageOrigin.BottomLeft = format_tga_ImageOrigin("BottomLeft", 0, ())
format_tga_ImageOrigin.BottomRight = format_tga_ImageOrigin("BottomRight", 1, ())
format_tga_ImageOrigin.TopLeft = format_tga_ImageOrigin("TopLeft", 2, ())
format_tga_ImageOrigin.TopRight = format_tga_ImageOrigin("TopRight", 3, ())
format_tga_ImageOrigin._hx_class = format_tga_ImageOrigin
_hx_classes["format.tga.ImageOrigin"] = format_tga_ImageOrigin

class format_tga_ImageType(Enum):
    __slots__ = ()
    _hx_class_name = "format.tga.ImageType"
    _hx_constructs = ["NoImage", "UncompressedColorMapped", "UncompressedTrueColor", "UncompressedBlackAndWhite", "RunLengthColorMapped", "RunLengthTrueColor", "RunLengthBlackAndWhite", "Unknown"]

    @staticmethod
    def Unknown(type):
        return format_tga_ImageType("Unknown", 7, (type,))
format_tga_ImageType.NoImage = format_tga_ImageType("NoImage", 0, ())
format_tga_ImageType.UncompressedColorMapped = format_tga_ImageType("UncompressedColorMapped", 1, ())
format_tga_ImageType.UncompressedTrueColor = format_tga_ImageType("UncompressedTrueColor", 2, ())
format_tga_ImageType.UncompressedBlackAndWhite = format_tga_ImageType("UncompressedBlackAndWhite", 3, ())
format_tga_ImageType.RunLengthColorMapped = format_tga_ImageType("RunLengthColorMapped", 4, ())
format_tga_ImageType.RunLengthTrueColor = format_tga_ImageType("RunLengthTrueColor", 5, ())
format_tga_ImageType.RunLengthBlackAndWhite = format_tga_ImageType("RunLengthBlackAndWhite", 6, ())
format_tga_ImageType._hx_class = format_tga_ImageType
_hx_classes["format.tga.ImageType"] = format_tga_ImageType


class format_tga_Reader:
    _hx_class_name = "format.tga.Reader"
    _hx_is_interface = "False"
    __slots__ = ("i",)
    _hx_fields = ["i"]
    _hx_methods = ["read", "readHeader", "readColorMapData", "readImageData", "readPixels", "readMono", "readIndexes", "parsePixel1", "parsePixelGreyAlpha", "parsePixel2", "parsePixel3", "parsePixel4"]

    def __init__(self,i):
        self.i = i
        i.set_bigEndian(False)

    def read(self):
        idLength = self.i.readByte()
        header = self.readHeader()
        id = ("" if ((idLength == 0)) else self.i.readString(idLength))
        colorMap = self.readColorMapData(header)
        return _hx_AnonObject({'header': header, 'imageId': id, 'colorMapData': colorMap, 'imageData': self.readImageData(header,colorMap), 'developerData': None})

    def readHeader(self):
        colorMapType = self.i.readByte()
        dataType = None
        dataId = self.i.readByte()
        dataId1 = dataId
        if (dataId1 == 0):
            dataType = format_tga_ImageType.NoImage
        elif (dataId1 == 1):
            dataType = format_tga_ImageType.UncompressedColorMapped
        elif (dataId1 == 2):
            dataType = format_tga_ImageType.UncompressedTrueColor
        elif (dataId1 == 3):
            dataType = format_tga_ImageType.UncompressedBlackAndWhite
        elif (dataId1 == 9):
            dataType = format_tga_ImageType.RunLengthColorMapped
        elif (dataId1 == 10):
            dataType = format_tga_ImageType.RunLengthTrueColor
        elif (dataId1 == 11):
            dataType = format_tga_ImageType.RunLengthBlackAndWhite
        else:
            dataType = format_tga_ImageType.Unknown(dataId)
        colorMapOrigin = self.i.readInt16()
        colorMapLength = self.i.readInt16()
        colorMapDepth = self.i.readByte()
        xOrigin = self.i.readInt16()
        yOrigin = self.i.readInt16()
        width = self.i.readInt16()
        height = self.i.readInt16()
        depth = self.i.readByte()
        descriptor = self.i.readByte()
        origin = None
        _g = (descriptor & 48)
        if (_g == 16):
            origin = format_tga_ImageOrigin.BottomRight
        elif (_g == 32):
            origin = format_tga_ImageOrigin.TopLeft
        elif (_g == 48):
            origin = format_tga_ImageOrigin.TopRight
        else:
            origin = format_tga_ImageOrigin.BottomLeft
        return _hx_AnonObject({'colorMapType': colorMapType, 'imageType': dataType, 'colorMapFirstIndex': colorMapOrigin, 'colorMapLength': colorMapLength, 'colorMapEntrySize': colorMapDepth, 'xOrigin': xOrigin, 'yOrigin': yOrigin, 'width': width, 'height': height, 'bitsPerPixel': depth, 'alphaChannelBits': (descriptor & 15), 'imageOrigin': origin})

    def readColorMapData(self,header):
        if (header.colorMapType == 0):
            return None
        return self.readPixels(header.colorMapEntrySize,header.colorMapLength,header.alphaChannelBits,False)

    def readImageData(self,header,colorMap):
        tmp = header.imageType.index
        if (tmp == 0):
            return None
        elif (tmp == 1):
            return self.readIndexes(header.bitsPerPixel,(header.width * header.height),colorMap,header.colorMapFirstIndex,False)
        elif (tmp == 2):
            return self.readPixels(header.bitsPerPixel,(header.width * header.height),header.alphaChannelBits,False)
        elif (tmp == 3):
            return self.readMono(header.bitsPerPixel,(header.width * header.height),header.alphaChannelBits,False)
        elif (tmp == 4):
            return self.readIndexes(header.bitsPerPixel,(header.width * header.height),colorMap,header.colorMapFirstIndex,True)
        elif (tmp == 5):
            return self.readPixels(header.bitsPerPixel,(header.width * header.height),header.alphaChannelBits,True)
        elif (tmp == 6):
            return self.readMono(header.bitsPerPixel,(header.width * header.height),header.alphaChannelBits,True)
        else:
            raise _HxException("Unsupported image data type!")

    def readPixels(self,bitsPerPixel,amount,alphaChannelBits,rle):
        this1 = [None]*amount
        _hx_list = this1
        alpha = (alphaChannelBits != 0)
        bitFieldSize = None
        try:
            bitFieldSize = int((bitsPerPixel / 3))
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            bitFieldSize = None
        bitFieldSize1 = bitFieldSize
        if (bitFieldSize1 > 8):
            bitFieldSize1 = 8
        parsePixel = None
        readEntry = None
        bitsPerPixel1 = bitsPerPixel
        if (bitsPerPixel1 == 8):
            readEntry = self.i.readByte
            parsePixel = self.parsePixel1
        elif (bitsPerPixel1 == 16):
            readEntry = self.i.readUInt16
            parsePixel = self.parsePixel2
        elif (bitsPerPixel1 == 24):
            readEntry = self.i.readUInt24
            parsePixel = self.parsePixel3
        elif (bitsPerPixel1 == 32):
            readEntry = self.i.readInt32
            parsePixel = self.parsePixel4
        else:
            raise _HxException("Unsupported bits per pixels amount!")
        if rle:
            rleChunk = None
            i = 0
            while (i < amount):
                rleChunk = self.i.readByte()
                if (((rleChunk & 128)) != 0):
                    rleChunk = (rleChunk & 127)
                    pixel = parsePixel(readEntry(),alpha)
                    while (rleChunk >= 0):
                        index = i
                        i = (i + 1)
                        _hx_list[index] = pixel
                        rleChunk = (rleChunk - 1)
                else:
                    rleChunk = (rleChunk & 127)
                    while (rleChunk >= 0):
                        index1 = i
                        i = (i + 1)
                        val = parsePixel(readEntry(),alpha)
                        _hx_list[index1] = val
                        rleChunk = (rleChunk - 1)
        else:
            _g = 0
            _g1 = amount
            while (_g < _g1):
                i1 = _g
                _g = (_g + 1)
                val1 = parsePixel(readEntry(),alpha)
                _hx_list[i1] = val1
        return _hx_list

    def readMono(self,bitsPerPixel,amount,alphaChannelBits,rle):
        this1 = [None]*amount
        _hx_list = this1
        alpha = (alphaChannelBits != 0)
        parsePixel = None
        readEntry = None
        bitsPerPixel1 = bitsPerPixel
        if (bitsPerPixel1 == 8):
            readEntry = self.i.readByte
            parsePixel = self.parsePixel1
        elif (bitsPerPixel1 == 16):
            readEntry = self.i.readUInt16
            parsePixel = self.parsePixelGreyAlpha
        else:
            raise _HxException("Unsupported bits per pixels amount!")
        if rle:
            rleChunk = None
            i = 0
            while (i < amount):
                rleChunk = self.i.readByte()
                if (((rleChunk & 128)) != 0):
                    rleChunk = (rleChunk & 127)
                    pixel = parsePixel(readEntry(),alpha)
                    while (rleChunk >= 0):
                        index = i
                        i = (i + 1)
                        _hx_list[index] = pixel
                        rleChunk = (rleChunk - 1)
                else:
                    rleChunk = (rleChunk & 127)
                    while (rleChunk >= 0):
                        index1 = i
                        i = (i + 1)
                        val = parsePixel(readEntry(),alpha)
                        _hx_list[index1] = val
                        rleChunk = (rleChunk - 1)
        else:
            _g = 0
            _g1 = amount
            while (_g < _g1):
                i1 = _g
                _g = (_g + 1)
                val1 = parsePixel(readEntry(),alpha)
                _hx_list[i1] = val1
        return _hx_list

    def readIndexes(self,bitsPerPixel,amount,colorMap,offset,rle):
        this1 = [None]*amount
        _hx_list = this1
        readEntry = None
        bitsPerPixel1 = bitsPerPixel
        if (bitsPerPixel1 == 8):
            readEntry = self.i.readByte
        elif (bitsPerPixel1 == 16):
            readEntry = self.i.readUInt16
        elif (bitsPerPixel1 == 24):
            readEntry = self.i.readUInt24
        elif (bitsPerPixel1 == 32):
            readEntry = self.i.readInt32
        else:
            raise _HxException("Unsupported bits per pixels amount!")
        if rle:
            i = 0
            rleChunk = None
            while (i < amount):
                rleChunk = self.i.readByte()
                if (((rleChunk & 128)) != 0):
                    rleChunk = (rleChunk & 127)
                    pixel = colorMap[(offset + readEntry())]
                    while (rleChunk >= 0):
                        index = i
                        i = (i + 1)
                        _hx_list[index] = pixel
                        rleChunk = (rleChunk - 1)
                else:
                    rleChunk = (rleChunk & 127)
                    while (rleChunk >= 0):
                        index1 = i
                        i = (i + 1)
                        val = colorMap[(offset + readEntry())]
                        _hx_list[index1] = val
                        rleChunk = (rleChunk - 1)
        else:
            _g = 0
            _g1 = amount
            while (_g < _g1):
                i1 = _g
                _g = (_g + 1)
                val1 = colorMap[(offset + readEntry())]
                _hx_list[i1] = val1
        return _hx_list

    def parsePixel1(self,value,alpha):
        return (((value << 16) | ((value << 8))) | value)

    def parsePixelGreyAlpha(self,value,alpha):
        return ((((((value & 65280)) << 16) if alpha else 0)) | self.parsePixel1((value & 255),False))

    def parsePixel2(self,value,alpha):
        tmp = ((-16777216 if ((((value & 32768)) == 1)) else 0) if alpha else 0)
        tmp1 = None
        try:
            tmp1 = int(((((((value & 31744)) >> 10)) / 31) * 255))
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            tmp1 = None
        tmp2 = (tmp | ((tmp1 << 16)))
        tmp3 = None
        try:
            tmp3 = int(((((((value & 992)) >> 5)) / 31) * 255))
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e1 = _hx_e1
            tmp3 = None
        tmp4 = (tmp2 | ((tmp3 << 8)))
        tmp5 = None
        try:
            tmp5 = int(((((value & 31)) / 31) * 255))
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e2 = _hx_e1
            tmp5 = None
        return (tmp4 | tmp5)

    def parsePixel3(self,value,alpha):
        return value

    def parsePixel4(self,value,alpha):
        return value

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.i = None
format_tga_Reader._hx_class = format_tga_Reader
_hx_classes["format.tga.Reader"] = format_tga_Reader


class format_tools_BitsInput:
    _hx_class_name = "format.tools.BitsInput"
    _hx_is_interface = "False"
    __slots__ = ("i", "nbits", "bits")
    _hx_fields = ["i", "nbits", "bits"]
    _hx_methods = ["readBits", "readBit", "reset"]

    def __init__(self,i):
        self.i = i
        self.nbits = 0
        self.bits = 0

    def readBits(self,n):
        if (self.nbits >= n):
            c = (self.nbits - n)
            k = (HxOverrides.rshift(self.bits, c) & ((((1 << n)) - 1)))
            self.nbits = c
            return k
        k1 = self.i.readByte()
        if (self.nbits >= 24):
            if (n > 31):
                raise _HxException("Bits error")
            c1 = ((8 + self.nbits) - n)
            d = (self.bits & ((((1 << self.nbits)) - 1)))
            d = ((d << ((8 - c1))) | ((k1 << c1)))
            self.bits = k1
            self.nbits = c1
            return d
        self.bits = ((self.bits << 8) | k1)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.nbits
        _hx_local_0.nbits = (_hx_local_1 + 8)
        _hx_local_0.nbits
        return self.readBits(n)

    def readBit(self):
        if (self.nbits == 0):
            self.bits = self.i.readByte()
            self.nbits = 8
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.nbits
        _hx_local_0.nbits = (_hx_local_1 - 1)
        _hx_local_1
        return (((HxOverrides.rshift(self.bits, self.nbits) & 1)) == 1)

    def reset(self):
        self.nbits = 0

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.i = None
        _hx_o.nbits = None
        _hx_o.bits = None
format_tools_BitsInput._hx_class = format_tools_BitsInput
_hx_classes["format.tools.BitsInput"] = format_tools_BitsInput


class format_tools_Deflate:
    _hx_class_name = "format.tools.Deflate"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["run"]

    @staticmethod
    def run(b,level = None):
        if (level is None):
            level = 9
        return haxe_zip_Compress.run(b,level)
format_tools_Deflate._hx_class = format_tools_Deflate
_hx_classes["format.tools.Deflate"] = format_tools_Deflate


class format_tools_Inflate:
    _hx_class_name = "format.tools.Inflate"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["run"]

    @staticmethod
    def run(_hx_bytes):
        return haxe_zip_Uncompress.run(_hx_bytes)
format_tools_Inflate._hx_class = format_tools_Inflate
_hx_classes["format.tools.Inflate"] = format_tools_Inflate

class format_wav_WAVEFormat(Enum):
    __slots__ = ()
    _hx_class_name = "format.wav.WAVEFormat"
    _hx_constructs = ["WF_PCM"]
format_wav_WAVEFormat.WF_PCM = format_wav_WAVEFormat("WF_PCM", 0, ())
format_wav_WAVEFormat._hx_class = format_wav_WAVEFormat
_hx_classes["format.wav.WAVEFormat"] = format_wav_WAVEFormat


class format_wav_Reader:
    _hx_class_name = "format.wav.Reader"
    _hx_is_interface = "False"
    __slots__ = ("i", "version")
    _hx_fields = ["i", "version"]
    _hx_methods = ["readInt", "read"]

    def __init__(self,i):
        self.version = None
        self.i = i
        i.set_bigEndian(False)

    def readInt(self):
        return self.i.readInt32()

    def read(self):
        if (self.i.readString(4) != "RIFF"):
            raise _HxException("RIFF header expected")
        _hx_len = self.i.readInt32()
        if (self.i.readString(4) != "WAVE"):
            raise _HxException("WAVE signature not found")
        fmt = self.i.readString(4)
        while (fmt != "fmt "):
            fmt1 = fmt
            if (fmt1 == "JUNK"):
                junkLen = self.i.readInt32()
                self.i.read(junkLen)
                fmt = self.i.readString(4)
            elif (fmt1 == "bext"):
                bextLen = self.i.readInt32()
                self.i.read(bextLen)
                fmt = self.i.readString(4)
            else:
                break
        if (fmt != "fmt "):
            raise _HxException(("unsupported wave chunk " + ("null" if fmt is None else fmt)))
        fmtlen = self.i.readInt32()
        format1 = None
        _g = self.i.readUInt16()
        if ((_g == 3) or ((_g == 1))):
            format1 = format_wav_WAVEFormat.WF_PCM
        else:
            raise _HxException("only PCM (uncompressed) WAV files are supported")
        channels = self.i.readUInt16()
        samplingRate = self.i.readInt32()
        byteRate = self.i.readInt32()
        blockAlign = self.i.readUInt16()
        bitsPerSample = self.i.readUInt16()
        if (fmtlen > 16):
            self.i.read((fmtlen - 16))
        nextChunk = self.i.readString(4)
        while (nextChunk != "data"):
            self.i.read(self.i.readInt32())
            nextChunk = self.i.readString(4)
        if (nextChunk != "data"):
            raise _HxException("expected data subchunk")
        datalen = self.i.readInt32()
        data = None
        try:
            data = self.i.read(datalen)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            if isinstance(_hx_e1, haxe_io_Eof):
                e = _hx_e1
                raise _HxException("Invalid chunk data length")
            else:
                raise _hx_e
        cuePoints = list()
        try:
            while True:
                nextChunk1 = self.i.readString(4)
                if (nextChunk1 == "cue "):
                    self.i.readInt32()
                    nbCuePoints = self.i.readInt32()
                    _g1 = 0
                    _g2 = nbCuePoints
                    while (_g1 < _g2):
                        _ = _g1
                        _g1 = (_g1 + 1)
                        cueId = self.i.readInt32()
                        self.i.readInt32()
                        self.i.readString(4)
                        self.i.readInt32()
                        self.i.readInt32()
                        cueSampleOffset = self.i.readInt32()
                        cuePoints.append(_hx_AnonObject({'id': cueId, 'sampleOffset': cueSampleOffset}))
                else:
                    self.i.read(self.i.readInt32())
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            if isinstance(_hx_e1, haxe_io_Eof):
                    pass
            else:
                raise _hx_e
        return _hx_AnonObject({'header': _hx_AnonObject({'format': format1, 'channels': channels, 'samplingRate': samplingRate, 'byteRate': byteRate, 'blockAlign': blockAlign, 'bitsPerSample': bitsPerSample}), 'data': data, 'cuePoints': cuePoints})

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.i = None
        _hx_o.version = None
format_wav_Reader._hx_class = format_wav_Reader
_hx_classes["format.wav.Reader"] = format_wav_Reader


class h2d_Object:
    _hx_class_name = "h2d.Object"
    _hx_is_interface = "False"
    __slots__ = ("children", "parentContainer", "parent", "name", "x", "y", "scaleX", "scaleY", "rotation", "visible", "alpha", "filter", "blendMode", "matA", "matB", "matC", "matD", "absX", "absY", "posChanged", "allocated", "lastFrame")
    _hx_fields = ["children", "parentContainer", "parent", "name", "x", "y", "scaleX", "scaleY", "rotation", "visible", "alpha", "filter", "blendMode", "matA", "matB", "matC", "matD", "absX", "absY", "posChanged", "allocated", "lastFrame"]
    _hx_methods = ["getBounds", "getSize", "getAbsPos", "find", "findAll", "set_filter", "getBoundsRec", "addBounds", "getObjectsCount", "localToGlobal", "globalToLocal", "getScene", "set_visible", "addChild", "addChildAt", "onContentChanged", "onHierarchyMoved", "onAdd", "onRemove", "getMatrix", "removeChild", "setParentContainer", "removeChildren", "remove", "drawTo", "drawToTextures", "draw", "sync", "syncPos", "calcAbsPos", "emitTile", "clipBounds", "drawFilters", "drawFiltered", "drawRec", "set_x", "set_y", "set_scaleX", "set_scaleY", "set_rotation", "move", "setPosition", "rotate", "scale", "setScale", "getChildAt", "getChildIndex", "getObjectByName", "get_numChildren", "iterator", "toString", "contentChanged", "constraintSize"]
    _hx_statics = ["nullDrawable"]

    def __init__(self,parent = None):
        self.lastFrame = None
        self.allocated = None
        self.filter = None
        self.visible = None
        self.name = None
        self.parent = None
        self.parentContainer = None
        self.children = None
        self.alpha = 1.
        self.matA = 1
        self.matB = 0
        self.matC = 0
        self.matD = 1
        self.absX = 0
        self.absY = 0
        self.posChanged = True
        self.x = 0
        self.posChanged = True
        self.y = 0
        self.posChanged = True
        self.scaleX = 1
        self.posChanged = True
        self.scaleY = 1
        self.posChanged = True
        self.rotation = 0
        self.blendMode = h2d_BlendMode.Alpha
        self.posChanged = (parent is not None)
        self.set_visible(True)
        self.children = []
        if (parent is not None):
            parent.addChild(self)

    def getBounds(self,relativeTo = None,out = None):
        if (out is None):
            out = h2d_col_Bounds()
        else:
            out.xMin = 1e20
            out.yMin = 1e20
            out.xMax = -1e20
            out.yMax = -1e20
        if (relativeTo is not None):
            relativeTo.syncPos()
        if (relativeTo != self):
            self.syncPos()
        self.getBoundsRec(relativeTo,out,False)
        if ((out.xMax <= out.xMin) or ((out.yMax <= out.yMin))):
            self.addBounds(relativeTo,out,-1,-1,2,2)
            def _hx_local_0():
                out.xMin = (((out.xMax + out.xMin)) * 0.5)
                return out.xMin
            out.xMax = _hx_local_0()
            def _hx_local_1():
                out.yMin = (((out.yMax + out.yMin)) * 0.5)
                return out.yMin
            out.yMax = _hx_local_1()
        return out

    def getSize(self,out = None):
        if (out is None):
            out = h2d_col_Bounds()
        else:
            out.xMin = 1e20
            out.yMin = 1e20
            out.xMax = -1e20
            out.yMax = -1e20
        self.syncPos()
        self.getBoundsRec(self.parent,out,True)
        if ((out.xMax <= out.xMin) or ((out.yMax <= out.yMin))):
            self.addBounds(self.parent,out,-1,-1,2,2)
            def _hx_local_0():
                out.xMin = (((out.xMax + out.xMin)) * 0.5)
                return out.xMin
            out.xMax = _hx_local_0()
            def _hx_local_1():
                out.yMin = (((out.yMax + out.yMin)) * 0.5)
                return out.yMin
            out.yMax = _hx_local_1()
        dx = -self.x
        dy = -self.y
        out.xMin = (out.xMin + dx)
        out.xMax = (out.xMax + dx)
        out.yMin = (out.yMin + dy)
        out.yMax = (out.yMax + dy)
        return out

    def getAbsPos(self):
        self.syncPos()
        m = h2d_col_Matrix()
        m.a = self.matA
        m.b = self.matB
        m.c = self.matC
        m.d = self.matD
        m.x = self.absX
        m.y = self.absY
        return m

    def find(self,f):
        v = f(self)
        if (v is not None):
            return v
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            o = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            v1 = o.find(f)
            if (v1 is not None):
                return v1
        return None

    def findAll(self,f,arr = None):
        if (arr is None):
            arr = []
        v = f(self)
        if (v is not None):
            arr.append(v)
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            o = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            o.findAll(f,arr)
        return arr

    def set_filter(self,f):
        if ((self.filter is not None) and self.allocated):
            self.filter.unbind(self)
        self.filter = f
        if ((f is not None) and self.allocated):
            f.bind(self)
        return f

    def getBoundsRec(self,relativeTo,out,forSize):
        if self.posChanged:
            self.calcAbsPos()
            _g = 0
            _g1 = self.children
            while (_g < len(_g1)):
                c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                c.posChanged = True
            self.posChanged = False
        n = len(self.children)
        if (n == 0):
            out.xMin = 1e20
            out.yMin = 1e20
            out.xMax = -1e20
            out.yMax = -1e20
            return
        if (n == 1):
            c1 = (self.children[0] if 0 < len(self.children) else None)
            if c1.visible:
                c1.getBoundsRec(relativeTo,out,forSize)
            else:
                out.xMin = 1e20
                out.yMin = 1e20
                out.xMax = -1e20
                out.yMax = -1e20
            return
        xmin = Math.POSITIVE_INFINITY
        ymin = Math.POSITIVE_INFINITY
        xmax = Math.NEGATIVE_INFINITY
        ymax = Math.NEGATIVE_INFINITY
        _g2 = 0
        _g11 = self.children
        while (_g2 < len(_g11)):
            c2 = (_g11[_g2] if _g2 >= 0 and _g2 < len(_g11) else None)
            _g2 = (_g2 + 1)
            if (not c2.visible):
                continue
            c2.getBoundsRec(relativeTo,out,forSize)
            if (out.xMin < xmin):
                xmin = out.xMin
            if (out.yMin < ymin):
                ymin = out.yMin
            if (out.xMax > xmax):
                xmax = out.xMax
            if (out.yMax > ymax):
                ymax = out.yMax
        out.xMin = xmin
        out.yMin = ymin
        out.xMax = xmax
        out.yMax = ymax

    def addBounds(self,relativeTo,out,dx,dy,width,height):
        if ((width <= 0) or ((height <= 0))):
            return
        if (relativeTo is None):
            x = None
            y = None
            x1 = (((dx * self.matA) + ((dy * self.matC))) + self.absX)
            y1 = (((dx * self.matB) + ((dy * self.matD))) + self.absY)
            if (x1 < out.xMin):
                out.xMin = x1
            if (x1 > out.xMax):
                out.xMax = x1
            if (y1 < out.yMin):
                out.yMin = y1
            if (y1 > out.yMax):
                out.yMax = y1
            x2 = (((((dx + width)) * self.matA) + ((dy * self.matC))) + self.absX)
            y2 = (((((dx + width)) * self.matB) + ((dy * self.matD))) + self.absY)
            if (x2 < out.xMin):
                out.xMin = x2
            if (x2 > out.xMax):
                out.xMax = x2
            if (y2 < out.yMin):
                out.yMin = y2
            if (y2 > out.yMax):
                out.yMax = y2
            x3 = (((dx * self.matA) + ((((dy + height)) * self.matC))) + self.absX)
            y3 = (((dx * self.matB) + ((((dy + height)) * self.matD))) + self.absY)
            if (x3 < out.xMin):
                out.xMin = x3
            if (x3 > out.xMax):
                out.xMax = x3
            if (y3 < out.yMin):
                out.yMin = y3
            if (y3 > out.yMax):
                out.yMax = y3
            x4 = (((((dx + width)) * self.matA) + ((((dy + height)) * self.matC))) + self.absX)
            y4 = (((((dx + width)) * self.matB) + ((((dy + height)) * self.matD))) + self.absY)
            if (x4 < out.xMin):
                out.xMin = x4
            if (x4 > out.xMax):
                out.xMax = x4
            if (y4 < out.yMin):
                out.yMin = y4
            if (y4 > out.yMax):
                out.yMax = y4
            return
        if (relativeTo == self):
            if (out.xMin > dx):
                out.xMin = dx
            if (out.yMin > dy):
                out.yMin = dy
            if (out.xMax < ((dx + width))):
                out.xMax = (dx + width)
            if (out.yMax < ((dy + height))):
                out.yMax = (dy + height)
            return
        r = ((relativeTo.matA * relativeTo.matD) - ((relativeTo.matB * relativeTo.matC)))
        if (r == 0):
            return
        det = (1 / r)
        rA = (relativeTo.matD * det)
        rB = (-relativeTo.matB * det)
        rC = (-relativeTo.matC * det)
        rD = (relativeTo.matA * det)
        rX = (self.absX - relativeTo.absX)
        rY = (self.absY - relativeTo.absY)
        x5 = (((dx * self.matA) + ((dy * self.matC))) + rX)
        y5 = (((dx * self.matB) + ((dy * self.matD))) + rY)
        x6 = ((x5 * rA) + ((y5 * rC)))
        y6 = ((x5 * rB) + ((y5 * rD)))
        if (x6 < out.xMin):
            out.xMin = x6
        if (x6 > out.xMax):
            out.xMax = x6
        if (y6 < out.yMin):
            out.yMin = y6
        if (y6 > out.yMax):
            out.yMax = y6
        x5 = (((((dx + width)) * self.matA) + ((dy * self.matC))) + rX)
        y5 = (((((dx + width)) * self.matB) + ((dy * self.matD))) + rY)
        x7 = ((x5 * rA) + ((y5 * rC)))
        y7 = ((x5 * rB) + ((y5 * rD)))
        if (x7 < out.xMin):
            out.xMin = x7
        if (x7 > out.xMax):
            out.xMax = x7
        if (y7 < out.yMin):
            out.yMin = y7
        if (y7 > out.yMax):
            out.yMax = y7
        x5 = (((dx * self.matA) + ((((dy + height)) * self.matC))) + rX)
        y5 = (((dx * self.matB) + ((((dy + height)) * self.matD))) + rY)
        x8 = ((x5 * rA) + ((y5 * rC)))
        y8 = ((x5 * rB) + ((y5 * rD)))
        if (x8 < out.xMin):
            out.xMin = x8
        if (x8 > out.xMax):
            out.xMax = x8
        if (y8 < out.yMin):
            out.yMin = y8
        if (y8 > out.yMax):
            out.yMax = y8
        x5 = (((((dx + width)) * self.matA) + ((((dy + height)) * self.matC))) + rX)
        y5 = (((((dx + width)) * self.matB) + ((((dy + height)) * self.matD))) + rY)
        x9 = ((x5 * rA) + ((y5 * rC)))
        y9 = ((x5 * rB) + ((y5 * rD)))
        if (x9 < out.xMin):
            out.xMin = x9
        if (x9 > out.xMax):
            out.xMax = x9
        if (y9 < out.yMin):
            out.yMin = y9
        if (y9 > out.yMax):
            out.yMax = y9

    def getObjectsCount(self):
        k = 0
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            k = (k + ((c.getObjectsCount() + 1)))
        return k

    def localToGlobal(self,pt = None):
        self.syncPos()
        if (pt is None):
            pt = h2d_col_Point()
        px = (((pt.x * self.matA) + ((pt.y * self.matC))) + self.absX)
        py = (((pt.x * self.matB) + ((pt.y * self.matD))) + self.absY)
        pt.x = px
        pt.y = py
        return pt

    def globalToLocal(self,pt):
        self.syncPos()
        pt.x = (pt.x - self.absX)
        pt.y = (pt.y - self.absY)
        invDet = (1 / (((self.matA * self.matD) - ((self.matB * self.matC)))))
        px = ((((pt.x * self.matD) - ((pt.y * self.matC)))) * invDet)
        py = ((((-pt.x * self.matB) + ((pt.y * self.matA)))) * invDet)
        pt.x = px
        pt.y = py
        return pt

    def getScene(self):
        p = self
        while (p.parent is not None):
            p = p.parent
        return Std.downcast(p,h2d_Scene)

    def set_visible(self,b):
        if (self.visible == b):
            return b
        self.visible = b
        if (self.parentContainer is not None):
            self.parentContainer.contentChanged(self)
        return b

    def addChild(self,s):
        self.addChildAt(s,len(self.children))

    def addChildAt(self,s,pos):
        if (pos < 0):
            pos = 0
        if (pos > len(self.children)):
            pos = len(self.children)
        p = self
        while (p is not None):
            if (p == s):
                raise _HxException("Recursive addChild")
            p = p.parent
        if (s.parent is not None):
            old = s.allocated
            s.allocated = False
            s.parent.removeChild(s)
            s.allocated = old
        self.children.insert(pos, s)
        if ((not self.allocated) and s.allocated):
            s.onRemove()
        s.parent = self
        s.parentContainer = self.parentContainer
        s.posChanged = True
        if self.allocated:
            if (not s.allocated):
                s.onAdd()
            else:
                s.onHierarchyMoved(True)
        if (self.parentContainer is not None):
            self.parentContainer.contentChanged(self)

    def onContentChanged(self):
        if (self.parentContainer is not None):
            self.parentContainer.contentChanged(self)

    def onHierarchyMoved(self,parentChanged):
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            c.onHierarchyMoved(parentChanged)

    def onAdd(self):
        self.allocated = True
        if (self.filter is not None):
            self.filter.bind(self)
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            c.onAdd()

    def onRemove(self):
        self.allocated = False
        if (self.filter is not None):
            self.filter.unbind(self)
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            c.onRemove()

    def getMatrix(self,m):
        m.a = self.matA
        m.b = self.matB
        m.c = self.matC
        m.d = self.matD
        m.x = self.absX
        m.y = self.absY

    def removeChild(self,s):
        if python_internal_ArrayImpl.remove(self.children,s):
            if s.allocated:
                s.onRemove()
            s.parent = None
            if (s.parentContainer is not None):
                s.setParentContainer(None)
            s.posChanged = True
            if (self.parentContainer is not None):
                self.parentContainer.contentChanged(self)

    def setParentContainer(self,c):
        self.parentContainer = c
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            s = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            s.setParentContainer(c)

    def removeChildren(self):
        while (len(self.children) > 0):
            self.removeChild((self.children[0] if 0 < len(self.children) else None))

    def remove(self):
        if (self.parent is not None):
            self.parent.removeChild(self)

    def drawTo(self,t):
        s = self.getScene()
        needDispose = (s is None)
        if (s is None):
            s = h2d_Scene()
        s.drawImplTo(self,[t])
        if needDispose:
            s.dispose()
            self.onRemove()

    def drawToTextures(self,texs,outputs):
        s = self.getScene()
        needDispose = (s is None)
        if (s is None):
            s = h2d_Scene()
        s.drawImplTo(self,texs,outputs)
        if needDispose:
            s.dispose()
            self.onRemove()

    def draw(self,ctx):
        pass

    def sync(self,ctx):
        changed = self.posChanged
        if changed:
            self.calcAbsPos()
            self.posChanged = False
        self.lastFrame = ctx.frame
        p = 0
        _hx_len = len(self.children)
        while (p < _hx_len):
            c = (self.children[p] if p >= 0 and p < len(self.children) else None)
            if (c is None):
                break
            if (c.lastFrame != ctx.frame):
                if changed:
                    c.posChanged = True
                c.sync(ctx)
            if ((self.children[p] if p >= 0 and p < len(self.children) else None) != c):
                p = 0
                _hx_len = len(self.children)
            else:
                p = (p + 1)

    def syncPos(self):
        if (self.parent is not None):
            self.parent.syncPos()
        if self.posChanged:
            self.calcAbsPos()
            _g = 0
            _g1 = self.children
            while (_g < len(_g1)):
                c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                c.posChanged = True
            self.posChanged = False

    def calcAbsPos(self):
        if (self.parent is None):
            cr = None
            sr = None
            if (self.rotation == 0):
                cr = 1.
                sr = 0.
                self.matA = self.scaleX
                self.matB = 0
                self.matC = 0
                self.matD = self.scaleY
            else:
                f = self.rotation
                cr = (Math.NaN if (((f == Math.POSITIVE_INFINITY) or ((f == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(f))
                f1 = self.rotation
                sr = (Math.NaN if (((f1 == Math.POSITIVE_INFINITY) or ((f1 == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(f1))
                self.matA = (self.scaleX * cr)
                self.matB = (self.scaleX * sr)
                self.matC = (self.scaleY * -sr)
                self.matD = (self.scaleY * cr)
            self.absX = self.x
            self.absY = self.y
        else:
            if (self.rotation == 0):
                self.matA = (self.scaleX * self.parent.matA)
                self.matB = (self.scaleX * self.parent.matB)
                self.matC = (self.scaleY * self.parent.matC)
                self.matD = (self.scaleY * self.parent.matD)
            else:
                f2 = self.rotation
                cr1 = (Math.NaN if (((f2 == Math.POSITIVE_INFINITY) or ((f2 == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(f2))
                f3 = self.rotation
                sr1 = (Math.NaN if (((f3 == Math.POSITIVE_INFINITY) or ((f3 == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(f3))
                tmpA = (self.scaleX * cr1)
                tmpB = (self.scaleX * sr1)
                tmpC = (self.scaleY * -sr1)
                tmpD = (self.scaleY * cr1)
                self.matA = ((tmpA * self.parent.matA) + ((tmpB * self.parent.matC)))
                self.matB = ((tmpA * self.parent.matB) + ((tmpB * self.parent.matD)))
                self.matC = ((tmpC * self.parent.matA) + ((tmpD * self.parent.matC)))
                self.matD = ((tmpC * self.parent.matB) + ((tmpD * self.parent.matD)))
            self.absX = (((self.x * self.parent.matA) + ((self.y * self.parent.matC))) + self.parent.absX)
            self.absY = (((self.x * self.parent.matB) + ((self.y * self.parent.matD))) + self.parent.absY)

    def emitTile(self,ctx,tile):
        if (h2d_Object.nullDrawable is None):
            h2d_Object.nullDrawable = h2d_Drawable(None)
        h2d_Object.nullDrawable.absX = self.absX
        h2d_Object.nullDrawable.absY = self.absY
        h2d_Object.nullDrawable.matA = self.matA
        h2d_Object.nullDrawable.matB = self.matB
        h2d_Object.nullDrawable.matC = self.matC
        h2d_Object.nullDrawable.matD = self.matD
        ctx.drawTile(h2d_Object.nullDrawable,tile)
        return

    def clipBounds(self,ctx,bounds):
        view = ctx.tmpBounds
        matA = None
        matB = None
        matC = None
        matD = None
        absX = None
        absY = None
        if (ctx.inFilter is not None):
            f1 = ctx.baseShader.filterMatrixA__
            f2 = ctx.baseShader.filterMatrixB__
            matA = ((self.matA * f1.x) + ((self.matB * f1.y)))
            matB = ((self.matA * f2.x) + ((self.matB * f2.y)))
            matC = ((self.matC * f1.x) + ((self.matD * f1.y)))
            matD = ((self.matC * f2.x) + ((self.matD * f2.y)))
            absX = (((self.absX * f1.x) + ((self.absY * f1.y))) + f1.z)
            absY = (((self.absX * f2.x) + ((self.absY * f2.y))) + f2.z)
        else:
            matA = self.matA
            matB = self.matB
            matC = self.matC
            matD = self.matD
            absX = self.absX
            absY = self.absY
        view.xMin = 1e20
        view.yMin = 1e20
        view.xMax = -1e20
        view.yMax = -1e20
        x = bounds.xMin
        y = bounds.yMin
        x1 = (((x * matA) + ((y * matC))) + absX)
        y1 = (((x * matB) + ((y * matD))) + absY)
        if (x1 < view.xMin):
            view.xMin = x1
        if (x1 > view.xMax):
            view.xMax = x1
        if (y1 < view.yMin):
            view.yMin = y1
        if (y1 > view.yMax):
            view.yMax = y1
        x2 = bounds.xMax
        y2 = bounds.yMin
        x3 = (((x2 * matA) + ((y2 * matC))) + absX)
        y3 = (((x2 * matB) + ((y2 * matD))) + absY)
        if (x3 < view.xMin):
            view.xMin = x3
        if (x3 > view.xMax):
            view.xMax = x3
        if (y3 < view.yMin):
            view.yMin = y3
        if (y3 > view.yMax):
            view.yMax = y3
        x4 = bounds.xMin
        y4 = bounds.yMax
        x5 = (((x4 * matA) + ((y4 * matC))) + absX)
        y5 = (((x4 * matB) + ((y4 * matD))) + absY)
        if (x5 < view.xMin):
            view.xMin = x5
        if (x5 > view.xMax):
            view.xMax = x5
        if (y5 < view.yMin):
            view.yMin = y5
        if (y5 > view.yMax):
            view.yMax = y5
        x6 = bounds.xMax
        y6 = bounds.yMax
        x7 = (((x6 * matA) + ((y6 * matC))) + absX)
        y7 = (((x6 * matB) + ((y6 * matD))) + absY)
        if (x7 < view.xMin):
            view.xMin = x7
        if (x7 > view.xMax):
            view.xMax = x7
        if (y7 < view.yMin):
            view.yMin = y7
        if (y7 > view.yMax):
            view.yMax = y7
        if (view.xMin < ctx.curX):
            view.xMin = ctx.curX
        if (view.yMin < ctx.curY):
            view.yMin = ctx.curY
        if (view.xMax > ((ctx.curX + ctx.curWidth))):
            view.xMax = (ctx.curX + ctx.curWidth)
        if (view.yMax > ((ctx.curY + ctx.curHeight))):
            view.yMax = (ctx.curY + ctx.curHeight)
        invDet = (1 / (((matA * matD) - ((matB * matC)))))
        sxMin = view.xMin
        syMin = view.yMin
        sxMax = view.xMax
        syMax = view.yMax
        view.xMin = 1e20
        view.yMin = 1e20
        view.xMax = -1e20
        view.yMax = -1e20
        x8 = sxMin
        y8 = syMin
        x8 = (x8 - absX)
        y8 = (y8 - absY)
        x9 = ((((x8 * matD) - ((y8 * matC)))) * invDet)
        y9 = ((((-x8 * matB) + ((y8 * matA)))) * invDet)
        if (x9 < view.xMin):
            view.xMin = x9
        if (x9 > view.xMax):
            view.xMax = x9
        if (y9 < view.yMin):
            view.yMin = y9
        if (y9 > view.yMax):
            view.yMax = y9
        x10 = sxMax
        y10 = syMin
        x10 = (x10 - absX)
        y10 = (y10 - absY)
        x11 = ((((x10 * matD) - ((y10 * matC)))) * invDet)
        y11 = ((((-x10 * matB) + ((y10 * matA)))) * invDet)
        if (x11 < view.xMin):
            view.xMin = x11
        if (x11 > view.xMax):
            view.xMax = x11
        if (y11 < view.yMin):
            view.yMin = y11
        if (y11 > view.yMax):
            view.yMax = y11
        x12 = sxMin
        y12 = syMax
        x12 = (x12 - absX)
        y12 = (y12 - absY)
        x13 = ((((x12 * matD) - ((y12 * matC)))) * invDet)
        y13 = ((((-x12 * matB) + ((y12 * matA)))) * invDet)
        if (x13 < view.xMin):
            view.xMin = x13
        if (x13 > view.xMax):
            view.xMax = x13
        if (y13 < view.yMin):
            view.yMin = y13
        if (y13 > view.yMax):
            view.yMax = y13
        x14 = sxMax
        y14 = syMax
        x14 = (x14 - absX)
        y14 = (y14 - absY)
        x15 = ((((x14 * matD) - ((y14 * matC)))) * invDet)
        y15 = ((((-x14 * matB) + ((y14 * matA)))) * invDet)
        if (x15 < view.xMin):
            view.xMin = x15
        if (x15 > view.xMax):
            view.xMax = x15
        if (y15 < view.yMin):
            view.yMin = y15
        if (y15 > view.yMax):
            view.yMax = y15
        a = bounds.xMin
        b = view.xMin
        bounds.xMin = (b if ((a < b)) else a)
        a1 = bounds.yMin
        b1 = view.yMin
        bounds.yMin = (b1 if ((a1 < b1)) else a1)
        a2 = bounds.xMax
        b2 = view.xMax
        bounds.xMax = (b2 if ((a2 > b2)) else a2)
        a3 = bounds.yMax
        b3 = view.yMax
        bounds.yMax = (b3 if ((a3 > b3)) else a3)

    def drawFilters(self,ctx):
        if (not ctx.pushFilter(self)):
            return
        bounds = ctx.tmpBounds
        total = h2d_col_Bounds()
        maxExtent = -1.
        self.filter.sync(ctx,self)
        if self.filter.autoBounds:
            maxExtent = self.filter.boundsExtend
        else:
            self.filter.getBounds(self,bounds)
            if (bounds.xMin < total.xMin):
                total.xMin = bounds.xMin
            if (bounds.xMax > total.xMax):
                total.xMax = bounds.xMax
            if (bounds.yMin < total.yMin):
                total.yMin = bounds.yMin
            if (bounds.yMax > total.yMax):
                total.yMax = bounds.yMax
        if (maxExtent >= 0):
            self.getBounds(self,bounds)
            bounds.xMin = (bounds.xMin - maxExtent)
            bounds.yMin = (bounds.yMin - maxExtent)
            bounds.xMax = (bounds.xMax + maxExtent)
            bounds.yMax = (bounds.yMax + maxExtent)
            if (bounds.xMin < total.xMin):
                total.xMin = bounds.xMin
            if (bounds.xMax > total.xMax):
                total.xMax = bounds.xMax
            if (bounds.yMin < total.yMin):
                total.yMin = bounds.yMin
            if (bounds.yMax > total.yMax):
                total.yMax = bounds.yMax
        self.clipBounds(ctx,total)
        xMin = Math.floor((total.xMin + 1e-10))
        yMin = Math.floor((total.yMin + 1e-10))
        width = Math.ceil(((total.xMax - xMin) - 1e-10))
        height = Math.ceil(((total.yMax - yMin) - 1e-10))
        if (((width <= 0) or ((height <= 0))) or ((total.xMax < total.xMin))):
            ctx.popFilter()
            return
        t = ctx.textures.allocTarget("filterTemp",width,height,False)
        ctx.pushTarget(t,xMin,yMin,width,height)
        ctx.engine.clear(0)
        oldAlpha = ctx.globalAlpha
        shader = ctx.baseShader
        _this = shader.filterMatrixA__
        x = _this.x
        y = _this.y
        z = _this.z
        w = _this.w
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        oldA_x = x
        oldA_y = y
        oldA_z = z
        oldA_w = w
        _this1 = shader.filterMatrixB__
        x1 = _this1.x
        y1 = _this1.y
        z1 = _this1.z
        w1 = _this1.w
        if (w1 is None):
            w1 = 1.
        if (z1 is None):
            z1 = 0.
        if (y1 is None):
            y1 = 0.
        if (x1 is None):
            x1 = 0.
        oldB_x = x1
        oldB_y = y1
        oldB_z = z1
        oldB_w = w1
        oldF = ctx.inFilter
        invDet = (1 / (((self.matA * self.matD) - ((self.matB * self.matC)))))
        invA = (self.matD * invDet)
        invB = (-self.matB * invDet)
        invC = (-self.matC * invDet)
        invD = (self.matA * invDet)
        invX = -(((self.absX * invA) + ((self.absY * invC))))
        invY = -(((self.absX * invB) + ((self.absY * invD))))
        _this2 = shader.filterMatrixA__
        x2 = invA
        y2 = invC
        z2 = invX
        if (z2 is None):
            z2 = 0.
        if (y2 is None):
            y2 = 0.
        if (x2 is None):
            x2 = 0.
        _this2.x = x2
        _this2.y = y2
        _this2.z = z2
        _this2.w = 1.
        _this3 = shader.filterMatrixB__
        x3 = invB
        y3 = invD
        z3 = invY
        if (z3 is None):
            z3 = 0.
        if (y3 is None):
            y3 = 0.
        if (x3 is None):
            x3 = 0.
        _this3.x = x3
        _this3.y = y3
        _this3.z = z3
        _this3.w = 1.
        ctx.globalAlpha = 1
        self.draw(ctx)
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            c.drawRec(ctx)
        finalTile = h2d_Tile.fromTexture(t)
        finalTile.dx = xMin
        finalTile.dy = yMin
        prev = finalTile
        finalTile = self.filter.draw(ctx,finalTile)
        if ((finalTile != prev) and ((finalTile is not None))):
            finalTile.dx = (finalTile.dx + xMin)
            finalTile.dy = (finalTile.dy + yMin)
        _this4 = shader.filterMatrixA__
        _this4.x = oldA_x
        _this4.y = oldA_y
        _this4.z = oldA_z
        _this4.w = oldA_w
        _this5 = shader.filterMatrixB__
        _this5.x = oldB_x
        _this5.y = oldB_y
        _this5.z = oldB_z
        _this5.w = oldB_w
        ctx.popTarget()
        ctx.popFilter()
        ctx.globalAlpha = oldAlpha
        if (finalTile is None):
            return
        self.drawFiltered(ctx,finalTile)

    def drawFiltered(self,ctx,tile):
        oldAlpha = ctx.globalAlpha
        ctx.currentBlend = None
        ctx.inFilterBlend = self.blendMode
        ctx.globalAlpha = (ctx.globalAlpha * self.alpha)
        self.emitTile(ctx,tile)
        ctx.globalAlpha = oldAlpha
        ctx.inFilterBlend = None
        ctx.currentBlend = None

    def drawRec(self,ctx):
        if (not self.visible):
            return
        if self.posChanged:
            self.calcAbsPos()
            _g = 0
            _g1 = self.children
            while (_g < len(_g1)):
                c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                c.posChanged = True
            self.posChanged = False
        if ((self.filter is not None) and self.filter.get_enable()):
            self.drawFilters(ctx)
        else:
            old = ctx.globalAlpha
            ctx.globalAlpha = (ctx.globalAlpha * self.alpha)
            if ctx.front2back:
                nchilds = len(self.children)
                _g2 = 0
                _g11 = nchilds
                while (_g2 < _g11):
                    i = _g2
                    _g2 = (_g2 + 1)
                    python_internal_ArrayImpl._get(self.children, ((nchilds - 1) - i)).drawRec(ctx)
                self.draw(ctx)
            else:
                self.draw(ctx)
                _g3 = 0
                _g12 = self.children
                while (_g3 < len(_g12)):
                    c1 = (_g12[_g3] if _g3 >= 0 and _g3 < len(_g12) else None)
                    _g3 = (_g3 + 1)
                    c1.drawRec(ctx)
            ctx.globalAlpha = old

    def set_x(self,v):
        self.posChanged = True
        def _hx_local_1():
            def _hx_local_0():
                self.x = v
                return self.x
            return _hx_local_0()
        return _hx_local_1()

    def set_y(self,v):
        self.posChanged = True
        def _hx_local_1():
            def _hx_local_0():
                self.y = v
                return self.y
            return _hx_local_0()
        return _hx_local_1()

    def set_scaleX(self,v):
        self.posChanged = True
        def _hx_local_1():
            def _hx_local_0():
                self.scaleX = v
                return self.scaleX
            return _hx_local_0()
        return _hx_local_1()

    def set_scaleY(self,v):
        self.posChanged = True
        def _hx_local_1():
            def _hx_local_0():
                self.scaleY = v
                return self.scaleY
            return _hx_local_0()
        return _hx_local_1()

    def set_rotation(self,v):
        self.posChanged = True
        def _hx_local_1():
            def _hx_local_0():
                self.rotation = v
                return self.rotation
            return _hx_local_0()
        return _hx_local_1()

    def move(self,dx,dy):
        _g = self
        _g1 = _g.x
        f = self.rotation
        v = (Math.NaN if (((f == Math.POSITIVE_INFINITY) or ((f == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(f))
        _g.posChanged = True
        _g.x = (_g1 + ((dx * v)))
        _g2 = self
        _g3 = _g2.y
        f1 = self.rotation
        v1 = (Math.NaN if (((f1 == Math.POSITIVE_INFINITY) or ((f1 == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(f1))
        _g2.posChanged = True
        _g2.y = (_g3 + ((dy * v1)))

    def setPosition(self,x,y):
        self.posChanged = True
        self.x = x
        self.posChanged = True
        self.y = y

    def rotate(self,v):
        _g = self
        _g.posChanged = True
        _g.rotation = (_g.rotation + v)

    def scale(self,v):
        _g = self
        _g.posChanged = True
        _g.scaleX = (_g.scaleX * v)
        _g1 = self
        _g1.posChanged = True
        _g1.scaleY = (_g1.scaleY * v)

    def setScale(self,v):
        self.posChanged = True
        self.scaleX = v
        self.posChanged = True
        self.scaleY = v

    def getChildAt(self,n):
        return (self.children[n] if n >= 0 and n < len(self.children) else None)

    def getChildIndex(self,o):
        _g = 0
        _g1 = len(self.children)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if ((self.children[i] if i >= 0 and i < len(self.children) else None) == o):
                return i
        return -1

    def getObjectByName(self,name):
        if (self.name == name):
            return self
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            o = c.getObjectByName(name)
            if (o is not None):
                return o
        return None

    def get_numChildren(self):
        return len(self.children)

    def iterator(self):
        return hxd_impl_ArrayIterator_h2d_Object(self.children)

    def toString(self):
        c = Type.getClassName(Type.getClass(self))
        if (self.name is None):
            return c
        else:
            return (((HxOverrides.stringOrNull(self.name) + "(") + ("null" if c is None else c)) + ")")

    def contentChanged(self,s):
        pass

    def constraintSize(self,maxWidth,maxHeight):
        pass
    nullDrawable = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.children = None
        _hx_o.parentContainer = None
        _hx_o.parent = None
        _hx_o.name = None
        _hx_o.x = None
        _hx_o.y = None
        _hx_o.scaleX = None
        _hx_o.scaleY = None
        _hx_o.rotation = None
        _hx_o.visible = None
        _hx_o.alpha = None
        _hx_o.filter = None
        _hx_o.blendMode = None
        _hx_o.matA = None
        _hx_o.matB = None
        _hx_o.matC = None
        _hx_o.matD = None
        _hx_o.absX = None
        _hx_o.absY = None
        _hx_o.posChanged = None
        _hx_o.allocated = None
        _hx_o.lastFrame = None
h2d_Object._hx_class = h2d_Object
_hx_classes["h2d.Object"] = h2d_Object


class h2d_Drawable(h2d_Object):
    _hx_class_name = "h2d.Drawable"
    _hx_is_interface = "False"
    __slots__ = ("color", "smooth", "tileWrap", "colorKey", "shaders")
    _hx_fields = ["color", "smooth", "tileWrap", "colorKey", "shaders"]
    _hx_methods = ["set_tileWrap", "get_colorAdd", "set_colorAdd", "drawFiltered", "set_colorKey", "adjustColor", "get_colorMatrix", "set_colorMatrix", "getDebugShaderCode", "getShader", "getShaders", "addShader", "removeShader", "emitTile"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h2d_Object


    def __init__(self,parent):
        self.shaders = None
        self.colorKey = None
        self.tileWrap = None
        self.smooth = None
        self.color = None
        super().__init__(parent)
        self.color = h3d_Vector(1,1,1,1)

    def set_tileWrap(self,b):
        def _hx_local_1():
            def _hx_local_0():
                self.tileWrap = b
                return self.tileWrap
            return _hx_local_0()
        return _hx_local_1()

    def get_colorAdd(self):
        s = self.getShader(h3d_shader_ColorAdd)
        if (s is None):
            return None
        else:
            return s.color__

    def set_colorAdd(self,c):
        s = self.getShader(h3d_shader_ColorAdd)
        if (s is None):
            if (c is not None):
                s = self.addShader(h3d_shader_ColorAdd())
                s.color__ = c
        elif (c is None):
            self.removeShader(s)
        else:
            s.color__ = c
        return c

    def drawFiltered(self,ctx,tile):
        old = self.shaders
        self.shaders = None
        super().drawFiltered(ctx,tile)
        self.shaders = old

    def set_colorKey(self,v):
        s = self.getShader(h3d_shader_ColorKey)
        if (s is None):
            if (v is not None):
                s = self.addShader(h3d_shader_ColorKey((-16777216 | v)))
        elif (v is None):
            self.removeShader(s)
        else:
            _this = s.colorKey__
            c = (-16777216 | v)
            _this.x = ((((c >> 16) & 255)) / 255)
            _this.y = ((((c >> 8) & 255)) / 255)
            _this.z = (((c & 255)) / 255)
            _this.w = ((HxOverrides.rshift(c, 24)) / 255)
        def _hx_local_1():
            def _hx_local_0():
                self.colorKey = v
                return self.colorKey
            return _hx_local_0()
        return _hx_local_1()

    def adjustColor(self,col = None):
        if (col is None):
            self.set_colorMatrix(None)
        else:
            m = self.get_colorMatrix()
            if (m is None):
                m = h3d_Matrix()
                self.set_colorMatrix(m)
            m.identity()
            m.adjustColor(col)

    def get_colorMatrix(self):
        s = self.getShader(h3d_shader_ColorMatrix)
        if (s is None):
            return None
        else:
            return s.matrix__

    def set_colorMatrix(self,m):
        s = self.getShader(h3d_shader_ColorMatrix)
        if (s is None):
            if (m is not None):
                s = self.addShader(h3d_shader_ColorMatrix())
                s.matrix__ = m
        elif (m is None):
            self.removeShader(s)
        else:
            s.matrix__ = m
        return m

    def getDebugShaderCode(self,toHxsl = None):
        if (toHxsl is None):
            toHxsl = True
        ctx = self.getScene().ctx
        shader = ctx.manager.compileShaders(hxsl_ShaderList(ctx.baseShader,self.shaders))
        if toHxsl:
            def _hx_local_0(s):
                return hxsl_Printer.shaderToString(s,True)
            toString = _hx_local_0
            return ((("// vertex:\n" + HxOverrides.stringOrNull(toString(shader.vertex.data))) + "\n\nfragment:\n") + HxOverrides.stringOrNull(toString(shader.fragment.data)))
        else:
            return h3d_Engine.CURRENT.driver.getNativeShaderCode(shader)

    def getShader(self,stype):
        if (self.shaders is not None):
            _g_l = self.shaders
            _g_last = None
            while (_g_l != _g_last):
                s = _g_l.s
                _g_l = _g_l.next
                s1 = s
                s2 = Std.downcast(s1,stype)
                if (s2 is not None):
                    return s2
        return None

    def getShaders(self):
        return hxsl__ShaderList_ShaderIterator(self.shaders,None)

    def addShader(self,s):
        if (s is None):
            raise _HxException("Can't add null shader")
        self.shaders = hxsl_ShaderList.addSort(s,self.shaders)
        return s

    def removeShader(self,s):
        prev = None
        cur = self.shaders
        while (cur is not None):
            if (cur.s == s):
                if (prev is None):
                    self.shaders = cur.next
                else:
                    prev.next = cur.next
                return True
            prev = cur
            cur = cur.next
        return False

    def emitTile(self,ctx,tile):
        if (tile is None):
            tile = h2d_Tile(None,0,0,5,5)
        if (not ctx.drawTile(self,tile)):
            return
        return

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.color = None
        _hx_o.smooth = None
        _hx_o.tileWrap = None
        _hx_o.colorKey = None
        _hx_o.shaders = None
h2d_Drawable._hx_class = h2d_Drawable
_hx_classes["h2d.Drawable"] = h2d_Drawable


class h2d_Bitmap(h2d_Drawable):
    _hx_class_name = "h2d.Bitmap"
    _hx_is_interface = "False"
    __slots__ = ("tile", "width", "height")
    _hx_fields = ["tile", "width", "height"]
    _hx_methods = ["set_tileWrap", "getBoundsRec", "set_width", "set_height", "set_tile", "draw"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h2d_Drawable


    def __init__(self,tile = None,parent = None):
        self.height = None
        self.width = None
        self.tile = None
        super().__init__(parent)
        self.set_tile(tile)

    def set_tileWrap(self,b):
        if ((b and ((self.tile is not None))) and ((((self.tile.innerTex.flags & ((1 << h3d_mat_TextureFlags.IsNPOT.index)))) != 0))):
            raise _HxException("Cannot set tileWrap on a non power-of-two texture")
        def _hx_local_1():
            def _hx_local_0():
                self.tileWrap = b
                return self.tileWrap
            return _hx_local_0()
        return _hx_local_1()

    def getBoundsRec(self,relativeTo,out,forSize):
        super().getBoundsRec(relativeTo,out,forSize)
        if (self.tile is not None):
            if ((self.width is None) and ((self.height is None))):
                self.addBounds(relativeTo,out,self.tile.dx,self.tile.dy,self.tile.width,self.tile.height)
            else:
                self.addBounds(relativeTo,out,self.tile.dx,self.tile.dy,(self.width if ((self.width is not None)) else ((self.tile.width * self.height) / self.tile.height)),(self.height if ((self.height is not None)) else ((self.tile.height * self.width) / self.tile.width)))

    def set_width(self,w):
        if (self.width == w):
            return w
        self.width = w
        if (self.parentContainer is not None):
            self.parentContainer.contentChanged(self)
        return w

    def set_height(self,h):
        if (self.height == h):
            return h
        self.height = h
        if (self.parentContainer is not None):
            self.parentContainer.contentChanged(self)
        return h

    def set_tile(self,t):
        if (self.tile == t):
            return t
        self.tile = t
        if (self.parentContainer is not None):
            self.parentContainer.contentChanged(self)
        return t

    def draw(self,ctx):
        if ((self.width is None) and ((self.height is None))):
            self.emitTile(ctx,self.tile)
            return
        if (self.tile is None):
            self.set_tile(h2d_Tile.fromColor(16711935))
        ow = self.tile.width
        oh = self.tile.height
        self.tile.width = (self.width if ((self.width is not None)) else ((ow * self.height) / oh))
        self.tile.height = (self.height if ((self.height is not None)) else ((oh * self.width) / ow))
        self.emitTile(ctx,self.tile)
        self.tile.width = ow
        self.tile.height = oh

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.tile = None
        _hx_o.width = None
        _hx_o.height = None
h2d_Bitmap._hx_class = h2d_Bitmap
_hx_classes["h2d.Bitmap"] = h2d_Bitmap

class h2d_BlendMode(Enum):
    __slots__ = ()
    _hx_class_name = "h2d.BlendMode"
    _hx_constructs = ["None", "Alpha", "Add", "AlphaAdd", "SoftAdd", "Multiply", "AlphaMultiply", "Erase", "Screen", "Sub", "Max", "Min"]
h2d_BlendMode._hx_None = h2d_BlendMode("None", 0, ())
h2d_BlendMode.Alpha = h2d_BlendMode("Alpha", 1, ())
h2d_BlendMode.Add = h2d_BlendMode("Add", 2, ())
h2d_BlendMode.AlphaAdd = h2d_BlendMode("AlphaAdd", 3, ())
h2d_BlendMode.SoftAdd = h2d_BlendMode("SoftAdd", 4, ())
h2d_BlendMode.Multiply = h2d_BlendMode("Multiply", 5, ())
h2d_BlendMode.AlphaMultiply = h2d_BlendMode("AlphaMultiply", 6, ())
h2d_BlendMode.Erase = h2d_BlendMode("Erase", 7, ())
h2d_BlendMode.Screen = h2d_BlendMode("Screen", 8, ())
h2d_BlendMode.Sub = h2d_BlendMode("Sub", 9, ())
h2d_BlendMode.Max = h2d_BlendMode("Max", 10, ())
h2d_BlendMode.Min = h2d_BlendMode("Min", 11, ())
h2d_BlendMode._hx_class = h2d_BlendMode
_hx_classes["h2d.BlendMode"] = h2d_BlendMode


class h2d_Kerning:
    _hx_class_name = "h2d.Kerning"
    _hx_is_interface = "False"
    __slots__ = ("prevChar", "offset", "next")
    _hx_fields = ["prevChar", "offset", "next"]

    def __init__(self,c,o):
        self.next = None
        self.prevChar = c
        self.offset = o

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.prevChar = None
        _hx_o.offset = None
        _hx_o.next = None
h2d_Kerning._hx_class = h2d_Kerning
_hx_classes["h2d.Kerning"] = h2d_Kerning


class h2d_FontChar:
    _hx_class_name = "h2d.FontChar"
    _hx_is_interface = "False"
    __slots__ = ("t", "width", "kerning")
    _hx_fields = ["t", "width", "kerning"]
    _hx_methods = ["addKerning", "getKerningOffset", "clone"]

    def __init__(self,t,w):
        self.kerning = None
        self.t = t
        self.width = w

    def addKerning(self,prevChar,offset):
        k = h2d_Kerning(prevChar,offset)
        k.next = self.kerning
        self.kerning = k

    def getKerningOffset(self,prevChar):
        k = self.kerning
        while (k is not None):
            if (k.prevChar == prevChar):
                return k.offset
            k = k.next
        return 0

    def clone(self):
        c = h2d_FontChar(self.t.clone(),self.width)
        k = self.kerning
        if (k is not None):
            kc = h2d_Kerning(k.prevChar,k.offset)
            c.kerning = kc
            k = k.next
            while (k is not None):
                kn = h2d_Kerning(k.prevChar,k.offset)
                def _hx_local_0():
                    kc.next = kn
                    return kc.next
                kc = _hx_local_0()
                k = k.next
        return c

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.t = None
        _hx_o.width = None
        _hx_o.kerning = None
h2d_FontChar._hx_class = h2d_FontChar
_hx_classes["h2d.FontChar"] = h2d_FontChar

class h2d_FontType(Enum):
    __slots__ = ()
    _hx_class_name = "h2d.FontType"
    _hx_constructs = ["BitmapFont", "SignedDistanceField"]

    @staticmethod
    def SignedDistanceField(channel,alphaCutoff,smoothing):
        return h2d_FontType("SignedDistanceField", 1, (channel,alphaCutoff,smoothing))
h2d_FontType.BitmapFont = h2d_FontType("BitmapFont", 0, ())
h2d_FontType._hx_class = h2d_FontType
_hx_classes["h2d.FontType"] = h2d_FontType


class h2d_Font:
    _hx_class_name = "h2d.Font"
    _hx_is_interface = "False"
    __slots__ = ("name", "size", "baseLine", "lineHeight", "tile", "tilePath", "type", "charset", "glyphs", "nullChar", "defaultChar", "initSize", "offsetX", "offsetY")
    _hx_fields = ["name", "size", "baseLine", "lineHeight", "tile", "tilePath", "type", "charset", "glyphs", "nullChar", "defaultChar", "initSize", "offsetX", "offsetY"]
    _hx_methods = ["getChar", "setOffset", "clone", "resizeTo", "hasChar", "dispose"]

    def __init__(self,name,size,_hx_type = None):
        self.type = None
        self.tilePath = None
        self.tile = None
        self.lineHeight = None
        self.baseLine = None
        self.offsetY = 0
        self.offsetX = 0
        self.name = name
        self.size = size
        self.initSize = size
        self.glyphs = haxe_ds_IntMap()
        def _hx_local_0():
            self.nullChar = h2d_FontChar(h2d_Tile(None,0,0,0,0),0)
            return self.nullChar
        self.defaultChar = _hx_local_0()
        self.charset = hxd_Charset.getDefault()
        if (name is not None):
            self.tilePath = haxe_io_Path.withExtension(name,"png")
        if (_hx_type is None):
            self.type = h2d_FontType.BitmapFont
        else:
            self.type = _hx_type

    def getChar(self,code):
        c = self.glyphs.h.get(code,None)
        if (c is None):
            c = self.charset.resolveChar(code,self.glyphs)
            if (c is None):
                c = (self.nullChar if (((code == 13) or ((code == 10)))) else self.defaultChar)
        return c

    def setOffset(self,x,y):
        dx = (x - self.offsetX)
        dy = (y - self.offsetY)
        if ((dx == 0) and ((dy == 0))):
            return
        g = self.glyphs.iterator()
        while g.hasNext():
            g1 = g.next()
            _hx_local_0 = g1.t
            _hx_local_1 = _hx_local_0.dx
            _hx_local_0.dx = (_hx_local_1 + dx)
            _hx_local_0.dx
            _hx_local_2 = g1.t
            _hx_local_3 = _hx_local_2.dy
            _hx_local_2.dy = (_hx_local_3 + dy)
            _hx_local_2.dy
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.offsetX
        _hx_local_4.offsetX = (_hx_local_5 + dx)
        _hx_local_4.offsetX
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6.offsetY
        _hx_local_6.offsetY = (_hx_local_7 + dy)
        _hx_local_6.offsetY

    def clone(self):
        f = h2d_Font(self.name,self.size)
        f.baseLine = self.baseLine
        f.lineHeight = self.lineHeight
        f.tile = self.tile.clone()
        f.charset = self.charset
        f.defaultChar = self.defaultChar.clone()
        f.type = self.type
        g = self.glyphs.keys()
        while g.hasNext():
            g1 = g.next()
            c = self.glyphs.h.get(g1,None)
            c2 = c.clone()
            if (c == self.defaultChar):
                f.defaultChar = c2
            f.glyphs.set(g1,c2)
        return f

    def resizeTo(self,size):
        ratio = (size / self.initSize)
        c = self.glyphs.iterator()
        while c.hasNext():
            c1 = c.next()
            c1.width = (c1.width * ratio)
            c1.t.scaleToSize((c1.t.width * ratio),(c1.t.height * ratio))
            _hx_local_1 = c1.t
            _hx_local_2 = _hx_local_1.dx
            _hx_local_1.dx = (_hx_local_2 * ratio)
            _hx_local_1.dx
            _hx_local_3 = c1.t
            _hx_local_4 = _hx_local_3.dy
            _hx_local_3.dy = (_hx_local_4 * ratio)
            _hx_local_3.dy
            k = c1.kerning
            while (k is not None):
                k.offset = (k.offset * ratio)
                k = k.next
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6.lineHeight
        _hx_local_6.lineHeight = (_hx_local_7 * ratio)
        _hx_local_6.lineHeight
        _hx_local_8 = self
        _hx_local_9 = _hx_local_8.baseLine
        _hx_local_8.baseLine = (_hx_local_9 * ratio)
        _hx_local_8.baseLine
        self.size = size

    def hasChar(self,code):
        return (self.glyphs.h.get(code,None) is not None)

    def dispose(self):
        self.tile.dispose()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.name = None
        _hx_o.size = None
        _hx_o.baseLine = None
        _hx_o.lineHeight = None
        _hx_o.tile = None
        _hx_o.tilePath = None
        _hx_o.type = None
        _hx_o.charset = None
        _hx_o.glyphs = None
        _hx_o.nullChar = None
        _hx_o.defaultChar = None
        _hx_o.initSize = None
        _hx_o.offsetX = None
        _hx_o.offsetY = None
h2d_Font._hx_class = h2d_Font
_hx_classes["h2d.Font"] = h2d_Font


class hxd_Interactive:
    _hx_class_name = "hxd.Interactive"
    _hx_is_interface = "True"
    __slots__ = ("propagateEvents", "cursor")
    _hx_fields = ["propagateEvents", "cursor"]
    _hx_methods = ["set_cursor", "handleEvent", "getInteractiveScene"]
hxd_Interactive._hx_class = hxd_Interactive
_hx_classes["hxd.Interactive"] = hxd_Interactive


class h2d_Interactive(h2d_Drawable):
    _hx_class_name = "h2d.Interactive"
    _hx_is_interface = "False"
    _hx_fields = ["width", "height", "cursor", "isEllipse", "cancelEvents", "propagateEvents", "backgroundColor", "enableRightButton", "scene", "mouseDownButton", "parentMask", "invDet", "shape", "shapeX", "shapeY"]
    _hx_methods = ["onAdd", "draw", "getBoundsRec", "onHierarchyMoved", "updateMask", "onRemove", "checkBounds", "preventClick", "getInteractiveScene", "handleEvent", "calcAbsPos", "set_cursor", "eventToLocal", "startDrag", "stopDrag", "focus", "blur", "isOver", "hasFocus", "onOver", "onOut", "onPush", "onRelease", "onReleaseOutside", "onClick", "onMove", "onWheel", "onFocus", "onFocusLost", "onKeyUp", "onKeyDown", "onCheck", "onTextInput"]
    _hx_statics = []
    _hx_interfaces = [hxd_Interactive]
    _hx_super = h2d_Drawable


    def __init__(self,width,height,parent = None,shape = None):
        self.shape = None
        self.invDet = None
        self.parentMask = None
        self.scene = None
        self.enableRightButton = None
        self.backgroundColor = None
        self.isEllipse = None
        self.cursor = None
        self.height = None
        self.width = None
        self.shapeY = 0
        self.shapeX = 0
        self.mouseDownButton = -1
        self.propagateEvents = False
        self.cancelEvents = False
        super().__init__(parent)
        self.width = width
        self.height = height
        self.shape = shape
        self.set_cursor(hxd_Cursor.Button)

    def onAdd(self):
        self.scene = self.getScene()
        if (self.scene is not None):
            self.scene.addEventTarget(self)
        self.updateMask()
        super().onAdd()

    def draw(self,ctx):
        if (self.backgroundColor is not None):
            tmp = self.backgroundColor
            x = self.width
            tmp1 = None
            try:
                tmp1 = int(x)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                tmp1 = None
            x1 = self.height
            tmp2 = None
            try:
                tmp2 = int(x1)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e1 = _hx_e1
                tmp2 = None
            self.emitTile(ctx,h2d_Tile.fromColor(tmp,tmp1,tmp2,((HxOverrides.rshift(self.backgroundColor, 24)) / 255)))

    def getBoundsRec(self,relativeTo,out,forSize):
        super().getBoundsRec(relativeTo,out,forSize)
        if ((self.backgroundColor is not None) or forSize):
            x = self.width
            tmp = None
            try:
                tmp = int(x)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                tmp = None
            x1 = self.height
            tmp1 = None
            try:
                tmp1 = int(x1)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e1 = _hx_e1
                tmp1 = None
            self.addBounds(relativeTo,out,0,0,tmp,tmp1)

    def onHierarchyMoved(self,parentChanged):
        super().onHierarchyMoved(parentChanged)
        if (self.scene is not None):
            self.scene.removeEventTarget(self)
            self.scene.addEventTarget(self)
        if parentChanged:
            self.updateMask()

    def updateMask(self):
        self.parentMask = None
        p = self.parent
        while (p is not None):
            m = Std.downcast(p,h2d_Mask)
            if (m is not None):
                self.parentMask = m
                break
            p = p.parent

    def onRemove(self):
        if (self.scene is not None):
            self.scene.removeEventTarget(self,True)
            self.scene = None
        super().onRemove()

    def checkBounds(self,e):
        tmp = e.kind.index
        if ((((tmp == 10) or ((tmp == 7))) or ((tmp == 6))) or ((tmp == 4))):
            return False
        else:
            return True

    def preventClick(self):
        self.mouseDownButton = -1

    def getInteractiveScene(self):
        return self.scene

    def handleEvent(self,e):
        if ((self.parentMask is not None) and self.checkBounds(e)):
            p = self.parentMask
            pt = h2d_col_Point(e.relX,e.relY)
            self.localToGlobal(pt)
            saveX = pt.x
            saveY = pt.y
            while (p is not None):
                pt.x = saveX
                pt.y = saveY
                pt1 = p.globalToLocal(pt)
                if ((((pt1.x < 0) or ((pt1.y < 0))) or ((pt1.x > p.width))) or ((pt1.y > p.height))):
                    e.cancel = True
                    return
                p = p.parentMask
        if (((self.shape is None) and self.isEllipse) and self.checkBounds(e)):
            cx = (self.width * 0.5)
            cy = (self.height * 0.5)
            dx = (((e.relX - cx)) / cx)
            dy = (((e.relY - cy)) / cy)
            if (((dx * dx) + ((dy * dy))) > 1):
                e.cancel = True
                return
        if self.propagateEvents:
            e.propagate = True
        if self.cancelEvents:
            e.cancel = True
        tmp = e.kind.index
        if (tmp == 0):
            if (self.enableRightButton or ((e.button == 0))):
                self.mouseDownButton = e.button
                self.onPush(e)
        elif (tmp == 1):
            if (self.enableRightButton or ((e.button == 0))):
                self.onRelease(e)
                if (self.mouseDownButton == e.button):
                    self.onClick(e)
            self.mouseDownButton = -1
        elif (tmp == 2):
            self.onMove(e)
        elif (tmp == 3):
            self.onOver(e)
        elif (tmp == 4):
            self.onOut(e)
        elif (tmp == 5):
            self.onWheel(e)
        elif (tmp == 6):
            self.onFocus(e)
        elif (tmp == 7):
            self.onFocusLost(e)
        elif (tmp == 8):
            self.onKeyDown(e)
        elif (tmp == 9):
            self.onKeyUp(e)
        elif (tmp == 10):
            if (self.enableRightButton or ((e.button == 0))):
                self.onRelease(e)
                if (self.mouseDownButton == e.button):
                    self.onReleaseOutside(e)
            self.mouseDownButton = -1
        elif (tmp == 11):
            self.onTextInput(e)
        elif (tmp == 12):
            self.onCheck(e)
        else:
            pass

    def calcAbsPos(self):
        super().calcAbsPos()
        self.invDet = (1 / (((self.matA * self.matD) - ((self.matB * self.matC)))))

    def set_cursor(self,c):
        self.cursor = c
        if ((self.scene is not None) and ((self.scene.events is not None))):
            self.scene.events.updateCursor(self)
        return c

    def eventToLocal(self,e):
        i = self
        dx = (e.relX - i.absX)
        dy = (e.relY - i.absY)
        e.relX = ((((dx * i.matD) - ((dy * i.matC)))) * i.invDet)
        e.relY = ((((-dx * i.matB) + ((dy * i.matA)))) * i.invDet)

    def startDrag(self,callb,onCancel = None):
        _gthis = self
        def _hx_local_0(event):
            x = event.relX
            y = event.relY
            _gthis.eventToLocal(event)
            callb(event)
            event.relX = x
            event.relY = y
        self.scene.startDrag(_hx_local_0,onCancel)

    def stopDrag(self):
        self.scene.stopDrag()

    def focus(self):
        if ((self.scene is None) or ((self.scene.events is None))):
            return
        self.scene.events.focus(self)

    def blur(self):
        if self.hasFocus():
            self.scene.events.blur()

    def isOver(self):
        if ((self.scene is not None) and ((self.scene.events is not None))):
            return (python_internal_ArrayImpl.indexOf(self.scene.events.overList,self,None) != -1)
        else:
            return False

    def hasFocus(self):
        if ((self.scene is not None) and ((self.scene.events is not None))):
            return (self.scene.events.currentFocus == self)
        else:
            return False

    def onOver(self,e):
        pass

    def onOut(self,e):
        pass

    def onPush(self,e):
        pass

    def onRelease(self,e):
        pass

    def onReleaseOutside(self,e):
        pass

    def onClick(self,e):
        pass

    def onMove(self,e):
        pass

    def onWheel(self,e):
        pass

    def onFocus(self,e):
        pass

    def onFocusLost(self,e):
        pass

    def onKeyUp(self,e):
        pass

    def onKeyDown(self,e):
        pass

    def onCheck(self,e):
        pass

    def onTextInput(self,e):
        pass

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.width = None
        _hx_o.height = None
        _hx_o.cursor = None
        _hx_o.isEllipse = None
        _hx_o.cancelEvents = None
        _hx_o.propagateEvents = None
        _hx_o.backgroundColor = None
        _hx_o.enableRightButton = None
        _hx_o.scene = None
        _hx_o.mouseDownButton = None
        _hx_o.parentMask = None
        _hx_o.invDet = None
        _hx_o.shape = None
        _hx_o.shapeX = None
        _hx_o.shapeY = None
h2d_Interactive._hx_class = h2d_Interactive
_hx_classes["h2d.Interactive"] = h2d_Interactive


class h2d_Layers(h2d_Object):
    _hx_class_name = "h2d.Layers"
    _hx_is_interface = "False"
    __slots__ = ("layersIndexes", "layerCount")
    _hx_fields = ["layersIndexes", "layerCount"]
    _hx_methods = ["addChild", "add", "addChildAt", "removeChild", "under", "over", "getLayer", "getChildLayer", "drawLayer", "ysort"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h2d_Object


    def __init__(self,parent = None):
        self.layerCount = None
        self.layersIndexes = None
        super().__init__(parent)
        self.layersIndexes = []
        self.layerCount = 0

    def addChild(self,s):
        self.addChildAt(s,0)

    def add(self,s,layer):
        self.addChildAt(s,layer)
        return

    def addChildAt(self,s,layer):
        if (s.parent == self):
            old = s.allocated
            s.allocated = False
            self.removeChild(s)
            s.allocated = old
        while (layer >= self.layerCount):
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.layerCount
                _hx_local_0.layerCount = (_hx_local_1 + 1)
                return _hx_local_1
            python_internal_ArrayImpl._set(self.layersIndexes, _hx_local_2(), len(self.children))
        super().addChildAt(s,(self.layersIndexes[layer] if layer >= 0 and layer < len(self.layersIndexes) else None))
        _g = layer
        _g1 = self.layerCount
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _hx_local_3 = self.layersIndexes
            _hx_local_4 = i
            _hx_local_5 = (_hx_local_3[_hx_local_4] if _hx_local_4 >= 0 and _hx_local_4 < len(_hx_local_3) else None)
            python_internal_ArrayImpl._set(_hx_local_3, _hx_local_4, (_hx_local_5 + 1))
            _hx_local_5

    def removeChild(self,s):
        _g = 0
        _g1 = len(self.children)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if ((self.children[i] if i >= 0 and i < len(self.children) else None) == s):
                _this = self.children
                pos = i
                if (pos < 0):
                    pos = (len(_this) + pos)
                if (pos < 0):
                    pos = 0
                res = _this[pos:(pos + 1)]
                del _this[pos:(pos + 1)]
                if s.allocated:
                    s.onRemove()
                s.parent = None
                s.posChanged = True
                if (s.parentContainer is not None):
                    s.setParentContainer(None)
                k = (self.layerCount - 1)
                while ((k >= 0) and (((self.layersIndexes[k] if k >= 0 and k < len(self.layersIndexes) else None) > i))):
                    _hx_local_0 = self.layersIndexes
                    _hx_local_1 = k
                    _hx_local_2 = (_hx_local_0[_hx_local_1] if _hx_local_1 >= 0 and _hx_local_1 < len(_hx_local_0) else None)
                    python_internal_ArrayImpl._set(_hx_local_0, _hx_local_1, (_hx_local_2 - 1))
                    _hx_local_2
                    k = (k - 1)
                if (self.parentContainer is not None):
                    self.parentContainer.contentChanged(self)
                break

    def under(self,s):
        _g = 0
        _g1 = len(self.children)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if ((self.children[i] if i >= 0 and i < len(self.children) else None) == s):
                pos = 0
                _g2 = 0
                _g11 = self.layersIndexes
                while (_g2 < len(_g11)):
                    l = (_g11[_g2] if _g2 >= 0 and _g2 < len(_g11) else None)
                    _g2 = (_g2 + 1)
                    if (l > i):
                        break
                    else:
                        pos = l
                p = i
                while (p > pos):
                    python_internal_ArrayImpl._set(self.children, p, python_internal_ArrayImpl._get(self.children, (p - 1)))
                    p = (p - 1)
                python_internal_ArrayImpl._set(self.children, pos, s)
                if s.allocated:
                    s.onHierarchyMoved(False)
                return

    def over(self,s):
        _g = 0
        _g1 = len(self.children)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if ((self.children[i] if i >= 0 and i < len(self.children) else None) == s):
                _g2 = 0
                _g11 = self.layersIndexes
                while (_g2 < len(_g11)):
                    l = (_g11[_g2] if _g2 >= 0 and _g2 < len(_g11) else None)
                    _g2 = (_g2 + 1)
                    if (l > i):
                        _g3 = i
                        _g12 = (l - 1)
                        while (_g3 < _g12):
                            p = _g3
                            _g3 = (_g3 + 1)
                            python_internal_ArrayImpl._set(self.children, p, python_internal_ArrayImpl._get(self.children, (p + 1)))
                        python_internal_ArrayImpl._set(self.children, (l - 1), s)
                        if s.allocated:
                            s.onHierarchyMoved(False)
                        return
                return

    def getLayer(self,layer):
        a = None
        if (layer >= self.layerCount):
            a = []
        else:
            start = (0 if ((layer == 0)) else python_internal_ArrayImpl._get(self.layersIndexes, (layer - 1)))
            _hx_max = (self.layersIndexes[layer] if layer >= 0 and layer < len(self.layersIndexes) else None)
            a = self.children[start:_hx_max]
        return hxd_impl_ArrayIterator_h2d_Object(a)

    def getChildLayer(self,s):
        if (s.parent != self):
            return -1
        index = python_internal_ArrayImpl.indexOf(self.children,s,None)
        _g = 0
        _g1 = self.layerCount
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if ((self.layersIndexes[i] if i >= 0 and i < len(self.layersIndexes) else None) > index):
                return i
        return -1

    def drawLayer(self,ctx,layer):
        if (layer >= self.layerCount):
            return
        old = ctx.globalAlpha
        ctx.globalAlpha = (ctx.globalAlpha * self.alpha)
        start = (0 if ((layer == 0)) else python_internal_ArrayImpl._get(self.layersIndexes, (layer - 1)))
        _hx_max = (self.layersIndexes[layer] if layer >= 0 and layer < len(self.layersIndexes) else None)
        if ctx.front2back:
            _g = start
            _g1 = _hx_max
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                python_internal_ArrayImpl._get(self.children, ((_hx_max - 1) - i)).drawRec(ctx)
        else:
            _g2 = start
            _g11 = _hx_max
            while (_g2 < _g11):
                i1 = _g2
                _g2 = (_g2 + 1)
                (self.children[i1] if i1 >= 0 and i1 < len(self.children) else None).drawRec(ctx)
        ctx.globalAlpha = old

    def ysort(self,layer):
        if (layer >= self.layerCount):
            return
        start = (0 if ((layer == 0)) else python_internal_ArrayImpl._get(self.layersIndexes, (layer - 1)))
        _hx_max = (self.layersIndexes[layer] if layer >= 0 and layer < len(self.layersIndexes) else None)
        if (start == _hx_max):
            return
        pos = start
        ymax = pos
        pos = (pos + 1)
        ymax1 = (self.children[ymax] if ymax >= 0 and ymax < len(self.children) else None).y
        while (pos < _hx_max):
            c = (self.children[pos] if pos >= 0 and pos < len(self.children) else None)
            if (c.y < ymax1):
                p = (pos - 1)
                while (p >= start):
                    c2 = (self.children[p] if p >= 0 and p < len(self.children) else None)
                    if (c.y >= c2.y):
                        break
                    python_internal_ArrayImpl._set(self.children, (p + 1), c2)
                    p = (p - 1)
                python_internal_ArrayImpl._set(self.children, (p + 1), c)
                if c.allocated:
                    c.onHierarchyMoved(False)
            else:
                ymax1 = c.y
            pos = (pos + 1)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.layersIndexes = None
        _hx_o.layerCount = None
h2d_Layers._hx_class = h2d_Layers
_hx_classes["h2d.Layers"] = h2d_Layers


class h2d_Mask(h2d_Object):
    _hx_class_name = "h2d.Mask"
    _hx_is_interface = "False"
    __slots__ = ("width", "height", "parentMask", "scrollX", "scrollY", "scrollBounds")
    _hx_fields = ["width", "height", "parentMask", "scrollX", "scrollY", "scrollBounds"]
    _hx_methods = ["scrollTo", "scrollBy", "onHierarchyMoved", "onAdd", "updateMask", "set_scrollX", "set_scrollY", "calcAbsPos", "getBoundsRec", "drawRec"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h2d_Object


    def __init__(self,width,height,parent = None):
        self.scrollBounds = None
        self.parentMask = None
        self.height = None
        self.width = None
        self.scrollY = 0
        self.scrollX = 0
        super().__init__(parent)
        self.width = width
        self.height = height

    def scrollTo(self,x,y):
        self.set_scrollX(x)
        self.set_scrollY(y)

    def scrollBy(self,x,y):
        _g = self
        _g.set_scrollX((_g.scrollX + x))
        _g1 = self
        _g1.set_scrollY((_g1.scrollY + y))

    def onHierarchyMoved(self,parentChanged):
        super().onHierarchyMoved(parentChanged)
        if parentChanged:
            self.updateMask()

    def onAdd(self):
        super().onAdd()
        self.updateMask()

    def updateMask(self):
        self.parentMask = None
        p = self.parent
        while (p is not None):
            m = Std.downcast(p,h2d_Mask)
            if (m is not None):
                self.parentMask = m
                break
            p = p.parent

    def set_scrollX(self,v):
        if (self.scrollBounds is not None):
            _hx_min = self.scrollBounds.xMin
            _hx_max = (self.scrollBounds.xMax - self.width)
            if (_hx_max is None):
                _hx_max = 1.
            if (_hx_min is None):
                _hx_min = 0.
            v = (_hx_min if ((v < _hx_min)) else (_hx_max if ((v > _hx_max)) else v))
        self.posChanged = True
        def _hx_local_1():
            def _hx_local_0():
                self.scrollX = v
                return self.scrollX
            return _hx_local_0()
        return _hx_local_1()

    def set_scrollY(self,v):
        if (self.scrollBounds is not None):
            _hx_min = self.scrollBounds.yMin
            _hx_max = (self.scrollBounds.yMax - self.height)
            if (_hx_max is None):
                _hx_max = 1.
            if (_hx_min is None):
                _hx_min = 0.
            v = (_hx_min if ((v < _hx_min)) else (_hx_max if ((v > _hx_max)) else v))
        self.posChanged = True
        def _hx_local_1():
            def _hx_local_0():
                self.scrollY = v
                return self.scrollY
            return _hx_local_0()
        return _hx_local_1()

    def calcAbsPos(self):
        super().calcAbsPos()
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.absX
        _hx_local_0.absX = (_hx_local_1 - self.scrollX)
        _hx_local_0.absX
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.absY
        _hx_local_2.absY = (_hx_local_3 - self.scrollY)
        _hx_local_2.absY

    def getBoundsRec(self,relativeTo,out,forSize):
        xMin = out.xMin
        yMin = out.yMin
        xMax = out.xMax
        yMax = out.yMax
        out.xMin = 1e20
        out.yMin = 1e20
        out.xMax = -1e20
        out.yMax = -1e20
        if self.posChanged:
            self.calcAbsPos()
            _g = 0
            _g1 = self.children
            while (_g < len(_g1)):
                c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                c.posChanged = True
            self.posChanged = False
        self.addBounds(relativeTo,out,0,0,self.width,self.height)
        bxMin = out.xMin
        byMin = out.yMin
        bxMax = out.xMax
        byMax = out.yMax
        out.xMin = xMin
        out.xMax = xMax
        out.yMin = yMin
        out.yMax = yMax
        super().getBoundsRec(relativeTo,out,forSize)
        if (out.xMin < bxMin):
            out.xMin = (bxMin if ((xMin > bxMin)) else xMin)
        if (out.yMin < byMin):
            out.yMin = (byMin if ((yMin > byMin)) else yMin)
        if (out.xMax > bxMax):
            out.xMax = (bxMax if ((xMax < bxMax)) else xMax)
        if (out.yMax > byMax):
            out.yMax = (byMax if ((yMax < byMax)) else yMax)

    def drawRec(self,ctx):
        x1 = (self.absX + self.scrollX)
        y1 = (self.absY + self.scrollY)
        x2 = (((self.width * self.matA) + ((self.height * self.matC))) + x1)
        y2 = (((self.width * self.matB) + ((self.height * self.matD))) + y1)
        tmp = None
        if (x1 > x2):
            tmp = x1
            x1 = x2
            x2 = tmp
        if (y1 > y2):
            tmp = y1
            y1 = y2
            y2 = tmp
        if ctx.hasRenderZone:
            oldX = ctx.renderX
            oldY = ctx.renderY
            oldW = ctx.renderW
            oldH = ctx.renderH
            ctx.setRenderZone(x1,y1,(x2 - x1),(y2 - y1))
            super().drawRec(ctx)
            ctx.setRenderZone(oldX,oldY,oldW,oldH)
        else:
            ctx.setRenderZone(x1,y1,(x2 - x1),(y2 - y1))
            super().drawRec(ctx)
            ctx.hasRenderZone = False
            ctx.engine.setRenderZone()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.width = None
        _hx_o.height = None
        _hx_o.parentMask = None
        _hx_o.scrollX = None
        _hx_o.scrollY = None
        _hx_o.scrollBounds = None
h2d_Mask._hx_class = h2d_Mask
_hx_classes["h2d.Mask"] = h2d_Mask


class h3d_impl_RenderContext:
    _hx_class_name = "h3d.impl.RenderContext"
    _hx_is_interface = "False"
    __slots__ = ("engine", "time", "elapsedTime", "frame", "textures")
    _hx_fields = ["engine", "time", "elapsedTime", "frame", "textures"]
    _hx_methods = ["dispose"]

    def __init__(self):
        self.textures = None
        self.engine = h3d_Engine.CURRENT
        self.frame = 0
        self.time = 0.
        self.elapsedTime = (1. / hxd_System.getDefaultFrameRate())
        self.textures = h3d_impl_TextureCache(self)

    def dispose(self):
        self.textures.dispose()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.engine = None
        _hx_o.time = None
        _hx_o.elapsedTime = None
        _hx_o.frame = None
        _hx_o.textures = None
h3d_impl_RenderContext._hx_class = h3d_impl_RenderContext
_hx_classes["h3d.impl.RenderContext"] = h3d_impl_RenderContext


class h2d_RenderContext(h3d_impl_RenderContext):
    _hx_class_name = "h2d.RenderContext"
    _hx_is_interface = "False"
    __slots__ = ("globalAlpha", "buffer", "bufPos", "scene", "defaultSmooth", "killAlpha", "front2back", "onBeginDraw", "onEnterFilter", "onLeaveFilter", "tmpBounds", "texture", "baseShader", "manager", "compiledShader", "buffers", "fixedBuffer", "_hx_pass", "currentShaders", "baseShaderList", "currentObj", "stride", "targetsStack", "targetsStackIndex", "hasUVPos", "filterStack", "inFilter", "inFilterBlend", "curX", "curY", "curWidth", "curHeight", "hasRenderZone", "renderX", "renderY", "renderW", "renderH", "currentBlend", "baseFlipY", "targetFlipY")
    _hx_fields = ["globalAlpha", "buffer", "bufPos", "scene", "defaultSmooth", "killAlpha", "front2back", "onBeginDraw", "onEnterFilter", "onLeaveFilter", "tmpBounds", "texture", "baseShader", "manager", "compiledShader", "buffers", "fixedBuffer", "pass", "currentShaders", "baseShaderList", "currentObj", "stride", "targetsStack", "targetsStackIndex", "hasUVPos", "filterStack", "inFilter", "inFilterBlend", "curX", "curY", "curWidth", "curHeight", "hasRenderZone", "renderX", "renderY", "renderW", "renderH", "currentBlend", "baseFlipY", "targetFlipY"]
    _hx_methods = ["dispose", "hasBuffering", "begin", "allocTarget", "clear", "initShaders", "end", "pushFilter", "popFilter", "pushTarget", "pushTargets", "popTarget", "setRenderZone", "clearRenderZone", "drawLayer", "drawScene", "flush", "_flush", "beforeDraw", "setupColor", "beginDrawObject", "beginDrawBatch", "drawTile", "beginDraw"]
    _hx_statics = ["BUFFERING"]
    _hx_interfaces = []
    _hx_super = h3d_impl_RenderContext


    def __init__(self,scene):
        self.targetFlipY = None
        self.baseFlipY = None
        self.currentBlend = None
        self.renderH = None
        self.renderW = None
        self.renderY = None
        self.renderX = None
        self.hasRenderZone = None
        self.curHeight = None
        self.curWidth = None
        self.curY = None
        self.curX = None
        self.inFilterBlend = None
        self.inFilter = None
        self.filterStack = None
        self.hasUVPos = None
        self.targetsStackIndex = None
        self.targetsStack = None
        self.stride = None
        self.currentObj = None
        self.baseShaderList = None
        self.currentShaders = None
        self._hx_pass = None
        self.fixedBuffer = None
        self.buffers = None
        self.compiledShader = None
        self.manager = None
        self.baseShader = None
        self.texture = None
        self.onLeaveFilter = None
        self.onEnterFilter = None
        self.onBeginDraw = None
        self.front2back = None
        self.killAlpha = None
        self.scene = None
        self.bufPos = None
        self.buffer = None
        self.tmpBounds = h2d_col_Bounds()
        self.defaultSmooth = False
        self.globalAlpha = 1.
        super().__init__()
        self.scene = scene
        self.bufPos = 0
        self.manager = h3d_pass_ShaderManager()
        self._hx_pass = h3d_mat_Pass("",None)
        self._hx_pass.depth(True,h3d_mat_Compare.Always)
        self._hx_pass.set_culling(h3d_mat_Face._hx_None)
        self.baseShader = h3d_shader_Base2d()
        self.baseShader.setPriority(100)
        self.baseShader.zValue__ = 0.
        self.baseShaderList = hxsl_ShaderList(self.baseShader)
        self.targetsStack = []
        self.targetsStackIndex = 0
        self.filterStack = []

    def dispose(self):
        super().dispose()
        if (self.fixedBuffer is not None):
            self.fixedBuffer.dispose()

    def hasBuffering(self):
        return False

    def begin(self):
        self.texture = None
        self.currentObj = None
        self.bufPos = 0
        self.stride = 0
        self.curX = 0
        self.curY = 0
        self.targetFlipY = (-1 if (self.engine.driver.hasFeature(h3d_impl_Feature.BottomLeftCoords)) else 1)
        self.baseFlipY = (self.targetFlipY if ((self.engine.getCurrentTarget() is not None)) else 1)
        self.inFilter = None
        self.curWidth = self.scene.width
        self.curHeight = self.scene.height
        self.manager.globals.set("time",self.time)
        _this = self.baseShader
        _this.constModified = True
        _this.pixelAlign__ = False
        _this1 = self.baseShader.halfPixelInverse__
        x = (0.5 / self.engine.width)
        y = (0.5 / self.engine.height)
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this1.x = x
        _this1.y = y
        _this1.z = 0.
        _this1.w = 1.
        _this2 = self.baseShader.viewport__
        x1 = ((-self.scene.width * 0.5) - self.scene.offsetX)
        y1 = ((-self.scene.height * 0.5) - self.scene.offsetY)
        z = ((2 / self.scene.width) * self.scene.ratioX)
        w = (((-2 * self.baseFlipY) / self.scene.height) * self.scene.ratioY)
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y1 is None):
            y1 = 0.
        if (x1 is None):
            x1 = 0.
        _this2.x = x1
        _this2.y = y1
        _this2.z = z
        _this2.w = w
        _this3 = self.baseShader.filterMatrixA__
        x2 = 1
        y2 = 0
        z1 = 0
        if (z1 is None):
            z1 = 0.
        if (y2 is None):
            y2 = 0.
        if (x2 is None):
            x2 = 0.
        _this3.x = x2
        _this3.y = y2
        _this3.z = z1
        _this3.w = 1.
        _this4 = self.baseShader.filterMatrixB__
        x3 = 0
        y3 = 1
        z2 = 0
        if (z2 is None):
            z2 = 0.
        if (y3 is None):
            y3 = 0.
        if (x3 is None):
            x3 = 0.
        _this4.x = x3
        _this4.y = y3
        _this4.z = z2
        _this4.w = 1.
        self.baseShaderList.next = None
        self.initShaders(self.baseShaderList)
        self.engine.selectMaterial(self._hx_pass)
        self.textures.begin()

    def allocTarget(self,name,_hx_filter = None):
        if (_hx_filter is None):
            _hx_filter = False
        t = self.textures.allocTarget(name,self.scene.width,self.scene.height,False)
        t.set_filter((h3d_mat_Filter.Linear if _hx_filter else h3d_mat_Filter.Nearest))
        return t

    def clear(self,color):
        self.engine.clear(color)

    def initShaders(self,shaders):
        self.currentShaders = shaders
        self.compiledShader = self.manager.compileShaders(shaders)
        if (self.buffers is None):
            self.buffers = h3d_shader_Buffers(self.compiledShader)
        else:
            _this = self.buffers
            s = self.compiledShader
            _this.vertex.grow(s.vertex)
            _this.fragment.grow(s.fragment)
        self.manager.fillGlobals(self.buffers,self.compiledShader)
        self.engine.selectShader(self.compiledShader)
        self.engine.uploadShaderBuffers(self.buffers,0)

    def end(self):
        self.texture = None
        self.currentObj = None
        self.baseShaderList.next = None
        if (self.targetsStackIndex != 0):
            raise _HxException("Missing popTarget()")

    def pushFilter(self,spr):
        if ((len(self.filterStack) == 0) and ((self.onEnterFilter is not None))):
            if (not self.onEnterFilter(spr)):
                return False
        _this = self.filterStack
        _this.append(spr)
        self.inFilter = spr
        return True

    def popFilter(self):
        _this = self.filterStack
        spr = (None if ((len(_this) == 0)) else _this.pop())
        if (len(self.filterStack) > 0):
            self.inFilter = python_internal_ArrayImpl._get(self.filterStack, (len(self.filterStack) - 1))
        else:
            self.inFilter = None
            if (self.onLeaveFilter is not None):
                self.onLeaveFilter(spr)

    def pushTarget(self,t,startX = None,startY = None,width = None,height = None):
        if (startX is None):
            startX = 0
        if (startY is None):
            startY = 0
        if (width is None):
            width = -1
        if (height is None):
            height = -1
        self.engine.pushTarget(t)
        self.initShaders(self.baseShaderList)
        if (width < 0):
            width = (self.scene.width if ((t is None)) else t.width)
        if (height < 0):
            height = (self.scene.height if ((t is None)) else t.height)
        _this = self.baseShader.halfPixelInverse__
        x = (0.5 / ((self.engine.width if ((t is None)) else t.width)))
        y = (0.5 / ((self.engine.height if ((t is None)) else t.height)))
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = 0.
        _this.w = 1.
        _this1 = self.baseShader.viewport__
        x1 = ((-width * 0.5) - startX)
        y1 = ((-height * 0.5) - startY)
        z = (2 / width)
        w = ((-2 * self.targetFlipY) / height)
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y1 is None):
            y1 = 0.
        if (x1 is None):
            x1 = 0.
        _this1.x = x1
        _this1.y = y1
        _this1.z = z
        _this1.w = w
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.targetsStackIndex
        _hx_local_0.targetsStackIndex = (_hx_local_1 + 1)
        _hx_local_1
        if (self.targetsStackIndex > len(self.targetsStack)):
            _this2 = self.targetsStack
            x2 = _hx_AnonObject({'t': t, 'x': startX, 'y': startY, 'w': width, 'h': height, 'hasRZ': self.hasRenderZone, 'rzX': self.renderX, 'rzY': self.renderY, 'rzW': self.renderW, 'rzH': self.renderH})
            _this2.append(x2)
        else:
            o = python_internal_ArrayImpl._get(self.targetsStack, (self.targetsStackIndex - 1))
            o.t = t
            o.x = startX
            o.y = startY
            o.w = width
            o.h = height
            o.hasRZ = self.hasRenderZone
            o.rzX = self.renderX
            o.rzY = self.renderY
            o.rzW = self.renderW
            o.rzH = self.renderH
        self.curX = startX
        self.curY = startY
        self.curWidth = width
        self.curHeight = height
        self.currentBlend = None
        if self.hasRenderZone:
            self.hasRenderZone = False
            self.engine.setRenderZone()

    def pushTargets(self,texs):
        self.pushTarget((texs[0] if 0 < len(texs) else None))
        if (len(texs) > 1):
            self.engine.popTarget()
            self.engine.pushTargets(texs)

    def popTarget(self,restore = None):
        if (restore is None):
            restore = True
        if (self.targetsStackIndex <= 0):
            raise _HxException("Too many popTarget()")
        def _hx_local_2():
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.targetsStackIndex
            _hx_local_0.targetsStackIndex = (_hx_local_1 - 1)
            return _hx_local_0.targetsStackIndex
        pinf = python_internal_ArrayImpl._get(self.targetsStack, _hx_local_2())
        self.engine.popTarget()
        if restore:
            tinf = python_internal_ArrayImpl._get(self.targetsStack, (self.targetsStackIndex - 1))
            t = None
            startX = None
            startY = None
            width = None
            height = None
            ratioX = None
            ratioY = None
            offsetX = None
            offsetY = None
            if (tinf is None):
                t = None
                startX = 0
                startY = 0
                width = self.scene.width
                height = self.scene.height
                ratioX = self.scene.ratioX
                ratioY = self.scene.ratioY
                offsetX = self.scene.offsetX
                offsetY = self.scene.offsetY
            else:
                t = tinf.t
                startX = tinf.x
                startY = tinf.y
                width = tinf.w
                height = tinf.h
                ratioX = 1
                ratioY = 1
                offsetX = 0
                offsetY = 0
            self.initShaders(self.baseShaderList)
            _this = self.baseShader.halfPixelInverse__
            x = (0.5 / ((self.engine.width if ((t is None)) else t.width)))
            y = (0.5 / ((self.engine.height if ((t is None)) else t.height)))
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            _this.x = x
            _this.y = y
            _this.z = 0.
            _this.w = 1.
            _this1 = self.baseShader.viewport__
            x1 = (((-width * 0.5) - startX) - offsetX)
            y1 = (((-height * 0.5) - startY) - offsetY)
            z = ((2 / width) * ratioX)
            w = (((-2 * ((self.baseFlipY if ((t is None)) else self.targetFlipY))) / height) * ratioY)
            if (w is None):
                w = 1.
            if (z is None):
                z = 0.
            if (y1 is None):
                y1 = 0.
            if (x1 is None):
                x1 = 0.
            _this1.x = x1
            _this1.y = y1
            _this1.z = z
            _this1.w = w
            self.curX = startX
            self.curY = startY
            self.curWidth = width
            self.curHeight = height
        if pinf.hasRZ:
            self.setRenderZone(pinf.rzX,pinf.rzY,pinf.rzW,pinf.rzH)

    def setRenderZone(self,x,y,w,h):
        self.hasRenderZone = True
        self.renderX = x
        self.renderY = y
        self.renderW = w
        self.renderH = h
        scaleX = ((self.engine.width * self.scene.ratioX) / self.scene.width)
        scaleY = ((self.engine.height * self.scene.ratioY) / self.scene.height)
        if (self.inFilter is not None):
            fa = self.baseShader.filterMatrixA__
            fb = self.baseShader.filterMatrixB__
            x2 = (x + w)
            y2 = (y + h)
            rx1 = (((x * fa.x) + ((y * fa.y))) + fa.z)
            ry1 = (((x * fb.x) + ((y * fb.y))) + fb.z)
            rx2 = (((x2 * fa.x) + ((y2 * fa.y))) + fa.z)
            ry2 = (((x2 * fb.x) + ((y2 * fb.y))) + fb.z)
            x = rx1
            y = ry1
            w = (rx2 - rx1)
            h = (ry2 - ry1)
        tmp = self.engine
        x1 = (((((x - self.curX) + self.scene.viewportX)) * scaleX) + 1e-10)
        tmp1 = None
        try:
            tmp1 = int(x1)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            tmp1 = None
        x3 = (((((y - self.curY) + self.scene.viewportY)) * scaleY) + 1e-10)
        tmp2 = None
        try:
            tmp2 = int(x3)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e1 = _hx_e1
            tmp2 = None
        tmp3 = None
        try:
            tmp3 = int(((w * scaleX) + 1e-10))
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e2 = _hx_e1
            tmp3 = None
        tmp4 = tmp3
        tmp5 = None
        try:
            tmp5 = int(((h * scaleY) + 1e-10))
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e3 = _hx_e1
            tmp5 = None
        tmp.setRenderZone(tmp1,tmp2,tmp4,tmp5)

    def clearRenderZone(self):
        self.hasRenderZone = False
        self.engine.setRenderZone()

    def drawLayer(self,layer):
        self.scene.drawLayer(self,layer)

    def drawScene(self):
        self.scene.drawRec(self)

    def flush(self):
        pass

    def _flush(self):
        if (self.bufPos == 0):
            return
        self.beforeDraw()
        x = (self.bufPos / self.stride)
        nverts = None
        try:
            nverts = int(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            nverts = None
        tmp = h3d_Buffer(nverts,self.stride,[h3d_BufferFlag.Quads, h3d_BufferFlag.Dynamic, h3d_BufferFlag.RawFormat])
        tmp.uploadVector(self.buffer,0,nverts)
        _this = self.engine
        _this.renderBuffer(tmp,_this.mem.quadIndexes,2,0,-1)
        tmp.dispose()
        self.bufPos = 0
        self.texture = None

    def beforeDraw(self):
        if (self.texture is None):
            self.texture = h3d_mat_Texture.fromColor(16711935)
        self.baseShader.texture__ = self.texture
        self.texture.set_filter((h3d_mat_Filter.Linear if ((self.defaultSmooth if ((self.currentObj.smooth is None)) else self.currentObj.smooth)) else h3d_mat_Filter.Nearest))
        self.texture.set_wrap((h3d_mat_Wrap.Repeat if ((self.currentObj.tileWrap and (((self.currentObj.filter is None) or ((self.inFilter is not None)))))) else h3d_mat_Wrap.Clamp))
        blend = self.currentObj.blendMode
        if ((self.inFilter == self.currentObj) and ((blend == h2d_BlendMode.Erase))):
            blend = h2d_BlendMode.Add
        if (self.inFilterBlend is not None):
            blend = self.inFilterBlend
        if (blend != self.currentBlend):
            self.currentBlend = blend
            self._hx_pass.setBlendMode(blend)
            if ((blend == h2d_BlendMode.Alpha) or ((blend == h2d_BlendMode.Add))):
                self._hx_pass.set_blendAlphaSrc(h3d_mat_Blend.One)
                if (self.inFilterBlend is not None):
                    self._hx_pass.set_blendSrc(h3d_mat_Blend.One)
        self.manager.fillParams(self.buffers,self.compiledShader,self.currentShaders)
        self.engine.selectMaterial(self._hx_pass)
        self.engine.uploadShaderBuffers(self.buffers,1)
        self.engine.uploadShaderBuffers(self.buffers,2)
        self.engine.uploadShaderBuffers(self.buffers,3)

    def setupColor(self,obj):
        if (self.inFilter == obj):
            _this = self.baseShader.color__
            x = obj.color.x
            y = obj.color.y
            z = obj.color.z
            w = obj.color.w
            if (w is None):
                w = 1.
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            _this.x = x
            _this.y = y
            _this.z = z
            _this.w = w
        elif (self.inFilterBlend is not None):
            _this1 = self.baseShader.color__
            x1 = self.globalAlpha
            y1 = self.globalAlpha
            z1 = self.globalAlpha
            w1 = self.globalAlpha
            if (w1 is None):
                w1 = 1.
            if (z1 is None):
                z1 = 0.
            if (y1 is None):
                y1 = 0.
            if (x1 is None):
                x1 = 0.
            _this1.x = x1
            _this1.y = y1
            _this1.z = z1
            _this1.w = w1
        else:
            _this2 = self.baseShader.color__
            x2 = obj.color.x
            y2 = obj.color.y
            z2 = obj.color.z
            w2 = (obj.color.w * self.globalAlpha)
            if (w2 is None):
                w2 = 1.
            if (z2 is None):
                z2 = 0.
            if (y2 is None):
                y2 = 0.
            if (x2 is None):
                x2 = 0.
            _this2.x = x2
            _this2.y = y2
            _this2.z = z2
            _this2.w = w2

    def beginDrawObject(self,obj,texture):
        if (not self.beginDraw(obj,texture,True)):
            return False
        if (self.inFilter == obj):
            _this = self.baseShader.color__
            x = obj.color.x
            y = obj.color.y
            z = obj.color.z
            w = obj.color.w
            if (w is None):
                w = 1.
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            _this.x = x
            _this.y = y
            _this.z = z
            _this.w = w
        elif (self.inFilterBlend is not None):
            _this1 = self.baseShader.color__
            x1 = self.globalAlpha
            y1 = self.globalAlpha
            z1 = self.globalAlpha
            w1 = self.globalAlpha
            if (w1 is None):
                w1 = 1.
            if (z1 is None):
                z1 = 0.
            if (y1 is None):
                y1 = 0.
            if (x1 is None):
                x1 = 0.
            _this1.x = x1
            _this1.y = y1
            _this1.z = z1
            _this1.w = w1
        else:
            _this2 = self.baseShader.color__
            x2 = obj.color.x
            y2 = obj.color.y
            z2 = obj.color.z
            w2 = (obj.color.w * self.globalAlpha)
            if (w2 is None):
                w2 = 1.
            if (z2 is None):
                z2 = 0.
            if (y2 is None):
                y2 = 0.
            if (x2 is None):
                x2 = 0.
            _this2.x = x2
            _this2.y = y2
            _this2.z = z2
            _this2.w = w2
        _this3 = self.baseShader.absoluteMatrixA__
        x3 = obj.matA
        y3 = obj.matC
        z3 = obj.absX
        if (z3 is None):
            z3 = 0.
        if (y3 is None):
            y3 = 0.
        if (x3 is None):
            x3 = 0.
        _this3.x = x3
        _this3.y = y3
        _this3.z = z3
        _this3.w = 1.
        _this4 = self.baseShader.absoluteMatrixB__
        x4 = obj.matB
        y4 = obj.matD
        z4 = obj.absY
        if (z4 is None):
            z4 = 0.
        if (y4 is None):
            y4 = 0.
        if (x4 is None):
            x4 = 0.
        _this4.x = x4
        _this4.y = y4
        _this4.z = z4
        _this4.w = 1.
        self.beforeDraw()
        return True

    def beginDrawBatch(self,obj,texture):
        return self.beginDraw(obj,texture,False)

    def drawTile(self,obj,tile):
        matA = None
        matB = None
        matC = None
        matD = None
        absX = None
        absY = None
        if (self.inFilter is not None):
            f1 = self.baseShader.filterMatrixA__
            f2 = self.baseShader.filterMatrixB__
            matA = ((obj.matA * f1.x) + ((obj.matB * f1.y)))
            matB = ((obj.matA * f2.x) + ((obj.matB * f2.y)))
            matC = ((obj.matC * f1.x) + ((obj.matD * f1.y)))
            matD = ((obj.matC * f2.x) + ((obj.matD * f2.y)))
            absX = (((obj.absX * f1.x) + ((obj.absY * f1.y))) + f1.z)
            absY = (((obj.absX * f2.x) + ((obj.absY * f2.y))) + f2.z)
        else:
            matA = obj.matA
            matB = obj.matB
            matC = obj.matC
            matD = obj.matD
            absX = obj.absX
            absY = obj.absY
        if ((matB == 0) and ((matC == 0))):
            tx = (tile.dx + ((tile.width * 0.5)))
            ty = (tile.dy + ((tile.height * 0.5)))
            f = obj.matA
            a = (-f if ((f < 0)) else f)
            f3 = obj.matD
            b = (-f3 if ((f3 < 0)) else f3)
            tr = ((((tile.width if ((tile.width > tile.height)) else tile.height)) * 1.5) * ((b if ((a < b)) else a)))
            cx = ((absX + ((tx * matA))) - self.curX)
            cy = ((absY + ((ty * matD))) - self.curY)
            if ((((cx < -tr) or ((cy < -tr))) or (((cx - tr) > self.curWidth))) or (((cy - tr) > self.curHeight))):
                return False
        else:
            xMin = 1e20
            yMin = 1e20
            xMax = -1e20
            yMax = -1e20
            hw = (tile.width * 0.5)
            hh = (tile.height * 0.5)
            px = ((tile.dx * matA) + ((tile.dy * matC)))
            py = ((tile.dx * matB) + ((tile.dy * matD)))
            if (px < xMin):
                xMin = px
            if (px > xMax):
                xMax = px
            if (py < yMin):
                yMin = py
            if (py > yMax):
                yMax = py
            x = tile.width
            px1 = ((((x + tile.dx)) * matA) + ((tile.dy * matC)))
            py1 = ((((x + tile.dx)) * matB) + ((tile.dy * matD)))
            if (px1 < xMin):
                xMin = px1
            if (px1 > xMax):
                xMax = px1
            if (py1 < yMin):
                yMin = py1
            if (py1 > yMax):
                yMax = py1
            y = tile.height
            px2 = ((tile.dx * matA) + ((((y + tile.dy)) * matC)))
            py2 = ((tile.dx * matB) + ((((y + tile.dy)) * matD)))
            if (px2 < xMin):
                xMin = px2
            if (px2 > xMax):
                xMax = px2
            if (py2 < yMin):
                yMin = py2
            if (py2 > yMax):
                yMax = py2
            x1 = tile.width
            y1 = tile.height
            px3 = ((((x1 + tile.dx)) * matA) + ((((y1 + tile.dy)) * matC)))
            py3 = ((((x1 + tile.dx)) * matB) + ((((y1 + tile.dy)) * matD)))
            if (px3 < xMin):
                xMin = px3
            if (px3 > xMax):
                xMax = px3
            if (py3 < yMin):
                yMin = py3
            if (py3 > yMax):
                yMax = py3
            cx1 = (absX - self.curX)
            cy1 = (absY - self.curY)
            if (((((cx1 + xMax) < 0) or (((cy1 + yMax) < 0))) or (((cx1 + xMin) > self.curWidth))) or (((cy1 + yMin) > self.curHeight))):
                return False
        if (not self.beginDraw(obj,tile.innerTex,True,True)):
            return False
        if (self.inFilter == obj):
            _this = self.baseShader.color__
            x2 = obj.color.x
            y2 = obj.color.y
            z = obj.color.z
            w = obj.color.w
            if (w is None):
                w = 1.
            if (z is None):
                z = 0.
            if (y2 is None):
                y2 = 0.
            if (x2 is None):
                x2 = 0.
            _this.x = x2
            _this.y = y2
            _this.z = z
            _this.w = w
        elif (self.inFilterBlend is not None):
            _this1 = self.baseShader.color__
            x3 = self.globalAlpha
            y3 = self.globalAlpha
            z1 = self.globalAlpha
            w1 = self.globalAlpha
            if (w1 is None):
                w1 = 1.
            if (z1 is None):
                z1 = 0.
            if (y3 is None):
                y3 = 0.
            if (x3 is None):
                x3 = 0.
            _this1.x = x3
            _this1.y = y3
            _this1.z = z1
            _this1.w = w1
        else:
            _this2 = self.baseShader.color__
            x4 = obj.color.x
            y4 = obj.color.y
            z2 = obj.color.z
            w2 = (obj.color.w * self.globalAlpha)
            if (w2 is None):
                w2 = 1.
            if (z2 is None):
                z2 = 0.
            if (y4 is None):
                y4 = 0.
            if (x4 is None):
                x4 = 0.
            _this2.x = x4
            _this2.y = y4
            _this2.z = z2
            _this2.w = w2
        _this3 = self.baseShader.absoluteMatrixA__
        x5 = (tile.width * obj.matA)
        y5 = (tile.height * obj.matC)
        z3 = ((obj.absX + ((tile.dx * obj.matA))) + ((tile.dy * obj.matC)))
        if (z3 is None):
            z3 = 0.
        if (y5 is None):
            y5 = 0.
        if (x5 is None):
            x5 = 0.
        _this3.x = x5
        _this3.y = y5
        _this3.z = z3
        _this3.w = 1.
        _this4 = self.baseShader.absoluteMatrixB__
        x6 = (tile.width * obj.matB)
        y6 = (tile.height * obj.matD)
        z4 = ((obj.absY + ((tile.dx * obj.matB))) + ((tile.dy * obj.matD)))
        if (z4 is None):
            z4 = 0.
        if (y6 is None):
            y6 = 0.
        if (x6 is None):
            x6 = 0.
        _this4.x = x6
        _this4.y = y6
        _this4.z = z4
        _this4.w = 1.
        _this5 = self.baseShader.uvPos__
        x7 = tile.u
        y7 = tile.v
        z5 = (tile.u2 - tile.u)
        w3 = (tile.v2 - tile.v)
        if (w3 is None):
            w3 = 1.
        if (z5 is None):
            z5 = 0.
        if (y7 is None):
            y7 = 0.
        if (x7 is None):
            x7 = 0.
        _this5.x = x7
        _this5.y = y7
        _this5.z = z5
        _this5.w = w3
        self.beforeDraw()
        if ((self.fixedBuffer is None) or self.fixedBuffer.isDisposed()):
            self.fixedBuffer = h3d_Buffer(4,8,[h3d_BufferFlag.Quads, h3d_BufferFlag.RawFormat])
            this1 = list()
            k = this1
            v = 0
            k.append(v)
            v1 = 0
            k.append(v1)
            v2 = 0
            k.append(v2)
            v3 = 0
            k.append(v3)
            v4 = 1
            k.append(v4)
            v5 = 1
            k.append(v5)
            v6 = 1
            k.append(v6)
            v7 = 1
            k.append(v7)
            v8 = 0
            k.append(v8)
            v9 = 1
            k.append(v9)
            v10 = 0
            k.append(v10)
            v11 = 1
            k.append(v11)
            v12 = 1
            k.append(v12)
            v13 = 1
            k.append(v13)
            v14 = 1
            k.append(v14)
            v15 = 1
            k.append(v15)
            v16 = 1
            k.append(v16)
            v17 = 0
            k.append(v17)
            v18 = 1
            k.append(v18)
            v19 = 0
            k.append(v19)
            v20 = 1
            k.append(v20)
            v21 = 1
            k.append(v21)
            v22 = 1
            k.append(v22)
            v23 = 1
            k.append(v23)
            v24 = 1
            k.append(v24)
            v25 = 1
            k.append(v25)
            v26 = 1
            k.append(v26)
            v27 = 1
            k.append(v27)
            v28 = 1
            k.append(v28)
            v29 = 1
            k.append(v29)
            v30 = 1
            k.append(v30)
            v31 = 1
            k.append(v31)
            self.fixedBuffer.uploadVector(k,0,4)
        _this6 = self.engine
        _this6.renderBuffer(self.fixedBuffer,_this6.mem.quadIndexes,2,0,-1)
        return True

    def beginDraw(self,obj,texture,isRelative,hasUVPos = None):
        if (hasUVPos is None):
            hasUVPos = False
        if ((self.onBeginDraw is not None) and (not self.onBeginDraw(obj))):
            return False
        stride = 8
        shaderChanged = False
        paramsChanged = False
        objShaders = obj.shaders
        curShaders = self.currentShaders.next
        while ((objShaders is not None) and ((curShaders is not None))):
            s = objShaders.s
            t = curShaders.s
            objShaders = objShaders.next
            curShaders = curShaders.next
            prevInst = t.instance
            if (s != t):
                paramsChanged = True
            s.updateConstants(self.manager.globals)
            if (s.instance != prevInst):
                shaderChanged = True
        if (((((objShaders is not None) or ((curShaders is not None))) or ((self.baseShader.isRelative__ != isRelative))) or ((self.baseShader.hasUVPos__ != hasUVPos))) or ((self.baseShader.killAlpha__ != self.killAlpha))):
            shaderChanged = True
        if shaderChanged:
            _this = self.baseShader
            _this.constModified = True
            _this.hasUVPos__ = hasUVPos
            _this1 = self.baseShader
            _this1.constModified = True
            _this1.isRelative__ = isRelative
            _this2 = self.baseShader
            _this2.constModified = True
            _this2.killAlpha__ = self.killAlpha
            self.baseShader.updateConstants(self.manager.globals)
            self.baseShaderList.next = obj.shaders
            self.initShaders(self.baseShaderList)
        elif paramsChanged:
            if (self.currentShaders != self.baseShaderList):
                raise _HxException("!")
            self.currentShaders.next = obj.shaders
        self.texture = texture
        self.stride = stride
        self.currentObj = obj
        return True

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.globalAlpha = None
        _hx_o.buffer = None
        _hx_o.bufPos = None
        _hx_o.scene = None
        _hx_o.defaultSmooth = None
        _hx_o.killAlpha = None
        _hx_o.front2back = None
        _hx_o.onBeginDraw = None
        _hx_o.onEnterFilter = None
        _hx_o.onLeaveFilter = None
        _hx_o.tmpBounds = None
        _hx_o.texture = None
        _hx_o.baseShader = None
        _hx_o.manager = None
        _hx_o.compiledShader = None
        _hx_o.buffers = None
        _hx_o.fixedBuffer = None
        _hx_o._hx_pass = None
        _hx_o.currentShaders = None
        _hx_o.baseShaderList = None
        _hx_o.currentObj = None
        _hx_o.stride = None
        _hx_o.targetsStack = None
        _hx_o.targetsStackIndex = None
        _hx_o.hasUVPos = None
        _hx_o.filterStack = None
        _hx_o.inFilter = None
        _hx_o.inFilterBlend = None
        _hx_o.curX = None
        _hx_o.curY = None
        _hx_o.curWidth = None
        _hx_o.curHeight = None
        _hx_o.hasRenderZone = None
        _hx_o.renderX = None
        _hx_o.renderY = None
        _hx_o.renderW = None
        _hx_o.renderH = None
        _hx_o.currentBlend = None
        _hx_o.baseFlipY = None
        _hx_o.targetFlipY = None
h2d_RenderContext._hx_class = h2d_RenderContext
_hx_classes["h2d.RenderContext"] = h2d_RenderContext

class h2d_ScaleModeAlign(Enum):
    __slots__ = ()
    _hx_class_name = "h2d.ScaleModeAlign"
    _hx_constructs = ["Left", "Right", "Center", "Top", "Bottom"]
h2d_ScaleModeAlign.Left = h2d_ScaleModeAlign("Left", 0, ())
h2d_ScaleModeAlign.Right = h2d_ScaleModeAlign("Right", 1, ())
h2d_ScaleModeAlign.Center = h2d_ScaleModeAlign("Center", 2, ())
h2d_ScaleModeAlign.Top = h2d_ScaleModeAlign("Top", 3, ())
h2d_ScaleModeAlign.Bottom = h2d_ScaleModeAlign("Bottom", 4, ())
h2d_ScaleModeAlign._hx_class = h2d_ScaleModeAlign
_hx_classes["h2d.ScaleModeAlign"] = h2d_ScaleModeAlign

class h2d_ScaleMode(Enum):
    __slots__ = ()
    _hx_class_name = "h2d.ScaleMode"
    _hx_constructs = ["Resize", "Stretch", "LetterBox", "Fixed", "Zoom", "AutoZoom"]

    @staticmethod
    def Stretch(width,height):
        return h2d_ScaleMode("Stretch", 1, (width,height))

    @staticmethod
    def LetterBox(width,height,integerScale = None,horizontalAlign= None,verticalAlign= None):
        return h2d_ScaleMode("LetterBox", 2, (width,height,integerScale,horizontalAlign,verticalAlign))

    @staticmethod
    def Fixed(width,height,zoom,horizontalAlign = None,verticalAlign= None):
        return h2d_ScaleMode("Fixed", 3, (width,height,zoom,horizontalAlign,verticalAlign))

    @staticmethod
    def Zoom(level):
        return h2d_ScaleMode("Zoom", 4, (level,))

    @staticmethod
    def AutoZoom(minWidth,minHeight,integerScaling = None):
        return h2d_ScaleMode("AutoZoom", 5, (minWidth,minHeight,integerScaling))
h2d_ScaleMode.Resize = h2d_ScaleMode("Resize", 0, ())
h2d_ScaleMode._hx_class = h2d_ScaleMode
_hx_classes["h2d.ScaleMode"] = h2d_ScaleMode


class hxd_InteractiveScene:
    _hx_class_name = "hxd.InteractiveScene"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_methods = ["setEvents", "handleEvent", "dispatchEvent", "dispatchListeners", "isInteractiveVisible"]
hxd_InteractiveScene._hx_class = hxd_InteractiveScene
_hx_classes["hxd.InteractiveScene"] = hxd_InteractiveScene


class h2d_Scene(h2d_Layers):
    _hx_class_name = "h2d.Scene"
    _hx_is_interface = "False"
    __slots__ = ("width", "height", "viewportX", "viewportY", "offsetX", "offsetY", "ratioX", "ratioY", "mouseX", "mouseY", "scaleMode", "interactive", "eventListeners", "ctx", "window", "events", "shapePoint")
    _hx_fields = ["width", "height", "viewportX", "viewportY", "offsetX", "offsetY", "ratioX", "ratioY", "scaleMode", "interactive", "eventListeners", "ctx", "window", "events", "shapePoint"]
    _hx_methods = ["get_defaultSmooth", "set_defaultSmooth", "setEvents", "get_zoom", "set_zoom", "set_scaleMode", "get_renderer", "set_renderer", "setFixedSize", "checkResize", "screenXToViewport", "screenYToViewport", "get_mouseX", "get_mouseY", "dispatchListeners", "isInteractiveVisible", "getInteractive", "screenToViewport", "dispatchEvent", "handleEvent", "addEventListener", "removeEventListener", "startDrag", "stopDrag", "getFocus", "addEventTarget", "removeEventTarget", "dispose", "setElapsedTime", "drawImplTo", "syncOnly", "render", "sync", "onAdd", "onRemove", "captureBitmap"]
    _hx_statics = []
    _hx_interfaces = [hxd_InteractiveScene, h3d_IDrawable]
    _hx_super = h2d_Layers


    def __init__(self):
        self.shapePoint = None
        self.events = None
        self.window = None
        self.ctx = None
        self.eventListeners = None
        self.interactive = None
        self.mouseY = None
        self.mouseX = None
        self.ratioY = None
        self.ratioX = None
        self.offsetY = None
        self.offsetX = None
        self.viewportY = None
        self.viewportX = None
        self.height = None
        self.width = None
        self.scaleMode = h2d_ScaleMode.Resize
        super().__init__(None)
        e = h3d_Engine.CURRENT
        self.ctx = h2d_RenderContext(self)
        self.width = e.width
        self.height = e.height
        self.offsetX = 0
        self.offsetY = 0
        self.ratioX = 1
        self.ratioY = 1
        self.viewportX = 0
        self.viewportY = 0
        self.interactive = list()
        self.eventListeners = list()
        self.shapePoint = h2d_col_Point()
        self.window = hxd_Window.getInstance()
        self.posChanged = True

    def get_defaultSmooth(self):
        return self.ctx.defaultSmooth

    def set_defaultSmooth(self,v):
        def _hx_local_1():
            def _hx_local_0():
                self.ctx.defaultSmooth = v
                return self.ctx.defaultSmooth
            return _hx_local_0()
        return _hx_local_1()

    def setEvents(self,events):
        self.events = events

    def get_zoom(self):
        _g = self.scaleMode
        if (_g.index == 4):
            level = _g.params[0]
            tmp = None
            try:
                tmp = int(level)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                tmp = None
            return tmp
        else:
            return 0

    def set_zoom(self,v):
        self.set_scaleMode(h2d_ScaleMode.Zoom(v))
        return v

    def set_scaleMode(self,v):
        self.scaleMode = v
        self.checkResize()
        return v

    def get_renderer(self):
        return self.ctx

    def set_renderer(self,v):
        self.ctx = v
        return v

    def setFixedSize(self,w,h):
        self.set_scaleMode(h2d_ScaleMode.Stretch(w,h))

    def checkResize(self):
        _gthis = self
        engine = h3d_Engine.CURRENT
        _g = self.scaleMode
        tmp = _g.index
        if (tmp == 0):
            w = engine.width
            h = engine.height
            if ((w != _gthis.width) or ((h != _gthis.height))):
                _gthis.width = w
                _gthis.height = h
                _gthis.posChanged = True
            self.ratioX = 1
            self.ratioY = 1
            _gthis.offsetX = 0
            _gthis.offsetY = 0
            _gthis.viewportX = 0
            _gthis.viewportY = 0
        elif (tmp == 1):
            _height = _g.params[1]
            _width = _g.params[0]
            if ((_width != _gthis.width) or ((_height != _gthis.height))):
                _gthis.width = _width
                _gthis.height = _height
                _gthis.posChanged = True
            self.ratioX = 1
            self.ratioY = 1
            _gthis.offsetX = 0
            _gthis.offsetY = 0
            _gthis.viewportX = 0
            _gthis.viewportY = 0
        elif (tmp == 2):
            verticalAlign = _g.params[4]
            horizontalAlign = _g.params[3]
            integerScale = _g.params[2]
            _height1 = _g.params[1]
            _width1 = _g.params[0]
            if ((_width1 != _gthis.width) or ((_height1 != _gthis.height))):
                _gthis.width = _width1
                _gthis.height = _height1
                _gthis.posChanged = True
            a = (engine.width / _width1)
            b = (engine.height / _height1)
            zoom = (b if ((a > b)) else a)
            if integerScale:
                zoom1 = None
                try:
                    zoom1 = int(zoom)
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e = _hx_e1
                    zoom1 = None
                zoom = zoom1
                if (zoom == 0):
                    zoom = 1
            _gthis.ratioX = ((_gthis.width * zoom) / engine.width)
            _gthis.ratioY = ((_gthis.height * zoom) / engine.height)
            horizontal = horizontalAlign
            vertical = verticalAlign
            if (horizontal is None):
                horizontal = h2d_ScaleModeAlign.Center
            tmp1 = horizontal.index
            if (tmp1 == 0):
                _gthis.offsetX = (((engine.width - ((_gthis.width * zoom)))) / ((2 * zoom)))
                _gthis.viewportX = 0
            elif (tmp1 == 1):
                _gthis.offsetX = -((((engine.width - ((_gthis.width * zoom)))) / ((2 * zoom))))
                _gthis.viewportX = (((engine.width - ((_gthis.width * zoom)))) / zoom)
            else:
                _gthis.offsetX = (-(HxOverrides.modf((((engine.width - ((_gthis.width * zoom)))) / 2), 1.)) * .5)
                _gthis.viewportX = (((engine.width - ((_gthis.width * zoom)))) / ((2 * zoom)))
            if (vertical is None):
                vertical = h2d_ScaleModeAlign.Center
            tmp2 = vertical.index
            if (tmp2 == 3):
                _gthis.offsetY = (((engine.height - ((_gthis.height * zoom)))) / ((2 * zoom)))
                _gthis.viewportY = 0
            elif (tmp2 == 4):
                _gthis.offsetY = -((((engine.height - ((_gthis.height * zoom)))) / ((2 * zoom))))
                _gthis.viewportY = (((engine.height - ((_gthis.height * zoom)))) / zoom)
            else:
                _gthis.offsetY = (-(HxOverrides.modf((((engine.height - ((_gthis.height * zoom)))) / 2), 1.)) * .5)
                _gthis.viewportY = (((engine.height - ((_gthis.height * zoom)))) / ((2 * zoom)))
        elif (tmp == 3):
            verticalAlign1 = _g.params[4]
            horizontalAlign1 = _g.params[3]
            zoom2 = _g.params[2]
            _height2 = _g.params[1]
            _width2 = _g.params[0]
            if ((_width2 != _gthis.width) or ((_height2 != _gthis.height))):
                _gthis.width = _width2
                _gthis.height = _height2
                _gthis.posChanged = True
            _gthis.ratioX = ((_gthis.width * zoom2) / engine.width)
            _gthis.ratioY = ((_gthis.height * zoom2) / engine.height)
            horizontal1 = horizontalAlign1
            vertical1 = verticalAlign1
            if (horizontal1 is None):
                horizontal1 = h2d_ScaleModeAlign.Center
            tmp3 = horizontal1.index
            if (tmp3 == 0):
                _gthis.offsetX = (((engine.width - ((_gthis.width * zoom2)))) / ((2 * zoom2)))
                _gthis.viewportX = 0
            elif (tmp3 == 1):
                _gthis.offsetX = -((((engine.width - ((_gthis.width * zoom2)))) / ((2 * zoom2))))
                _gthis.viewportX = (((engine.width - ((_gthis.width * zoom2)))) / zoom2)
            else:
                _gthis.offsetX = (-(HxOverrides.modf((((engine.width - ((_gthis.width * zoom2)))) / 2), 1.)) * .5)
                _gthis.viewportX = (((engine.width - ((_gthis.width * zoom2)))) / ((2 * zoom2)))
            if (vertical1 is None):
                vertical1 = h2d_ScaleModeAlign.Center
            tmp4 = vertical1.index
            if (tmp4 == 3):
                _gthis.offsetY = (((engine.height - ((_gthis.height * zoom2)))) / ((2 * zoom2)))
                _gthis.viewportY = 0
            elif (tmp4 == 4):
                _gthis.offsetY = -((((engine.height - ((_gthis.height * zoom2)))) / ((2 * zoom2))))
                _gthis.viewportY = (((engine.height - ((_gthis.height * zoom2)))) / zoom2)
            else:
                _gthis.offsetY = (-(HxOverrides.modf((((engine.height - ((_gthis.height * zoom2)))) / 2), 1.)) * .5)
                _gthis.viewportY = (((engine.height - ((_gthis.height * zoom2)))) / ((2 * zoom2)))
        elif (tmp == 4):
            level = _g.params[0]
            w1 = Math.ceil((engine.width / level))
            h1 = Math.ceil((engine.height / level))
            if ((w1 != _gthis.width) or ((h1 != _gthis.height))):
                _gthis.width = w1
                _gthis.height = h1
                _gthis.posChanged = True
            _gthis.ratioX = ((_gthis.width * level) / engine.width)
            _gthis.ratioY = ((_gthis.height * level) / engine.height)
            _gthis.offsetX = 0
            _gthis.offsetY = 0
            _gthis.viewportX = 0
            _gthis.viewportY = 0
        elif (tmp == 5):
            integerScaling = _g.params[2]
            minHeight = _g.params[1]
            minWidth = _g.params[0]
            a1 = (engine.width / minWidth)
            b1 = (engine.height / minHeight)
            zoom3 = (b1 if ((a1 > b1)) else a1)
            if integerScaling:
                zoom4 = None
                try:
                    zoom4 = int(zoom3)
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e1 = _hx_e1
                    zoom4 = None
                zoom3 = zoom4
                if (zoom3 == 0):
                    zoom3 = 1
            w2 = Math.ceil((engine.width / zoom3))
            h2 = Math.ceil((engine.height / zoom3))
            if ((w2 != _gthis.width) or ((h2 != _gthis.height))):
                _gthis.width = w2
                _gthis.height = h2
                _gthis.posChanged = True
            _gthis.ratioX = ((_gthis.width * zoom3) / engine.width)
            _gthis.ratioY = ((_gthis.height * zoom3) / engine.height)
            _gthis.offsetX = 0
            _gthis.offsetY = 0
            _gthis.viewportX = 0
            _gthis.viewportY = 0
        else:
            pass

    def screenXToViewport(self,mx):
        return (((mx * self.width) / ((self.window.get_width() * self.ratioX))) - self.viewportX)

    def screenYToViewport(self,my):
        return (((my * self.height) / ((self.window.get_height() * self.ratioY))) - self.viewportY)

    def get_mouseX(self):
        self.syncPos()
        dx = ((((self.window.get_mouseX() * self.width) / ((self.window.get_width() * self.ratioX))) - self.viewportX) - self.absX)
        if (self.matC == 0):
            return (dx / self.matA)
        dy = ((((self.window.get_mouseY() * self.height) / ((self.window.get_height() * self.ratioY))) - self.viewportY) - self.absY)
        return ((((dx * self.matD) - ((dy * self.matC)))) / (((self.matA * self.matD) - ((self.matB * self.matC)))))

    def get_mouseY(self):
        self.syncPos()
        dy = ((((self.window.get_mouseY() * self.height) / ((self.window.get_height() * self.ratioY))) - self.viewportY) - self.absY)
        if (self.matB == 0):
            return (dy / self.matD)
        dx = ((((self.window.get_mouseX() * self.width) / ((self.window.get_width() * self.ratioX))) - self.viewportX) - self.absX)
        return ((((dy * self.matA) - ((dx * self.matB)))) / (((self.matA * self.matD) - ((self.matB * self.matC)))))

    def dispatchListeners(self,event):
        self.screenToViewport(event)
        _g = 0
        _g1 = self.eventListeners
        while (_g < len(_g1)):
            l = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            l(event)
            if (not event.propagate):
                break

    def isInteractiveVisible(self,i):
        s = i
        while (s != self):
            if ((s is None) or (not s.visible)):
                return False
            s = s.parent
        return True

    def getInteractive(self,x,y):
        pt = self.shapePoint
        _g = 0
        _g1 = self.interactive
        while (_g < len(_g1)):
            i = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if i.posChanged:
                i.syncPos()
            dx = (x - i.absX)
            dy = (y - i.absY)
            rx = ((((dx * i.matD) - ((dy * i.matC)))) * i.invDet)
            ry = ((((dy * i.matA) - ((dx * i.matB)))) * i.invDet)
            if (i.shape is not None):
                pt.x = (rx + i.shapeX)
                pt.y = (ry + i.shapeY)
                if (not i.shape.contains(pt)):
                    continue
            elif ((((ry < 0) or ((rx < 0))) or ((rx >= i.width))) or ((ry >= i.height))):
                continue
            visible = True
            p = i
            while (p is not None):
                if (not p.visible):
                    visible = False
                    break
                p = p.parent
            if (not visible):
                continue
            return i
        return None

    def screenToViewport(self,e):
        e.relX = (((e.relX * self.width) / ((self.window.get_width() * self.ratioX))) - self.viewportX)
        e.relY = (((e.relY * self.height) / ((self.window.get_height() * self.ratioY))) - self.viewportY)

    def dispatchEvent(self,event,to):
        i = to
        self.screenToViewport(event)
        dx = (event.relX - i.absX)
        dy = (event.relY - i.absY)
        rx = ((((dx * i.matD) - ((dy * i.matC)))) * i.invDet)
        ry = ((((dy * i.matA) - ((dx * i.matB)))) * i.invDet)
        event.relX = rx
        event.relY = ry
        i.handleEvent(event)

    def handleEvent(self,event,last):
        self.screenToViewport(event)
        ex = event.relX
        ey = event.relY
        index = (0 if ((last is None)) else (python_internal_ArrayImpl.indexOf(self.interactive,last,None) + 1))
        pt = self.shapePoint
        _g = index
        _g1 = len(self.interactive)
        while (_g < _g1):
            idx = _g
            _g = (_g + 1)
            i = (self.interactive[idx] if idx >= 0 and idx < len(self.interactive) else None)
            if (i is None):
                break
            if (i.invDet == 0):
                continue
            dx = (ex - i.absX)
            dy = (ey - i.absY)
            rx = ((((dx * i.matD) - ((dy * i.matC)))) * i.invDet)
            ry = ((((dy * i.matA) - ((dx * i.matB)))) * i.invDet)
            if (i.shape is not None):
                pt.x = (rx + i.shapeX)
                pt.y = (ry + i.shapeY)
                if (not i.shape.contains(pt)):
                    continue
            elif ((((ry < 0) or ((rx < 0))) or ((rx >= i.width))) or ((ry >= i.height))):
                continue
            visible = True
            p = i
            while (p is not None):
                if (not p.visible):
                    visible = False
                    break
                p = p.parent
            if (not visible):
                continue
            event.relX = rx
            event.relY = ry
            i.handleEvent(event)
            if event.cancel:
                event.cancel = False
                event.propagate = False
                continue
            return i
        return None

    def addEventListener(self,f):
        _this = self.eventListeners
        _this.append(f)

    def removeEventListener(self,f):
        _g = 0
        _g1 = self.eventListeners
        while (_g < len(_g1)):
            e = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if Reflect.compareMethods(e,f):
                python_internal_ArrayImpl.remove(self.eventListeners,e)
                return True
        return False

    def startDrag(self,onEvent,onCancel = None,refEvent = None):
        _gthis = self
        def _hx_local_0(e):
            _gthis.screenToViewport(e)
            onEvent(e)
        self.events.startDrag(_hx_local_0,onCancel,refEvent)

    def stopDrag(self):
        self.events.stopDrag()

    def getFocus(self):
        if (self.events is None):
            return None
        f = self.events.getFocus()
        if (f is None):
            return None
        i = Std.downcast(f,h2d_Interactive)
        if (i is None):
            return None
        return python_internal_ArrayImpl._get(self.interactive, python_internal_ArrayImpl.indexOf(self.interactive,i,None))

    def addEventTarget(self,i):
        i1 = i
        lv = 0
        while (i1 is not None):
            i1 = i1.parent
            lv = (lv + 1)
        level = lv
        _g = 0
        _g1 = len(self.interactive)
        while (_g < _g1):
            index = _g
            _g = (_g + 1)
            i11 = i
            i2 = (self.interactive[index] if index >= 0 and index < len(self.interactive) else None)
            lv1 = level
            i3 = i2
            lv2 = 0
            while (i3 is not None):
                i3 = i3.parent
                lv2 = (lv2 + 1)
            lv21 = lv2
            p1 = i11
            p2 = i2
            while (lv1 > lv21):
                i11 = p1
                p1 = p1.parent
                lv1 = (lv1 - 1)
            while (lv21 > lv1):
                i2 = p2
                p2 = p2.parent
                lv21 = (lv21 - 1)
            while (p1 != p2):
                i11 = p1
                p1 = p1.parent
                i2 = p2
                p2 = p2.parent
            id = -1
            _g2 = 0
            _g11 = len(p1.children)
            while (_g2 < _g11):
                k = _g2
                _g2 = (_g2 + 1)
                if ((p1.children[k] if k >= 0 and k < len(p1.children) else None) == i11):
                    id = k
                    break
            tmp = id
            id1 = -1
            _g3 = 0
            _g12 = len(p2.children)
            while (_g3 < _g12):
                k1 = _g3
                _g3 = (_g3 + 1)
                if ((p2.children[k1] if k1 >= 0 and k1 < len(p2.children) else None) == i2):
                    id1 = k1
                    break
            if (tmp > id1):
                self.interactive.insert(index, i)
                return
        _this = self.interactive
        _this.append(i)

    def removeEventTarget(self,i,notify = None):
        if (notify is None):
            notify = False
        python_internal_ArrayImpl.remove(self.interactive,i)
        if (notify and ((self.events is not None))):
            self.events.onRemove(i)

    def dispose(self):
        if self.allocated:
            self.onRemove()
        self.ctx.dispose()

    def setElapsedTime(self,v):
        self.ctx.elapsedTime = v

    def drawImplTo(self,s,texs,outputs = None):
        _g = 0
        while (_g < len(texs)):
            t = (texs[_g] if _g >= 0 and _g < len(texs) else None)
            _g = (_g + 1)
            if (((t.flags & ((1 << h3d_mat_TextureFlags.Target.index)))) == 0):
                raise _HxException("Can only draw to texture created with Target flag")
        self.ctx.engine = h3d_Engine.CURRENT
        oldBG = self.ctx.engine.backgroundColor
        self.ctx.engine.backgroundColor = None
        self.ctx.engine.begin()
        self.ctx.globalAlpha = self.alpha
        self.ctx.begin()
        self.ctx.pushTargets(texs)
        if (outputs is not None):
            self.ctx.manager.setOutput(outputs)
        if ((len(texs) == 1) and (((((texs[0] if 0 < len(texs) else None).flags & ((1 << h3d_mat_TextureFlags.WasCleared.index)))) == 0))):
            self.ctx.engine.clear(0)
        s.drawRec(self.ctx)
        if (outputs is not None):
            self.ctx.manager.setOutput()
        self.ctx.popTarget()
        self.ctx.engine.backgroundColor = oldBG

    def syncOnly(self,et):
        engine = h3d_Engine.CURRENT
        self.setElapsedTime(et)
        self.ctx.engine = engine
        _hx_local_0 = self.ctx
        _hx_local_1 = _hx_local_0.frame
        _hx_local_0.frame = (_hx_local_1 + 1)
        _hx_local_1
        _hx_local_2 = self.ctx
        _hx_local_3 = _hx_local_2.time
        _hx_local_2.time = (_hx_local_3 + self.ctx.elapsedTime)
        _hx_local_2.time
        self.ctx.globalAlpha = self.alpha
        self.sync(self.ctx)

    def render(self,engine):
        self.ctx.engine = engine
        _hx_local_0 = self.ctx
        _hx_local_1 = _hx_local_0.frame
        _hx_local_0.frame = (_hx_local_1 + 1)
        _hx_local_1
        _hx_local_2 = self.ctx
        _hx_local_3 = _hx_local_2.time
        _hx_local_2.time = (_hx_local_3 + self.ctx.elapsedTime)
        _hx_local_2.time
        self.ctx.globalAlpha = self.alpha
        self.sync(self.ctx)
        if (len(self.children) == 0):
            return
        self.ctx.begin()
        self.ctx.drawScene()
        self.ctx.end()

    def sync(self,ctx):
        if (not self.allocated):
            self.onAdd()
        super().sync(ctx)

    def onAdd(self):
        self.checkResize()
        super().onAdd()
        self.window.addResizeEvent(self.checkResize)

    def onRemove(self):
        super().onRemove()
        self.window.removeResizeEvent(self.checkResize)

    def captureBitmap(self,target = None):
        engine = h3d_Engine.CURRENT
        if (target is None):
            tex = h3d_mat_Texture(self.width,self.height,[h3d_mat_TextureFlags.Target])
            target = h2d_Tile(tex,0,0,self.width,self.height)
        engine.begin()
        x = target.x
        tmp = None
        try:
            tmp = int(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            tmp = None
        x1 = target.y
        tmp1 = None
        try:
            tmp1 = int(x1)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e1 = _hx_e1
            tmp1 = None
        engine.setRenderZone(tmp,tmp1,Math.ceil(target.width),Math.ceil(target.height))
        tex1 = target.innerTex
        engine.pushTarget(tex1)
        ow = self.width
        oh = self.height
        ox = self.offsetX
        oy = self.offsetY
        ovx = self.viewportX
        ovy = self.viewportY
        orx = self.ratioX
        ory = self.ratioY
        self.width = tex1.width
        self.height = tex1.height
        self.ratioX = 1
        self.ratioY = 1
        self.offsetX = 0
        self.offsetY = 0
        self.viewportX = 0
        self.viewportY = 0
        self.posChanged = True
        self.render(engine)
        engine.popTarget()
        self.width = ow
        self.height = oh
        self.ratioX = orx
        self.ratioY = ory
        self.offsetX = ox
        self.offsetY = oy
        self.viewportX = ovx
        self.viewportY = ovy
        self.posChanged = True
        engine.setRenderZone()
        engine.end()
        return h2d_Bitmap(target)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.width = None
        _hx_o.height = None
        _hx_o.viewportX = None
        _hx_o.viewportY = None
        _hx_o.offsetX = None
        _hx_o.offsetY = None
        _hx_o.ratioX = None
        _hx_o.ratioY = None
        _hx_o.scaleMode = None
        _hx_o.interactive = None
        _hx_o.eventListeners = None
        _hx_o.ctx = None
        _hx_o.window = None
        _hx_o.events = None
        _hx_o.shapePoint = None
h2d_Scene._hx_class = h2d_Scene
_hx_classes["h2d.Scene"] = h2d_Scene


class h2d_Tile:
    _hx_class_name = "h2d.Tile"
    _hx_is_interface = "False"
    __slots__ = ("innerTex", "u", "v", "u2", "v2", "dx", "dy", "x", "y", "width", "height")
    _hx_fields = ["innerTex", "u", "v", "u2", "v2", "dx", "dy", "x", "y", "width", "height"]
    _hx_methods = ["get_ix", "get_iy", "get_iwidth", "get_iheight", "getTexture", "isDisposed", "setTexture", "switchTexture", "sub", "center", "setCenterRatio", "flipX", "flipY", "setPosition", "setSize", "scaleToSize", "scrollDiscrete", "dispose", "clone", "split", "gridFlatten", "grid", "toString", "upload"]
    _hx_statics = ["fromColor", "fromBitmap", "autoCut", "fromTexture", "fromPixels", "isEmpty"]

    def __init__(self,tex,x,y,w,h,dx = None,dy = None):
        if (dx is None):
            dx = 0
        if (dy is None):
            dy = 0
        self.v2 = None
        self.u2 = None
        self.v = None
        self.u = None
        self.innerTex = tex
        self.x = x
        self.y = y
        self.width = w
        self.height = h
        self.dx = dx
        self.dy = dy
        if (tex is not None):
            self.setTexture(tex)

    def get_ix(self):
        return Math.floor(self.x)

    def get_iy(self):
        return Math.floor(self.y)

    def get_iwidth(self):
        return (Math.ceil((self.width + self.x)) - Math.floor(self.x))

    def get_iheight(self):
        return (Math.ceil((self.height + self.y)) - Math.floor(self.y))

    def getTexture(self):
        return self.innerTex

    def isDisposed(self):
        if (self.innerTex is not None):
            _this = self.innerTex
            if (_this.t is None):
                return (_this.realloc is None)
            else:
                return False
        else:
            return True

    def setTexture(self,tex):
        self.innerTex = tex
        if (tex is not None):
            self.u = (self.x / tex.width)
            self.v = (self.y / tex.height)
            self.u2 = (((self.x + self.width)) / tex.width)
            self.v2 = (((self.y + self.height)) / tex.height)

    def switchTexture(self,t):
        self.setTexture(t.innerTex)

    def sub(self,x,y,w,h,dx = None,dy = None):
        if (dx is None):
            dx = 0.
        if (dy is None):
            dy = 0.
        return h2d_Tile(self.innerTex,(self.x + x),(self.y + y),w,h,dx,dy)

    def center(self):
        return self.sub(0,0,self.width,self.height,-((self.width * .5)),-((self.height * .5)))

    def setCenterRatio(self,px = None,py = None):
        if (px is None):
            px = 0.5
        if (py is None):
            py = 0.5
        self.dx = -((px * self.width))
        self.dy = -((py * self.height))

    def flipX(self):
        tmp = self.u
        self.u = self.u2
        self.u2 = tmp
        self.dx = (-self.dx - self.width)

    def flipY(self):
        tmp = self.v
        self.v = self.v2
        self.v2 = tmp
        self.dy = (-self.dy - self.height)

    def setPosition(self,x,y):
        self.x = x
        self.y = y
        tex = self.innerTex
        if (tex is not None):
            self.u = (x / tex.width)
            self.v = (y / tex.height)
            self.u2 = (((x + self.width)) / tex.width)
            self.v2 = (((y + self.height)) / tex.height)

    def setSize(self,w,h):
        self.width = w
        self.height = h
        tex = self.innerTex
        if (tex is not None):
            self.u2 = (((self.x + w)) / tex.width)
            self.v2 = (((self.y + h)) / tex.height)

    def scaleToSize(self,w,h):
        self.width = w
        self.height = h

    def scrollDiscrete(self,dx,dy):
        tex = self.innerTex
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.u
        _hx_local_0.u = (_hx_local_1 + ((dx / tex.width)))
        _hx_local_0.u
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.v
        _hx_local_2.v = (_hx_local_3 - ((dy / tex.height)))
        _hx_local_2.v
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.u2
        _hx_local_4.u2 = (_hx_local_5 + ((dx / tex.width)))
        _hx_local_4.u2
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6.v2
        _hx_local_6.v2 = (_hx_local_7 - ((dy / tex.height)))
        _hx_local_6.v2
        self.x = (self.u * tex.width)
        self.y = (self.v * tex.height)

    def dispose(self):
        if (self.innerTex is not None):
            self.innerTex.dispose()
        self.innerTex = None

    def clone(self):
        t = h2d_Tile(None,self.x,self.y,self.width,self.height,self.dx,self.dy)
        t.innerTex = self.innerTex
        t.u = self.u
        t.u2 = self.u2
        t.v = self.v
        t.v2 = self.v2
        return t

    def split(self,frames = None,vertical = None,subpixel = None):
        if (frames is None):
            frames = 0
        if (vertical is None):
            vertical = False
        if (subpixel is None):
            subpixel = False
        tl = []
        if vertical:
            if (frames == 0):
                x = (self.height / self.width)
                try:
                    frames = int(x)
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e = _hx_e1
                    frames = None
            stride = None
            if subpixel:
                stride = (self.height / frames)
            else:
                x1 = (self.height / frames)
                try:
                    stride = int(x1)
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e1 = _hx_e1
                    stride = None
            _g = 0
            _g1 = frames
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                x2 = self.sub(0,(i * stride),self.width,stride)
                tl.append(x2)
        else:
            if (frames == 0):
                x3 = (self.width / self.height)
                try:
                    frames = int(x3)
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e2 = _hx_e1
                    frames = None
            stride1 = None
            if subpixel:
                stride1 = (self.width / frames)
            else:
                x4 = (self.width / frames)
                try:
                    stride1 = int(x4)
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e3 = _hx_e1
                    stride1 = None
            _g2 = 0
            _g11 = frames
            while (_g2 < _g11):
                i1 = _g2
                _g2 = (_g2 + 1)
                x5 = self.sub((i1 * stride1),0,stride1,self.height)
                tl.append(x5)
        return tl

    def gridFlatten(self,size,dx = None,dy = None):
        if (dx is None):
            dx = 0.
        if (dy is None):
            dy = 0.
        _g = []
        _g1 = 0
        x = (self.height / size)
        _g2 = None
        try:
            _g2 = int(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            _g2 = None
        while (_g1 < _g2):
            y = _g1
            _g1 = (_g1 + 1)
            _g11 = 0
            x1 = (self.width / size)
            _g21 = None
            try:
                _g21 = int(x1)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e1 = _hx_e1
                _g21 = None
            while (_g11 < _g21):
                x2 = _g11
                _g11 = (_g11 + 1)
                x3 = self.sub((x2 * size),(y * size),size,size,dx,dy)
                _g.append(x3)
        return _g

    def grid(self,size,dx = None,dy = None):
        if (dx is None):
            dx = 0.
        if (dy is None):
            dy = 0.
        _g = []
        _g1 = 0
        x = (self.width / size)
        _g2 = None
        try:
            _g2 = int(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            _g2 = None
        while (_g1 < _g2):
            x1 = _g1
            _g1 = (_g1 + 1)
            _g11 = []
            _g21 = 0
            x2 = (self.height / size)
            _g3 = None
            try:
                _g3 = int(x2)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e1 = _hx_e1
                _g3 = None
            while (_g21 < _g3):
                y = _g21
                _g21 = (_g21 + 1)
                x3 = self.sub((x1 * size),(y * size),size,size,dx,dy)
                _g11.append(x3)
            _g.append(_g11)
        return _g

    def toString(self):
        return ((((((((("Tile(" + Std.string(self.x)) + ",") + Std.string(self.y)) + ",") + Std.string(self.width)) + "x") + Std.string(self.height)) + HxOverrides.stringOrNull(((((("," + Std.string(self.dx)) + ":") + Std.string(self.dy)) if (((self.dx != 0) or ((self.dy != 0)))) else "")))) + ")")

    def upload(self,bmp):
        w = self.innerTex.width
        h = self.innerTex.height
        self.innerTex.uploadBitmap(bmp)

    @staticmethod
    def fromColor(color,width = None,height = None,alpha = None):
        if (width is None):
            width = 1
        if (height is None):
            height = 1
        if (alpha is None):
            alpha = 1.
        t = h2d_Tile(h3d_mat_Texture.fromColor(color,alpha),0,0,1,1)
        t.width = width
        t.height = height
        return t

    @staticmethod
    def fromBitmap(bmp):
        tex = h3d_mat_Texture.fromBitmap(bmp)
        return h2d_Tile(tex,0,0,bmp.data.width,bmp.data.height)

    @staticmethod
    def autoCut(bmp,width,height = None):
        if (height is None):
            height = width
        colorBG = bmp.getPixel((bmp.data.width - 1),(bmp.data.height - 1))
        tl = list()
        w = 1
        h = 1
        while (w < bmp.data.width):
            w = (w << 1)
        while (h < bmp.data.height):
            h = (h << 1)
        tex = h3d_mat_Texture(w,h)
        _g = 0
        x = (bmp.data.height / height)
        _g1 = None
        try:
            _g1 = int(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            _g1 = None
        while (_g < _g1):
            y = _g
            _g = (_g + 1)
            a = []
            python_internal_ArrayImpl._set(tl, y, a)
            _g2 = 0
            x1 = (bmp.data.width / width)
            _g11 = None
            try:
                _g11 = int(x1)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e1 = _hx_e1
                _g11 = None
            while (_g2 < _g11):
                x2 = _g2
                _g2 = (_g2 + 1)
                sz = h2d_Tile.isEmpty(bmp,(x2 * width),(y * height),width,height,colorBG)
                if (sz is None):
                    break
                x3 = h2d_Tile(tex,((x2 * width) + sz.dx),((y * height) + sz.dy),sz.w,sz.h,sz.dx,sz.dy)
                a.append(x3)
        main = h2d_Tile(tex,0,0,bmp.data.width,bmp.data.height)
        main.upload(bmp)
        return _hx_AnonObject({'main': main, 'tiles': tl})

    @staticmethod
    def fromTexture(t):
        return h2d_Tile(t,0,0,t.width,t.height)

    @staticmethod
    def fromPixels(pixels):
        pix2 = pixels.makeSquare(True)
        t = h3d_mat_Texture.fromPixels(pix2)
        if (pix2 != pixels):
            pix2.dispose()
        return h2d_Tile(t,0,0,pixels.width,pixels.height)

    @staticmethod
    def isEmpty(b,px,py,width,height,bg):
        empty = True
        xmin = width
        ymin = height
        xmax = 0
        ymax = 0
        _g = 0
        _g1 = width
        while (_g < _g1):
            x = _g
            _g = (_g + 1)
            _g2 = 0
            _g11 = height
            while (_g2 < _g11):
                y = _g2
                _g2 = (_g2 + 1)
                color = b.getPixel((x + px),(y + py))
                if (((color & -16777216)) == 0):
                    if (color != 0):
                        b.setPixel((x + px),(y + py),0)
                    continue
                if (color != bg):
                    empty = False
                    if (x < xmin):
                        xmin = x
                    if (y < ymin):
                        ymin = y
                    if (x > xmax):
                        xmax = x
                    if (y > ymax):
                        ymax = y
                if ((color == bg) and ((color != 0))):
                    b.setPixel((x + px),(y + py),0)
        if empty:
            return None
        else:
            return _hx_AnonObject({'dx': xmin, 'dy': ymin, 'w': ((xmax - xmin) + 1), 'h': ((ymax - ymin) + 1)})

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.innerTex = None
        _hx_o.u = None
        _hx_o.v = None
        _hx_o.u2 = None
        _hx_o.v2 = None
        _hx_o.dx = None
        _hx_o.dy = None
        _hx_o.x = None
        _hx_o.y = None
        _hx_o.width = None
        _hx_o.height = None
h2d_Tile._hx_class = h2d_Tile
_hx_classes["h2d.Tile"] = h2d_Tile


class h2d_col_Bounds:
    _hx_class_name = "h2d.col.Bounds"
    _hx_is_interface = "False"
    __slots__ = ("xMin", "yMin", "xMax", "yMax")
    _hx_fields = ["xMin", "yMin", "xMax", "yMax"]
    _hx_methods = ["toIBounds", "intersects", "contains", "addBounds", "addPoint", "addPos", "set", "setMin", "setMax", "doIntersect", "doUnion", "intersection", "union", "load", "scalePivot", "scaleCenter", "rotate", "offset", "getMin", "getCenter", "getSize", "getMax", "isEmpty", "empty", "all", "clone", "get_x", "get_y", "set_x", "set_y", "get_width", "get_height", "set_width", "set_height", "toString"]
    _hx_statics = ["fromValues", "fromPoints"]

    def __init__(self):
        self.xMin = 1e20
        self.yMin = 1e20
        self.xMax = -1e20
        self.yMax = -1e20

    def toIBounds(self,scale = None):
        if (scale is None):
            scale = 1.
        ix = Math.floor((self.xMin * scale))
        iy = Math.floor((self.yMin * scale))
        width = (Math.ceil((self.xMax * scale)) - ix)
        height = (Math.ceil((self.yMax * scale)) - iy)
        b = h2d_col_IBounds()
        b.xMin = ix
        b.yMin = iy
        b.xMax = (ix + width)
        b.yMax = (iy + height)
        return b

    def intersects(self,b):
        return (not (((((self.xMin > b.xMax) or ((self.yMin > b.yMax))) or ((self.xMax < b.xMin))) or ((self.yMax < b.yMin)))))

    def contains(self,p):
        if (((p.x >= self.xMin) and ((p.x < self.xMax))) and ((p.y >= self.yMin))):
            return (p.y < self.yMax)
        else:
            return False

    def addBounds(self,b):
        if (b.xMin < self.xMin):
            self.xMin = b.xMin
        if (b.xMax > self.xMax):
            self.xMax = b.xMax
        if (b.yMin < self.yMin):
            self.yMin = b.yMin
        if (b.yMax > self.yMax):
            self.yMax = b.yMax

    def addPoint(self,p):
        if (p.x < self.xMin):
            self.xMin = p.x
        if (p.x > self.xMax):
            self.xMax = p.x
        if (p.y < self.yMin):
            self.yMin = p.y
        if (p.y > self.yMax):
            self.yMax = p.y

    def addPos(self,x,y):
        if (x < self.xMin):
            self.xMin = x
        if (x > self.xMax):
            self.xMax = x
        if (y < self.yMin):
            self.yMin = y
        if (y > self.yMax):
            self.yMax = y

    def set(self,x,y,width,height):
        self.xMin = x
        self.yMin = y
        self.xMax = (x + width)
        self.yMax = (y + height)

    def setMin(self,p):
        self.xMin = p.x
        self.yMin = p.y

    def setMax(self,p):
        self.xMax = p.x
        self.yMax = p.y

    def doIntersect(self,b):
        a = self.xMin
        b1 = b.xMin
        self.xMin = (b1 if ((a < b1)) else a)
        a1 = self.yMin
        b2 = b.yMin
        self.yMin = (b2 if ((a1 < b2)) else a1)
        a2 = self.xMax
        b3 = b.xMax
        self.xMax = (b3 if ((a2 > b3)) else a2)
        a3 = self.yMax
        b4 = b.yMax
        self.yMax = (b4 if ((a3 > b4)) else a3)

    def doUnion(self,b):
        a = self.xMin
        b1 = b.xMin
        self.xMin = (b1 if ((a > b1)) else a)
        a1 = self.yMin
        b2 = b.yMin
        self.yMin = (b2 if ((a1 > b2)) else a1)
        a2 = self.xMax
        b3 = b.xMax
        self.xMax = (b3 if ((a2 < b3)) else a2)
        a3 = self.yMax
        b4 = b.yMax
        self.yMax = (b4 if ((a3 < b4)) else a3)

    def intersection(self,b):
        i = h2d_col_Bounds()
        a = self.xMin
        b1 = b.xMin
        i.xMin = (b1 if ((a < b1)) else a)
        a1 = self.yMin
        b2 = b.yMin
        i.yMin = (b2 if ((a1 < b2)) else a1)
        a2 = self.xMax
        b3 = b.xMax
        i.xMax = (b3 if ((a2 > b3)) else a2)
        a3 = self.yMax
        b4 = b.yMax
        i.yMax = (b4 if ((a3 > b4)) else a3)
        if (i.xMax < i.xMin):
            i.xMax = i.xMin
        if (i.yMax < i.yMin):
            i.yMax = i.yMin
        return i

    def union(self,b):
        i = h2d_col_Bounds()
        a = self.xMin
        b1 = b.xMin
        i.xMin = (b1 if ((a > b1)) else a)
        a1 = self.yMin
        b2 = b.yMin
        i.yMin = (b2 if ((a1 > b2)) else a1)
        a2 = self.xMax
        b3 = b.xMax
        i.xMax = (b3 if ((a2 < b3)) else a2)
        a3 = self.yMax
        b4 = b.yMax
        i.yMax = (b4 if ((a3 < b4)) else a3)
        return i

    def load(self,b):
        self.xMin = b.xMin
        self.yMin = b.yMin
        self.xMax = b.xMax
        self.yMax = b.yMax

    def scalePivot(self,v):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.xMin
        _hx_local_0.xMin = (_hx_local_1 * v)
        _hx_local_0.xMin
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.yMin
        _hx_local_2.yMin = (_hx_local_3 * v)
        _hx_local_2.yMin
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.xMax
        _hx_local_4.xMax = (_hx_local_5 * v)
        _hx_local_4.xMax
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6.yMax
        _hx_local_6.yMax = (_hx_local_7 * v)
        _hx_local_6.yMax

    def scaleCenter(self,v):
        dx = ((((self.xMax - self.xMin)) * 0.5) * v)
        dy = ((((self.yMax - self.yMin)) * 0.5) * v)
        mx = (((self.xMax + self.xMin)) * 0.5)
        my = (((self.yMax + self.yMin)) * 0.5)
        self.xMin = (mx - dx)
        self.yMin = (my - dy)
        self.xMax = (mx + dx)
        self.yMax = (my + dy)

    def rotate(self,angle):
        cos = (Math.NaN if (((angle == Math.POSITIVE_INFINITY) or ((angle == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(angle))
        sin = (Math.NaN if (((angle == Math.POSITIVE_INFINITY) or ((angle == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(angle))
        x0 = self.xMin
        y0 = self.yMin
        x1 = self.xMax
        y1 = self.yMax
        self.xMin = 1e20
        self.yMin = 1e20
        self.xMax = -1e20
        self.yMax = -1e20
        x = ((x0 * cos) - ((y0 * sin)))
        y = ((x0 * sin) + ((y0 * cos)))
        if (x < self.xMin):
            self.xMin = x
        if (x > self.xMax):
            self.xMax = x
        if (y < self.yMin):
            self.yMin = y
        if (y > self.yMax):
            self.yMax = y
        x2 = ((x1 * cos) - ((y0 * sin)))
        y2 = ((x1 * sin) + ((y0 * cos)))
        if (x2 < self.xMin):
            self.xMin = x2
        if (x2 > self.xMax):
            self.xMax = x2
        if (y2 < self.yMin):
            self.yMin = y2
        if (y2 > self.yMax):
            self.yMax = y2
        x3 = ((x0 * cos) - ((y1 * sin)))
        y3 = ((x0 * sin) + ((y1 * cos)))
        if (x3 < self.xMin):
            self.xMin = x3
        if (x3 > self.xMax):
            self.xMax = x3
        if (y3 < self.yMin):
            self.yMin = y3
        if (y3 > self.yMax):
            self.yMax = y3
        x4 = ((x1 * cos) - ((y1 * sin)))
        y4 = ((x1 * sin) + ((y1 * cos)))
        if (x4 < self.xMin):
            self.xMin = x4
        if (x4 > self.xMax):
            self.xMax = x4
        if (y4 < self.yMin):
            self.yMin = y4
        if (y4 > self.yMax):
            self.yMax = y4

    def offset(self,dx,dy):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.xMin
        _hx_local_0.xMin = (_hx_local_1 + dx)
        _hx_local_0.xMin
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.xMax
        _hx_local_2.xMax = (_hx_local_3 + dx)
        _hx_local_2.xMax
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.yMin
        _hx_local_4.yMin = (_hx_local_5 + dy)
        _hx_local_4.yMin
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6.yMax
        _hx_local_6.yMax = (_hx_local_7 + dy)
        _hx_local_6.yMax

    def getMin(self):
        return h2d_col_Point(self.xMin,self.yMin)

    def getCenter(self):
        return h2d_col_Point((((self.xMin + self.xMax)) * 0.5),(((self.yMin + self.yMax)) * 0.5))

    def getSize(self):
        return h2d_col_Point((self.xMax - self.xMin),(self.yMax - self.yMin))

    def getMax(self):
        return h2d_col_Point(self.xMax,self.yMax)

    def isEmpty(self):
        if (not ((self.xMax <= self.xMin))):
            return (self.yMax <= self.yMin)
        else:
            return True

    def empty(self):
        self.xMin = 1e20
        self.yMin = 1e20
        self.xMax = -1e20
        self.yMax = -1e20

    def all(self):
        self.xMin = -1e20
        self.yMin = -1e20
        self.xMax = 1e20
        self.yMax = 1e20

    def clone(self):
        b = h2d_col_Bounds()
        b.xMin = self.xMin
        b.yMin = self.yMin
        b.xMax = self.xMax
        b.yMax = self.yMax
        return b

    def get_x(self):
        return self.xMin

    def get_y(self):
        return self.yMin

    def set_x(self,x):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.xMax
        _hx_local_0.xMax = (_hx_local_1 + ((x - self.xMin)))
        _hx_local_0.xMax
        def _hx_local_3():
            def _hx_local_2():
                self.xMin = x
                return self.xMin
            return _hx_local_2()
        return _hx_local_3()

    def set_y(self,y):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.yMax
        _hx_local_0.yMax = (_hx_local_1 + ((y - self.yMin)))
        _hx_local_0.yMax
        def _hx_local_3():
            def _hx_local_2():
                self.yMin = y
                return self.yMin
            return _hx_local_2()
        return _hx_local_3()

    def get_width(self):
        return (self.xMax - self.xMin)

    def get_height(self):
        return (self.yMax - self.yMin)

    def set_width(self,w):
        self.xMax = (self.xMin + w)
        return w

    def set_height(self,h):
        self.yMax = (self.yMin + h)
        return h

    def toString(self):
        return (((("{" + Std.string(h2d_col_Point(self.xMin,self.yMin))) + ",") + Std.string(h2d_col_Point((self.xMax - self.xMin),(self.yMax - self.yMin)))) + "}")

    @staticmethod
    def fromValues(x0,y0,width,height):
        b = h2d_col_Bounds()
        b.xMin = x0
        b.yMin = y0
        b.xMax = (x0 + width)
        b.yMax = (y0 + height)
        return b

    @staticmethod
    def fromPoints(_hx_min,_hx_max):
        b = h2d_col_Bounds()
        b.xMin = _hx_min.x
        b.yMin = _hx_min.y
        b.xMax = _hx_max.x
        b.yMax = _hx_max.y
        return b

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.xMin = None
        _hx_o.yMin = None
        _hx_o.xMax = None
        _hx_o.yMax = None
h2d_col_Bounds._hx_class = h2d_col_Bounds
_hx_classes["h2d.col.Bounds"] = h2d_col_Bounds


class h2d_col_Collider:
    _hx_class_name = "h2d.col.Collider"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_methods = ["contains"]
h2d_col_Collider._hx_class = h2d_col_Collider
_hx_classes["h2d.col.Collider"] = h2d_col_Collider


class h2d_col_IBounds:
    _hx_class_name = "h2d.col.IBounds"
    _hx_is_interface = "False"
    __slots__ = ("xMin", "yMin", "xMax", "yMax")
    _hx_fields = ["xMin", "yMin", "xMax", "yMax"]
    _hx_methods = ["toBounds", "intersects", "contains", "addBounds", "addPoint", "addPos", "set", "setMin", "setMax", "doIntersect", "doUnion", "intersection", "union", "load", "offset", "getMin", "getCenter", "getSize", "getMax", "isEmpty", "empty", "all", "clone", "get_x", "get_y", "set_x", "set_y", "get_width", "get_height", "set_width", "set_height", "toString"]
    _hx_statics = ["fromValues", "fromPoints"]

    def __init__(self):
        self.xMin = 2147483647
        self.yMin = 2147483647
        self.xMax = -2147483648
        self.yMax = -2147483648

    def toBounds(self,scale = None):
        if (scale is None):
            scale = 1.
        x0 = (self.xMin * scale)
        y0 = (self.yMin * scale)
        width = (((self.xMax - self.xMin)) * scale)
        height = (((self.yMax - self.yMin)) * scale)
        b = h2d_col_Bounds()
        b.xMin = x0
        b.yMin = y0
        b.xMax = (x0 + width)
        b.yMax = (y0 + height)
        return b

    def intersects(self,b):
        return (not (((((self.xMin > b.xMax) or ((self.yMin > b.yMax))) or ((self.xMax < b.xMin))) or ((self.yMax < b.yMin)))))

    def contains(self,p):
        if (((p.x >= self.xMin) and ((p.x < self.xMax))) and ((p.y >= self.yMin))):
            return (p.y < self.yMax)
        else:
            return False

    def addBounds(self,b):
        if (b.xMin < self.xMin):
            self.xMin = b.xMin
        if (b.xMax > self.xMax):
            self.xMax = b.xMax
        if (b.yMin < self.yMin):
            self.yMin = b.yMin
        if (b.yMax > self.yMax):
            self.yMax = b.yMax

    def addPoint(self,p):
        if (p.x < self.xMin):
            self.xMin = p.x
        if (p.x > self.xMax):
            self.xMax = p.x
        if (p.y < self.yMin):
            self.yMin = p.y
        if (p.y > self.yMax):
            self.yMax = p.y

    def addPos(self,x,y):
        if (x < self.xMin):
            self.xMin = x
        if (x > self.xMax):
            self.xMax = x
        if (y < self.yMin):
            self.yMin = y
        if (y > self.yMax):
            self.yMax = y

    def set(self,x,y,width,height):
        self.xMin = x
        self.yMin = y
        self.xMax = (x + width)
        self.yMax = (y + height)

    def setMin(self,p):
        self.xMin = p.x
        self.yMin = p.y

    def setMax(self,p):
        self.xMax = p.x
        self.yMax = p.y

    def doIntersect(self,b):
        a = self.xMin
        b1 = b.xMin
        self.xMin = (b1 if ((a < b1)) else a)
        a1 = self.yMin
        b2 = b.yMin
        self.yMin = (b2 if ((a1 < b2)) else a1)
        a2 = self.xMax
        b3 = b.xMax
        self.xMax = (b3 if ((a2 > b3)) else a2)
        a3 = self.yMax
        b4 = b.yMax
        self.yMax = (b4 if ((a3 > b4)) else a3)

    def doUnion(self,b):
        a = self.xMin
        b1 = b.xMin
        self.xMin = (b1 if ((a > b1)) else a)
        a1 = self.yMin
        b2 = b.yMin
        self.yMin = (b2 if ((a1 > b2)) else a1)
        a2 = self.xMax
        b3 = b.xMax
        self.xMax = (b3 if ((a2 < b3)) else a2)
        a3 = self.yMax
        b4 = b.yMax
        self.yMax = (b4 if ((a3 < b4)) else a3)

    def intersection(self,b):
        i = h2d_col_Bounds()
        a = self.xMin
        b1 = b.xMin
        i.xMin = (b1 if ((a < b1)) else a)
        a1 = self.yMin
        b2 = b.yMin
        i.yMin = (b2 if ((a1 < b2)) else a1)
        a2 = self.xMax
        b3 = b.xMax
        i.xMax = (b3 if ((a2 > b3)) else a2)
        a3 = self.yMax
        b4 = b.yMax
        i.yMax = (b4 if ((a3 > b4)) else a3)
        if (i.xMax < i.xMin):
            i.xMax = i.xMin
        if (i.yMax < i.yMin):
            i.yMax = i.yMin
        return i

    def union(self,b):
        i = h2d_col_Bounds()
        a = self.xMin
        b1 = b.xMin
        i.xMin = (b1 if ((a > b1)) else a)
        a1 = self.yMin
        b2 = b.yMin
        i.yMin = (b2 if ((a1 > b2)) else a1)
        a2 = self.xMax
        b3 = b.xMax
        i.xMax = (b3 if ((a2 < b3)) else a2)
        a3 = self.yMax
        b4 = b.yMax
        i.yMax = (b4 if ((a3 < b4)) else a3)
        return i

    def load(self,b):
        self.xMin = b.xMin
        self.yMin = b.yMin
        self.xMax = b.xMax
        self.yMax = b.yMax

    def offset(self,dx,dy):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.xMin
        _hx_local_0.xMin = (_hx_local_1 + dx)
        _hx_local_0.xMin
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.xMax
        _hx_local_2.xMax = (_hx_local_3 + dx)
        _hx_local_2.xMax
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.yMin
        _hx_local_4.yMin = (_hx_local_5 + dy)
        _hx_local_4.yMin
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6.yMax
        _hx_local_6.yMax = (_hx_local_7 + dy)
        _hx_local_6.yMax

    def getMin(self):
        return h2d_col_IPoint(self.xMin,self.yMin)

    def getCenter(self):
        return h2d_col_IPoint(((self.xMin + self.xMax) >> 1),((self.yMin + self.yMax) >> 1))

    def getSize(self):
        return h2d_col_IPoint((self.xMax - self.xMin),(self.yMax - self.yMin))

    def getMax(self):
        return h2d_col_IPoint(self.xMax,self.yMax)

    def isEmpty(self):
        if (self.xMax > self.xMin):
            return (self.yMax <= self.yMin)
        else:
            return True

    def empty(self):
        self.xMin = 2147483647
        self.yMin = 2147483647
        self.xMax = -2147483648
        self.yMax = -2147483648

    def all(self):
        self.xMin = -2147483648
        self.yMin = -2147483648
        self.xMax = 2147483647
        self.yMax = 2147483647

    def clone(self):
        b = h2d_col_IBounds()
        b.xMin = self.xMin
        b.yMin = self.yMin
        b.xMax = self.xMax
        b.yMax = self.yMax
        return b

    def get_x(self):
        return self.xMin

    def get_y(self):
        return self.yMin

    def set_x(self,x):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.xMax
        _hx_local_0.xMax = (_hx_local_1 + ((x - self.xMin)))
        _hx_local_0.xMax
        def _hx_local_3():
            def _hx_local_2():
                self.xMin = x
                return self.xMin
            return _hx_local_2()
        return _hx_local_3()

    def set_y(self,y):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.yMax
        _hx_local_0.yMax = (_hx_local_1 + ((y - self.yMin)))
        _hx_local_0.yMax
        def _hx_local_3():
            def _hx_local_2():
                self.yMin = y
                return self.yMin
            return _hx_local_2()
        return _hx_local_3()

    def get_width(self):
        return (self.xMax - self.xMin)

    def get_height(self):
        return (self.yMax - self.yMin)

    def set_width(self,w):
        self.xMax = (self.xMin + w)
        return w

    def set_height(self,h):
        self.yMax = (self.yMin + h)
        return h

    def toString(self):
        return (((("{" + Std.string(h2d_col_IPoint(self.xMin,self.yMin))) + ",") + Std.string(h2d_col_IPoint((self.xMax - self.xMin),(self.yMax - self.yMin)))) + "}")

    @staticmethod
    def fromValues(x0,y0,width,height):
        b = h2d_col_IBounds()
        b.xMin = x0
        b.yMin = y0
        b.xMax = (x0 + width)
        b.yMax = (y0 + height)
        return b

    @staticmethod
    def fromPoints(_hx_min,_hx_max):
        b = h2d_col_IBounds()
        b.xMin = _hx_min.x
        b.yMin = _hx_min.y
        b.xMax = _hx_max.x
        b.yMax = _hx_max.y
        return b

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.xMin = None
        _hx_o.yMin = None
        _hx_o.xMax = None
        _hx_o.yMax = None
h2d_col_IBounds._hx_class = h2d_col_IBounds
_hx_classes["h2d.col.IBounds"] = h2d_col_IBounds


class h2d_col_IPoint:
    _hx_class_name = "h2d.col.IPoint"
    _hx_is_interface = "False"
    __slots__ = ("x", "y")
    _hx_fields = ["x", "y"]
    _hx_methods = ["toPoint", "distanceSq", "distance", "toString", "sub", "add", "equals", "dot", "lengthSq", "length", "set", "clone"]

    def __init__(self,x = None,y = None):
        if (x is None):
            x = 0
        if (y is None):
            y = 0
        self.x = x
        self.y = y

    def toPoint(self,scale = None):
        if (scale is None):
            scale = 1.
        return h2d_col_Point((self.x * scale),(self.y * scale))

    def distanceSq(self,p):
        dx = (self.x - p.x)
        dy = (self.y - p.y)
        return ((dx * dx) + ((dy * dy)))

    def distance(self,p):
        dx = (self.x - p.x)
        dy = (self.y - p.y)
        f = ((dx * dx) + ((dy * dy)))
        if (f < 0):
            return Math.NaN
        else:
            return python_lib_Math.sqrt(f)

    def toString(self):
        return (((("{" + Std.string(self.x)) + ",") + Std.string(self.y)) + "}")

    def sub(self,p):
        return h2d_col_Point((self.x - p.x),(self.y - p.y))

    def add(self,p):
        return h2d_col_Point((self.x + p.x),(self.y + p.y))

    def equals(self,other):
        if (self.x == other.x):
            return (self.y == other.y)
        else:
            return False

    def dot(self,p):
        return ((self.x * p.x) + ((self.y * p.y)))

    def lengthSq(self):
        return ((self.x * self.x) + ((self.y * self.y)))

    def length(self):
        f = ((self.x * self.x) + ((self.y * self.y)))
        if (f < 0):
            return Math.NaN
        else:
            return python_lib_Math.sqrt(f)

    def set(self,x,y):
        self.x = x
        self.y = y

    def clone(self):
        return h2d_col_IPoint(self.x,self.y)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.x = None
        _hx_o.y = None
h2d_col_IPoint._hx_class = h2d_col_IPoint
_hx_classes["h2d.col.IPoint"] = h2d_col_IPoint


class h2d_col_Matrix:
    _hx_class_name = "h2d.col.Matrix"
    _hx_is_interface = "False"
    __slots__ = ("a", "b", "c", "d", "x", "y")
    _hx_fields = ["a", "b", "c", "d", "x", "y"]
    _hx_methods = ["identity", "initTranslate", "initScale", "initRotate", "invert", "getDeterminant", "inverse", "transform", "translate", "prependTranslate", "multiply", "getScale", "scale", "rotate", "clone", "getPosition", "toString"]
    _hx_statics = ["tmp"]

    def __init__(self):
        self.a = 1
        self.b = 0
        self.c = 0
        self.d = 1
        self.x = 0
        self.y = 0

    def identity(self):
        self.a = 1
        self.b = 0
        self.c = 0
        self.d = 1
        self.x = 0
        self.y = 0

    def initTranslate(self,x,y):
        self.a = 1
        self.b = 0
        self.c = 0
        self.d = 1
        self.x = x
        self.y = y

    def initScale(self,sx,sy):
        self.a = sx
        self.b = 0
        self.c = 0
        self.d = sy
        self.x = 0
        self.y = 0

    def initRotate(self,angle):
        cos = (Math.NaN if (((angle == Math.POSITIVE_INFINITY) or ((angle == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(angle))
        sin = (Math.NaN if (((angle == Math.POSITIVE_INFINITY) or ((angle == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(angle))
        self.a = cos
        self.b = sin
        self.c = -sin
        self.d = cos
        self.x = 0
        self.y = 0

    def invert(self):
        self.inverse(self)

    def getDeterminant(self):
        return ((self.a * self.d) - ((self.b * self.c)))

    def inverse(self,m):
        a = m.a
        b = m.b
        c = m.c
        d = m.d
        x = m.x
        y = m.y
        invDet = (1 / (((self.a * self.d) - ((self.b * self.c)))))
        self.a = (d * invDet)
        self.b = (-b * invDet)
        self.c = (-c * invDet)
        self.d = (a * invDet)
        self.x = ((((-x * d) + ((c * y)))) * invDet)
        self.y = ((((x * b) - ((a * y)))) * invDet)

    def transform(self,pt):
        return h2d_col_Point((((pt.x * self.a) + ((pt.y * self.c))) + self.x),(((pt.x * self.b) + ((pt.y * self.d))) + self.y))

    def translate(self,x,y):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.x
        _hx_local_0.x = (_hx_local_1 + x)
        _hx_local_0.x
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.y
        _hx_local_2.y = (_hx_local_3 + y)
        _hx_local_2.y

    def prependTranslate(self,x,y):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.x
        _hx_local_0.x = (_hx_local_1 + (((self.a * x) + ((self.c * y)))))
        _hx_local_0.x
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.y
        _hx_local_2.y = (_hx_local_3 + (((self.b * x) + ((self.d * y)))))
        _hx_local_2.y

    def multiply(self,a,b):
        aa = a.a
        ab = a.b
        ac = a.c
        ad = a.d
        ax = a.x
        ay = a.y
        ba = b.a
        bb = b.b
        bc = b.c
        bd = b.d
        bx = b.x
        by = b.y
        self.a = ((aa * ba) + ((ab * bc)))
        self.b = ((aa * bb) + ((ab * bd)))
        self.c = ((ac * ba) + ((ad * bc)))
        self.d = ((ac * bb) + ((ad * bd)))
        self.x = (((ax * ba) + ((ay * bc))) + bx)
        self.y = (((ax * bb) + ((ay * bd))) + by)

    def getScale(self,p = None):
        if (p is None):
            p = h2d_col_Point()
        f = ((self.a * self.a) + ((self.b * self.b)))
        p.x = (Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))
        f1 = ((self.c * self.c) + ((self.d * self.d)))
        p.y = (Math.NaN if ((f1 < 0)) else python_lib_Math.sqrt(f1))
        if (((self.a * self.d) - ((self.b * self.c))) < 0):
            p.x = (p.x * -1)
            p.y = (p.y * -1)
        return p

    def scale(self,sx,sy):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.a
        _hx_local_0.a = (_hx_local_1 * sx)
        _hx_local_0.a
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.c
        _hx_local_2.c = (_hx_local_3 * sx)
        _hx_local_2.c
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.x
        _hx_local_4.x = (_hx_local_5 * sx)
        _hx_local_4.x
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6.b
        _hx_local_6.b = (_hx_local_7 * sy)
        _hx_local_6.b
        _hx_local_8 = self
        _hx_local_9 = _hx_local_8.d
        _hx_local_8.d = (_hx_local_9 * sy)
        _hx_local_8.d
        _hx_local_10 = self
        _hx_local_11 = _hx_local_10.y
        _hx_local_10.y = (_hx_local_11 * sy)
        _hx_local_10.y

    def rotate(self,angle):
        _this = h2d_col_Matrix.tmp
        cos = (Math.NaN if (((angle == Math.POSITIVE_INFINITY) or ((angle == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(angle))
        sin = (Math.NaN if (((angle == Math.POSITIVE_INFINITY) or ((angle == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(angle))
        _this.a = cos
        _this.b = sin
        _this.c = -sin
        _this.d = cos
        _this.x = 0
        _this.y = 0
        self.multiply(self,h2d_col_Matrix.tmp)

    def clone(self):
        m = h2d_col_Matrix()
        m.a = self.a
        m.b = self.b
        m.c = self.c
        m.d = self.d
        m.x = self.x
        m.y = self.y
        return m

    def getPosition(self,p = None):
        if (p is None):
            p = h2d_col_Point()
        p.x = self.x
        p.y = self.y
        return p

    def toString(self):
        return (((((((((((((((("MAT=[\n" + "  [ ") + Std.string(hxd_Math.fmt(self.a))) + ", ") + Std.string(hxd_Math.fmt(self.b))) + " ]\n") + "  [ ") + Std.string(hxd_Math.fmt(self.c))) + ", ") + Std.string(hxd_Math.fmt(self.d))) + " ]\n") + "  [ ") + Std.string(hxd_Math.fmt(self.x))) + ", ") + Std.string(hxd_Math.fmt(self.y))) + " ]\n") + "]")

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.a = None
        _hx_o.b = None
        _hx_o.c = None
        _hx_o.d = None
        _hx_o.x = None
        _hx_o.y = None
h2d_col_Matrix._hx_class = h2d_col_Matrix
_hx_classes["h2d.col.Matrix"] = h2d_col_Matrix


class h2d_col_Point:
    _hx_class_name = "h2d.col.Point"
    _hx_is_interface = "False"
    __slots__ = ("x", "y")
    _hx_fields = ["x", "y"]
    _hx_methods = ["toIPoint", "distanceSq", "distance", "toString", "sub", "add", "equals", "dot", "rotate", "lengthSq", "length", "normalize", "normalizeFast", "set", "load", "scale", "clone"]

    def __init__(self,x = None,y = None):
        if (x is None):
            x = 0.
        if (y is None):
            y = 0.
        self.x = x
        self.y = y

    def toIPoint(self,scale = None):
        if (scale is None):
            scale = 1.
        return h2d_col_IPoint(Math.floor(((self.x * scale) + 0.5)),Math.floor(((self.y * scale) + 0.5)))

    def distanceSq(self,p):
        dx = (self.x - p.x)
        dy = (self.y - p.y)
        return ((dx * dx) + ((dy * dy)))

    def distance(self,p):
        dx = (self.x - p.x)
        dy = (self.y - p.y)
        f = ((dx * dx) + ((dy * dy)))
        if (f < 0):
            return Math.NaN
        else:
            return python_lib_Math.sqrt(f)

    def toString(self):
        return (((("{" + Std.string(hxd_Math.fmt(self.x))) + ",") + Std.string(hxd_Math.fmt(self.y))) + "}")

    def sub(self,p):
        return h2d_col_Point((self.x - p.x),(self.y - p.y))

    def add(self,p):
        return h2d_col_Point((self.x + p.x),(self.y + p.y))

    def equals(self,other):
        if (self.x == other.x):
            return (self.y == other.y)
        else:
            return False

    def dot(self,p):
        return ((self.x * p.x) + ((self.y * p.y)))

    def rotate(self,angle):
        c = (Math.NaN if (((angle == Math.POSITIVE_INFINITY) or ((angle == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(angle))
        s = (Math.NaN if (((angle == Math.POSITIVE_INFINITY) or ((angle == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(angle))
        x2 = ((self.x * c) - ((self.y * s)))
        y2 = ((self.x * s) + ((self.y * c)))
        self.x = x2
        self.y = y2

    def lengthSq(self):
        return ((self.x * self.x) + ((self.y * self.y)))

    def length(self):
        f = ((self.x * self.x) + ((self.y * self.y)))
        if (f < 0):
            return Math.NaN
        else:
            return python_lib_Math.sqrt(f)

    def normalize(self):
        k = ((self.x * self.x) + ((self.y * self.y)))
        if (k < 1e-10):
            k = 0
        else:
            k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.x
        _hx_local_0.x = (_hx_local_1 * k)
        _hx_local_0.x
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.y
        _hx_local_2.y = (_hx_local_3 * k)
        _hx_local_2.y

    def normalizeFast(self):
        k = ((self.x * self.x) + ((self.y * self.y)))
        k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.x
        _hx_local_0.x = (_hx_local_1 * k)
        _hx_local_0.x
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.y
        _hx_local_2.y = (_hx_local_3 * k)
        _hx_local_2.y

    def set(self,x,y):
        self.x = x
        self.y = y

    def load(self,p):
        self.x = p.x
        self.y = p.y

    def scale(self,f):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.x
        _hx_local_0.x = (_hx_local_1 * f)
        _hx_local_0.x
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.y
        _hx_local_2.y = (_hx_local_3 * f)
        _hx_local_2.y
        return self

    def clone(self):
        return h2d_col_Point(self.x,self.y)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.x = None
        _hx_o.y = None
h2d_col_Point._hx_class = h2d_col_Point
_hx_classes["h2d.col.Point"] = h2d_col_Point


class h2d_filter_Filter:
    _hx_class_name = "h2d.filter.Filter"
    _hx_is_interface = "False"
    __slots__ = ("autoBounds", "boundsExtend", "smooth", "enable")
    _hx_fields = ["autoBounds", "boundsExtend", "smooth", "enable"]
    _hx_methods = ["get_enable", "set_enable", "sync", "bind", "unbind", "getBounds", "draw"]

    def __init__(self):
        self.enable = True
        self.smooth = False
        self.boundsExtend = 0.
        self.autoBounds = True

    def get_enable(self):
        return self.enable

    def set_enable(self,v):
        def _hx_local_1():
            def _hx_local_0():
                self.enable = v
                return self.enable
            return _hx_local_0()
        return _hx_local_1()

    def sync(self,ctx,s):
        pass

    def bind(self,s):
        pass

    def unbind(self,s):
        pass

    def getBounds(self,s,bounds):
        s.getBounds(s,bounds)
        bounds.xMin = (bounds.xMin - self.boundsExtend)
        bounds.yMin = (bounds.yMin - self.boundsExtend)
        bounds.xMax = (bounds.xMax + self.boundsExtend)
        bounds.yMax = (bounds.yMax + self.boundsExtend)

    def draw(self,ctx,input):
        return input

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.autoBounds = None
        _hx_o.boundsExtend = None
        _hx_o.smooth = None
h2d_filter_Filter._hx_class = h2d_filter_Filter
_hx_classes["h2d.filter.Filter"] = h2d_filter_Filter

class h3d_BufferFlag(Enum):
    __slots__ = ()
    _hx_class_name = "h3d.BufferFlag"
    _hx_constructs = ["Dynamic", "Triangles", "Quads", "Managed", "RawFormat", "NoAlloc", "UniformBuffer"]
h3d_BufferFlag.Dynamic = h3d_BufferFlag("Dynamic", 0, ())
h3d_BufferFlag.Triangles = h3d_BufferFlag("Triangles", 1, ())
h3d_BufferFlag.Quads = h3d_BufferFlag("Quads", 2, ())
h3d_BufferFlag.Managed = h3d_BufferFlag("Managed", 3, ())
h3d_BufferFlag.RawFormat = h3d_BufferFlag("RawFormat", 4, ())
h3d_BufferFlag.NoAlloc = h3d_BufferFlag("NoAlloc", 5, ())
h3d_BufferFlag.UniformBuffer = h3d_BufferFlag("UniformBuffer", 6, ())
h3d_BufferFlag._hx_class = h3d_BufferFlag
_hx_classes["h3d.BufferFlag"] = h3d_BufferFlag


class h3d_Buffer:
    _hx_class_name = "h3d.Buffer"
    _hx_is_interface = "False"
    __slots__ = ("id", "buffer", "position", "vertices", "next", "flags")
    _hx_fields = ["id", "buffer", "position", "vertices", "next", "flags"]
    _hx_methods = ["isDisposed", "dispose", "totalVertices", "uploadVector", "uploadBytes", "readBytes"]
    _hx_statics = ["GUID", "ofFloats", "ofSubFloats"]

    def __init__(self,vertices,stride,flags = None):
        self.next = None
        self.position = None
        self.buffer = None
        def _hx_local_2():
            _hx_local_0 = h3d_Buffer
            _hx_local_1 = _hx_local_0.GUID
            _hx_local_0.GUID = (_hx_local_1 + 1)
            return _hx_local_1
        self.id = _hx_local_2()
        self.vertices = vertices
        this1 = 0
        self.flags = this1
        if (flags is not None):
            _g = 0
            while (_g < len(flags)):
                f = (flags[_g] if _g >= 0 and _g < len(flags) else None)
                _g = (_g + 1)
                _hx_local_4 = self
                _hx_local_5 = _hx_local_4.flags
                _hx_local_4.flags = (_hx_local_5 | ((1 << f.index)))
                _hx_local_4.flags
        if (((self.flags & ((1 << h3d_BufferFlag.NoAlloc.index)))) == 0):
            h3d_Engine.CURRENT.mem.allocBuffer(self,stride)

    def isDisposed(self):
        if (self.buffer is not None):
            return (self.buffer.vbuf is None)
        else:
            return True

    def dispose(self):
        if (self.buffer is not None):
            self.buffer.freeBuffer(self)
            self.buffer = None
            if (self.next is not None):
                self.next.dispose()

    def totalVertices(self):
        count = 0
        b = self
        while (b is not None):
            count = (count + b.vertices)
            b = b.next
        return count

    def uploadVector(self,buf,bufPos,vertices,startVertice = None):
        if (startVertice is None):
            startVertice = 0
        cur = self
        while ((cur is not None) and ((startVertice >= cur.vertices))):
            startVertice = (startVertice - cur.vertices)
            cur = cur.next
        while (vertices > 0):
            if (cur is None):
                raise _HxException("Too many vertices")
            count = ((cur.vertices - startVertice) if (((vertices + startVertice) > cur.vertices)) else vertices)
            cur.buffer.uploadVertexBuffer((cur.position + startVertice),count,buf,bufPos)
            startVertice = 0
            bufPos = (bufPos + ((count * self.buffer.stride)))
            vertices = (vertices - count)
            cur = cur.next

    def uploadBytes(self,data,dataPos,vertices):
        cur = self
        while (vertices > 0):
            if (cur is None):
                raise _HxException("Too many vertices")
            count = (cur.vertices if ((vertices > cur.vertices)) else vertices)
            cur.buffer.uploadVertexBytes(cur.position,count,data,dataPos)
            dataPos = (dataPos + (((count * self.buffer.stride) * 4)))
            vertices = (vertices - count)
            cur = cur.next

    def readBytes(self,_hx_bytes,bytesPosition,vertices,startVertice = None):
        if (startVertice is None):
            startVertice = 0
        cur = self
        while ((cur is not None) and ((startVertice >= cur.vertices))):
            startVertice = (startVertice - cur.vertices)
            cur = cur.next
        while (vertices > 0):
            if (cur is None):
                raise _HxException("Too many vertices")
            count = ((cur.vertices - startVertice) if (((vertices + startVertice) > cur.vertices)) else vertices)
            cur.buffer.readVertexBytes((cur.position + startVertice),count,_hx_bytes,bytesPosition)
            startVertice = 0
            bytesPosition = (bytesPosition + (((count * self.buffer.stride) * 4)))
            vertices = (vertices - count)
            cur = cur.next

    @staticmethod
    def ofFloats(v,stride,flags = None):
        x = (len(v) / stride)
        nvert = None
        try:
            nvert = int(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            nvert = None
        b = h3d_Buffer(nvert,stride,flags)
        b.uploadVector(v,0,nvert)
        return b

    @staticmethod
    def ofSubFloats(v,stride,vertices,flags = None):
        b = h3d_Buffer(vertices,stride,flags)
        b.uploadVector(v,0,vertices)
        return b

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.id = None
        _hx_o.buffer = None
        _hx_o.position = None
        _hx_o.vertices = None
        _hx_o.next = None
        _hx_o.flags = None
h3d_Buffer._hx_class = h3d_Buffer
_hx_classes["h3d.Buffer"] = h3d_Buffer


class h3d_BufferOffset:
    _hx_class_name = "h3d.BufferOffset"
    _hx_is_interface = "False"
    __slots__ = ("buffer", "offset", "next")
    _hx_fields = ["buffer", "offset", "next"]
    _hx_methods = ["clone", "dispose"]

    def __init__(self,buffer,offset):
        self.next = None
        self.buffer = buffer
        self.offset = offset

    def clone(self):
        b = h3d_BufferOffset(self.buffer,self.offset)
        return b

    def dispose(self):
        if (self.buffer is not None):
            self.buffer.dispose()
            self.buffer = None
        self.next = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.buffer = None
        _hx_o.offset = None
        _hx_o.next = None
h3d_BufferOffset._hx_class = h3d_BufferOffset
_hx_classes["h3d.BufferOffset"] = h3d_BufferOffset


class h3d_Camera:
    _hx_class_name = "h3d.Camera"
    _hx_is_interface = "False"
    __slots__ = ("zoom", "screenRatio", "fovY", "zNear", "zFar", "orthoBounds", "rightHanded", "mproj", "mcam", "m", "pos", "up", "target", "viewX", "viewY", "follow", "frustum", "minv", "mcamInv", "mprojInv", "needInv")
    _hx_fields = ["zoom", "screenRatio", "fovY", "zNear", "zFar", "orthoBounds", "rightHanded", "mproj", "mcam", "m", "pos", "up", "target", "viewX", "viewY", "follow", "frustum", "minv", "mcamInv", "mprojInv", "needInv"]
    _hx_methods = ["setFovX", "getFovX", "clone", "getInverseViewProj", "getInverseProj", "getInverseView", "setCubeMap", "unproject", "rayFromScreen", "update", "getFrustumCorners", "lostUp", "movePosAxis", "moveTargetAxis", "forward", "backward", "makeCameraMatrix", "makeFrustumMatrix", "project", "load"]

    def __init__(self,fovY = None,zoom = None,screenRatio = None,zNear = None,zFar = None,rightHanded = None):
        if (fovY is None):
            fovY = 25.
        if (zoom is None):
            zoom = 1.
        if (screenRatio is None):
            screenRatio = 1.333333
        if (zNear is None):
            zNear = 0.02
        if (zFar is None):
            zFar = 4000.
        if (rightHanded is None):
            rightHanded = False
        self.needInv = None
        self.mprojInv = None
        self.mcamInv = None
        self.minv = None
        self.follow = None
        self.orthoBounds = None
        self.viewY = 0.
        self.viewX = 0.
        self.fovY = fovY
        self.zoom = zoom
        self.screenRatio = screenRatio
        self.zNear = zNear
        self.zFar = zFar
        self.rightHanded = rightHanded
        self.pos = h3d_Vector(2,3,4)
        self.up = h3d_Vector(0,0,1)
        self.target = h3d_Vector(0,0,0)
        self.m = h3d_Matrix()
        self.mcam = h3d_Matrix()
        self.mproj = h3d_Matrix()
        self.frustum = h3d_col_Frustum()
        self.update()

    def setFovX(self,fovX,withRatio):
        degToRad = (Math.PI / 180)
        self.fovY = ((2 * Math.atan((Math.tan(((fovX * 0.5) * degToRad)) / withRatio))) / degToRad)

    def getFovX(self):
        degToRad = (Math.PI / 180)
        halfFovX = Math.atan((Math.tan(((self.fovY * 0.5) * degToRad)) * self.screenRatio))
        fovX = ((halfFovX * 2) / degToRad)
        return fovX

    def clone(self):
        c = h3d_Camera(self.fovY,self.zoom,self.screenRatio,self.zNear,self.zFar,self.rightHanded)
        _this = self.pos
        c.pos = h3d_Vector(_this.x,_this.y,_this.z,_this.w)
        _this1 = self.up
        c.up = h3d_Vector(_this1.x,_this1.y,_this1.z,_this1.w)
        _this2 = self.target
        c.target = h3d_Vector(_this2.x,_this2.y,_this2.z,_this2.w)
        c.update()
        return c

    def getInverseViewProj(self):
        if (self.minv is None):
            self.minv = h3d_Matrix()
        if self.needInv:
            self.minv.initInverse(self.m)
            self.needInv = False
        return self.minv

    def getInverseProj(self):
        if (self.mprojInv is None):
            self.mprojInv = h3d_Matrix()
            self.mprojInv._44 = 0
        if (self.mprojInv._44 == 0):
            self.mprojInv.initInverse(self.mproj)
        return self.mprojInv

    def getInverseView(self):
        if (self.mcamInv is None):
            self.mcamInv = h3d_Matrix()
            self.mcamInv._44 = 0
        if (self.mcamInv._44 == 0):
            self.mcamInv.initInverse(self.mcam)
        return self.mcamInv

    def setCubeMap(self,face,position = None):
        dx = 0
        dy = 0
        dz = 0
        face1 = face
        if (face1 == 0):
            dx = 1
            _this = self.up
            x = 0
            y = 1
            z = 0
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            _this.x = x
            _this.y = y
            _this.z = z
            _this.w = 1.
        elif (face1 == 1):
            dx = -1
            _this1 = self.up
            x1 = 0
            y1 = 1
            z1 = 0
            if (z1 is None):
                z1 = 0.
            if (y1 is None):
                y1 = 0.
            if (x1 is None):
                x1 = 0.
            _this1.x = x1
            _this1.y = y1
            _this1.z = z1
            _this1.w = 1.
        elif (face1 == 2):
            dy = 1
            _this2 = self.up
            x2 = 0
            y2 = 0
            z2 = -1
            if (z2 is None):
                z2 = 0.
            if (y2 is None):
                y2 = 0.
            if (x2 is None):
                x2 = 0.
            _this2.x = x2
            _this2.y = y2
            _this2.z = z2
            _this2.w = 1.
        elif (face1 == 3):
            dy = -1
            _this3 = self.up
            x3 = 0
            y3 = 0
            z3 = 1
            if (z3 is None):
                z3 = 0.
            if (y3 is None):
                y3 = 0.
            if (x3 is None):
                x3 = 0.
            _this3.x = x3
            _this3.y = y3
            _this3.z = z3
            _this3.w = 1.
        elif (face1 == 4):
            dz = 1
            _this4 = self.up
            x4 = 0
            y4 = 1
            z4 = 0
            if (z4 is None):
                z4 = 0.
            if (y4 is None):
                y4 = 0.
            if (x4 is None):
                x4 = 0.
            _this4.x = x4
            _this4.y = y4
            _this4.z = z4
            _this4.w = 1.
        elif (face1 == 5):
            dz = -1
            _this5 = self.up
            x5 = 0
            y5 = 1
            z5 = 0
            if (z5 is None):
                z5 = 0.
            if (y5 is None):
                y5 = 0.
            if (x5 is None):
                x5 = 0.
            _this5.x = x5
            _this5.y = y5
            _this5.z = z5
            _this5.w = 1.
        else:
            pass
        if (position is not None):
            _this6 = self.pos
            _this6.x = position.x
            _this6.y = position.y
            _this6.z = position.z
            _this6.w = position.w
        _this7 = self.target
        x6 = (self.pos.x + dx)
        y6 = (self.pos.y + dy)
        z6 = (self.pos.z + dz)
        if (z6 is None):
            z6 = 0.
        if (y6 is None):
            y6 = 0.
        if (x6 is None):
            x6 = 0.
        _this7.x = x6
        _this7.y = y6
        _this7.z = z6
        _this7.w = 1.

    def unproject(self,screenX,screenY,camZ):
        p = h3d_Vector(screenX,screenY,camZ)
        m = self.getInverseViewProj()
        px = ((((p.x * m._11) + ((p.y * m._21))) + ((p.z * m._31))) + ((p.w * m._41)))
        py = ((((p.x * m._12) + ((p.y * m._22))) + ((p.z * m._32))) + ((p.w * m._42)))
        pz = ((((p.x * m._13) + ((p.y * m._23))) + ((p.z * m._33))) + ((p.w * m._43)))
        iw = (1 / (((((p.x * m._14) + ((p.y * m._24))) + ((p.z * m._34))) + ((p.w * m._44)))))
        p.x = (px * iw)
        p.y = (py * iw)
        p.z = (pz * iw)
        p.w = 1
        return p

    def rayFromScreen(self,pixelX,pixelY):
        engine = h3d_Engine.CURRENT
        rx = ((((pixelX / engine.width) - 0.5)) * 2)
        ry = (((0.5 - ((pixelY / engine.height)))) * 2)
        _this = self.unproject(rx,ry,0)
        x = _this.x
        y = _this.y
        z = _this.z
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        p1_x = x
        p1_y = y
        p1_z = z
        _this1 = self.unproject(rx,ry,1)
        x1 = _this1.x
        y1 = _this1.y
        z1 = _this1.z
        if (z1 is None):
            z1 = 0.
        if (y1 is None):
            y1 = 0.
        if (x1 is None):
            x1 = 0.
        p2_x = x1
        p2_y = y1
        p2_z = z1
        r = h3d_col_Ray()
        r.px = p1_x
        r.py = p1_y
        r.pz = p1_z
        r.lx = (p2_x - p1_x)
        r.ly = (p2_y - p1_y)
        r.lz = (p2_z - p1_z)
        r.normalize()
        return r

    def update(self):
        if (self.follow is not None):
            _this = self.pos
            x = 0
            y = 0
            z = 0
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            _this.x = x
            _this.y = y
            _this.z = z
            _this.w = 1.
            _this1 = self.target
            x1 = 0
            y1 = 0
            z1 = 0
            if (z1 is None):
                z1 = 0.
            if (y1 is None):
                y1 = 0.
            if (x1 is None):
                x1 = 0.
            _this1.x = x1
            _this1.y = y1
            _this1.z = z1
            _this1.w = 1.
            self.follow.pos.localToGlobal(self.pos)
            self.follow.target.localToGlobal(self.target)
            if (self.follow.pos.name is not None):
                p = self.follow.pos
                while (p is not None):
                    if (p.currentAnimation is not None):
                        v = p.currentAnimation.getPropValue(self.follow.pos.name,"FOVY")
                        if (v is not None):
                            self.fovY = v
                            break
                    p = p.parent
        self.makeCameraMatrix(self.mcam)
        self.makeFrustumMatrix(self.mproj)
        self.m.multiply(self.mcam,self.mproj)
        self.needInv = True
        if (self.mcamInv is not None):
            self.mcamInv._44 = 0
        if (self.mprojInv is not None):
            self.mprojInv._44 = 0
        self.frustum.loadMatrix(self.m)

    def getFrustumCorners(self,zMax = None):
        if (zMax is None):
            zMax = 1.
        return [self.unproject(-1,1,0), self.unproject(1,1,0), self.unproject(1,-1,0), self.unproject(-1,-1,0), self.unproject(-1,1,zMax), self.unproject(1,1,zMax), self.unproject(1,-1,zMax), self.unproject(-1,-1,zMax)]

    def lostUp(self):
        _this = self.pos
        p2 = h3d_Vector(_this.x,_this.y,_this.z,_this.w)
        p2.normalize()
        v = self.up
        return (Reflect.field(Math,"fabs")((((p2.x * v.x) + ((p2.y * v.y))) + ((p2.z * v.z)))) > 0.999)

    def movePosAxis(self,dx,dy,dz = None):
        if (dz is None):
            dz = 0.
        x = dx
        y = dy
        z = dz
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        p_x = x
        p_y = y
        p_z = z
        p_w = 1.
        m = self.mcam
        px = ((((p_x * m._11) + ((p_y * m._21))) + ((p_z * m._31))) + ((p_w * m._41)))
        py = ((((p_x * m._12) + ((p_y * m._22))) + ((p_z * m._32))) + ((p_w * m._42)))
        pz = ((((p_x * m._13) + ((p_y * m._23))) + ((p_z * m._33))) + ((p_w * m._43)))
        iw = (1 / (((((p_x * m._14) + ((p_y * m._24))) + ((p_z * m._34))) + ((p_w * m._44)))))
        p_x = (px * iw)
        p_y = (py * iw)
        p_z = (pz * iw)
        p_w = 1
        _hx_local_0 = self.pos
        _hx_local_1 = _hx_local_0.x
        _hx_local_0.x = (_hx_local_1 + p_x)
        _hx_local_0.x
        _hx_local_2 = self.pos
        _hx_local_3 = _hx_local_2.y
        _hx_local_2.y = (_hx_local_3 + p_y)
        _hx_local_2.y
        _hx_local_4 = self.pos
        _hx_local_5 = _hx_local_4.z
        _hx_local_4.z = (_hx_local_5 + p_z)
        _hx_local_4.z

    def moveTargetAxis(self,dx,dy,dz = None):
        if (dz is None):
            dz = 0.
        x = dx
        y = dy
        z = dz
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        p_x = x
        p_y = y
        p_z = z
        p_w = 1.
        m = self.mcam
        px = ((((p_x * m._11) + ((p_y * m._21))) + ((p_z * m._31))) + ((p_w * m._41)))
        py = ((((p_x * m._12) + ((p_y * m._22))) + ((p_z * m._32))) + ((p_w * m._42)))
        pz = ((((p_x * m._13) + ((p_y * m._23))) + ((p_z * m._33))) + ((p_w * m._43)))
        iw = (1 / (((((p_x * m._14) + ((p_y * m._24))) + ((p_z * m._34))) + ((p_w * m._44)))))
        p_x = (px * iw)
        p_y = (py * iw)
        p_z = (pz * iw)
        p_w = 1
        _hx_local_0 = self.target
        _hx_local_1 = _hx_local_0.x
        _hx_local_0.x = (_hx_local_1 + p_x)
        _hx_local_0.x
        _hx_local_2 = self.target
        _hx_local_3 = _hx_local_2.y
        _hx_local_2.y = (_hx_local_3 + p_y)
        _hx_local_2.y
        _hx_local_4 = self.target
        _hx_local_5 = _hx_local_4.z
        _hx_local_4.z = (_hx_local_5 + p_z)
        _hx_local_4.z

    def forward(self,speed = None):
        if (speed is None):
            speed = 1.
        c = (1 - ((0.025 * speed)))
        _this = self.pos
        x = (self.target.x + ((((self.pos.x - self.target.x)) * c)))
        y = (self.target.y + ((((self.pos.y - self.target.y)) * c)))
        z = (self.target.z + ((((self.pos.z - self.target.z)) * c)))
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.

    def backward(self,speed = None):
        if (speed is None):
            speed = 1.
        c = (1 + ((0.025 * speed)))
        _this = self.pos
        x = (self.target.x + ((((self.pos.x - self.target.x)) * c)))
        y = (self.target.y + ((((self.pos.y - self.target.y)) * c)))
        z = (self.target.z + ((((self.pos.z - self.target.z)) * c)))
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.

    def makeCameraMatrix(self,m):
        _this = self.target
        v = self.pos
        x = (_this.x - v.x)
        y = (_this.y - v.y)
        z = (_this.z - v.z)
        w = (_this.w - v.w)
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        az_x = x
        az_y = y
        az_z = z
        az_w = w
        if self.rightHanded:
            az_x = (az_x * -1)
            az_y = (az_y * -1)
            az_z = (az_z * -1)
        f = (((az_x * az_x) + ((az_y * az_y))) + ((az_z * az_z)))
        k = (1. / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
        az_x = (az_x * k)
        az_y = (az_y * k)
        az_z = (az_z * k)
        _this1 = self.up
        x1 = ((_this1.y * az_z) - ((_this1.z * az_y)))
        y1 = ((_this1.z * az_x) - ((_this1.x * az_z)))
        z1 = ((_this1.x * az_y) - ((_this1.y * az_x)))
        w1 = 1
        if (w1 is None):
            w1 = 1.
        if (z1 is None):
            z1 = 0.
        if (y1 is None):
            y1 = 0.
        if (x1 is None):
            x1 = 0.
        ax_x = x1
        ax_y = y1
        ax_z = z1
        ax_w = w1
        f1 = (((ax_x * ax_x) + ((ax_y * ax_y))) + ((ax_z * ax_z)))
        k1 = (1. / ((Math.NaN if ((f1 < 0)) else python_lib_Math.sqrt(f1))))
        ax_x = (ax_x * k1)
        ax_y = (ax_y * k1)
        ax_z = (ax_z * k1)
        f2 = (((ax_x * ax_x) + ((ax_y * ax_y))) + ((ax_z * ax_z)))
        if (((Math.NaN if ((f2 < 0)) else python_lib_Math.sqrt(f2))) == 0):
            ax_x = az_y
            ax_y = az_z
            ax_z = az_x
        x2 = ((az_y * ax_z) - ((az_z * ax_y)))
        y2 = ((az_z * ax_x) - ((az_x * ax_z)))
        z2 = ((az_x * ax_y) - ((az_y * ax_x)))
        w2 = 1
        if (w2 is None):
            w2 = 1.
        if (z2 is None):
            z2 = 0.
        if (y2 is None):
            y2 = 0.
        if (x2 is None):
            x2 = 0.
        ay_x = x2
        ay_y = y2
        ay_z = z2
        ay_w = w2
        m._11 = ax_x
        m._12 = ay_x
        m._13 = az_x
        m._14 = 0
        m._21 = ax_y
        m._22 = ay_y
        m._23 = az_y
        m._24 = 0
        m._31 = ax_z
        m._32 = ay_z
        m._33 = az_z
        m._34 = 0
        v1 = self.pos
        m._41 = -((((ax_x * v1.x) + ((ax_y * v1.y))) + ((ax_z * v1.z))))
        v2 = self.pos
        m._42 = -((((ay_x * v2.x) + ((ay_y * v2.y))) + ((ay_z * v2.z))))
        v3 = self.pos
        m._43 = -((((az_x * v3.x) + ((az_y * v3.y))) + ((az_z * v3.z))))
        m._44 = 1

    def makeFrustumMatrix(self,m):
        m.zero()
        bounds = self.orthoBounds
        if (bounds is not None):
            w = (1 / ((bounds.xMax - bounds.xMin)))
            h = (1 / ((bounds.yMax - bounds.yMin)))
            d = (1 / ((bounds.zMax - bounds.zMin)))
            m._11 = (2 * w)
            m._22 = (2 * h)
            m._33 = d
            m._41 = (-((bounds.xMin + bounds.xMax)) * w)
            m._42 = (-((bounds.yMin + bounds.yMax)) * h)
            m._43 = (-bounds.zMin * d)
            m._44 = 1
        else:
            degToRad = (Math.PI / 180)
            halfFovX = Math.atan((Math.tan(((self.fovY * 0.5) * degToRad)) * self.screenRatio))
            scale = (self.zoom / Math.tan(halfFovX))
            m._11 = scale
            m._22 = (scale * self.screenRatio)
            m._33 = (self.zFar / ((self.zFar - self.zNear)))
            m._34 = 1
            m._43 = (-((self.zNear * self.zFar)) / ((self.zFar - self.zNear)))
        m._11 = (m._11 + ((self.viewX * m._14)))
        m._21 = (m._21 + ((self.viewX * m._24)))
        m._31 = (m._31 + ((self.viewX * m._34)))
        m._41 = (m._41 + ((self.viewX * m._44)))
        m._12 = (m._12 + ((self.viewY * m._14)))
        m._22 = (m._22 + ((self.viewY * m._24)))
        m._32 = (m._32 + ((self.viewY * m._34)))
        m._42 = (m._42 + ((self.viewY * m._44)))
        if self.rightHanded:
            m._33 = (m._33 * -1)
            m._34 = (m._34 * -1)

    def project(self,x,y,z,screenWidth,screenHeight,snapToPixel = None):
        if (snapToPixel is None):
            snapToPixel = True
        p = h3d_Vector(x,y,z)
        m = self.m
        px = ((((p.x * m._11) + ((p.y * m._21))) + ((p.z * m._31))) + ((p.w * m._41)))
        py = ((((p.x * m._12) + ((p.y * m._22))) + ((p.z * m._32))) + ((p.w * m._42)))
        pz = ((((p.x * m._13) + ((p.y * m._23))) + ((p.z * m._33))) + ((p.w * m._43)))
        iw = (1 / (((((p.x * m._14) + ((p.y * m._24))) + ((p.z * m._34))) + ((p.w * m._44)))))
        p.x = (px * iw)
        p.y = (py * iw)
        p.z = (pz * iw)
        p.w = 1
        p.x = ((((p.x + 1)) * 0.5) * screenWidth)
        p.y = ((((-p.y + 1)) * 0.5) * screenHeight)
        if snapToPixel:
            p.x = Math.floor((p.x + 0.5))
            p.y = Math.floor((p.y + 0.5))
        return p

    def load(self,cam):
        _this = self.pos
        v = cam.pos
        _this.x = v.x
        _this.y = v.y
        _this.z = v.z
        _this.w = v.w
        _this1 = self.target
        v1 = cam.target
        _this1.x = v1.x
        _this1.y = v1.y
        _this1.z = v1.z
        _this1.w = v1.w
        _this2 = self.up
        v2 = cam.up
        _this2.x = v2.x
        _this2.y = v2.y
        _this2.z = v2.z
        _this2.w = v2.w
        if (cam.orthoBounds is not None):
            self.orthoBounds = h3d_col_Bounds()
            self.orthoBounds.load(cam.orthoBounds)
        else:
            self.orthoBounds = None
        self.fovY = cam.fovY
        self.screenRatio = cam.screenRatio
        self.zoom = cam.zoom
        self.zNear = cam.zNear
        self.zFar = cam.zFar
        if (cam.follow is not None):
            self.follow = _hx_AnonObject({'pos': cam.follow.pos, 'target': cam.follow.target})
        else:
            self.follow = None
        self.viewX = cam.viewX
        self.viewY = cam.viewY
        self.update()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.zoom = None
        _hx_o.screenRatio = None
        _hx_o.fovY = None
        _hx_o.zNear = None
        _hx_o.zFar = None
        _hx_o.orthoBounds = None
        _hx_o.rightHanded = None
        _hx_o.mproj = None
        _hx_o.mcam = None
        _hx_o.m = None
        _hx_o.pos = None
        _hx_o.up = None
        _hx_o.target = None
        _hx_o.viewX = None
        _hx_o.viewY = None
        _hx_o.follow = None
        _hx_o.frustum = None
        _hx_o.minv = None
        _hx_o.mcamInv = None
        _hx_o.mprojInv = None
        _hx_o.needInv = None
h3d_Camera._hx_class = h3d_Camera
_hx_classes["h3d.Camera"] = h3d_Camera


class h3d__Engine_TargetTmp:
    _hx_class_name = "h3d._Engine.TargetTmp"
    _hx_is_interface = "False"
    __slots__ = ("t", "textures", "next", "layer", "mipLevel")
    _hx_fields = ["t", "textures", "next", "layer", "mipLevel"]

    def __init__(self,t,n,l,m):
        self.textures = None
        self.t = t
        self.next = n
        self.layer = l
        self.mipLevel = m

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.t = None
        _hx_o.textures = None
        _hx_o.next = None
        _hx_o.layer = None
        _hx_o.mipLevel = None
h3d__Engine_TargetTmp._hx_class = h3d__Engine_TargetTmp
_hx_classes["h3d._Engine.TargetTmp"] = h3d__Engine_TargetTmp


class h3d_Engine:
    _hx_class_name = "h3d.Engine"
    _hx_is_interface = "False"
    _hx_fields = ["driver", "mem", "hardware", "width", "height", "debug", "drawTriangles", "drawCalls", "shaderSwitches", "backgroundColor", "autoResize", "fullScreen", "realFps", "lastTime", "antiAlias", "tmpVector", "window", "targetTmp", "targetStack", "currentTargetTex", "currentTargetLayer", "currentTargetMip", "needFlushTarget", "nullTexture", "textureColorCache", "ready", "resCache"]
    _hx_methods = ["setDriver", "setCurrent", "init", "driverName", "selectShader", "selectMaterial", "uploadShaderBuffers", "selectBuffer", "renderTriBuffer", "renderQuadBuffer", "renderBuffer", "renderIndexed", "renderMultiBuffers", "renderInstanced", "set_debug", "onCreate", "onContextLost", "onReady", "onWindowResize", "set_fullScreen", "onResized", "resize", "begin", "hasFeature", "end", "getCurrentTarget", "pushTarget", "updateNeedFlush", "pushTargets", "popTarget", "flushTarget", "doFlushTarget", "clearF", "clear", "setRenderZone", "render", "dispose", "get_fps"]
    _hx_statics = ["SOFTWARE_DRIVER", "ANTIALIASING", "CURRENT", "getCurrent"]

    def __init__(self):
        self.nullTexture = None
        self.needFlushTarget = None
        self.currentTargetMip = None
        self.currentTargetLayer = None
        self.currentTargetTex = None
        self.targetStack = None
        self.targetTmp = None
        self.window = None
        self.lastTime = None
        self.realFps = None
        self.fullScreen = None
        self.shaderSwitches = None
        self.drawCalls = None
        self.drawTriangles = None
        self.debug = None
        self.height = None
        self.width = None
        self.mem = None
        self.driver = None
        self.resCache = haxe_ds_ObjectMap()
        self.ready = False
        self.textureColorCache = haxe_ds_IntMap()
        self.tmpVector = h3d_Vector()
        self.backgroundColor = -16777216
        self.hardware = (not h3d_Engine.SOFTWARE_DRIVER)
        self.antiAlias = h3d_Engine.ANTIALIASING
        self.autoResize = True
        self.set_fullScreen((not hxd_System.getValue(hxd_SystemValue.IsWindowed)))
        self.window = hxd_Window.getInstance()
        self.realFps = hxd_System.getDefaultFrameRate()
        self.lastTime = python_lib_Timeit.default_timer()
        self.window.addResizeEvent(self.onWindowResize)
        _hx_str = "No output driver available."
        python_Lib.printString((("" + ("null" if _hx_str is None else _hx_str)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))
        self.driver = h3d_impl_LogDriver(h3d_impl_NullDriver())
        self.driver.logEnable = True
        h3d_Engine.CURRENT = self

    def setDriver(self,d):
        self.driver = d
        if (self.mem is not None):
            self.mem.driver = d

    def setCurrent(self):
        h3d_Engine.CURRENT = self

    def init(self):
        self.driver.init(self.onCreate,(not self.hardware))

    def driverName(self,details = None):
        if (details is None):
            details = False
        return self.driver.getDriverName(details)

    def selectShader(self,shader):
        if self.needFlushTarget:
            self.doFlushTarget()
        if self.driver.selectShader(shader):
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.shaderSwitches
            _hx_local_0.shaderSwitches = (_hx_local_1 + 1)
            _hx_local_1

    def selectMaterial(self,_hx_pass):
        self.driver.selectMaterial(_hx_pass)

    def uploadShaderBuffers(self,buffers,which):
        self.driver.uploadShaderBuffers(buffers,which)

    def selectBuffer(self,buf):
        if buf.isDisposed():
            return False
        if self.needFlushTarget:
            self.doFlushTarget()
        self.driver.selectBuffer(buf)
        return True

    def renderTriBuffer(self,b,start = None,_hx_max = None):
        if (start is None):
            start = 0
        if (_hx_max is None):
            _hx_max = -1
        self.renderBuffer(b,self.mem.triIndexes,3,start,_hx_max)
        return

    def renderQuadBuffer(self,b,start = None,_hx_max = None):
        if (start is None):
            start = 0
        if (_hx_max is None):
            _hx_max = -1
        self.renderBuffer(b,self.mem.quadIndexes,2,start,_hx_max)
        return

    def renderBuffer(self,b,indexes,vertPerTri,startTri = None,drawTri = None):
        if (startTri is None):
            startTri = 0
        if (drawTri is None):
            drawTri = -1
        if indexes.isDisposed():
            return
        while True:
            x = (b.vertices / vertPerTri)
            ntri = None
            try:
                ntri = int(x)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                ntri = None
            x1 = (b.position / vertPerTri)
            pos = None
            try:
                pos = int(x1)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e1 = _hx_e1
                pos = None
            if (startTri > 0):
                if (startTri >= ntri):
                    startTri = (startTri - ntri)
                    b = b.next
                    if (not ((b is not None))):
                        break
                    else:
                        continue
                pos = (pos + startTri)
                ntri = (ntri - startTri)
                startTri = 0
            if (drawTri >= 0):
                if (drawTri == 0):
                    return
                drawTri = (drawTri - ntri)
                if (drawTri < 0):
                    ntri = (ntri + drawTri)
                    drawTri = 0
            if ((ntri > 0) and self.selectBuffer(b)):
                self.driver.draw(indexes.ibuf,(pos * 3),ntri)
                _hx_local_5 = self
                _hx_local_6 = _hx_local_5.drawTriangles
                _hx_local_5.drawTriangles = (_hx_local_6 + ntri)
                _hx_local_5.drawTriangles
                _hx_local_7 = self
                _hx_local_8 = _hx_local_7.drawCalls
                _hx_local_7.drawCalls = (_hx_local_8 + 1)
                _hx_local_8
            b = b.next
            if (not ((b is not None))):
                break

    def renderIndexed(self,b,indexes,startTri = None,drawTri = None):
        if (startTri is None):
            startTri = 0
        if (drawTri is None):
            drawTri = -1
        if (b.next is not None):
            raise _HxException("Buffer is split")
        if indexes.isDisposed():
            return
        x = (indexes.count / 3)
        maxTri = None
        try:
            maxTri = int(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            maxTri = None
        if (drawTri < 0):
            drawTri = (maxTri - startTri)
        if ((drawTri > 0) and self.selectBuffer(b)):
            self.driver.draw(indexes.ibuf,(startTri * 3),drawTri)
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.drawTriangles
            _hx_local_0.drawTriangles = (_hx_local_1 + drawTri)
            _hx_local_0.drawTriangles
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.drawCalls
            _hx_local_2.drawCalls = (_hx_local_3 + 1)
            _hx_local_3

    def renderMultiBuffers(self,buffers,indexes,startTri = None,drawTri = None):
        if (startTri is None):
            startTri = 0
        if (drawTri is None):
            drawTri = -1
        x = (indexes.count / 3)
        maxTri = None
        try:
            maxTri = int(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            maxTri = None
        if (maxTri <= 0):
            return
        if self.needFlushTarget:
            self.doFlushTarget()
        self.driver.selectMultiBuffers(buffers)
        if indexes.isDisposed():
            return
        if (drawTri < 0):
            drawTri = (maxTri - startTri)
        if (drawTri > 0):
            self.driver.draw(indexes.ibuf,(startTri * 3),drawTri)
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.drawTriangles
            _hx_local_0.drawTriangles = (_hx_local_1 + drawTri)
            _hx_local_0.drawTriangles
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.drawCalls
            _hx_local_2.drawCalls = (_hx_local_3 + 1)
            _hx_local_3

    def renderInstanced(self,buffers,indexes,commands):
        if self.needFlushTarget:
            self.doFlushTarget()
        self.driver.selectMultiBuffers(buffers)
        if indexes.isDisposed():
            return
        if (commands.commandCount > 0):
            self.driver.drawInstanced(indexes.ibuf,commands)
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.drawTriangles
            _hx_local_0.drawTriangles = (_hx_local_1 + commands.triCount)
            _hx_local_0.drawTriangles
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.drawCalls
            _hx_local_2.drawCalls = (_hx_local_3 + 1)
            _hx_local_3

    def set_debug(self,d):
        self.debug = d
        self.driver.setDebug(self.debug)
        return d

    def onCreate(self,disposed):
        h3d_Engine.CURRENT = self
        if self.autoResize:
            self.width = self.window.get_width()
            self.height = self.window.get_height()
        if disposed:
            hxd_impl_Allocator.get().onContextLost()
            self.mem.onContextLost()
        else:
            self.mem = h3d_impl_MemoryManager(self.driver)
            self.mem.init()
            self.nullTexture = h3d_mat_Texture(0,0,[h3d_mat_TextureFlags.NoAlloc])
        self.hardware = self.driver.hasFeature(h3d_impl_Feature.HardwareAccelerated)
        self.set_debug(self.debug)
        self.set_fullScreen(self.fullScreen)
        self.resize(self.width,self.height)
        if disposed:
            self.onContextLost()
        else:
            self.onReady()
        self.ready = True

    def onContextLost(self):
        pass

    def onReady(self):
        pass

    def onWindowResize(self):
        if (self.autoResize and (not self.driver.isDisposed())):
            w = self.window.get_width()
            h = self.window.get_height()
            if ((w != self.width) or ((h != self.height))):
                self.resize(w,h)
            self.onResized()

    def set_fullScreen(self,v):
        self.fullScreen = v
        if ((self.mem is not None) and hxd_System.getValue(hxd_SystemValue.IsWindowed)):
            self.window.set_displayMode((hxd_DisplayMode.Borderless if v else hxd_DisplayMode.Windowed))
        return v

    def onResized(self):
        pass

    def resize(self,width,height):
        if (width < 32):
            width = 32
        if (height < 32):
            height = 32
        self.width = width
        self.height = height
        if (not self.driver.isDisposed()):
            self.driver.resize(width,height)

    def begin(self):
        if self.driver.isDisposed():
            return False
        self.drawTriangles = 0
        self.shaderSwitches = 0
        self.drawCalls = 0
        self.targetStack = None
        self.needFlushTarget = (self.currentTargetTex is not None)
        self.driver.begin(hxd_Timer.frameCount)
        if (self.backgroundColor is not None):
            self.clear(self.backgroundColor,1,0)
        return True

    def hasFeature(self,f):
        return self.driver.hasFeature(f)

    def end(self):
        self.driver.end()

    def getCurrentTarget(self):
        if (self.targetStack is None):
            return None
        else:
            return self.targetStack.t

    def pushTarget(self,tex,layer = None,mipLevel = None):
        if (layer is None):
            layer = 0
        if (mipLevel is None):
            mipLevel = 0
        c = self.targetTmp
        if (c is None):
            c = h3d__Engine_TargetTmp(tex,self.targetStack,layer,mipLevel)
        else:
            self.targetTmp = c.next
            c.t = tex
            c.next = self.targetStack
            c.mipLevel = mipLevel
            c.layer = layer
        self.targetStack = c
        self.updateNeedFlush()

    def updateNeedFlush(self):
        t = self.targetStack
        if (t is None):
            self.needFlushTarget = (self.currentTargetTex is not None)
        else:
            self.needFlushTarget = ((((self.currentTargetTex != t.t) or ((self.currentTargetLayer != t.layer))) or ((self.currentTargetMip != t.mipLevel))) or ((t.textures is not None)))

    def pushTargets(self,textures):
        self.pushTarget(self.nullTexture)
        self.targetStack.textures = textures
        self.needFlushTarget = True

    def popTarget(self):
        c = self.targetStack
        if (c is None):
            raise _HxException("popTarget() with no matching pushTarget()")
        self.targetStack = c.next
        self.updateNeedFlush()
        c.t = None
        c.textures = None
        c.next = self.targetTmp
        self.targetTmp = c

    def flushTarget(self):
        if self.needFlushTarget:
            self.doFlushTarget()

    def doFlushTarget(self):
        t = self.targetStack
        if (t is None):
            self.driver.setRenderTarget(None)
            self.currentTargetTex = None
        else:
            if (t.textures is not None):
                self.driver.setRenderTargets(t.textures)
            else:
                self.driver.setRenderTarget(t.t,t.layer,t.mipLevel)
            self.currentTargetTex = t.t
            self.currentTargetLayer = t.layer
            self.currentTargetMip = t.mipLevel
        self.needFlushTarget = False

    def clearF(self,color,depth = None,stencil = None):
        if self.needFlushTarget:
            self.doFlushTarget()
        self.driver.clear(color,depth,stencil)

    def clear(self,color = None,depth = None,stencil = None):
        if (color is not None):
            _this = self.tmpVector
            _this.x = ((((color >> 16) & 255)) / 255)
            _this.y = ((((color >> 8) & 255)) / 255)
            _this.z = (((color & 255)) / 255)
            _this.w = ((HxOverrides.rshift(color, 24)) / 255)
        if self.needFlushTarget:
            self.doFlushTarget()
        self.driver.clear((None if ((color is None)) else self.tmpVector),depth,stencil)

    def setRenderZone(self,x = None,y = None,width = None,height = None):
        if (x is None):
            x = 0
        if (y is None):
            y = 0
        if (width is None):
            width = -1
        if (height is None):
            height = -1
        if self.needFlushTarget:
            self.doFlushTarget()
        self.driver.setRenderZone(x,y,width,height)

    def render(self,obj):
        if (not self.begin()):
            return False
        obj.render(self)
        self.end()
        delta = (python_lib_Timeit.default_timer() - self.lastTime)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.lastTime
        _hx_local_0.lastTime = (_hx_local_1 + delta)
        _hx_local_0.lastTime
        if (delta > 0):
            curFps = (1. / delta)
            if (curFps > ((self.realFps * 2))):
                curFps = (self.realFps * 2)
            elif (curFps < ((self.realFps * 0.5))):
                curFps = (self.realFps * 0.5)
            f = (delta / .5)
            if (f > 0.3):
                f = 0.3
            self.realFps = ((self.realFps * ((1 - f))) + ((curFps * f)))
        return True

    def dispose(self):
        self.driver.dispose()
        self.window.removeResizeEvent(self.onWindowResize)

    def get_fps(self):
        return (Math.ceil((self.realFps * 100)) / 100)

    @staticmethod
    def getCurrent():
        return h3d_Engine.CURRENT

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.driver = None
        _hx_o.mem = None
        _hx_o.hardware = None
        _hx_o.width = None
        _hx_o.height = None
        _hx_o.debug = None
        _hx_o.drawTriangles = None
        _hx_o.drawCalls = None
        _hx_o.shaderSwitches = None
        _hx_o.backgroundColor = None
        _hx_o.autoResize = None
        _hx_o.fullScreen = None
        _hx_o.realFps = None
        _hx_o.lastTime = None
        _hx_o.antiAlias = None
        _hx_o.tmpVector = None
        _hx_o.window = None
        _hx_o.targetTmp = None
        _hx_o.targetStack = None
        _hx_o.currentTargetTex = None
        _hx_o.currentTargetLayer = None
        _hx_o.currentTargetMip = None
        _hx_o.needFlushTarget = None
        _hx_o.nullTexture = None
        _hx_o.textureColorCache = None
        _hx_o.ready = None
        _hx_o.resCache = None
h3d_Engine._hx_class = h3d_Engine
_hx_classes["h3d.Engine"] = h3d_Engine


class h3d_Indexes:
    _hx_class_name = "h3d.Indexes"
    _hx_is_interface = "False"
    __slots__ = ("mem", "ibuf", "is32", "count")
    _hx_fields = ["mem", "ibuf", "is32", "count"]
    _hx_methods = ["isDisposed", "upload", "uploadBytes", "readBytes", "dispose"]
    _hx_statics = ["alloc"]

    def __init__(self,count,is32 = None):
        if (is32 is None):
            is32 = False
        self.ibuf = None
        self.mem = h3d_Engine.CURRENT.mem
        self.count = count
        self.is32 = is32
        self.mem.allocIndexes(self)

    def isDisposed(self):
        return (self.ibuf is None)

    def upload(self,indexes,pos,count,bufferPos = None):
        if (bufferPos is None):
            bufferPos = 0
        self.mem.driver.uploadIndexBuffer(self.ibuf,pos,count,indexes,bufferPos)

    def uploadBytes(self,_hx_bytes,dataPos,indices):
        self.mem.driver.uploadIndexBytes(self.ibuf,0,indices,_hx_bytes,dataPos)

    def readBytes(self,_hx_bytes,bytesPosition,indices,startIndice = None):
        if (startIndice is None):
            startIndice = 0
        self.mem.driver.readIndexBytes(self.ibuf,startIndice,indices,_hx_bytes,bytesPosition)

    def dispose(self):
        if (self.ibuf is not None):
            self.mem.deleteIndexes(self)

    @staticmethod
    def alloc(i,startPos = None,length = None):
        if (startPos is None):
            startPos = 0
        if (length is None):
            length = -1
        if (length < 0):
            length = len(i)
        idx = h3d_Indexes(length)
        idx.upload(i,0,length)
        return idx

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.mem = None
        _hx_o.ibuf = None
        _hx_o.is32 = None
        _hx_o.count = None
h3d_Indexes._hx_class = h3d_Indexes
_hx_classes["h3d.Indexes"] = h3d_Indexes


class h3d_Matrix:
    _hx_class_name = "h3d.Matrix"
    _hx_is_interface = "False"
    __slots__ = ("_11", "_12", "_13", "_14", "_21", "_22", "_23", "_24", "_31", "_32", "_33", "_34", "_41", "_42", "_43", "_44")
    _hx_fields = ["_11", "_12", "_13", "_14", "_21", "_22", "_23", "_24", "_31", "_32", "_33", "_34", "_41", "_42", "_43", "_44"]
    _hx_methods = ["get_tx", "get_ty", "get_tz", "set_tx", "set_ty", "set_tz", "equal", "zero", "identity", "initRotationX", "initRotationY", "initRotationZ", "initTranslation", "initScale", "initRotationAxis", "initRotation", "translate", "scale", "rotate", "rotateAxis", "getPosition", "setPosition", "prependTranslation", "getScale", "prependRotation", "prependRotationAxis", "prependScale", "multiply3x4", "multiply3x4inline", "multiply", "multiplyValue", "invert", "getDeterminant", "inverse3x4", "initInverse", "initInverse3x3", "front", "right", "up", "transpose", "clone", "load", "loadValues", "getFloats", "getEulerAngles", "toString", "colorHue", "colorSaturate", "colorContrast", "colorLightness", "colorGain", "colorBits", "colorAdd", "colorSet", "adjustColor"]
    _hx_statics = ["tmp", "lumR", "lumG", "lumB", "SQ13", "I", "L", "T", "R", "S", "lookAtX"]

    def __init__(self):
        self._44 = None
        self._43 = None
        self._42 = None
        self._41 = None
        self._34 = None
        self._33 = None
        self._32 = None
        self._31 = None
        self._24 = None
        self._23 = None
        self._22 = None
        self._21 = None
        self._14 = None
        self._13 = None
        self._12 = None
        self._11 = None

    def get_tx(self):
        return self._41

    def get_ty(self):
        return self._42

    def get_tz(self):
        return self._43

    def set_tx(self,v):
        def _hx_local_1():
            def _hx_local_0():
                self._41 = v
                return self._41
            return _hx_local_0()
        return _hx_local_1()

    def set_ty(self,v):
        def _hx_local_1():
            def _hx_local_0():
                self._42 = v
                return self._42
            return _hx_local_0()
        return _hx_local_1()

    def set_tz(self,v):
        def _hx_local_1():
            def _hx_local_0():
                self._43 = v
                return self._43
            return _hx_local_0()
        return _hx_local_1()

    def equal(self,other):
        if (((((((((((((((self._11 == other._11) and ((self._12 == other._12))) and ((self._13 == other._13))) and ((self._14 == other._14))) and ((self._21 == other._21))) and ((self._22 == other._22))) and ((self._23 == other._23))) and ((self._24 == other._24))) and ((self._31 == other._31))) and ((self._32 == other._32))) and ((self._33 == other._33))) and ((self._34 == other._34))) and ((self._41 == other._41))) and ((self._42 == other._42))) and ((self._43 == other._43))):
            return (self._44 == other._44)
        else:
            return False

    def zero(self):
        self._11 = 0.0
        self._12 = 0.0
        self._13 = 0.0
        self._14 = 0.0
        self._21 = 0.0
        self._22 = 0.0
        self._23 = 0.0
        self._24 = 0.0
        self._31 = 0.0
        self._32 = 0.0
        self._33 = 0.0
        self._34 = 0.0
        self._41 = 0.0
        self._42 = 0.0
        self._43 = 0.0
        self._44 = 0.0

    def identity(self):
        self._11 = 1.0
        self._12 = 0.0
        self._13 = 0.0
        self._14 = 0.0
        self._21 = 0.0
        self._22 = 1.0
        self._23 = 0.0
        self._24 = 0.0
        self._31 = 0.0
        self._32 = 0.0
        self._33 = 1.0
        self._34 = 0.0
        self._41 = 0.0
        self._42 = 0.0
        self._43 = 0.0
        self._44 = 1.0

    def initRotationX(self,a):
        cos = (Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(a))
        sin = (Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(a))
        self._11 = 1.0
        self._12 = 0.0
        self._13 = 0.0
        self._14 = 0.0
        self._21 = 0.0
        self._22 = cos
        self._23 = sin
        self._24 = 0.0
        self._31 = 0.0
        self._32 = -sin
        self._33 = cos
        self._34 = 0.0
        self._41 = 0.0
        self._42 = 0.0
        self._43 = 0.0
        self._44 = 1.0

    def initRotationY(self,a):
        cos = (Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(a))
        sin = (Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(a))
        self._11 = cos
        self._12 = 0.0
        self._13 = -sin
        self._14 = 0.0
        self._21 = 0.0
        self._22 = 1.0
        self._23 = 0.0
        self._24 = 0.0
        self._31 = sin
        self._32 = 0.0
        self._33 = cos
        self._34 = 0.0
        self._41 = 0.0
        self._42 = 0.0
        self._43 = 0.0
        self._44 = 1.0

    def initRotationZ(self,a):
        cos = (Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(a))
        sin = (Math.NaN if (((a == Math.POSITIVE_INFINITY) or ((a == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(a))
        self._11 = cos
        self._12 = sin
        self._13 = 0.0
        self._14 = 0.0
        self._21 = -sin
        self._22 = cos
        self._23 = 0.0
        self._24 = 0.0
        self._31 = 0.0
        self._32 = 0.0
        self._33 = 1.0
        self._34 = 0.0
        self._41 = 0.0
        self._42 = 0.0
        self._43 = 0.0
        self._44 = 1.0

    def initTranslation(self,x = None,y = None,z = None):
        if (x is None):
            x = 0.
        if (y is None):
            y = 0.
        if (z is None):
            z = 0.
        self._11 = 1.0
        self._12 = 0.0
        self._13 = 0.0
        self._14 = 0.0
        self._21 = 0.0
        self._22 = 1.0
        self._23 = 0.0
        self._24 = 0.0
        self._31 = 0.0
        self._32 = 0.0
        self._33 = 1.0
        self._34 = 0.0
        self._41 = x
        self._42 = y
        self._43 = z
        self._44 = 1.0

    def initScale(self,x = None,y = None,z = None):
        if (x is None):
            x = 1.
        if (y is None):
            y = 1.
        if (z is None):
            z = 1.
        self._11 = x
        self._12 = 0.0
        self._13 = 0.0
        self._14 = 0.0
        self._21 = 0.0
        self._22 = y
        self._23 = 0.0
        self._24 = 0.0
        self._31 = 0.0
        self._32 = 0.0
        self._33 = z
        self._34 = 0.0
        self._41 = 0.0
        self._42 = 0.0
        self._43 = 0.0
        self._44 = 1.0

    def initRotationAxis(self,axis,angle):
        cos = (Math.NaN if (((angle == Math.POSITIVE_INFINITY) or ((angle == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(angle))
        sin = (Math.NaN if (((angle == Math.POSITIVE_INFINITY) or ((angle == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(angle))
        cos1 = (1 - cos)
        x = -axis.x
        y = -axis.y
        z = -axis.z
        xx = (x * x)
        yy = (y * y)
        zz = (z * z)
        f = ((xx + yy) + zz)
        _hx_len = (1. / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
        x = (x * _hx_len)
        y = (y * _hx_len)
        z = (z * _hx_len)
        xcos1 = (x * cos1)
        zcos1 = (z * cos1)
        self._11 = (cos + ((x * xcos1)))
        self._12 = ((y * xcos1) - ((z * sin)))
        self._13 = ((x * zcos1) + ((y * sin)))
        self._14 = 0.
        self._21 = ((y * xcos1) + ((z * sin)))
        self._22 = (cos + (((y * y) * cos1)))
        self._23 = ((y * zcos1) - ((x * sin)))
        self._24 = 0.
        self._31 = ((x * zcos1) - ((y * sin)))
        self._32 = ((y * zcos1) + ((x * sin)))
        self._33 = (cos + ((z * zcos1)))
        self._34 = 0.
        self._41 = 0.
        self._42 = 0.
        self._43 = 0.
        self._44 = 1.

    def initRotation(self,x,y,z):
        cx = (Math.NaN if (((x == Math.POSITIVE_INFINITY) or ((x == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(x))
        sx = (Math.NaN if (((x == Math.POSITIVE_INFINITY) or ((x == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(x))
        cy = (Math.NaN if (((y == Math.POSITIVE_INFINITY) or ((y == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(y))
        sy = (Math.NaN if (((y == Math.POSITIVE_INFINITY) or ((y == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(y))
        cz = (Math.NaN if (((z == Math.POSITIVE_INFINITY) or ((z == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(z))
        sz = (Math.NaN if (((z == Math.POSITIVE_INFINITY) or ((z == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(z))
        cxsy = (cx * sy)
        sxsy = (sx * sy)
        self._11 = (cy * cz)
        self._12 = (cy * sz)
        self._13 = -sy
        self._14 = 0
        self._21 = ((sxsy * cz) - ((cx * sz)))
        self._22 = ((sxsy * sz) + ((cx * cz)))
        self._23 = (sx * cy)
        self._24 = 0
        self._31 = ((cxsy * cz) + ((sx * sz)))
        self._32 = ((cxsy * sz) - ((sx * cz)))
        self._33 = (cx * cy)
        self._34 = 0
        self._41 = 0
        self._42 = 0
        self._43 = 0
        self._44 = 1

    def translate(self,x = None,y = None,z = None):
        if (x is None):
            x = 0.
        if (y is None):
            y = 0.
        if (z is None):
            z = 0.
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0._11
        _hx_local_0._11 = (_hx_local_1 + ((x * self._14)))
        _hx_local_0._11
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2._12
        _hx_local_2._12 = (_hx_local_3 + ((y * self._14)))
        _hx_local_2._12
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4._13
        _hx_local_4._13 = (_hx_local_5 + ((z * self._14)))
        _hx_local_4._13
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6._21
        _hx_local_6._21 = (_hx_local_7 + ((x * self._24)))
        _hx_local_6._21
        _hx_local_8 = self
        _hx_local_9 = _hx_local_8._22
        _hx_local_8._22 = (_hx_local_9 + ((y * self._24)))
        _hx_local_8._22
        _hx_local_10 = self
        _hx_local_11 = _hx_local_10._23
        _hx_local_10._23 = (_hx_local_11 + ((z * self._24)))
        _hx_local_10._23
        _hx_local_12 = self
        _hx_local_13 = _hx_local_12._31
        _hx_local_12._31 = (_hx_local_13 + ((x * self._34)))
        _hx_local_12._31
        _hx_local_14 = self
        _hx_local_15 = _hx_local_14._32
        _hx_local_14._32 = (_hx_local_15 + ((y * self._34)))
        _hx_local_14._32
        _hx_local_16 = self
        _hx_local_17 = _hx_local_16._33
        _hx_local_16._33 = (_hx_local_17 + ((z * self._34)))
        _hx_local_16._33
        _hx_local_18 = self
        _hx_local_19 = _hx_local_18._41
        _hx_local_18._41 = (_hx_local_19 + ((x * self._44)))
        _hx_local_18._41
        _hx_local_20 = self
        _hx_local_21 = _hx_local_20._42
        _hx_local_20._42 = (_hx_local_21 + ((y * self._44)))
        _hx_local_20._42
        _hx_local_22 = self
        _hx_local_23 = _hx_local_22._43
        _hx_local_22._43 = (_hx_local_23 + ((z * self._44)))
        _hx_local_22._43

    def scale(self,x = None,y = None,z = None):
        if (x is None):
            x = 1.
        if (y is None):
            y = 1.
        if (z is None):
            z = 1.
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0._11
        _hx_local_0._11 = (_hx_local_1 * x)
        _hx_local_0._11
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2._21
        _hx_local_2._21 = (_hx_local_3 * x)
        _hx_local_2._21
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4._31
        _hx_local_4._31 = (_hx_local_5 * x)
        _hx_local_4._31
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6._41
        _hx_local_6._41 = (_hx_local_7 * x)
        _hx_local_6._41
        _hx_local_8 = self
        _hx_local_9 = _hx_local_8._12
        _hx_local_8._12 = (_hx_local_9 * y)
        _hx_local_8._12
        _hx_local_10 = self
        _hx_local_11 = _hx_local_10._22
        _hx_local_10._22 = (_hx_local_11 * y)
        _hx_local_10._22
        _hx_local_12 = self
        _hx_local_13 = _hx_local_12._32
        _hx_local_12._32 = (_hx_local_13 * y)
        _hx_local_12._32
        _hx_local_14 = self
        _hx_local_15 = _hx_local_14._42
        _hx_local_14._42 = (_hx_local_15 * y)
        _hx_local_14._42
        _hx_local_16 = self
        _hx_local_17 = _hx_local_16._13
        _hx_local_16._13 = (_hx_local_17 * z)
        _hx_local_16._13
        _hx_local_18 = self
        _hx_local_19 = _hx_local_18._23
        _hx_local_18._23 = (_hx_local_19 * z)
        _hx_local_18._23
        _hx_local_20 = self
        _hx_local_21 = _hx_local_20._33
        _hx_local_20._33 = (_hx_local_21 * z)
        _hx_local_20._33
        _hx_local_22 = self
        _hx_local_23 = _hx_local_22._43
        _hx_local_22._43 = (_hx_local_23 * z)
        _hx_local_22._43

    def rotate(self,x,y,z):
        tmp = h3d_Matrix.tmp
        tmp.initRotation(x,y,z)
        self.multiply(self,tmp)

    def rotateAxis(self,axis,angle):
        tmp = h3d_Matrix.tmp
        tmp.initRotationAxis(axis,angle)
        self.multiply(self,tmp)

    def getPosition(self,v = None):
        if (v is None):
            v = h3d_Vector()
        x = self._41
        y = self._42
        z = self._43
        w = self._44
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v.x = x
        v.y = y
        v.z = z
        v.w = w
        return v

    def setPosition(self,v):
        self._41 = v.x
        self._42 = v.y
        self._43 = v.z
        self._44 = v.w

    def prependTranslation(self,x = None,y = None,z = None):
        if (x is None):
            x = 0.
        if (y is None):
            y = 0.
        if (z is None):
            z = 0.
        vx = ((((self._11 * x) + ((self._21 * y))) + ((self._31 * z))) + self._41)
        vy = ((((self._12 * x) + ((self._22 * y))) + ((self._32 * z))) + self._42)
        vz = ((((self._13 * x) + ((self._23 * y))) + ((self._33 * z))) + self._43)
        vw = ((((self._14 * x) + ((self._24 * y))) + ((self._34 * z))) + self._44)
        self._41 = vx
        self._42 = vy
        self._43 = vz
        self._44 = vw

    def getScale(self,v = None):
        if (v is None):
            v = h3d_Vector()
        f = (((self._11 * self._11) + ((self._12 * self._12))) + ((self._13 * self._13)))
        v.x = (Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))
        f1 = (((self._21 * self._21) + ((self._22 * self._22))) + ((self._23 * self._23)))
        v.y = (Math.NaN if ((f1 < 0)) else python_lib_Math.sqrt(f1))
        f2 = (((self._31 * self._31) + ((self._32 * self._32))) + ((self._33 * self._33)))
        v.z = (Math.NaN if ((f2 < 0)) else python_lib_Math.sqrt(f2))
        if ((((self._11 * (((self._22 * self._33) - ((self._23 * self._32))))) + ((self._12 * (((self._23 * self._31) - ((self._21 * self._33))))))) + ((self._13 * (((self._21 * self._32) - ((self._22 * self._31))))))) < 0):
            v.x = (v.x * -1)
            v.y = (v.y * -1)
            v.z = (v.z * -1)
        return v

    def prependRotation(self,x,y,z):
        tmp = h3d_Matrix.tmp
        tmp.initRotation(x,y,z)
        self.multiply(tmp,self)

    def prependRotationAxis(self,axis,angle):
        tmp = h3d_Matrix.tmp
        tmp.initRotationAxis(axis,angle)
        self.multiply(tmp,self)

    def prependScale(self,sx = None,sy = None,sz = None):
        if (sx is None):
            sx = 1.
        if (sy is None):
            sy = 1.
        if (sz is None):
            sz = 1.
        tmp = h3d_Matrix.tmp
        tmp.initScale(sx,sy,sz)
        self.multiply(tmp,self)

    def multiply3x4(self,a,b):
        m11 = a._11
        m12 = a._12
        m13 = a._13
        m21 = a._21
        m22 = a._22
        m23 = a._23
        a31 = a._31
        a32 = a._32
        a33 = a._33
        a41 = a._41
        a42 = a._42
        a43 = a._43
        b11 = b._11
        b12 = b._12
        b13 = b._13
        b21 = b._21
        b22 = b._22
        b23 = b._23
        b31 = b._31
        b32 = b._32
        b33 = b._33
        b41 = b._41
        b42 = b._42
        b43 = b._43
        self._11 = (((m11 * b11) + ((m12 * b21))) + ((m13 * b31)))
        self._12 = (((m11 * b12) + ((m12 * b22))) + ((m13 * b32)))
        self._13 = (((m11 * b13) + ((m12 * b23))) + ((m13 * b33)))
        self._14 = 0
        self._21 = (((m21 * b11) + ((m22 * b21))) + ((m23 * b31)))
        self._22 = (((m21 * b12) + ((m22 * b22))) + ((m23 * b32)))
        self._23 = (((m21 * b13) + ((m22 * b23))) + ((m23 * b33)))
        self._24 = 0
        self._31 = (((a31 * b11) + ((a32 * b21))) + ((a33 * b31)))
        self._32 = (((a31 * b12) + ((a32 * b22))) + ((a33 * b32)))
        self._33 = (((a31 * b13) + ((a32 * b23))) + ((a33 * b33)))
        self._34 = 0
        self._41 = ((((a41 * b11) + ((a42 * b21))) + ((a43 * b31))) + b41)
        self._42 = ((((a41 * b12) + ((a42 * b22))) + ((a43 * b32))) + b42)
        self._43 = ((((a41 * b13) + ((a42 * b23))) + ((a43 * b33))) + b43)
        self._44 = 1

    def multiply3x4inline(self,a,b):
        m11 = a._11
        m12 = a._12
        m13 = a._13
        m21 = a._21
        m22 = a._22
        m23 = a._23
        a31 = a._31
        a32 = a._32
        a33 = a._33
        a41 = a._41
        a42 = a._42
        a43 = a._43
        b11 = b._11
        b12 = b._12
        b13 = b._13
        b21 = b._21
        b22 = b._22
        b23 = b._23
        b31 = b._31
        b32 = b._32
        b33 = b._33
        b41 = b._41
        b42 = b._42
        b43 = b._43
        self._11 = (((m11 * b11) + ((m12 * b21))) + ((m13 * b31)))
        self._12 = (((m11 * b12) + ((m12 * b22))) + ((m13 * b32)))
        self._13 = (((m11 * b13) + ((m12 * b23))) + ((m13 * b33)))
        self._14 = 0
        self._21 = (((m21 * b11) + ((m22 * b21))) + ((m23 * b31)))
        self._22 = (((m21 * b12) + ((m22 * b22))) + ((m23 * b32)))
        self._23 = (((m21 * b13) + ((m22 * b23))) + ((m23 * b33)))
        self._24 = 0
        self._31 = (((a31 * b11) + ((a32 * b21))) + ((a33 * b31)))
        self._32 = (((a31 * b12) + ((a32 * b22))) + ((a33 * b32)))
        self._33 = (((a31 * b13) + ((a32 * b23))) + ((a33 * b33)))
        self._34 = 0
        self._41 = ((((a41 * b11) + ((a42 * b21))) + ((a43 * b31))) + b41)
        self._42 = ((((a41 * b12) + ((a42 * b22))) + ((a43 * b32))) + b42)
        self._43 = ((((a41 * b13) + ((a42 * b23))) + ((a43 * b33))) + b43)
        self._44 = 1

    def multiply(self,a,b):
        a11 = a._11
        a12 = a._12
        a13 = a._13
        a14 = a._14
        a21 = a._21
        a22 = a._22
        a23 = a._23
        a24 = a._24
        a31 = a._31
        a32 = a._32
        a33 = a._33
        a34 = a._34
        a41 = a._41
        a42 = a._42
        a43 = a._43
        a44 = a._44
        b11 = b._11
        b12 = b._12
        b13 = b._13
        b14 = b._14
        b21 = b._21
        b22 = b._22
        b23 = b._23
        b24 = b._24
        b31 = b._31
        b32 = b._32
        b33 = b._33
        b34 = b._34
        b41 = b._41
        b42 = b._42
        b43 = b._43
        b44 = b._44
        self._11 = ((((a11 * b11) + ((a12 * b21))) + ((a13 * b31))) + ((a14 * b41)))
        self._12 = ((((a11 * b12) + ((a12 * b22))) + ((a13 * b32))) + ((a14 * b42)))
        self._13 = ((((a11 * b13) + ((a12 * b23))) + ((a13 * b33))) + ((a14 * b43)))
        self._14 = ((((a11 * b14) + ((a12 * b24))) + ((a13 * b34))) + ((a14 * b44)))
        self._21 = ((((a21 * b11) + ((a22 * b21))) + ((a23 * b31))) + ((a24 * b41)))
        self._22 = ((((a21 * b12) + ((a22 * b22))) + ((a23 * b32))) + ((a24 * b42)))
        self._23 = ((((a21 * b13) + ((a22 * b23))) + ((a23 * b33))) + ((a24 * b43)))
        self._24 = ((((a21 * b14) + ((a22 * b24))) + ((a23 * b34))) + ((a24 * b44)))
        self._31 = ((((a31 * b11) + ((a32 * b21))) + ((a33 * b31))) + ((a34 * b41)))
        self._32 = ((((a31 * b12) + ((a32 * b22))) + ((a33 * b32))) + ((a34 * b42)))
        self._33 = ((((a31 * b13) + ((a32 * b23))) + ((a33 * b33))) + ((a34 * b43)))
        self._34 = ((((a31 * b14) + ((a32 * b24))) + ((a33 * b34))) + ((a34 * b44)))
        self._41 = ((((a41 * b11) + ((a42 * b21))) + ((a43 * b31))) + ((a44 * b41)))
        self._42 = ((((a41 * b12) + ((a42 * b22))) + ((a43 * b32))) + ((a44 * b42)))
        self._43 = ((((a41 * b13) + ((a42 * b23))) + ((a43 * b33))) + ((a44 * b43)))
        self._44 = ((((a41 * b14) + ((a42 * b24))) + ((a43 * b34))) + ((a44 * b44)))

    def multiplyValue(self,v):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0._11
        _hx_local_0._11 = (_hx_local_1 * v)
        _hx_local_0._11
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2._12
        _hx_local_2._12 = (_hx_local_3 * v)
        _hx_local_2._12
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4._13
        _hx_local_4._13 = (_hx_local_5 * v)
        _hx_local_4._13
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6._14
        _hx_local_6._14 = (_hx_local_7 * v)
        _hx_local_6._14
        _hx_local_8 = self
        _hx_local_9 = _hx_local_8._21
        _hx_local_8._21 = (_hx_local_9 * v)
        _hx_local_8._21
        _hx_local_10 = self
        _hx_local_11 = _hx_local_10._22
        _hx_local_10._22 = (_hx_local_11 * v)
        _hx_local_10._22
        _hx_local_12 = self
        _hx_local_13 = _hx_local_12._23
        _hx_local_12._23 = (_hx_local_13 * v)
        _hx_local_12._23
        _hx_local_14 = self
        _hx_local_15 = _hx_local_14._24
        _hx_local_14._24 = (_hx_local_15 * v)
        _hx_local_14._24
        _hx_local_16 = self
        _hx_local_17 = _hx_local_16._31
        _hx_local_16._31 = (_hx_local_17 * v)
        _hx_local_16._31
        _hx_local_18 = self
        _hx_local_19 = _hx_local_18._32
        _hx_local_18._32 = (_hx_local_19 * v)
        _hx_local_18._32
        _hx_local_20 = self
        _hx_local_21 = _hx_local_20._33
        _hx_local_20._33 = (_hx_local_21 * v)
        _hx_local_20._33
        _hx_local_22 = self
        _hx_local_23 = _hx_local_22._34
        _hx_local_22._34 = (_hx_local_23 * v)
        _hx_local_22._34
        _hx_local_24 = self
        _hx_local_25 = _hx_local_24._41
        _hx_local_24._41 = (_hx_local_25 * v)
        _hx_local_24._41
        _hx_local_26 = self
        _hx_local_27 = _hx_local_26._42
        _hx_local_26._42 = (_hx_local_27 * v)
        _hx_local_26._42
        _hx_local_28 = self
        _hx_local_29 = _hx_local_28._43
        _hx_local_28._43 = (_hx_local_29 * v)
        _hx_local_28._43
        _hx_local_30 = self
        _hx_local_31 = _hx_local_30._44
        _hx_local_30._44 = (_hx_local_31 * v)
        _hx_local_30._44

    def invert(self):
        self.initInverse(self)

    def getDeterminant(self):
        return (((self._11 * (((self._22 * self._33) - ((self._23 * self._32))))) + ((self._12 * (((self._23 * self._31) - ((self._21 * self._33))))))) + ((self._13 * (((self._21 * self._32) - ((self._22 * self._31)))))))

    def inverse3x4(self,m):
        m11 = m._11
        m12 = m._12
        m13 = m._13
        m21 = m._21
        m22 = m._22
        m23 = m._23
        m31 = m._31
        m32 = m._32
        m33 = m._33
        m41 = m._41
        m42 = m._42
        m43 = m._43
        self._11 = ((m22 * m33) - ((m23 * m32)))
        self._12 = ((m13 * m32) - ((m12 * m33)))
        self._13 = ((m12 * m23) - ((m13 * m22)))
        self._14 = 0
        self._21 = ((m23 * m31) - ((m21 * m33)))
        self._22 = ((m11 * m33) - ((m13 * m31)))
        self._23 = ((m13 * m21) - ((m11 * m23)))
        self._24 = 0
        self._31 = ((m21 * m32) - ((m22 * m31)))
        self._32 = ((m12 * m31) - ((m11 * m32)))
        self._33 = ((m11 * m22) - ((m12 * m21)))
        self._34 = 0
        self._41 = (((((((-m21 * m32) * m43) + (((m21 * m33) * m42))) + (((m31 * m22) * m43))) - (((m31 * m23) * m42))) - (((m41 * m22) * m33))) + (((m41 * m23) * m32)))
        self._42 = (((((((m11 * m32) * m43) - (((m11 * m33) * m42))) - (((m31 * m12) * m43))) + (((m31 * m13) * m42))) + (((m41 * m12) * m33))) - (((m41 * m13) * m32)))
        self._43 = (((((((-m11 * m22) * m43) + (((m11 * m23) * m42))) + (((m21 * m12) * m43))) - (((m21 * m13) * m42))) - (((m41 * m12) * m23))) + (((m41 * m13) * m22)))
        self._44 = (((((((m11 * m22) * m33) - (((m11 * m23) * m32))) - (((m21 * m12) * m33))) + (((m21 * m13) * m32))) + (((m31 * m12) * m23))) - (((m31 * m13) * m22)))
        self._44 = 1
        det = (((m11 * self._11) + ((m12 * self._21))) + ((m13 * self._31)))
        if (((-det if ((det < 0)) else det)) < 1e-10):
            self.zero()
            return
        invDet = (1.0 / det)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0._11
        _hx_local_0._11 = (_hx_local_1 * invDet)
        _hx_local_0._11
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2._12
        _hx_local_2._12 = (_hx_local_3 * invDet)
        _hx_local_2._12
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4._13
        _hx_local_4._13 = (_hx_local_5 * invDet)
        _hx_local_4._13
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6._21
        _hx_local_6._21 = (_hx_local_7 * invDet)
        _hx_local_6._21
        _hx_local_8 = self
        _hx_local_9 = _hx_local_8._22
        _hx_local_8._22 = (_hx_local_9 * invDet)
        _hx_local_8._22
        _hx_local_10 = self
        _hx_local_11 = _hx_local_10._23
        _hx_local_10._23 = (_hx_local_11 * invDet)
        _hx_local_10._23
        _hx_local_12 = self
        _hx_local_13 = _hx_local_12._31
        _hx_local_12._31 = (_hx_local_13 * invDet)
        _hx_local_12._31
        _hx_local_14 = self
        _hx_local_15 = _hx_local_14._32
        _hx_local_14._32 = (_hx_local_15 * invDet)
        _hx_local_14._32
        _hx_local_16 = self
        _hx_local_17 = _hx_local_16._33
        _hx_local_16._33 = (_hx_local_17 * invDet)
        _hx_local_16._33
        _hx_local_18 = self
        _hx_local_19 = _hx_local_18._41
        _hx_local_18._41 = (_hx_local_19 * invDet)
        _hx_local_18._41
        _hx_local_20 = self
        _hx_local_21 = _hx_local_20._42
        _hx_local_20._42 = (_hx_local_21 * invDet)
        _hx_local_20._42
        _hx_local_22 = self
        _hx_local_23 = _hx_local_22._43
        _hx_local_22._43 = (_hx_local_23 * invDet)
        _hx_local_22._43

    def initInverse(self,m):
        m11 = m._11
        m12 = m._12
        m13 = m._13
        m14 = m._14
        m21 = m._21
        m22 = m._22
        m23 = m._23
        m24 = m._24
        m31 = m._31
        m32 = m._32
        m33 = m._33
        m34 = m._34
        m41 = m._41
        m42 = m._42
        m43 = m._43
        m44 = m._44
        self._11 = (((((((m22 * m33) * m44) - (((m22 * m34) * m43))) - (((m32 * m23) * m44))) + (((m32 * m24) * m43))) + (((m42 * m23) * m34))) - (((m42 * m24) * m33)))
        self._12 = (((((((-m12 * m33) * m44) + (((m12 * m34) * m43))) + (((m32 * m13) * m44))) - (((m32 * m14) * m43))) - (((m42 * m13) * m34))) + (((m42 * m14) * m33)))
        self._13 = (((((((m12 * m23) * m44) - (((m12 * m24) * m43))) - (((m22 * m13) * m44))) + (((m22 * m14) * m43))) + (((m42 * m13) * m24))) - (((m42 * m14) * m23)))
        self._14 = (((((((-m12 * m23) * m34) + (((m12 * m24) * m33))) + (((m22 * m13) * m34))) - (((m22 * m14) * m33))) - (((m32 * m13) * m24))) + (((m32 * m14) * m23)))
        self._21 = (((((((-m21 * m33) * m44) + (((m21 * m34) * m43))) + (((m31 * m23) * m44))) - (((m31 * m24) * m43))) - (((m41 * m23) * m34))) + (((m41 * m24) * m33)))
        self._22 = (((((((m11 * m33) * m44) - (((m11 * m34) * m43))) - (((m31 * m13) * m44))) + (((m31 * m14) * m43))) + (((m41 * m13) * m34))) - (((m41 * m14) * m33)))
        self._23 = (((((((-m11 * m23) * m44) + (((m11 * m24) * m43))) + (((m21 * m13) * m44))) - (((m21 * m14) * m43))) - (((m41 * m13) * m24))) + (((m41 * m14) * m23)))
        self._24 = (((((((m11 * m23) * m34) - (((m11 * m24) * m33))) - (((m21 * m13) * m34))) + (((m21 * m14) * m33))) + (((m31 * m13) * m24))) - (((m31 * m14) * m23)))
        self._31 = (((((((m21 * m32) * m44) - (((m21 * m34) * m42))) - (((m31 * m22) * m44))) + (((m31 * m24) * m42))) + (((m41 * m22) * m34))) - (((m41 * m24) * m32)))
        self._32 = (((((((-m11 * m32) * m44) + (((m11 * m34) * m42))) + (((m31 * m12) * m44))) - (((m31 * m14) * m42))) - (((m41 * m12) * m34))) + (((m41 * m14) * m32)))
        self._33 = (((((((m11 * m22) * m44) - (((m11 * m24) * m42))) - (((m21 * m12) * m44))) + (((m21 * m14) * m42))) + (((m41 * m12) * m24))) - (((m41 * m14) * m22)))
        self._34 = (((((((-m11 * m22) * m34) + (((m11 * m24) * m32))) + (((m21 * m12) * m34))) - (((m21 * m14) * m32))) - (((m31 * m12) * m24))) + (((m31 * m14) * m22)))
        self._41 = (((((((-m21 * m32) * m43) + (((m21 * m33) * m42))) + (((m31 * m22) * m43))) - (((m31 * m23) * m42))) - (((m41 * m22) * m33))) + (((m41 * m23) * m32)))
        self._42 = (((((((m11 * m32) * m43) - (((m11 * m33) * m42))) - (((m31 * m12) * m43))) + (((m31 * m13) * m42))) + (((m41 * m12) * m33))) - (((m41 * m13) * m32)))
        self._43 = (((((((-m11 * m22) * m43) + (((m11 * m23) * m42))) + (((m21 * m12) * m43))) - (((m21 * m13) * m42))) - (((m41 * m12) * m23))) + (((m41 * m13) * m22)))
        self._44 = (((((((m11 * m22) * m33) - (((m11 * m23) * m32))) - (((m21 * m12) * m33))) + (((m21 * m13) * m32))) + (((m31 * m12) * m23))) - (((m31 * m13) * m22)))
        det = ((((m11 * self._11) + ((m12 * self._21))) + ((m13 * self._31))) + ((m14 * self._41)))
        if (((-det if ((det < 0)) else det)) < 1e-10):
            self.zero()
            return
        det = (1.0 / det)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0._11
        _hx_local_0._11 = (_hx_local_1 * det)
        _hx_local_0._11
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2._12
        _hx_local_2._12 = (_hx_local_3 * det)
        _hx_local_2._12
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4._13
        _hx_local_4._13 = (_hx_local_5 * det)
        _hx_local_4._13
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6._14
        _hx_local_6._14 = (_hx_local_7 * det)
        _hx_local_6._14
        _hx_local_8 = self
        _hx_local_9 = _hx_local_8._21
        _hx_local_8._21 = (_hx_local_9 * det)
        _hx_local_8._21
        _hx_local_10 = self
        _hx_local_11 = _hx_local_10._22
        _hx_local_10._22 = (_hx_local_11 * det)
        _hx_local_10._22
        _hx_local_12 = self
        _hx_local_13 = _hx_local_12._23
        _hx_local_12._23 = (_hx_local_13 * det)
        _hx_local_12._23
        _hx_local_14 = self
        _hx_local_15 = _hx_local_14._24
        _hx_local_14._24 = (_hx_local_15 * det)
        _hx_local_14._24
        _hx_local_16 = self
        _hx_local_17 = _hx_local_16._31
        _hx_local_16._31 = (_hx_local_17 * det)
        _hx_local_16._31
        _hx_local_18 = self
        _hx_local_19 = _hx_local_18._32
        _hx_local_18._32 = (_hx_local_19 * det)
        _hx_local_18._32
        _hx_local_20 = self
        _hx_local_21 = _hx_local_20._33
        _hx_local_20._33 = (_hx_local_21 * det)
        _hx_local_20._33
        _hx_local_22 = self
        _hx_local_23 = _hx_local_22._34
        _hx_local_22._34 = (_hx_local_23 * det)
        _hx_local_22._34
        _hx_local_24 = self
        _hx_local_25 = _hx_local_24._41
        _hx_local_24._41 = (_hx_local_25 * det)
        _hx_local_24._41
        _hx_local_26 = self
        _hx_local_27 = _hx_local_26._42
        _hx_local_26._42 = (_hx_local_27 * det)
        _hx_local_26._42
        _hx_local_28 = self
        _hx_local_29 = _hx_local_28._43
        _hx_local_28._43 = (_hx_local_29 * det)
        _hx_local_28._43
        _hx_local_30 = self
        _hx_local_31 = _hx_local_30._44
        _hx_local_30._44 = (_hx_local_31 * det)
        _hx_local_30._44

    def initInverse3x3(self,m):
        m11 = m._11
        m12 = m._12
        m13 = m._13
        m21 = m._21
        m22 = m._22
        m23 = m._23
        m31 = m._31
        m32 = m._32
        m33 = m._33
        self._11 = ((m22 * m33) - ((m32 * m23)))
        self._12 = ((-m12 * m33) + ((m32 * m13)))
        self._13 = ((m12 * m23) - ((m22 * m13)))
        self._21 = ((-m21 * m33) + ((m31 * m23)))
        self._22 = ((m11 * m33) - ((m31 * m13)))
        self._23 = ((-m11 * m23) + ((m21 * m13)))
        self._31 = ((m21 * m32) - ((m31 * m22)))
        self._32 = ((-m11 * m32) + ((m31 * m12)))
        self._33 = ((m11 * m22) - ((m21 * m12)))
        det = (((m11 * self._11) + ((m12 * self._21))) + ((m13 * self._31)))
        if (((-det if ((det < 0)) else det)) < 1e-10):
            self.zero()
            return
        det = (1.0 / det)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0._11
        _hx_local_0._11 = (_hx_local_1 * det)
        _hx_local_0._11
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2._12
        _hx_local_2._12 = (_hx_local_3 * det)
        _hx_local_2._12
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4._13
        _hx_local_4._13 = (_hx_local_5 * det)
        _hx_local_4._13
        self._14 = 0
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6._21
        _hx_local_6._21 = (_hx_local_7 * det)
        _hx_local_6._21
        _hx_local_8 = self
        _hx_local_9 = _hx_local_8._22
        _hx_local_8._22 = (_hx_local_9 * det)
        _hx_local_8._22
        _hx_local_10 = self
        _hx_local_11 = _hx_local_10._23
        _hx_local_10._23 = (_hx_local_11 * det)
        _hx_local_10._23
        self._24 = 0
        _hx_local_12 = self
        _hx_local_13 = _hx_local_12._31
        _hx_local_12._31 = (_hx_local_13 * det)
        _hx_local_12._31
        _hx_local_14 = self
        _hx_local_15 = _hx_local_14._32
        _hx_local_14._32 = (_hx_local_15 * det)
        _hx_local_14._32
        _hx_local_16 = self
        _hx_local_17 = _hx_local_16._33
        _hx_local_16._33 = (_hx_local_17 * det)
        _hx_local_16._33
        self._34 = 0
        self._41 = 0
        self._42 = 0
        self._43 = 0
        self._44 = 1

    def front(self):
        v = h3d_Vector(self._11,self._12,self._13)
        f = (((v.x * v.x) + ((v.y * v.y))) + ((v.z * v.z)))
        k = (1. / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
        v.x = (v.x * k)
        v.y = (v.y * k)
        v.z = (v.z * k)
        return v

    def right(self):
        v = h3d_Vector(self._21,self._22,self._23)
        f = (((v.x * v.x) + ((v.y * v.y))) + ((v.z * v.z)))
        k = (1. / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
        v.x = (v.x * k)
        v.y = (v.y * k)
        v.z = (v.z * k)
        return v

    def up(self):
        v = h3d_Vector(self._31,self._32,self._33)
        f = (((v.x * v.x) + ((v.y * v.y))) + ((v.z * v.z)))
        k = (1. / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
        v.x = (v.x * k)
        v.y = (v.y * k)
        v.z = (v.z * k)
        return v

    def transpose(self):
        tmp = self._12
        self._12 = self._21
        self._21 = tmp
        tmp = self._13
        self._13 = self._31
        self._31 = tmp
        tmp = self._14
        self._14 = self._41
        self._41 = tmp
        tmp = self._23
        self._23 = self._32
        self._32 = tmp
        tmp = self._24
        self._24 = self._42
        self._42 = tmp
        tmp = self._34
        self._34 = self._43
        self._43 = tmp

    def clone(self):
        m = h3d_Matrix()
        m._11 = self._11
        m._12 = self._12
        m._13 = self._13
        m._14 = self._14
        m._21 = self._21
        m._22 = self._22
        m._23 = self._23
        m._24 = self._24
        m._31 = self._31
        m._32 = self._32
        m._33 = self._33
        m._34 = self._34
        m._41 = self._41
        m._42 = self._42
        m._43 = self._43
        m._44 = self._44
        return m

    def load(self,m):
        self._11 = m._11
        self._12 = m._12
        self._13 = m._13
        self._14 = m._14
        self._21 = m._21
        self._22 = m._22
        self._23 = m._23
        self._24 = m._24
        self._31 = m._31
        self._32 = m._32
        self._33 = m._33
        self._34 = m._34
        self._41 = m._41
        self._42 = m._42
        self._43 = m._43
        self._44 = m._44

    def loadValues(self,a):
        self._11 = (a[0] if 0 < len(a) else None)
        self._12 = (a[1] if 1 < len(a) else None)
        self._13 = (a[2] if 2 < len(a) else None)
        self._14 = (a[3] if 3 < len(a) else None)
        self._21 = (a[4] if 4 < len(a) else None)
        self._22 = (a[5] if 5 < len(a) else None)
        self._23 = (a[6] if 6 < len(a) else None)
        self._24 = (a[7] if 7 < len(a) else None)
        self._31 = (a[8] if 8 < len(a) else None)
        self._32 = (a[9] if 9 < len(a) else None)
        self._33 = (a[10] if 10 < len(a) else None)
        self._34 = (a[11] if 11 < len(a) else None)
        self._41 = (a[12] if 12 < len(a) else None)
        self._42 = (a[13] if 13 < len(a) else None)
        self._43 = (a[14] if 14 < len(a) else None)
        self._44 = (a[15] if 15 < len(a) else None)

    def getFloats(self):
        return [self._11, self._12, self._13, self._14, self._21, self._22, self._23, self._24, self._31, self._32, self._33, self._34, self._41, self._42, self._43, self._44]

    def getEulerAngles(self):
        m = self.clone()
        v = None
        if (v is None):
            v = h3d_Vector()
        f = (((self._11 * self._11) + ((self._12 * self._12))) + ((self._13 * self._13)))
        v.x = (Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))
        f1 = (((self._21 * self._21) + ((self._22 * self._22))) + ((self._23 * self._23)))
        v.y = (Math.NaN if ((f1 < 0)) else python_lib_Math.sqrt(f1))
        f2 = (((self._31 * self._31) + ((self._32 * self._32))) + ((self._33 * self._33)))
        v.z = (Math.NaN if ((f2 < 0)) else python_lib_Math.sqrt(f2))
        if ((((self._11 * (((self._22 * self._33) - ((self._23 * self._32))))) + ((self._12 * (((self._23 * self._31) - ((self._21 * self._33))))))) + ((self._13 * (((self._21 * self._32) - ((self._22 * self._31))))))) < 0):
            v.x = (v.x * -1)
            v.y = (v.y * -1)
            v.z = (v.z * -1)
        s = v
        m.prependScale((1.0 / s.x),(1.0 / s.y),(1.0 / s.z))
        f3 = ((m._11 * m._11) + ((m._12 * m._12)))
        cy = (Math.NaN if ((f3 < 0)) else python_lib_Math.sqrt(f3))
        if (cy > 0.01):
            v1 = h3d_Vector(Math.atan2(m._23,m._33),Math.atan2(-m._13,cy),Math.atan2(m._12,m._11))
            v2 = h3d_Vector(Math.atan2(-m._23,-m._33),Math.atan2(-m._13,-cy),Math.atan2(-m._12,-m._11))
            if ((((v1.x * v1.x) + ((v1.y * v1.y))) + ((v1.z * v1.z))) < ((((v2.x * v2.x) + ((v2.y * v2.y))) + ((v2.z * v2.z))))):
                return v1
            else:
                return v2
        else:
            return h3d_Vector(Math.atan2(-m._32,m._22),Math.atan2(-m._13,cy),0.0)

    def toString(self):
        return ((((((((((((((((((((((((((((((((((((("MAT=[\n" + "  [ ") + Std.string(hxd_Math.fmt(self._11))) + ", ") + Std.string(hxd_Math.fmt(self._12))) + ", ") + Std.string(hxd_Math.fmt(self._13))) + ", ") + Std.string(hxd_Math.fmt(self._14))) + " ]\n") + "  [ ") + Std.string(hxd_Math.fmt(self._21))) + ", ") + Std.string(hxd_Math.fmt(self._22))) + ", ") + Std.string(hxd_Math.fmt(self._23))) + ", ") + Std.string(hxd_Math.fmt(self._24))) + " ]\n") + "  [ ") + Std.string(hxd_Math.fmt(self._31))) + ", ") + Std.string(hxd_Math.fmt(self._32))) + ", ") + Std.string(hxd_Math.fmt(self._33))) + ", ") + Std.string(hxd_Math.fmt(self._34))) + " ]\n") + "  [ ") + Std.string(hxd_Math.fmt(self._41))) + ", ") + Std.string(hxd_Math.fmt(self._42))) + ", ") + Std.string(hxd_Math.fmt(self._43))) + ", ") + Std.string(hxd_Math.fmt(self._44))) + " ]\n") + "]")

    def colorHue(self,hue):
        if (hue == 0.):
            return
        f = -hue
        cosA = (Math.NaN if (((f == Math.POSITIVE_INFINITY) or ((f == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(f))
        f1 = -hue
        sinA = (Math.NaN if (((f1 == Math.POSITIVE_INFINITY) or ((f1 == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(f1))
        ch = (((1 - cosA)) / 3)
        tmp = h3d_Matrix.tmp
        tmp._11 = (cosA + ch)
        tmp._12 = (ch - ((0.57735026918962576450914878050196 * sinA)))
        tmp._13 = (ch + ((0.57735026918962576450914878050196 * sinA)))
        tmp._21 = (ch + ((0.57735026918962576450914878050196 * sinA)))
        tmp._22 = (cosA + ch)
        tmp._23 = (ch - ((0.57735026918962576450914878050196 * sinA)))
        tmp._31 = (ch - ((0.57735026918962576450914878050196 * sinA)))
        tmp._32 = (ch + ((0.57735026918962576450914878050196 * sinA)))
        tmp._33 = (cosA + ch)
        tmp._34 = 0
        tmp._41 = 0
        tmp._42 = 0
        tmp._43 = 0
        self.multiply3x4(self,tmp)

    def colorSaturate(self,sat):
        sat = (sat + 1)
        _hx_is = (1 - sat)
        r = (_hx_is * 0.212671)
        g = (_hx_is * 0.71516)
        b = (_hx_is * 0.072169)
        tmp = h3d_Matrix.tmp
        tmp._11 = (r + sat)
        tmp._12 = r
        tmp._13 = r
        tmp._21 = g
        tmp._22 = (g + sat)
        tmp._23 = g
        tmp._31 = b
        tmp._32 = b
        tmp._33 = (b + sat)
        tmp._41 = 0
        tmp._42 = 0
        tmp._43 = 0
        self.multiply3x4(self,tmp)

    def colorContrast(self,contrast):
        tmp = h3d_Matrix.tmp
        v = (contrast + 1)
        tmp._11 = v
        tmp._12 = 0
        tmp._13 = 0
        tmp._21 = 0
        tmp._22 = v
        tmp._23 = 0
        tmp._31 = 0
        tmp._32 = 0
        tmp._33 = v
        tmp._41 = (-contrast * 0.5)
        tmp._42 = (-contrast * 0.5)
        tmp._43 = (-contrast * 0.5)
        self.multiply3x4(self,tmp)

    def colorLightness(self,lightness):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0._41
        _hx_local_0._41 = (_hx_local_1 + lightness)
        _hx_local_0._41
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2._42
        _hx_local_2._42 = (_hx_local_3 + lightness)
        _hx_local_2._42
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4._43
        _hx_local_4._43 = (_hx_local_5 + lightness)
        _hx_local_4._43

    def colorGain(self,color,alpha):
        tmp = h3d_Matrix.tmp
        tmp._11 = (1 - alpha)
        tmp._12 = 0
        tmp._13 = 0
        tmp._21 = 0
        tmp._22 = (1 - alpha)
        tmp._23 = 0
        tmp._31 = 0
        tmp._32 = 0
        tmp._33 = (1 - alpha)
        tmp._41 = (((((color >> 16) & 255)) / 255) * alpha)
        tmp._42 = (((((color >> 8) & 255)) / 255) * alpha)
        tmp._43 = ((((color & 255)) / 255) * alpha)
        self.multiply3x4(self,tmp)

    def colorBits(self,bits,blend):
        t11 = 0.
        t12 = 0.
        t13 = 0.
        t21 = 0.
        t22 = 0.
        t23 = 0.
        t31 = 0.
        t32 = 0.
        t33 = 0.
        c = bits
        if (((c & 1)) == 1):
            t11 = 1
        c = (c >> 1)
        if (((c & 1)) == 1):
            t12 = 1
        c = (c >> 1)
        if (((c & 1)) == 1):
            t13 = 1
        c = (c >> 1)
        if (((c & 1)) == 1):
            t21 = 1
        c = (c >> 1)
        if (((c & 1)) == 1):
            t22 = 1
        c = (c >> 1)
        if (((c & 1)) == 1):
            t23 = 1
        c = (c >> 1)
        if (((c & 1)) == 1):
            t31 = 1
        c = (c >> 1)
        if (((c & 1)) == 1):
            t32 = 1
        c = (c >> 1)
        if (((c & 1)) == 1):
            t33 = 1
        c = (c >> 1)
        r = ((t11 + t21) + t31)
        g = ((t12 + t22) + t32)
        b = ((t13 + t23) + t33)
        if (r > 1):
            t11 = (t11 / r)
            t21 = (t21 / r)
            t31 = (t31 / r)
        if (g > 1):
            t12 = (t12 / g)
            t22 = (t22 / g)
            t32 = (t32 / g)
        if (b > 1):
            t13 = (t13 / b)
            t23 = (t23 / b)
            t33 = (t33 / b)
        b11 = (((self._11 * t11) + ((self._12 * t21))) + ((self._13 * t31)))
        b12 = (((self._11 * t12) + ((self._12 * t22))) + ((self._13 * t32)))
        b13 = (((self._11 * t13) + ((self._12 * t23))) + ((self._13 * t33)))
        b21 = (((self._21 * t11) + ((self._22 * t21))) + ((self._23 * t31)))
        b22 = (((self._21 * t12) + ((self._22 * t22))) + ((self._23 * t32)))
        b23 = (((self._21 * t13) + ((self._22 * t23))) + ((self._23 * t33)))
        b31 = (((self._31 * t11) + ((self._32 * t21))) + ((self._33 * t31)))
        b32 = (((self._31 * t12) + ((self._32 * t22))) + ((self._33 * t32)))
        b33 = (((self._31 * t13) + ((self._32 * t23))) + ((self._33 * t33)))
        ik = blend
        k = (1 - ik)
        self._11 = ((self._11 * k) + ((b11 * ik)))
        self._12 = ((self._12 * k) + ((b12 * ik)))
        self._13 = ((self._13 * k) + ((b13 * ik)))
        self._21 = ((self._21 * k) + ((b21 * ik)))
        self._22 = ((self._22 * k) + ((b22 * ik)))
        self._23 = ((self._23 * k) + ((b23 * ik)))
        self._31 = ((self._31 * k) + ((b31 * ik)))
        self._32 = ((self._32 * k) + ((b32 * ik)))
        self._33 = ((self._33 * k) + ((b33 * ik)))

    def colorAdd(self,c):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0._41
        _hx_local_0._41 = (_hx_local_1 + (((((c >> 16) & 255)) / 255)))
        _hx_local_0._41
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2._42
        _hx_local_2._42 = (_hx_local_3 + (((((c >> 8) & 255)) / 255)))
        _hx_local_2._42
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4._43
        _hx_local_4._43 = (_hx_local_5 + ((((c & 255)) / 255)))
        _hx_local_4._43

    def colorSet(self,c,alpha = None):
        if (alpha is None):
            alpha = 1.
        self.zero()
        self._44 = alpha
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0._41
        _hx_local_0._41 = (_hx_local_1 + (((((c >> 16) & 255)) / 255)))
        _hx_local_0._41
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2._42
        _hx_local_2._42 = (_hx_local_3 + (((((c >> 8) & 255)) / 255)))
        _hx_local_2._42
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4._43
        _hx_local_4._43 = (_hx_local_5 + ((((c & 255)) / 255)))
        _hx_local_4._43

    def adjustColor(self,col):
        if (Reflect.field(col,"hue") is not None):
            self.colorHue(Reflect.field(col,"hue"))
        if (Reflect.field(col,"saturation") is not None):
            self.colorSaturate(Reflect.field(col,"saturation"))
        if (Reflect.field(col,"contrast") is not None):
            self.colorContrast(Reflect.field(col,"contrast"))
        if (Reflect.field(col,"lightness") is not None):
            self.colorLightness(Reflect.field(col,"lightness"))
        if (Reflect.field(col,"gain") is not None):
            self.colorGain(Reflect.field(col,"gain").color,Reflect.field(col,"gain").alpha)

    @staticmethod
    def I():
        m = h3d_Matrix()
        m.identity()
        return m

    @staticmethod
    def L(a):
        m = h3d_Matrix()
        m.loadValues(a)
        return m

    @staticmethod
    def T(x = None,y = None,z = None):
        if (x is None):
            x = 0.
        if (y is None):
            y = 0.
        if (z is None):
            z = 0.
        m = h3d_Matrix()
        m.initTranslation(x,y,z)
        return m

    @staticmethod
    def R(x,y,z):
        m = h3d_Matrix()
        m.initRotation(x,y,z)
        return m

    @staticmethod
    def S(x = None,y = None,z = None):
        if (x is None):
            x = 1.
        if (y is None):
            y = 1.
        if (z is None):
            z = 1.0
        m = h3d_Matrix()
        m.initScale(x,y,z)
        return m

    @staticmethod
    def lookAtX(dir,up = None,m = None):
        if (up is None):
            up = h3d_Vector(0,0,1)
        if (m is None):
            m = h3d_Matrix()
        k = (((dir.x * dir.x) + ((dir.y * dir.y))) + ((dir.z * dir.z)))
        if (k < 1e-10):
            k = 0
        else:
            k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
        x = (dir.x * k)
        y = (dir.y * k)
        z = (dir.z * k)
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        ax_x = x
        ax_y = y
        ax_z = z
        ax_w = 1.
        x1 = ((up.y * ax_z) - ((up.z * ax_y)))
        y1 = ((up.z * ax_x) - ((up.x * ax_z)))
        z1 = ((up.x * ax_y) - ((up.y * ax_x)))
        w = 1
        if (w is None):
            w = 1.
        if (z1 is None):
            z1 = 0.
        if (y1 is None):
            y1 = 0.
        if (x1 is None):
            x1 = 0.
        _this_x = x1
        _this_y = y1
        _this_z = z1
        _this_w = w
        k1 = (((_this_x * _this_x) + ((_this_y * _this_y))) + ((_this_z * _this_z)))
        if (k1 < 1e-10):
            k1 = 0
        else:
            k1 = (1. / ((Math.NaN if ((k1 < 0)) else python_lib_Math.sqrt(k1))))
        x2 = (_this_x * k1)
        y2 = (_this_y * k1)
        z2 = (_this_z * k1)
        if (z2 is None):
            z2 = 0.
        if (y2 is None):
            y2 = 0.
        if (x2 is None):
            x2 = 0.
        ay_x = x2
        ay_y = y2
        ay_z = z2
        ay_w = 1.
        if ((((ay_x * ay_x) + ((ay_y * ay_y))) + ((ay_z * ay_z))) < 1e-10):
            ay_x = ax_y
            ay_y = ax_z
            ay_z = ax_x
        x3 = ((ax_y * ay_z) - ((ax_z * ay_y)))
        y3 = ((ax_z * ay_x) - ((ax_x * ay_z)))
        z3 = ((ax_x * ay_y) - ((ax_y * ay_x)))
        w1 = 1
        if (w1 is None):
            w1 = 1.
        if (z3 is None):
            z3 = 0.
        if (y3 is None):
            y3 = 0.
        if (x3 is None):
            x3 = 0.
        az_x = x3
        az_y = y3
        az_z = z3
        az_w = w1
        m._11 = ax_x
        m._12 = ax_y
        m._13 = ax_z
        m._14 = 0
        m._21 = ay_x
        m._22 = ay_y
        m._23 = ay_z
        m._24 = 0
        m._31 = az_x
        m._32 = az_y
        m._33 = az_z
        m._34 = 0
        m._41 = 0
        m._42 = 0
        m._43 = 0
        m._44 = 1
        return m

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o._11 = None
        _hx_o._12 = None
        _hx_o._13 = None
        _hx_o._14 = None
        _hx_o._21 = None
        _hx_o._22 = None
        _hx_o._23 = None
        _hx_o._24 = None
        _hx_o._31 = None
        _hx_o._32 = None
        _hx_o._33 = None
        _hx_o._34 = None
        _hx_o._41 = None
        _hx_o._42 = None
        _hx_o._43 = None
        _hx_o._44 = None
h3d_Matrix._hx_class = h3d_Matrix
_hx_classes["h3d.Matrix"] = h3d_Matrix


class h3d_Quat:
    _hx_class_name = "h3d.Quat"
    _hx_is_interface = "False"
    __slots__ = ("x", "y", "z", "w")
    _hx_fields = ["x", "y", "z", "w"]
    _hx_methods = ["set", "identity", "lengthSq", "length", "load", "clone", "initMoveTo", "initDirection", "initRotateAxis", "initRotateMatrix", "normalize", "initRotation", "multiply", "toEuler", "lerp", "slerp", "conjugate", "negate", "dot", "getDirection", "toMatrix", "toString"]

    def __init__(self,x = None,y = None,z = None,w = None):
        if (x is None):
            x = 0.
        if (y is None):
            y = 0.
        if (z is None):
            z = 0.
        if (w is None):
            w = 1.
        self.x = x
        self.y = y
        self.z = z
        self.w = w

    def set(self,x,y,z,w):
        self.x = x
        self.y = y
        self.z = z
        self.w = w

    def identity(self):
        def _hx_local_1():
            def _hx_local_0():
                self.z = 0
                return self.z
            self.y = _hx_local_0()
            return self.y
        self.x = _hx_local_1()
        self.w = 1

    def lengthSq(self):
        return ((((self.x * self.x) + ((self.y * self.y))) + ((self.z * self.z))) + ((self.w * self.w)))

    def length(self):
        f = ((((self.x * self.x) + ((self.y * self.y))) + ((self.z * self.z))) + ((self.w * self.w)))
        if (f < 0):
            return Math.NaN
        else:
            return python_lib_Math.sqrt(f)

    def load(self,q):
        self.x = q.x
        self.y = q.y
        self.z = q.z
        self.w = q.w

    def clone(self):
        return h3d_Quat(self.x,self.y,self.z,self.w)

    def initMoveTo(self,_hx_from,to):
        hx = (_hx_from.x + to.x)
        hy = (_hx_from.y + to.y)
        hz = (_hx_from.z + to.z)
        f = (((hx * hx) + ((hy * hy))) + ((hz * hz)))
        h = (1. / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
        self.x = ((_hx_from.y * hz) - ((_hx_from.z * hy)))
        self.y = ((_hx_from.z * hx) - ((_hx_from.x * hz)))
        self.z = ((_hx_from.x * hy) - ((_hx_from.y * hx)))
        self.w = (((_hx_from.x * hx) + ((_hx_from.y * hy))) + ((_hx_from.z * hz)))
        self.normalize()

    def initDirection(self,dir):
        x = dir.x
        y = dir.y
        z = dir.z
        w = dir.w
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this_x = x
        _this_y = y
        _this_z = z
        _this_w = w
        k = (((_this_x * _this_x) + ((_this_y * _this_y))) + ((_this_z * _this_z)))
        if (k < 1e-10):
            k = 0
        else:
            k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
        x1 = (_this_x * k)
        y1 = (_this_y * k)
        z1 = (_this_z * k)
        if (z1 is None):
            z1 = 0.
        if (y1 is None):
            y1 = 0.
        if (x1 is None):
            x1 = 0.
        ax_x = x1
        ax_y = y1
        ax_z = z1
        ax_w = 1.
        x2 = -ax_y
        y2 = ax_x
        z2 = 0
        if (z2 is None):
            z2 = 0.
        if (y2 is None):
            y2 = 0.
        if (x2 is None):
            x2 = 0.
        _this_x1 = x2
        _this_y1 = y2
        _this_z1 = z2
        _this_w1 = 1.
        k1 = (((_this_x1 * _this_x1) + ((_this_y1 * _this_y1))) + ((_this_z1 * _this_z1)))
        if (k1 < 1e-10):
            k1 = 0
        else:
            k1 = (1. / ((Math.NaN if ((k1 < 0)) else python_lib_Math.sqrt(k1))))
        x3 = (_this_x1 * k1)
        y3 = (_this_y1 * k1)
        z3 = (_this_z1 * k1)
        if (z3 is None):
            z3 = 0.
        if (y3 is None):
            y3 = 0.
        if (x3 is None):
            x3 = 0.
        ay_x = x3
        ay_y = y3
        ay_z = z3
        ay_w = 1.
        if ((((ay_x * ay_x) + ((ay_y * ay_y))) + ((ay_z * ay_z))) < 1e-10):
            ay_x = ax_y
            ay_y = ax_z
            ay_z = ax_x
        x4 = ((ax_y * ay_z) - ((ax_z * ay_y)))
        y4 = ((ax_z * ay_x) - ((ax_x * ay_z)))
        z4 = ((ax_x * ay_y) - ((ax_y * ay_x)))
        w1 = 1
        if (w1 is None):
            w1 = 1.
        if (z4 is None):
            z4 = 0.
        if (y4 is None):
            y4 = 0.
        if (x4 is None):
            x4 = 0.
        az_x = x4
        az_y = y4
        az_z = z4
        az_w = w1
        tr = ((ax_x + ay_y) + az_z)
        if (tr > 0):
            f = (tr + 1.0)
            s = (((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))) * 2)
            _hx_is = (1 / s)
            self.x = (((ay_z - az_y)) * _hx_is)
            self.y = (((az_x - ax_z)) * _hx_is)
            self.z = (((ax_y - ay_x)) * _hx_is)
            self.w = (0.25 * s)
        elif ((ax_x > ay_y) and ((ax_x > az_z))):
            f1 = (((1.0 + ax_x) - ay_y) - az_z)
            s1 = (((Math.NaN if ((f1 < 0)) else python_lib_Math.sqrt(f1))) * 2)
            is1 = (1 / s1)
            self.x = (0.25 * s1)
            self.y = (((ay_x + ax_y)) * is1)
            self.z = (((az_x + ax_z)) * is1)
            self.w = (((ay_z - az_y)) * is1)
        elif (ay_y > az_z):
            f2 = (((1.0 + ay_y) - ax_x) - az_z)
            s2 = (((Math.NaN if ((f2 < 0)) else python_lib_Math.sqrt(f2))) * 2)
            is2 = (1 / s2)
            self.x = (((ay_x + ax_y)) * is2)
            self.y = (0.25 * s2)
            self.z = (((az_y + ay_z)) * is2)
            self.w = (((az_x - ax_z)) * is2)
        else:
            f3 = (((1.0 + az_z) - ax_x) - ay_y)
            s3 = (((Math.NaN if ((f3 < 0)) else python_lib_Math.sqrt(f3))) * 2)
            is3 = (1 / s3)
            self.x = (((az_x + ax_z)) * is3)
            self.y = (((az_y + ay_z)) * is3)
            self.z = (0.25 * s3)
            self.w = (((ax_y - ay_x)) * is3)

    def initRotateAxis(self,x,y,z,a):
        f = (a / 2)
        sin = (Math.NaN if (((f == Math.POSITIVE_INFINITY) or ((f == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(f))
        f1 = (a / 2)
        cos = (Math.NaN if (((f1 == Math.POSITIVE_INFINITY) or ((f1 == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(f1))
        self.x = (x * sin)
        self.y = (y * sin)
        self.z = (z * sin)
        f2 = (((x * x) + ((y * y))) + ((z * z)))
        self.w = (cos * ((Math.NaN if ((f2 < 0)) else python_lib_Math.sqrt(f2))))
        self.normalize()

    def initRotateMatrix(self,m):
        tr = ((m._11 + m._22) + m._33)
        if (tr > 0):
            f = (tr + 1.0)
            s = (((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))) * 2)
            _hx_is = (1 / s)
            self.x = (((m._23 - m._32)) * _hx_is)
            self.y = (((m._31 - m._13)) * _hx_is)
            self.z = (((m._12 - m._21)) * _hx_is)
            self.w = (0.25 * s)
        elif ((m._11 > m._22) and ((m._11 > m._33))):
            f1 = (((1.0 + m._11) - m._22) - m._33)
            s1 = (((Math.NaN if ((f1 < 0)) else python_lib_Math.sqrt(f1))) * 2)
            is1 = (1 / s1)
            self.x = (0.25 * s1)
            self.y = (((m._21 + m._12)) * is1)
            self.z = (((m._31 + m._13)) * is1)
            self.w = (((m._23 - m._32)) * is1)
        elif (m._22 > m._33):
            f2 = (((1.0 + m._22) - m._11) - m._33)
            s2 = (((Math.NaN if ((f2 < 0)) else python_lib_Math.sqrt(f2))) * 2)
            is2 = (1 / s2)
            self.x = (((m._21 + m._12)) * is2)
            self.y = (0.25 * s2)
            self.z = (((m._32 + m._23)) * is2)
            self.w = (((m._31 - m._13)) * is2)
        else:
            f3 = (((1.0 + m._33) - m._11) - m._22)
            s3 = (((Math.NaN if ((f3 < 0)) else python_lib_Math.sqrt(f3))) * 2)
            is3 = (1 / s3)
            self.x = (((m._31 + m._13)) * is3)
            self.y = (((m._32 + m._23)) * is3)
            self.z = (0.25 * s3)
            self.w = (((m._12 - m._21)) * is3)

    def normalize(self):
        _hx_len = ((((self.x * self.x) + ((self.y * self.y))) + ((self.z * self.z))) + ((self.w * self.w)))
        if (_hx_len < 1e-10):
            def _hx_local_1():
                def _hx_local_0():
                    self.z = 0
                    return self.z
                self.y = _hx_local_0()
                return self.y
            self.x = _hx_local_1()
            self.w = 1
        else:
            m = (1. / ((Math.NaN if ((_hx_len < 0)) else python_lib_Math.sqrt(_hx_len))))
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.x
            _hx_local_2.x = (_hx_local_3 * m)
            _hx_local_2.x
            _hx_local_4 = self
            _hx_local_5 = _hx_local_4.y
            _hx_local_4.y = (_hx_local_5 * m)
            _hx_local_4.y
            _hx_local_6 = self
            _hx_local_7 = _hx_local_6.z
            _hx_local_6.z = (_hx_local_7 * m)
            _hx_local_6.z
            _hx_local_8 = self
            _hx_local_9 = _hx_local_8.w
            _hx_local_8.w = (_hx_local_9 * m)
            _hx_local_8.w

    def initRotation(self,ax,ay,az):
        f = (ax * 0.5)
        sinX = (Math.NaN if (((f == Math.POSITIVE_INFINITY) or ((f == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(f))
        f1 = (ax * 0.5)
        cosX = (Math.NaN if (((f1 == Math.POSITIVE_INFINITY) or ((f1 == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(f1))
        f2 = (ay * 0.5)
        sinY = (Math.NaN if (((f2 == Math.POSITIVE_INFINITY) or ((f2 == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(f2))
        f3 = (ay * 0.5)
        cosY = (Math.NaN if (((f3 == Math.POSITIVE_INFINITY) or ((f3 == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(f3))
        f4 = (az * 0.5)
        sinZ = (Math.NaN if (((f4 == Math.POSITIVE_INFINITY) or ((f4 == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(f4))
        f5 = (az * 0.5)
        cosZ = (Math.NaN if (((f5 == Math.POSITIVE_INFINITY) or ((f5 == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(f5))
        cosYZ = (cosY * cosZ)
        sinYZ = (sinY * sinZ)
        self.x = ((sinX * cosYZ) - ((cosX * sinYZ)))
        self.y = (((cosX * sinY) * cosZ) + (((sinX * cosY) * sinZ)))
        self.z = (((cosX * cosY) * sinZ) - (((sinX * sinY) * cosZ)))
        self.w = ((cosX * cosYZ) + ((sinX * sinYZ)))

    def multiply(self,q1,q2):
        x2 = ((((q1.x * q2.w) + ((q1.w * q2.x))) + ((q1.y * q2.z))) - ((q1.z * q2.y)))
        y2 = ((((q1.w * q2.y) - ((q1.x * q2.z))) + ((q1.y * q2.w))) + ((q1.z * q2.x)))
        z2 = ((((q1.w * q2.z) + ((q1.x * q2.y))) - ((q1.y * q2.x))) + ((q1.z * q2.w)))
        w2 = ((((q1.w * q2.w) - ((q1.x * q2.x))) - ((q1.y * q2.y))) - ((q1.z * q2.z)))
        self.x = x2
        self.y = y2
        self.z = z2
        self.w = w2

    def toEuler(self):
        return self.toMatrix().getEulerAngles()

    def lerp(self,q1,q2,v,nearest = None):
        if (nearest is None):
            nearest = False
        v2 = None
        if (nearest and ((((((q1.x * q2.x) + ((q1.y * q2.y))) + ((q1.z * q2.z))) + ((q1.w * q2.w))) < 0))):
            v2 = (v - 1)
        else:
            v2 = (1 - v)
        x = ((q1.x * v) + ((q2.x * v2)))
        y = ((q1.y * v) + ((q2.y * v2)))
        z = ((q1.z * v) + ((q2.z * v2)))
        w = ((q1.w * v) + ((q2.w * v2)))
        self.x = x
        self.y = y
        self.z = z
        self.w = w

    def slerp(self,q1,q2,v):
        cosHalfTheta = ((((q1.x * q2.x) + ((q1.y * q2.y))) + ((q1.z * q2.z))) + ((q1.w * q2.w)))
        if (((-cosHalfTheta if ((cosHalfTheta < 0)) else cosHalfTheta)) >= 1):
            self.x = q1.x
            self.y = q1.y
            self.z = q1.z
            self.w = q1.w
            return
        halfTheta = Math.acos(cosHalfTheta)
        f = (1 - ((cosHalfTheta * cosHalfTheta)))
        invSinHalfTheta = (1. / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
        if (((-invSinHalfTheta if ((invSinHalfTheta < 0)) else invSinHalfTheta)) > 1e3):
            nearest = True
            if (nearest is None):
                nearest = False
            v2 = None
            if (nearest and ((((((q1.x * q2.x) + ((q1.y * q2.y))) + ((q1.z * q2.z))) + ((q1.w * q2.w))) < 0))):
                v2 = -0.5
            else:
                v2 = 0.5
            x = ((q1.x * 0.5) + ((q2.x * v2)))
            y = ((q1.y * 0.5) + ((q2.y * v2)))
            z = ((q1.z * 0.5) + ((q2.z * v2)))
            w = ((q1.w * 0.5) + ((q2.w * v2)))
            self.x = x
            self.y = y
            self.z = z
            self.w = w
            return
        f1 = (((1 - v)) * halfTheta)
        a = (((Math.NaN if (((f1 == Math.POSITIVE_INFINITY) or ((f1 == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(f1))) * invSinHalfTheta)
        f2 = (v * halfTheta)
        b = ((((Math.NaN if (((f2 == Math.POSITIVE_INFINITY) or ((f2 == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(f2))) * invSinHalfTheta) * ((-1 if ((cosHalfTheta < 0)) else 1)))
        self.x = ((q1.x * a) + ((q2.x * b)))
        self.y = ((q1.y * a) + ((q2.y * b)))
        self.z = ((q1.z * a) + ((q2.z * b)))
        self.w = ((q1.w * a) + ((q2.w * b)))

    def conjugate(self):
        self.x = -self.x
        self.y = -self.y
        self.z = -self.z

    def negate(self):
        self.x = -self.x
        self.y = -self.y
        self.z = -self.z
        self.w = -self.w

    def dot(self,q):
        return ((((self.x * q.x) + ((self.y * q.y))) + ((self.z * q.z))) + ((self.w * q.w)))

    def getDirection(self):
        return h3d_Vector((1 - ((2 * (((self.y * self.y) + ((self.z * self.z))))))),(2 * (((self.x * self.y) - ((self.z * self.w))))),(2 * (((self.x * self.z) + ((self.y * self.w))))))

    def toMatrix(self,m = None):
        if (m is None):
            m = h3d_Matrix()
        xx = (self.x * self.x)
        xy = (self.x * self.y)
        xz = (self.x * self.z)
        xw = (self.x * self.w)
        yy = (self.y * self.y)
        yz = (self.y * self.z)
        yw = (self.y * self.w)
        zz = (self.z * self.z)
        zw = (self.z * self.w)
        m._11 = (1 - ((2 * ((yy + zz)))))
        m._12 = (2 * ((xy + zw)))
        m._13 = (2 * ((xz - yw)))
        m._14 = 0
        m._21 = (2 * ((xy - zw)))
        m._22 = (1 - ((2 * ((xx + zz)))))
        m._23 = (2 * ((yz + xw)))
        m._24 = 0
        m._31 = (2 * ((xz + yw)))
        m._32 = (2 * ((yz - xw)))
        m._33 = (1 - ((2 * ((xx + yy)))))
        m._34 = 0
        m._41 = 0
        m._42 = 0
        m._43 = 0
        m._44 = 1
        return m

    def toString(self):
        return (((((((("{" + Std.string(hxd_Math.fmt(self.x))) + ",") + Std.string(hxd_Math.fmt(self.y))) + ",") + Std.string(hxd_Math.fmt(self.z))) + ",") + Std.string(hxd_Math.fmt(self.w))) + "}")

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.x = None
        _hx_o.y = None
        _hx_o.z = None
        _hx_o.w = None
h3d_Quat._hx_class = h3d_Quat
_hx_classes["h3d.Quat"] = h3d_Quat


class h3d_Vector:
    _hx_class_name = "h3d.Vector"
    _hx_is_interface = "False"
    __slots__ = ("x", "y", "z", "w")
    _hx_fields = ["x", "y", "z", "w"]
    _hx_methods = ["distance", "distanceSq", "sub", "add", "cross", "reflect", "dot3", "dot4", "lengthSq", "length", "normalize", "normalizeFast", "getNormalized", "set", "load", "scale3", "project", "lerp", "transform3x4", "transform3x3", "transform", "clone", "toPoint", "toString", "get_r", "get_g", "get_b", "get_a", "set_r", "set_g", "set_b", "set_a", "setColor", "makeColor", "toColor", "toColorHSL"]
    _hx_statics = ["fromColor", "fromArray"]

    def __init__(self,x = None,y = None,z = None,w = None):
        if (x is None):
            x = 0.
        if (y is None):
            y = 0.
        if (z is None):
            z = 0.
        if (w is None):
            w = 1.
        self.x = x
        self.y = y
        self.z = z
        self.w = w

    def distance(self,v):
        dx = (v.x - self.x)
        dy = (v.y - self.y)
        dz = (v.z - self.z)
        f = (((dx * dx) + ((dy * dy))) + ((dz * dz)))
        if (f < 0):
            return Math.NaN
        else:
            return python_lib_Math.sqrt(f)

    def distanceSq(self,v):
        dx = (v.x - self.x)
        dy = (v.y - self.y)
        dz = (v.z - self.z)
        return (((dx * dx) + ((dy * dy))) + ((dz * dz)))

    def sub(self,v):
        return h3d_Vector((self.x - v.x),(self.y - v.y),(self.z - v.z),(self.w - v.w))

    def add(self,v):
        return h3d_Vector((self.x + v.x),(self.y + v.y),(self.z + v.z),(self.w + v.w))

    def cross(self,v):
        return h3d_Vector(((self.y * v.z) - ((self.z * v.y))),((self.z * v.x) - ((self.x * v.z))),((self.x * v.y) - ((self.y * v.x))),1)

    def reflect(self,n):
        k = (2 * ((((self.x * n.x) + ((self.y * n.y))) + ((self.z * n.z)))))
        return h3d_Vector((self.x - ((k * n.x))),(self.y - ((k * n.y))),(self.z - ((k * n.z))),1)

    def dot3(self,v):
        return (((self.x * v.x) + ((self.y * v.y))) + ((self.z * v.z)))

    def dot4(self,v):
        return ((((self.x * v.x) + ((self.y * v.y))) + ((self.z * v.z))) + ((self.w * v.w)))

    def lengthSq(self):
        return (((self.x * self.x) + ((self.y * self.y))) + ((self.z * self.z)))

    def length(self):
        f = (((self.x * self.x) + ((self.y * self.y))) + ((self.z * self.z)))
        if (f < 0):
            return Math.NaN
        else:
            return python_lib_Math.sqrt(f)

    def normalize(self):
        k = (((self.x * self.x) + ((self.y * self.y))) + ((self.z * self.z)))
        if (k < 1e-10):
            k = 0
        else:
            k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.x
        _hx_local_0.x = (_hx_local_1 * k)
        _hx_local_0.x
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.y
        _hx_local_2.y = (_hx_local_3 * k)
        _hx_local_2.y
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.z
        _hx_local_4.z = (_hx_local_5 * k)
        _hx_local_4.z

    def normalizeFast(self):
        f = (((self.x * self.x) + ((self.y * self.y))) + ((self.z * self.z)))
        k = (1. / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.x
        _hx_local_0.x = (_hx_local_1 * k)
        _hx_local_0.x
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.y
        _hx_local_2.y = (_hx_local_3 * k)
        _hx_local_2.y
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.z
        _hx_local_4.z = (_hx_local_5 * k)
        _hx_local_4.z

    def getNormalized(self):
        k = (((self.x * self.x) + ((self.y * self.y))) + ((self.z * self.z)))
        if (k < 1e-10):
            k = 0
        else:
            k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
        return h3d_Vector((self.x * k),(self.y * k),(self.z * k))

    def set(self,x = None,y = None,z = None,w = None):
        if (x is None):
            x = 0.
        if (y is None):
            y = 0.
        if (z is None):
            z = 0.
        if (w is None):
            w = 1.
        self.x = x
        self.y = y
        self.z = z
        self.w = w

    def load(self,v):
        self.x = v.x
        self.y = v.y
        self.z = v.z
        self.w = v.w

    def scale3(self,f):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.x
        _hx_local_0.x = (_hx_local_1 * f)
        _hx_local_0.x
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.y
        _hx_local_2.y = (_hx_local_3 * f)
        _hx_local_2.y
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.z
        _hx_local_4.z = (_hx_local_5 * f)
        _hx_local_4.z

    def project(self,m):
        px = ((((self.x * m._11) + ((self.y * m._21))) + ((self.z * m._31))) + ((self.w * m._41)))
        py = ((((self.x * m._12) + ((self.y * m._22))) + ((self.z * m._32))) + ((self.w * m._42)))
        pz = ((((self.x * m._13) + ((self.y * m._23))) + ((self.z * m._33))) + ((self.w * m._43)))
        iw = (1 / (((((self.x * m._14) + ((self.y * m._24))) + ((self.z * m._34))) + ((self.w * m._44)))))
        self.x = (px * iw)
        self.y = (py * iw)
        self.z = (pz * iw)
        self.w = 1

    def lerp(self,v1,v2,k):
        a = v1.x
        x = (a + ((k * ((v2.x - a)))))
        a1 = v1.y
        y = (a1 + ((k * ((v2.y - a1)))))
        a2 = v1.z
        z = (a2 + ((k * ((v2.z - a2)))))
        a3 = v1.w
        w = (a3 + ((k * ((v2.w - a3)))))
        self.x = x
        self.y = y
        self.z = z
        self.w = w

    def transform3x4(self,m):
        px = ((((self.x * m._11) + ((self.y * m._21))) + ((self.z * m._31))) + ((self.w * m._41)))
        py = ((((self.x * m._12) + ((self.y * m._22))) + ((self.z * m._32))) + ((self.w * m._42)))
        pz = ((((self.x * m._13) + ((self.y * m._23))) + ((self.z * m._33))) + ((self.w * m._43)))
        self.x = px
        self.y = py
        self.z = pz

    def transform3x3(self,m):
        px = (((self.x * m._11) + ((self.y * m._21))) + ((self.z * m._31)))
        py = (((self.x * m._12) + ((self.y * m._22))) + ((self.z * m._32)))
        pz = (((self.x * m._13) + ((self.y * m._23))) + ((self.z * m._33)))
        self.x = px
        self.y = py
        self.z = pz

    def transform(self,m):
        px = ((((self.x * m._11) + ((self.y * m._21))) + ((self.z * m._31))) + ((self.w * m._41)))
        py = ((((self.x * m._12) + ((self.y * m._22))) + ((self.z * m._32))) + ((self.w * m._42)))
        pz = ((((self.x * m._13) + ((self.y * m._23))) + ((self.z * m._33))) + ((self.w * m._43)))
        pw = ((((self.x * m._14) + ((self.y * m._24))) + ((self.z * m._34))) + ((self.w * m._44)))
        self.x = px
        self.y = py
        self.z = pz
        self.w = pw

    def clone(self):
        return h3d_Vector(self.x,self.y,self.z,self.w)

    def toPoint(self):
        return h3d_col_Point(self.x,self.y,self.z)

    def toString(self):
        return (((((((("{" + Std.string(hxd_Math.fmt(self.x))) + ",") + Std.string(hxd_Math.fmt(self.y))) + ",") + Std.string(hxd_Math.fmt(self.z))) + ",") + Std.string(hxd_Math.fmt(self.w))) + "}")

    def get_r(self):
        return self.x

    def get_g(self):
        return self.y

    def get_b(self):
        return self.z

    def get_a(self):
        return self.w

    def set_r(self,v):
        def _hx_local_1():
            def _hx_local_0():
                self.x = v
                return self.x
            return _hx_local_0()
        return _hx_local_1()

    def set_g(self,v):
        def _hx_local_1():
            def _hx_local_0():
                self.y = v
                return self.y
            return _hx_local_0()
        return _hx_local_1()

    def set_b(self,v):
        def _hx_local_1():
            def _hx_local_0():
                self.z = v
                return self.z
            return _hx_local_0()
        return _hx_local_1()

    def set_a(self,v):
        def _hx_local_1():
            def _hx_local_0():
                self.w = v
                return self.w
            return _hx_local_0()
        return _hx_local_1()

    def setColor(self,c):
        self.x = ((((c >> 16) & 255)) / 255)
        self.y = ((((c >> 8) & 255)) / 255)
        self.z = (((c & 255)) / 255)
        self.w = ((HxOverrides.rshift(c, 24)) / 255)

    def makeColor(self,hue,saturation = None,brightness = None):
        if (saturation is None):
            saturation = 1.
        if (brightness is None):
            brightness = 0.5
        r = HxOverrides.modf(hue, 6.28318530717958623)
        hue = (r if ((r >= 0)) else (r + 6.28318530717958623))
        f = ((2 * brightness) - 1)
        c = (((1 - ((-f if ((f < 0)) else f)))) * saturation)
        f1 = (HxOverrides.modf(((hue * 3) / 3.14159265358979323), 2.) - 1)
        x = (c * ((1 - ((-f1 if ((f1 < 0)) else f1)))))
        m = (brightness - ((c / 2)))
        if (hue < 1.04719755119659763):
            self.x = c
            self.y = x
            self.z = 0
        elif (hue < 2.09439510239319526):
            self.x = x
            self.y = c
            self.z = 0
        elif (hue < 3.14159265358979323):
            self.x = 0
            self.y = c
            self.z = x
        elif (hue < 4.18879020478639053):
            self.x = 0
            self.y = x
            self.z = c
        elif (hue < 5.23598775598298882):
            self.x = x
            self.y = 0
            self.z = c
        else:
            self.x = c
            self.y = 0
            self.z = x
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.x
        _hx_local_0.x = (_hx_local_1 + m)
        _hx_local_0.x
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.y
        _hx_local_2.y = (_hx_local_3 + m)
        _hx_local_2.y
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.z
        _hx_local_4.z = (_hx_local_5 + m)
        _hx_local_4.z
        self.w = 1

    def toColor(self):
        f = self.w
        x = ((((0. if ((f < 0.)) else (1. if ((f > 1.)) else f))) * 255) + 0.499)
        tmp = None
        try:
            tmp = int(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            tmp = None
        tmp1 = (tmp << 24)
        f1 = self.x
        x1 = ((((0. if ((f1 < 0.)) else (1. if ((f1 > 1.)) else f1))) * 255) + 0.499)
        tmp2 = None
        try:
            tmp2 = int(x1)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e1 = _hx_e1
            tmp2 = None
        tmp3 = (tmp1 | ((tmp2 << 16)))
        f2 = self.y
        x2 = ((((0. if ((f2 < 0.)) else (1. if ((f2 > 1.)) else f2))) * 255) + 0.499)
        tmp4 = None
        try:
            tmp4 = int(x2)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e2 = _hx_e1
            tmp4 = None
        tmp5 = (tmp3 | ((tmp4 << 8)))
        f3 = self.z
        x3 = ((((0. if ((f3 < 0.)) else (1. if ((f3 > 1.)) else f3))) * 255) + 0.499)
        tmp6 = None
        try:
            tmp6 = int(x3)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e3 = _hx_e1
            tmp6 = None
        return (tmp5 | tmp6)

    def toColorHSL(self):
        a = self.x
        b = self.y
        a1 = (b if ((a < b)) else a)
        b1 = self.z
        _hx_max = (b1 if ((a1 < b1)) else a1)
        a2 = self.x
        b2 = self.y
        a3 = (b2 if ((a2 > b2)) else a2)
        b3 = self.z
        _hx_min = (b3 if ((a3 > b3)) else a3)
        h = None
        s = None
        l = (((_hx_max + _hx_min)) / 2.0)
        if (_hx_max == _hx_min):
            s = 0.0
            h = s
        else:
            d = (_hx_max - _hx_min)
            s = ((d / (((2 - _hx_max) - _hx_min))) if ((l > 0.5)) else (d / ((_hx_max + _hx_min))))
            if (_hx_max == self.x):
                h = ((((self.y - self.z)) / d) + ((6.0 if ((self.y < self.z)) else 0.0)))
            elif (_hx_max == self.y):
                h = ((((self.z - self.x)) / d) + 2.0)
            else:
                h = ((((self.x - self.y)) / d) + 4.0)
            h = (h * 1.04719755119659763)
        return h3d_Vector(h,s,l,self.w)

    @staticmethod
    def fromColor(c,scale = None):
        if (scale is None):
            scale = 1.0
        s = (scale / 255)
        return h3d_Vector(((((c >> 16) & 255)) * s),((((c >> 8) & 255)) * s),(((c & 255)) * s),((HxOverrides.rshift(c, 24)) * s))

    @staticmethod
    def fromArray(a):
        r = h3d_Vector()
        if (len(a) > 0):
            r.x = (a[0] if 0 < len(a) else None)
        if (len(a) > 1):
            r.y = (a[1] if 1 < len(a) else None)
        if (len(a) > 2):
            r.z = (a[2] if 2 < len(a) else None)
        if (len(a) > 3):
            r.w = (a[3] if 3 < len(a) else None)
        return r

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.x = None
        _hx_o.y = None
        _hx_o.z = None
        _hx_o.w = None
h3d_Vector._hx_class = h3d_Vector
_hx_classes["h3d.Vector"] = h3d_Vector


class h3d_anim_AnimatedObject:
    _hx_class_name = "h3d.anim.AnimatedObject"
    _hx_is_interface = "False"
    __slots__ = ("objectName", "targetObject", "targetSkin", "targetJoint")
    _hx_fields = ["objectName", "targetObject", "targetSkin", "targetJoint"]
    _hx_methods = ["clone"]

    def __init__(self,name):
        self.targetJoint = None
        self.targetSkin = None
        self.targetObject = None
        self.objectName = name

    def clone(self):
        return h3d_anim_AnimatedObject(self.objectName)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.objectName = None
        _hx_o.targetObject = None
        _hx_o.targetSkin = None
        _hx_o.targetJoint = None
h3d_anim_AnimatedObject._hx_class = h3d_anim_AnimatedObject
_hx_classes["h3d.anim.AnimatedObject"] = h3d_anim_AnimatedObject


class hxd_impl__Serializable_NoSerializeSupport:
    _hx_class_name = "hxd.impl._Serializable.NoSerializeSupport"
    _hx_is_interface = "True"
    __slots__ = ()
hxd_impl__Serializable_NoSerializeSupport._hx_class = hxd_impl__Serializable_NoSerializeSupport
_hx_classes["hxd.impl._Serializable.NoSerializeSupport"] = hxd_impl__Serializable_NoSerializeSupport


class h3d_anim_Animation:
    _hx_class_name = "h3d.anim.Animation"
    _hx_is_interface = "False"
    __slots__ = ("name", "resourcePath", "frameCount", "sampling", "frame", "speed", "onAnimEnd", "onEvent", "pause", "loop", "events", "isInstance", "objects", "isSync", "lastEvent")
    _hx_fields = ["name", "resourcePath", "frameCount", "sampling", "frame", "speed", "onAnimEnd", "onEvent", "pause", "loop", "events", "isInstance", "objects", "isSync", "lastEvent"]
    _hx_methods = ["getDuration", "getIFrame", "unbind", "setEvents", "addEvent", "getEvents", "getObjects", "setFrame", "clone", "initInstance", "createInstance", "bind", "getPropValue", "sync", "isPlaying", "endFrame", "update", "initAndBind", "toString"]
    _hx_statics = ["EPSILON"]
    _hx_interfaces = [hxd_impl__Serializable_NoSerializeSupport]

    def __init__(self,name,frameCount,sampling):
        self.isSync = None
        self.isInstance = None
        self.events = None
        self.onEvent = None
        self.onAnimEnd = None
        self.resourcePath = None
        self.name = name
        self.frameCount = frameCount
        self.sampling = sampling
        self.objects = []
        self.lastEvent = -1
        self.frame = 0.
        self.speed = 1.
        self.loop = True
        self.pause = False

    def getDuration(self):
        return (self.frameCount / ((self.sampling * self.speed)))

    def getIFrame(self):
        x = self.frame
        f = None
        try:
            f = int(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            f = None
        _hx_max = self.endFrame()
        if (f == _hx_max):
            f = (f - 1)
        return f

    def unbind(self,objectName):
        _g = 0
        _g1 = self.objects
        while (_g < len(_g1)):
            o = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (o.objectName == objectName):
                self.isSync = False
                o.targetObject = None
                o.targetSkin = None
                return

    def setEvents(self,el):
        _g = []
        _g1 = 0
        _g2 = self.frameCount
        while (_g1 < _g2):
            i = _g1
            _g1 = (_g1 + 1)
            _g.append(None)
        self.events = _g
        e = HxOverrides.iterator(el)
        while e.hasNext():
            e1 = e.next()
            if (python_internal_ArrayImpl._get(self.events, e1.frame) is None):
                python_internal_ArrayImpl._set(self.events, e1.frame, [])
            _this = python_internal_ArrayImpl._get(self.events, e1.frame)
            x = e1.data
            _this.append(x)

    def addEvent(self,frame,data):
        if (self.events is None):
            self.events = []
        if ((self.events[frame] if frame >= 0 and frame < len(self.events) else None) is None):
            python_internal_ArrayImpl._set(self.events, frame, [data])
        else:
            _this = (self.events[frame] if frame >= 0 and frame < len(self.events) else None)
            _this.append(data)

    def getEvents(self):
        return self.events

    def getObjects(self):
        return self.objects

    def setFrame(self,f):
        self.frame = f
        self.lastEvent = -1
        while (self.frame < 0):
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.frame
            _hx_local_0.frame = (_hx_local_1 + self.frameCount)
            _hx_local_0.frame
        while (self.frame > self.frameCount):
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.frame
            _hx_local_2.frame = (_hx_local_3 - self.frameCount)
            _hx_local_2.frame

    def clone(self,a = None):
        if (a is None):
            a = h3d_anim_Animation(self.name,self.frameCount,self.sampling)
        a.objects = self.objects
        a.speed = self.speed
        a.loop = self.loop
        a.pause = self.pause
        a.events = self.events
        a.resourcePath = self.resourcePath
        return a

    def initInstance(self):
        self.isInstance = True

    def createInstance(self,base):
        _g = []
        _g1 = 0
        _g2 = self.objects
        while (_g1 < len(_g2)):
            a = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
            _g1 = (_g1 + 1)
            x = a.clone()
            _g.append(x)
        objects = _g
        a1 = self.clone()
        a1.objects = objects
        a1.bind(base)
        a1.initInstance()
        return a1

    def bind(self,base):
        currentSkin = None
        _g = 0
        _g1 = list(self.objects)
        while (_g < len(_g1)):
            a = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (currentSkin is not None):
                j = currentSkin.skinData.namedJoints.h.get(a.objectName,None)
                if (j is not None):
                    a.targetSkin = currentSkin
                    a.targetJoint = j.index
                    continue
            obj = base.getObjectByName(a.objectName)
            if (obj is None):
                python_internal_ArrayImpl.remove(self.objects,a)
                continue
            joint = Std.downcast(obj,h3d_scene_Joint)
            if (joint is not None):
                currentSkin = joint.parent
                a.targetSkin = currentSkin
                a.targetJoint = joint.index
            else:
                a.targetObject = obj
        self.isSync = False

    def getPropValue(self,objectName,propName):
        return None

    def sync(self,decompose = None):
        if (decompose is None):
            decompose = False
        raise _HxException("assert")

    def isPlaying(self):
        if (not self.pause):
            return (((-self.speed if ((self.speed < 0)) else self.speed)) > 0.000001)
        else:
            return False

    def endFrame(self):
        return self.frameCount

    def update(self,dt):
        if (not self.isInstance):
            raise _HxException("You must instanciate this animation first")
        if (not self.isPlaying()):
            return 0
        if ((self.events is not None) and ((self.onEvent is not None))):
            x = self.frame
            f0 = None
            try:
                f0 = int(x)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                f0 = None
            x1 = (self.frame + (((dt * self.speed) * self.sampling)))
            f1 = None
            try:
                f1 = int(x1)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e1 = _hx_e1
                f1 = None
            if (f1 >= self.frameCount):
                f1 = (self.frameCount - 1)
            _g = f0
            _g1 = (f1 + 1)
            while (_g < _g1):
                f = _g
                _g = (_g + 1)
                if (f == self.lastEvent):
                    continue
                self.lastEvent = f
                if ((self.events[f] if f >= 0 and f < len(self.events) else None) is not None):
                    oldF = self.frame
                    oldDT = dt
                    dt = (dt - ((((f - self.frame)) / ((self.speed * self.sampling)))))
                    self.frame = f
                    _g2 = 0
                    _g11 = (self.events[f] if f >= 0 and f < len(self.events) else None)
                    while (_g2 < len(_g11)):
                        e2 = (_g11[_g2] if _g2 >= 0 and _g2 < len(_g11) else None)
                        _g2 = (_g2 + 1)
                        self.onEvent(e2)
                    if ((self.frame == f) and ((f == ((self.frameCount - 1))))):
                        self.frame = oldF
                        dt = oldDT
                        break
                    else:
                        return dt
        if (self.onAnimEnd is not None):
            end = self.endFrame()
            et = (0 if ((self.speed == 0)) else (((end - self.frame)) / ((self.speed * self.sampling))))
            if ((et <= dt) and ((et > 0))):
                self.frame = end
                dt = (dt - et)
                self.onAnimEnd()
                if ((self.frame == end) and self.isPlaying()):
                    if self.loop:
                        self.frame = 0
                    else:
                        dt = 0
                return dt
        _hx_local_3 = self
        _hx_local_4 = _hx_local_3.frame
        _hx_local_3.frame = (_hx_local_4 + (((dt * self.speed) * self.sampling)))
        _hx_local_3.frame
        if (self.frame >= self.frameCount):
            if self.loop:
                _hx_local_5 = self
                _hx_local_6 = _hx_local_5.frame
                _hx_local_5.frame = HxOverrides.modf(_hx_local_6, self.frameCount)
                _hx_local_5.frame
            else:
                self.frame = self.frameCount
        return 0

    def initAndBind(self,obj):
        self.bind(obj)
        self.initInstance()
        self.pause = True

    def toString(self):
        return self.name

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.name = None
        _hx_o.resourcePath = None
        _hx_o.frameCount = None
        _hx_o.sampling = None
        _hx_o.frame = None
        _hx_o.speed = None
        _hx_o.onAnimEnd = None
        _hx_o.onEvent = None
        _hx_o.pause = None
        _hx_o.loop = None
        _hx_o.events = None
        _hx_o.isInstance = None
        _hx_o.objects = None
        _hx_o.isSync = None
        _hx_o.lastEvent = None
h3d_anim_Animation._hx_class = h3d_anim_Animation
_hx_classes["h3d.anim.Animation"] = h3d_anim_Animation

class h3d_anim_DataLayout(Enum):
    __slots__ = ()
    _hx_class_name = "h3d.anim.DataLayout"
    _hx_constructs = ["Position", "Rotation", "Scale", "UV", "Alpha", "Property", "SingleFrame"]
h3d_anim_DataLayout.Position = h3d_anim_DataLayout("Position", 0, ())
h3d_anim_DataLayout.Rotation = h3d_anim_DataLayout("Rotation", 1, ())
h3d_anim_DataLayout.Scale = h3d_anim_DataLayout("Scale", 2, ())
h3d_anim_DataLayout.UV = h3d_anim_DataLayout("UV", 3, ())
h3d_anim_DataLayout.Alpha = h3d_anim_DataLayout("Alpha", 4, ())
h3d_anim_DataLayout.Property = h3d_anim_DataLayout("Property", 5, ())
h3d_anim_DataLayout.SingleFrame = h3d_anim_DataLayout("SingleFrame", 6, ())
h3d_anim_DataLayout._hx_class = h3d_anim_DataLayout
_hx_classes["h3d.anim.DataLayout"] = h3d_anim_DataLayout


class h3d_anim_BufferObject(h3d_anim_AnimatedObject):
    _hx_class_name = "h3d.anim.BufferObject"
    _hx_is_interface = "False"
    __slots__ = ("layout", "dataOffset", "propCurrentValue", "propName", "matrix")
    _hx_fields = ["layout", "dataOffset", "propCurrentValue", "propName", "matrix"]
    _hx_methods = ["getStride", "clone"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_anim_AnimatedObject


    def __init__(self,objectName,dataOffset):
        self.matrix = None
        self.propName = None
        self.propCurrentValue = None
        self.dataOffset = None
        self.layout = None
        super().__init__(objectName)
        self.dataOffset = dataOffset

    def getStride(self):
        stride = 0
        if (((self.layout & ((1 << h3d_anim_DataLayout.Position.index)))) != 0):
            stride = (stride + 3)
        if (((self.layout & ((1 << h3d_anim_DataLayout.Rotation.index)))) != 0):
            stride = (stride + 3)
        if (((self.layout & ((1 << h3d_anim_DataLayout.Scale.index)))) != 0):
            stride = (stride + 3)
        if (((self.layout & ((1 << h3d_anim_DataLayout.UV.index)))) != 0):
            stride = (stride + 2)
        if (((self.layout & ((1 << h3d_anim_DataLayout.Alpha.index)))) != 0):
            stride = (stride + 1)
        if (((self.layout & ((1 << h3d_anim_DataLayout.Property.index)))) != 0):
            stride = (stride + 1)
        return stride

    def clone(self):
        o = h3d_anim_BufferObject(self.objectName,self.dataOffset)
        o.layout = self.layout
        o.propName = self.propName
        return o

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.layout = None
        _hx_o.dataOffset = None
        _hx_o.propCurrentValue = None
        _hx_o.propName = None
        _hx_o.matrix = None
h3d_anim_BufferObject._hx_class = h3d_anim_BufferObject
_hx_classes["h3d.anim.BufferObject"] = h3d_anim_BufferObject


class h3d_anim_BufferAnimation(h3d_anim_Animation):
    _hx_class_name = "h3d.anim.BufferAnimation"
    _hx_is_interface = "False"
    __slots__ = ("syncFrame", "data", "stride")
    _hx_fields = ["syncFrame", "data", "stride"]
    _hx_methods = ["setData", "addObject", "getPropValue", "getFrames", "clone", "endFrame", "initInstance", "sortByFrameCountDesc", "uvLerp", "sync"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_anim_Animation


    def __init__(self,name,frame,sampling):
        self.stride = None
        self.data = None
        self.syncFrame = None
        super().__init__(name,frame,sampling)
        self.syncFrame = -1

    def setData(self,data,stride):
        self.data = data
        self.stride = stride

    def addObject(self,objName,offset):
        f = h3d_anim_BufferObject(objName,offset)
        _this = self.objects
        _this.append(f)
        return f

    def getPropValue(self,objName,propName):
        _g = 0
        _g1 = self.objects
        while (_g < len(_g1)):
            o = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if ((o.objectName == objName) and ((o.propName == propName))):
                return o.propCurrentValue
        return None

    def getFrames(self):
        return self.objects

    def clone(self,a = None):
        if (a is None):
            a = h3d_anim_BufferAnimation(self.name,self.frameCount,self.sampling)
        super().clone(a)
        la = Std.downcast(a,h3d_anim_BufferAnimation)
        la.setData(self.data,self.stride)
        return a

    def endFrame(self):
        if self.loop:
            return self.frameCount
        else:
            return (self.frameCount - 1)

    def initInstance(self):
        super().initInstance()
        frames = self.objects
        _g = 0
        while (_g < len(frames)):
            a = (frames[_g] if _g >= 0 and _g < len(frames) else None)
            _g = (_g + 1)
            if (((a.layout & ((1 << h3d_anim_DataLayout.Property.index)))) != 0):
                a.propCurrentValue = self.data[a.dataOffset]
            if ((((a.layout & ((1 << h3d_anim_DataLayout.Alpha.index)))) != 0) and (((a.targetObject is None) or ((Std.downcast(a.targetObject,h3d_scene_Mesh) is None))))):
                raise _HxException((HxOverrides.stringOrNull(a.objectName) + " should be a mesh (for alpha animation)"))
            if (((((a.layout & ((1 << h3d_anim_DataLayout.Position.index)))) != 0) or ((((a.layout & ((1 << h3d_anim_DataLayout.Rotation.index)))) != 0))) or ((((a.layout & ((1 << h3d_anim_DataLayout.Scale.index)))) != 0))):
                a.matrix = h3d_Matrix()
                a.matrix.identity()
                if ((((a.layout & ((1 << h3d_anim_DataLayout.Position.index)))) == 0) and ((a.targetSkin is not None))):
                    m2 = python_internal_ArrayImpl._get(a.targetSkin.getSkinData().allJoints, a.targetJoint).defMat
                    a.matrix._14 = m2._41
                    a.matrix._24 = m2._42
                    a.matrix._34 = m2._43
        frames.sort(key= python_lib_Functools.cmp_to_key(self.sortByFrameCountDesc))

    def sortByFrameCountDesc(self,o1,o2):
        return (((0 if ((((o2.layout & ((1 << h3d_anim_DataLayout.SingleFrame.index)))) != 0)) else 1)) - ((0 if ((((o1.layout & ((1 << h3d_anim_DataLayout.SingleFrame.index)))) != 0)) else 1)))

    def uvLerp(self,v1,v2,k):
        v1 = HxOverrides.modf(v1, 1.)
        v2 = HxOverrides.modf(v2, 1.)
        if (v1 < ((v2 - 0.5))):
            v1 = (v1 + 1)
        elif (v1 > ((v2 + 0.5))):
            v1 = (v1 - 1)
        return ((v1 * ((1 - k))) + ((v2 * k)))

    def sync(self,decompose = None):
        if (decompose is None):
            decompose = False
        _gthis = self
        if ((self.frame == self.syncFrame) and (not decompose)):
            return
        x = self.frame
        f = None
        try:
            f = int(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            f = None
        _hx_max = self.endFrame()
        if (f == _hx_max):
            f = (f - 1)
        frame1 = f
        frame2 = HxOverrides.mod(((frame1 + 1)), self.frameCount)
        k2 = (self.frame - frame1)
        k1 = (1 - k2)
        if (frame1 < 0):
            frame2 = 0
            frame1 = frame2
        elif (self.frame >= self.frameCount):
            frame2 = (self.frameCount - 1)
            frame1 = frame2
        elif ((not self.loop) and ((frame2 == 0))):
            frame2 = (self.frameCount - 1)
        self.syncFrame = self.frame
        if decompose:
            self.isSync = False
        _g = 0
        _g1 = self.objects
        while (_g < len(_g1)):
            o = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if ((o.targetObject is None) and ((o.targetSkin is None))):
                continue
            layout = o.layout
            offset1 = ((self.stride * frame1) + o.dataOffset)
            offset2 = ((self.stride * frame2) + o.dataOffset)
            frame11 = frame1
            frame21 = frame2
            if (((layout & ((1 << h3d_anim_DataLayout.SingleFrame.index)))) != 0):
                if self.isSync:
                    break
                frame21 = 0
                frame11 = frame21
                offset2 = o.dataOffset
                offset1 = offset2
            m = o.matrix
            if (m is not None):
                if (((layout & ((1 << h3d_anim_DataLayout.Position.index)))) != 0):
                    index = offset1
                    offset1 = (offset1 + 1)
                    index1 = offset2
                    offset2 = (offset2 + 1)
                    m._41 = ((_gthis.data[index] * k1) + ((_gthis.data[index1] * k2)))
                    index2 = offset1
                    offset1 = (offset1 + 1)
                    index3 = offset2
                    offset2 = (offset2 + 1)
                    m._42 = ((_gthis.data[index2] * k1) + ((_gthis.data[index3] * k2)))
                    index4 = offset1
                    offset1 = (offset1 + 1)
                    index5 = offset2
                    offset2 = (offset2 + 1)
                    m._43 = ((_gthis.data[index4] * k1) + ((_gthis.data[index5] * k2)))
                else:
                    m._41 = m._14
                    m._42 = m._24
                    m._43 = m._34
                if (((layout & ((1 << h3d_anim_DataLayout.Rotation.index)))) != 0):
                    index6 = offset1
                    offset1 = (offset1 + 1)
                    q1x = self.data[index6]
                    index7 = offset1
                    offset1 = (offset1 + 1)
                    q1y = self.data[index7]
                    index8 = offset1
                    offset1 = (offset1 + 1)
                    q1z = self.data[index8]
                    f1 = (1 - ((((q1x * q1x) + ((q1y * q1y))) + ((q1z * q1z)))))
                    v = (-f1 if ((f1 < 0)) else f1)
                    q1w = (Math.NaN if ((v < 0)) else python_lib_Math.sqrt(v))
                    index9 = offset2
                    offset2 = (offset2 + 1)
                    q2x = self.data[index9]
                    index10 = offset2
                    offset2 = (offset2 + 1)
                    q2y = self.data[index10]
                    index11 = offset2
                    offset2 = (offset2 + 1)
                    q2z = self.data[index11]
                    f2 = (1 - ((((q2x * q2x) + ((q2y * q2y))) + ((q2z * q2z)))))
                    v1 = (-f2 if ((f2 < 0)) else f2)
                    q2w = (Math.NaN if ((v1 < 0)) else python_lib_Math.sqrt(v1))
                    dot = ((((q1x * q2x) + ((q1y * q2y))) + ((q1z * q2z))) + ((q1w * q2w)))
                    q2 = (-k2 if ((dot < 0)) else k2)
                    qx = ((q1x * k1) + ((q2x * q2)))
                    qy = ((q1y * k1) + ((q2y * q2)))
                    qz = ((q1z * k1) + ((q2z * q2)))
                    qw = ((q1w * k1) + ((q2w * q2)))
                    v2 = ((((qx * qx) + ((qy * qy))) + ((qz * qz))) + ((qw * qw)))
                    ql = (1 / ((Math.NaN if ((v2 < 0)) else python_lib_Math.sqrt(v2))))
                    qx = (qx * ql)
                    qy = (qy * ql)
                    qz = (qz * ql)
                    qw = (qw * ql)
                    if decompose:
                        m._12 = qx
                        m._13 = qy
                        m._21 = qz
                        m._23 = qw
                        if (((layout & ((1 << h3d_anim_DataLayout.Scale.index)))) != 0):
                            index12 = offset1
                            offset1 = (offset1 + 1)
                            index13 = offset2
                            offset2 = (offset2 + 1)
                            m._11 = ((_gthis.data[index12] * k1) + ((_gthis.data[index13] * k2)))
                            index14 = offset1
                            offset1 = (offset1 + 1)
                            index15 = offset2
                            offset2 = (offset2 + 1)
                            m._22 = ((_gthis.data[index14] * k1) + ((_gthis.data[index15] * k2)))
                            index16 = offset1
                            offset1 = (offset1 + 1)
                            index17 = offset2
                            offset2 = (offset2 + 1)
                            m._33 = ((_gthis.data[index16] * k1) + ((_gthis.data[index17] * k2)))
                        else:
                            m._11 = 1
                            m._22 = 1
                            m._33 = 1
                    else:
                        xx = (qx * qx)
                        xy = (qx * qy)
                        xz = (qx * qz)
                        xw = (qx * qw)
                        yy = (qy * qy)
                        yz = (qy * qz)
                        yw = (qy * qw)
                        zz = (qz * qz)
                        zw = (qz * qw)
                        m._11 = (1 - ((2 * ((yy + zz)))))
                        m._12 = (2 * ((xy + zw)))
                        m._13 = (2 * ((xz - yw)))
                        m._21 = (2 * ((xy - zw)))
                        m._22 = (1 - ((2 * ((xx + zz)))))
                        m._23 = (2 * ((yz + xw)))
                        m._31 = (2 * ((xz + yw)))
                        m._32 = (2 * ((yz - xw)))
                        m._33 = (1 - ((2 * ((xx + yy)))))
                        if (((layout & ((1 << h3d_anim_DataLayout.Scale.index)))) != 0):
                            index18 = offset1
                            offset1 = (offset1 + 1)
                            index19 = offset2
                            offset2 = (offset2 + 1)
                            sx = ((_gthis.data[index18] * k1) + ((_gthis.data[index19] * k2)))
                            index20 = offset1
                            offset1 = (offset1 + 1)
                            index21 = offset2
                            offset2 = (offset2 + 1)
                            sy = ((_gthis.data[index20] * k1) + ((_gthis.data[index21] * k2)))
                            index22 = offset1
                            offset1 = (offset1 + 1)
                            index23 = offset2
                            offset2 = (offset2 + 1)
                            sz = ((_gthis.data[index22] * k1) + ((_gthis.data[index23] * k2)))
                            m._11 = (m._11 * sx)
                            m._12 = (m._12 * sx)
                            m._13 = (m._13 * sx)
                            m._21 = (m._21 * sy)
                            m._22 = (m._22 * sy)
                            m._23 = (m._23 * sy)
                            m._31 = (m._31 * sz)
                            m._32 = (m._32 * sz)
                            m._33 = (m._33 * sz)
                else:
                    m._12 = 0
                    m._13 = 0
                    m._21 = 0
                    m._23 = (1 if decompose else 0)
                    if (((layout & ((1 << h3d_anim_DataLayout.Scale.index)))) != 0):
                        index24 = offset1
                        offset1 = (offset1 + 1)
                        index25 = offset2
                        offset2 = (offset2 + 1)
                        m._11 = ((_gthis.data[index24] * k1) + ((_gthis.data[index25] * k2)))
                        index26 = offset1
                        offset1 = (offset1 + 1)
                        index27 = offset2
                        offset2 = (offset2 + 1)
                        m._22 = ((_gthis.data[index26] * k1) + ((_gthis.data[index27] * k2)))
                        index28 = offset1
                        offset1 = (offset1 + 1)
                        index29 = offset2
                        offset2 = (offset2 + 1)
                        m._33 = ((_gthis.data[index28] * k1) + ((_gthis.data[index29] * k2)))
                    else:
                        m._11 = 1
                        m._22 = 1
                        m._33 = 1
                if (o.targetSkin is not None):
                    python_internal_ArrayImpl._set(o.targetSkin.currentRelPose, o.targetJoint, m)
                    o.targetSkin.jointsUpdated = True
                else:
                    _this = o.targetObject
                    _this.defaultTransform = m
                    f3 = 1
                    b = True
                    if b:
                        _this.flags = (_this.flags | f3)
                    else:
                        _this.flags = (_this.flags & ~f3)
            if (((layout & ((1 << h3d_anim_DataLayout.UV.index)))) != 0):
                mat = o.targetObject.toMesh().material
                s = mat.passes.getShader(h3d_shader_UVDelta)
                if (s is None):
                    s = mat.passes.addShader(h3d_shader_UVDelta())
                    mat.get_texture().set_wrap(h3d_mat_Wrap.Repeat)
                index30 = offset1
                offset1 = (offset1 + 1)
                v11 = self.data[index30]
                index31 = offset2
                offset2 = (offset2 + 1)
                v21 = self.data[index31]
                v11 = HxOverrides.modf(v11, 1.)
                v21 = HxOverrides.modf(v21, 1.)
                if (v11 < ((v21 - 0.5))):
                    v11 = (v11 + 1)
                elif (v11 > ((v21 + 0.5))):
                    v11 = (v11 - 1)
                s.uvDelta__.x = ((v11 * ((1 - k2))) + ((v21 * k2)))
                index32 = offset1
                offset1 = (offset1 + 1)
                v12 = self.data[index32]
                index33 = offset2
                offset2 = (offset2 + 1)
                v22 = self.data[index33]
                v12 = HxOverrides.modf(v12, 1.)
                v22 = HxOverrides.modf(v22, 1.)
                if (v12 < ((v22 - 0.5))):
                    v12 = (v12 + 1)
                elif (v12 > ((v22 + 0.5))):
                    v12 = (v12 - 1)
                s.uvDelta__.y = ((v12 * ((1 - k2))) + ((v22 * k2)))
            if (((layout & ((1 << h3d_anim_DataLayout.Alpha.index)))) != 0):
                mat1 = o.targetObject.toMesh().material
                if (mat1.blendMode == h2d_BlendMode._hx_None):
                    mat1.set_blendMode(h2d_BlendMode.Alpha)
                index34 = offset1
                offset1 = (offset1 + 1)
                tmp = (_gthis.data[index34] * k1)
                index35 = offset2
                offset2 = (offset2 + 1)
                tmp1 = (_gthis.data[index35] * k2)
                mat1.mshader.color__.w = (tmp + tmp1)
            if (((layout & ((1 << h3d_anim_DataLayout.Property.index)))) != 0):
                index36 = offset1
                offset1 = (offset1 + 1)
                index37 = offset2
                offset2 = (offset2 + 1)
                o.propCurrentValue = ((_gthis.data[index36] * k1) + ((_gthis.data[index37] * k2)))
        if (not decompose):
            self.isSync = True

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.syncFrame = None
        _hx_o.data = None
        _hx_o.stride = None
h3d_anim_BufferAnimation._hx_class = h3d_anim_BufferAnimation
_hx_classes["h3d.anim.BufferAnimation"] = h3d_anim_BufferAnimation


class h3d_anim_LinearFrame:
    _hx_class_name = "h3d.anim.LinearFrame"
    _hx_is_interface = "False"
    __slots__ = ("tx", "ty", "tz", "qx", "qy", "qz", "qw", "sx", "sy", "sz")
    _hx_fields = ["tx", "ty", "tz", "qx", "qy", "qz", "qw", "sx", "sy", "sz"]
    _hx_methods = ["toMatrix"]

    def __init__(self):
        self.sz = None
        self.sy = None
        self.sx = None
        self.qw = None
        self.qz = None
        self.qy = None
        self.qx = None
        self.tz = None
        self.ty = None
        self.tx = None

    def toMatrix(self):
        m = h3d_Matrix()
        h3d_Quat(self.qx,self.qy,self.qz,self.qw).toMatrix(m)
        m.prependScale(self.sx,self.sy,self.sz)
        m.translate(self.tx,self.ty,self.tz)
        return m

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.tx = None
        _hx_o.ty = None
        _hx_o.tz = None
        _hx_o.qx = None
        _hx_o.qy = None
        _hx_o.qz = None
        _hx_o.qw = None
        _hx_o.sx = None
        _hx_o.sy = None
        _hx_o.sz = None
h3d_anim_LinearFrame._hx_class = h3d_anim_LinearFrame
_hx_classes["h3d.anim.LinearFrame"] = h3d_anim_LinearFrame


class h3d_anim_LinearObject(h3d_anim_AnimatedObject):
    _hx_class_name = "h3d.anim.LinearObject"
    _hx_is_interface = "False"
    __slots__ = ("hasPosition", "hasRotation", "hasScale", "frames", "alphas", "uvs", "propName", "propValues", "matrix", "propCurrentValue")
    _hx_fields = ["hasPosition", "hasRotation", "hasScale", "frames", "alphas", "uvs", "propName", "propValues", "matrix", "propCurrentValue"]
    _hx_methods = ["clone"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_anim_AnimatedObject


    def __init__(self,name):
        self.propCurrentValue = None
        self.matrix = None
        self.propValues = None
        self.propName = None
        self.uvs = None
        self.alphas = None
        self.frames = None
        self.hasScale = None
        self.hasRotation = None
        self.hasPosition = True
        super().__init__(name)

    def clone(self):
        o = h3d_anim_LinearObject(self.objectName)
        o.hasPosition = self.hasPosition
        o.hasRotation = self.hasRotation
        o.hasScale = self.hasScale
        o.frames = self.frames
        o.alphas = self.alphas
        o.uvs = self.uvs
        o.propName = self.propName
        o.propValues = self.propValues
        return o

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.hasPosition = None
        _hx_o.hasRotation = None
        _hx_o.hasScale = None
        _hx_o.frames = None
        _hx_o.alphas = None
        _hx_o.uvs = None
        _hx_o.propName = None
        _hx_o.propValues = None
        _hx_o.matrix = None
        _hx_o.propCurrentValue = None
h3d_anim_LinearObject._hx_class = h3d_anim_LinearObject
_hx_classes["h3d.anim.LinearObject"] = h3d_anim_LinearObject


class h3d_anim_LinearAnimation(h3d_anim_Animation):
    _hx_class_name = "h3d.anim.LinearAnimation"
    _hx_is_interface = "False"
    __slots__ = ("syncFrame",)
    _hx_fields = ["syncFrame"]
    _hx_methods = ["addCurve", "addAlphaCurve", "addUVCurve", "addPropCurve", "getPropValue", "getFrames", "clone", "endFrame", "initInstance", "sortByFrameCountDesc", "uvLerp", "sync"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_anim_Animation


    def __init__(self,name,frame,sampling):
        self.syncFrame = None
        super().__init__(name,frame,sampling)
        self.syncFrame = -1

    def addCurve(self,objName,frames,hasPos,hasRot,hasScale):
        f = h3d_anim_LinearObject(objName)
        f.frames = frames
        f.hasPosition = hasPos
        f.hasRotation = hasRot
        f.hasScale = hasScale
        _this = self.objects
        _this.append(f)

    def addAlphaCurve(self,objName,alphas):
        f = h3d_anim_LinearObject(objName)
        f.alphas = alphas
        _this = self.objects
        _this.append(f)

    def addUVCurve(self,objName,uvs):
        f = h3d_anim_LinearObject(objName)
        f.uvs = uvs
        _this = self.objects
        _this.append(f)

    def addPropCurve(self,objName,propName,values):
        f = h3d_anim_LinearObject(objName)
        f.propName = propName
        f.propValues = values
        _this = self.objects
        _this.append(f)

    def getPropValue(self,objName,propName):
        _g = 0
        _g1 = self.objects
        while (_g < len(_g1)):
            o = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if ((o.objectName == objName) and ((o.propName == propName))):
                return o.propCurrentValue
        return None

    def getFrames(self):
        return self.objects

    def clone(self,a = None):
        if (a is None):
            a = h3d_anim_LinearAnimation(self.name,self.frameCount,self.sampling)
        super().clone(a)
        return a

    def endFrame(self):
        if self.loop:
            return self.frameCount
        else:
            return (self.frameCount - 1)

    def initInstance(self):
        super().initInstance()
        frames = self.objects
        _g = 0
        while (_g < len(frames)):
            a = (frames[_g] if _g >= 0 and _g < len(frames) else None)
            _g = (_g + 1)
            if (a.propValues is not None):
                a.propCurrentValue = a.propValues[0]
                continue
            if ((a.alphas is not None) and (((a.targetObject is None) or ((Std.downcast(a.targetObject,h3d_scene_Mesh) is None))))):
                raise _HxException((HxOverrides.stringOrNull(a.objectName) + " should be a mesh (for alpha animation)"))
            if ((a.uvs is not None) or ((a.alphas is not None))):
                continue
            a.matrix = h3d_Matrix()
            a.matrix.identity()
        frames.sort(key= python_lib_Functools.cmp_to_key(self.sortByFrameCountDesc))

    def sortByFrameCountDesc(self,o1,o2):
        return (((10 if ((o2.frames is None)) else len(o2.frames))) - ((10 if ((o1.frames is None)) else len(o1.frames))))

    def uvLerp(self,v1,v2,k):
        v1 = HxOverrides.modf(v1, 1.)
        v2 = HxOverrides.modf(v2, 1.)
        if (v1 < ((v2 - 0.5))):
            v1 = (v1 + 1)
        elif (v1 > ((v2 + 0.5))):
            v1 = (v1 - 1)
        return ((v1 * ((1 - k))) + ((v2 * k)))

    def sync(self,decompose = None):
        if (decompose is None):
            decompose = False
        if ((self.frame == self.syncFrame) and (not decompose)):
            return
        x = self.frame
        f = None
        try:
            f = int(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            f = None
        _hx_max = self.endFrame()
        if (f == _hx_max):
            f = (f - 1)
        frame1 = f
        frame2 = HxOverrides.mod(((frame1 + 1)), self.frameCount)
        k2 = (self.frame - frame1)
        k1 = (1 - k2)
        if (frame1 < 0):
            frame2 = 0
            frame1 = frame2
        elif (self.frame >= self.frameCount):
            frame2 = (self.frameCount - 1)
            frame1 = frame2
        elif ((not self.loop) and ((frame2 == 0))):
            frame2 = (self.frameCount - 1)
        self.syncFrame = self.frame
        if decompose:
            self.isSync = False
        _g = 0
        _g1 = self.objects
        while (_g < len(_g1)):
            o = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if ((o.targetObject is None) and ((o.targetSkin is None))):
                continue
            if (o.alphas is not None):
                mat = o.targetObject.toMesh().material
                if (mat.blendMode == h2d_BlendMode._hx_None):
                    mat.set_blendMode(h2d_BlendMode.Alpha)
                tmp = (o.alphas[frame1] * k1)
                tmp1 = (o.alphas[frame2] * k2)
                mat.mshader.color__.w = (tmp + tmp1)
                continue
            if (o.uvs is not None):
                mat1 = o.targetObject.toMesh().material
                s = mat1.passes.getShader(h3d_shader_UVDelta)
                if (s is None):
                    s = mat1.passes.addShader(h3d_shader_UVDelta())
                    mat1.get_texture().set_wrap(h3d_mat_Wrap.Repeat)
                v1 = o.uvs[(frame1 << 1)]
                v2 = o.uvs[(frame2 << 1)]
                v1 = HxOverrides.modf(v1, 1.)
                v2 = HxOverrides.modf(v2, 1.)
                if (v1 < ((v2 - 0.5))):
                    v1 = (v1 + 1)
                elif (v1 > ((v2 + 0.5))):
                    v1 = (v1 - 1)
                s.uvDelta__.x = ((v1 * ((1 - k2))) + ((v2 * k2)))
                v11 = o.uvs[((frame1 << 1) | 1)]
                v21 = o.uvs[((frame2 << 1) | 1)]
                v11 = HxOverrides.modf(v11, 1.)
                v21 = HxOverrides.modf(v21, 1.)
                if (v11 < ((v21 - 0.5))):
                    v11 = (v11 + 1)
                elif (v11 > ((v21 + 0.5))):
                    v11 = (v11 - 1)
                s.uvDelta__.y = ((v11 * ((1 - k2))) + ((v21 * k2)))
                continue
            if (o.propValues is not None):
                o.propCurrentValue = ((o.propValues[frame1] * k1) + ((o.propValues[frame2] * k2)))
                continue
            frame11 = frame1
            frame21 = frame2
            if (len(o.frames) == 1):
                if self.isSync:
                    break
                frame21 = 0
                frame11 = frame21
            f1 = o.frames[frame11]
            f2 = o.frames[frame21]
            m = o.matrix
            m._41 = ((f1.tx * k1) + ((f2.tx * k2)))
            m._42 = ((f1.ty * k1) + ((f2.ty * k2)))
            m._43 = ((f1.tz * k1) + ((f2.tz * k2)))
            if o.hasRotation:
                dot = ((((f1.qx * f2.qx) + ((f1.qy * f2.qy))) + ((f1.qz * f2.qz))) + ((f1.qw * f2.qw)))
                q2 = (-k2 if ((dot < 0)) else k2)
                qx = ((f1.qx * k1) + ((f2.qx * q2)))
                qy = ((f1.qy * k1) + ((f2.qy * q2)))
                qz = ((f1.qz * k1) + ((f2.qz * q2)))
                qw = ((f1.qw * k1) + ((f2.qw * q2)))
                v = ((((qx * qx) + ((qy * qy))) + ((qz * qz))) + ((qw * qw)))
                ql = (1 / ((Math.NaN if ((v < 0)) else python_lib_Math.sqrt(v))))
                qx = (qx * ql)
                qy = (qy * ql)
                qz = (qz * ql)
                qw = (qw * ql)
                if decompose:
                    m._12 = qx
                    m._13 = qy
                    m._21 = qz
                    m._23 = qw
                    if o.hasScale:
                        m._11 = ((f1.sx * k1) + ((f2.sx * k2)))
                        m._22 = ((f1.sy * k1) + ((f2.sy * k2)))
                        m._33 = ((f1.sz * k1) + ((f2.sz * k2)))
                    else:
                        m._11 = 1
                        m._22 = 1
                        m._33 = 1
                else:
                    xx = (qx * qx)
                    xy = (qx * qy)
                    xz = (qx * qz)
                    xw = (qx * qw)
                    yy = (qy * qy)
                    yz = (qy * qz)
                    yw = (qy * qw)
                    zz = (qz * qz)
                    zw = (qz * qw)
                    m._11 = (1 - ((2 * ((yy + zz)))))
                    m._12 = (2 * ((xy + zw)))
                    m._13 = (2 * ((xz - yw)))
                    m._21 = (2 * ((xy - zw)))
                    m._22 = (1 - ((2 * ((xx + zz)))))
                    m._23 = (2 * ((yz + xw)))
                    m._31 = (2 * ((xz + yw)))
                    m._32 = (2 * ((yz - xw)))
                    m._33 = (1 - ((2 * ((xx + yy)))))
                    if o.hasScale:
                        sx = ((f1.sx * k1) + ((f2.sx * k2)))
                        sy = ((f1.sy * k1) + ((f2.sy * k2)))
                        sz = ((f1.sz * k1) + ((f2.sz * k2)))
                        m._11 = (m._11 * sx)
                        m._12 = (m._12 * sx)
                        m._13 = (m._13 * sx)
                        m._21 = (m._21 * sy)
                        m._22 = (m._22 * sy)
                        m._23 = (m._23 * sy)
                        m._31 = (m._31 * sz)
                        m._32 = (m._32 * sz)
                        m._33 = (m._33 * sz)
            else:
                m._12 = 0
                m._13 = 0
                m._21 = 0
                m._23 = (1 if decompose else 0)
                if o.hasScale:
                    m._11 = ((f1.sx * k1) + ((f2.sx * k2)))
                    m._22 = ((f1.sy * k1) + ((f2.sy * k2)))
                    m._33 = ((f1.sz * k1) + ((f2.sz * k2)))
                else:
                    m._11 = 1
                    m._22 = 1
                    m._33 = 1
            if (o.targetSkin is not None):
                python_internal_ArrayImpl._set(o.targetSkin.currentRelPose, o.targetJoint, o.matrix)
                o.targetSkin.jointsUpdated = True
            else:
                _this = o.targetObject
                v3 = o.matrix
                _this.defaultTransform = v3
                f3 = 1
                b = True
                if b:
                    _this.flags = (_this.flags | f3)
                else:
                    _this.flags = (_this.flags & ~f3)
        if (not decompose):
            self.isSync = True

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.syncFrame = None
h3d_anim_LinearAnimation._hx_class = h3d_anim_LinearAnimation
_hx_classes["h3d.anim.LinearAnimation"] = h3d_anim_LinearAnimation


class h3d_anim_Joint:
    _hx_class_name = "h3d.anim.Joint"
    _hx_is_interface = "False"
    __slots__ = ("index", "name", "bindIndex", "splitIndex", "defMat", "transPos", "parent", "subs", "retargetAnim")
    _hx_fields = ["index", "name", "bindIndex", "splitIndex", "defMat", "transPos", "parent", "subs", "retargetAnim"]

    def __init__(self):
        self.retargetAnim = None
        self.parent = None
        self.transPos = None
        self.defMat = None
        self.name = None
        self.index = None
        self.bindIndex = -1
        self.splitIndex = -1
        self.subs = []

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.index = None
        _hx_o.name = None
        _hx_o.bindIndex = None
        _hx_o.splitIndex = None
        _hx_o.defMat = None
        _hx_o.transPos = None
        _hx_o.parent = None
        _hx_o.subs = None
        _hx_o.retargetAnim = None
h3d_anim_Joint._hx_class = h3d_anim_Joint
_hx_classes["h3d.anim.Joint"] = h3d_anim_Joint


class h3d_anim__Skin_Permut:
    _hx_class_name = "h3d.anim._Skin.Permut"
    _hx_is_interface = "False"
    __slots__ = ("joints", "triangles", "material", "indexedJoints")
    _hx_fields = ["joints", "triangles", "material", "indexedJoints"]

    def __init__(self):
        self.indexedJoints = None
        self.material = None
        self.triangles = None
        self.joints = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.joints = None
        _hx_o.triangles = None
        _hx_o.material = None
        _hx_o.indexedJoints = None
h3d_anim__Skin_Permut._hx_class = h3d_anim__Skin_Permut
_hx_classes["h3d.anim._Skin.Permut"] = h3d_anim__Skin_Permut


class h3d_anim__Skin_Influence:
    _hx_class_name = "h3d.anim._Skin.Influence"
    _hx_is_interface = "False"
    __slots__ = ("j", "w")
    _hx_fields = ["j", "w"]

    def __init__(self,j,w):
        self.j = j
        self.w = w

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.j = None
        _hx_o.w = None
h3d_anim__Skin_Influence._hx_class = h3d_anim__Skin_Influence
_hx_classes["h3d.anim._Skin.Influence"] = h3d_anim__Skin_Influence


class h3d_anim_Skin:
    _hx_class_name = "h3d.anim.Skin"
    _hx_is_interface = "False"
    __slots__ = ("name", "vertexCount", "bonesPerVertex", "vertexJoints", "vertexWeights", "rootJoints", "namedJoints", "allJoints", "boundJoints", "primitive", "splitJoints", "triangleGroups", "envelop")
    _hx_fields = ["name", "vertexCount", "bonesPerVertex", "vertexJoints", "vertexWeights", "rootJoints", "namedJoints", "allJoints", "boundJoints", "primitive", "splitJoints", "triangleGroups", "envelop"]
    _hx_methods = ["setJoints", "addInfluence", "sortInfluences", "isSplit", "initWeights", "sortByBindIndex", "isSub", "merge", "jointsDiff", "split"]

    def __init__(self,name,vertexCount,bonesPerVertex):
        self.envelop = None
        self.triangleGroups = None
        self.splitJoints = None
        self.primitive = None
        self.boundJoints = None
        self.allJoints = None
        self.namedJoints = None
        self.rootJoints = None
        self.vertexWeights = None
        self.vertexJoints = None
        self.name = name
        self.vertexCount = vertexCount
        self.bonesPerVertex = bonesPerVertex
        if (vertexCount > 0):
            this1 = [None]*(vertexCount * bonesPerVertex)
            self.vertexJoints = this1
            this2 = [None]*(vertexCount * bonesPerVertex)
            self.vertexWeights = this2
            self.envelop = []

    def setJoints(self,joints,roots):
        self.rootJoints = roots
        self.allJoints = joints
        self.namedJoints = haxe_ds_StringMap()
        _g = 0
        while (_g < len(joints)):
            j = (joints[_g] if _g >= 0 and _g < len(joints) else None)
            _g = (_g + 1)
            if (j.name is not None):
                self.namedJoints.h[j.name] = j

    def addInfluence(self,vid,j,w):
        il = (self.envelop[vid] if vid >= 0 and vid < len(self.envelop) else None)
        if (il is None):
            def _hx_local_0():
                python_internal_ArrayImpl._set(self.envelop, vid, [])
                return (self.envelop[vid] if vid >= 0 and vid < len(self.envelop) else None)
            il = _hx_local_0()
        x = h3d_anim__Skin_Influence(j,w)
        il.append(x)

    def sortInfluences(self,i1,i2):
        if (i2.w > i1.w):
            return 1
        else:
            return -1

    def isSplit(self):
        return (self.splitJoints is not None)

    def initWeights(self):
        self.boundJoints = []
        pos = 0
        _g = 0
        _g1 = self.vertexCount
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            il = (self.envelop[i] if i >= 0 and i < len(self.envelop) else None)
            if (il is None):
                il = []
            haxe_ds_ArraySort.sort(il,self.sortInfluences)
            if (len(il) > self.bonesPerVertex):
                il = il[0:self.bonesPerVertex]
            tw = 0.
            _g2 = 0
            while (_g2 < len(il)):
                i1 = (il[_g2] if _g2 >= 0 and _g2 < len(il) else None)
                _g2 = (_g2 + 1)
                tw = (tw + i1.w)
            tw = (1 / tw)
            _g11 = 0
            _g21 = self.bonesPerVertex
            while (_g11 < _g21):
                i2 = _g11
                _g11 = (_g11 + 1)
                i3 = (il[i2] if i2 >= 0 and i2 < len(il) else None)
                if (i3 is None):
                    self.vertexJoints[pos] = 0
                    self.vertexWeights[pos] = 0
                else:
                    if (i3.j.bindIndex == -1):
                        i3.j.bindIndex = len(self.boundJoints)
                        _this = self.boundJoints
                        x = i3.j
                        _this.append(x)
                    val = i3.j.bindIndex
                    self.vertexJoints[pos] = val
                    val1 = (i3.w * tw)
                    self.vertexWeights[pos] = val1
                pos = (pos + 1)
        self.envelop = None

    def sortByBindIndex(self,j1,j2):
        return (j1.bindIndex - j2.bindIndex)

    def isSub(self,a,b):
        j = 0
        _hx_max = len(b)
        _g = 0
        while (_g < len(a)):
            e = (a[_g] if _g >= 0 and _g < len(a) else None)
            _g = (_g + 1)
            while True:
                b1 = j
                j = (j + 1)
                if (not ((e != (b[b1] if b1 >= 0 and b1 < len(b) else None)))):
                    break
                if (j >= _hx_max):
                    return False
                continue
        return True

    def merge(self,permuts):
        _g = 0
        while (_g < len(permuts)):
            p1 = (permuts[_g] if _g >= 0 and _g < len(permuts) else None)
            _g = (_g + 1)
            _g1 = 0
            while (_g1 < len(permuts)):
                p2 = (permuts[_g1] if _g1 >= 0 and _g1 < len(permuts) else None)
                _g1 = (_g1 + 1)
                if (((p1 != p2) and ((p1.material == p2.material))) and self.isSub(p1.joints,p2.joints)):
                    _g2 = 0
                    _g11 = p1.triangles
                    while (_g2 < len(_g11)):
                        t = (_g11[_g2] if _g2 >= 0 and _g2 < len(_g11) else None)
                        _g2 = (_g2 + 1)
                        _this = p2.triangles
                        _this.append(t)
                    python_internal_ArrayImpl.remove(permuts,p1)
                    return True
        return False

    def jointsDiff(self,p1,p2):
        diff = 0
        i = 0
        j = 0
        imax = len(p1.joints)
        jmax = len(p2.joints)
        while ((i < imax) and ((j < jmax))):
            j1 = (p1.joints[i] if i >= 0 and i < len(p1.joints) else None)
            j2 = (p2.joints[j] if j >= 0 and j < len(p2.joints) else None)
            if (j1 == j2):
                i = (i + 1)
                j = (j + 1)
            else:
                diff = (diff + 1)
                if (j1.bindIndex < j2.bindIndex):
                    i = (i + 1)
                else:
                    j = (j + 1)
        return ((diff + ((imax - i))) + ((jmax - j)))

    def split(self,maxBones,index,triangleMaterials):
        if (self.splitJoints is not None):
            return True
        if (len(self.boundJoints) <= maxBones):
            return False
        self.splitJoints = []
        x = (len(index) / 3)
        length = None
        try:
            length = int(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            length = None
        this1 = [None]*length
        self.triangleGroups = this1
        permuts = list()
        _g = 0
        x1 = (len(index) / 3)
        _g1 = None
        try:
            _g1 = int(x1)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e1 = _hx_e1
            _g1 = None
        while (_g < _g1):
            tri = _g
            _g = (_g + 1)
            iid = (tri * 3)
            mid = (0 if ((triangleMaterials is None)) else (triangleMaterials[tri] if tri >= 0 and tri < len(triangleMaterials) else None))
            jl = []
            _g2 = 0
            while (_g2 < 3):
                i = _g2
                _g2 = (_g2 + 1)
                vid = python_internal_ArrayImpl._get(index, (iid + i))
                _g3 = 0
                _g11 = self.bonesPerVertex
                while (_g3 < _g11):
                    b = _g3
                    _g3 = (_g3 + 1)
                    bidx = ((vid * self.bonesPerVertex) + b)
                    if (self.vertexWeights[bidx] == 0):
                        continue
                    j = python_internal_ArrayImpl._get(self.boundJoints, self.vertexJoints[bidx])
                    if (j.splitIndex != iid):
                        j.splitIndex = iid
                        jl.append(j)
            jl.sort(key= python_lib_Functools.cmp_to_key(self.sortByBindIndex))
            _g12 = 0
            while (_g12 < len(permuts)):
                p2 = (permuts[_g12] if _g12 >= 0 and _g12 < len(permuts) else None)
                _g12 = (_g12 + 1)
                if ((p2.material == mid) and self.isSub(jl,p2.joints)):
                    _this = p2.triangles
                    _this.append(tri)
                    jl = None
                    break
            if (jl is None):
                continue
            _g21 = 0
            while (_g21 < len(permuts)):
                p21 = (permuts[_g21] if _g21 >= 0 and _g21 < len(permuts) else None)
                _g21 = (_g21 + 1)
                if ((p21.material == mid) and self.isSub(p21.joints,jl)):
                    p21.joints = jl
                    _this1 = p21.triangles
                    _this1.append(tri)
                    jl = None
                    break
            if (jl is None):
                continue
            pr = h3d_anim__Skin_Permut()
            pr.joints = jl
            pr.triangles = [tri]
            pr.material = mid
            permuts.append(pr)
        while True:
            while self.merge(permuts):
                pass
            minDif = 100000
            minTot = 100000
            minP1 = None
            minP2 = None
            _g22 = 0
            _g31 = len(permuts)
            while (_g22 < _g31):
                i1 = _g22
                _g22 = (_g22 + 1)
                p1 = (permuts[i1] if i1 >= 0 and i1 < len(permuts) else None)
                if (len(p1.joints) == maxBones):
                    continue
                _g23 = (i1 + 1)
                _g32 = len(permuts)
                while (_g23 < _g32):
                    j1 = _g23
                    _g23 = (_g23 + 1)
                    p22 = (permuts[j1] if j1 >= 0 and j1 < len(permuts) else None)
                    if ((len(p22.joints) == maxBones) or ((p1.material != p22.material))):
                        continue
                    count = self.jointsDiff(p1,p22)
                    tot = (count + ((((len(p1.joints) + len(p22.joints)) - count) >> 1)))
                    if (((tot > maxBones) or ((tot > minTot))) or (((tot == minTot) and ((count > minDif))))):
                        continue
                    minDif = count
                    minTot = tot
                    minP1 = p1
                    minP2 = p22
            if (minP1 is None):
                break
            p11 = minP1
            p23 = minP2
            _g4 = 0
            _g5 = p11.joints
            while (_g4 < len(_g5)):
                j2 = (_g5[_g4] if _g4 >= 0 and _g4 < len(_g5) else None)
                _g4 = (_g4 + 1)
                python_internal_ArrayImpl.remove(p23.joints,j2)
                _this2 = p23.joints
                _this2.append(j2)
            p23.joints.sort(key= python_lib_Functools.cmp_to_key(self.sortByBindIndex))
            _g6 = 0
            _g7 = p11.triangles
            while (_g6 < len(_g7)):
                t = (_g7[_g6] if _g6 >= 0 and _g6 < len(_g7) else None)
                _g6 = (_g6 + 1)
                _this3 = p23.triangles
                _this3.append(t)
            python_internal_ArrayImpl.remove(permuts,p11)
        _g24 = 0
        _g33 = len(permuts)
        while (_g24 < _g33):
            i2 = _g24
            _g24 = (_g24 + 1)
            _g25 = 0
            _g34 = (permuts[i2] if i2 >= 0 and i2 < len(permuts) else None).triangles
            while (_g25 < len(_g34)):
                tri1 = (_g34[_g25] if _g25 >= 0 and _g25 < len(_g34) else None)
                _g25 = (_g25 + 1)
                self.triangleGroups[tri1] = i2
        jointsPermuts = []
        _g41 = 0
        _g51 = self.boundJoints
        while (_g41 < len(_g51)):
            j3 = (_g51[_g41] if _g41 >= 0 and _g41 < len(_g51) else None)
            _g41 = (_g41 + 1)
            pl = []
            _g42 = 0
            while (_g42 < len(permuts)):
                p = (permuts[_g42] if _g42 >= 0 and _g42 < len(permuts) else None)
                _g42 = (_g42 + 1)
                if (python_internal_ArrayImpl.indexOf(p.joints,j3,None) >= 0):
                    pl.append(p)
            jointsPermuts.append(_hx_AnonObject({'j': j3, 'pl': pl}))
        def _hx_local_7(j11,j21):
            return (len(j21.pl) - len(j11.pl))
        jointsPermuts.sort(key= python_lib_Functools.cmp_to_key(_hx_local_7))
        _g61 = 0
        while (_g61 < len(permuts)):
            p3 = (permuts[_g61] if _g61 >= 0 and _g61 < len(permuts) else None)
            _g61 = (_g61 + 1)
            p3.indexedJoints = []
        _g71 = 0
        while (_g71 < len(jointsPermuts)):
            j4 = (jointsPermuts[_g71] if _g71 >= 0 and _g71 < len(jointsPermuts) else None)
            _g71 = (_g71 + 1)
            j4.j.splitIndex = -1
            _g72 = 0
            _g8 = maxBones
            while (_g72 < _g8):
                id = _g72
                _g72 = (_g72 + 1)
                ok = True
                _g73 = 0
                _g81 = j4.pl
                while (_g73 < len(_g81)):
                    p4 = (_g81[_g73] if _g73 >= 0 and _g73 < len(_g81) else None)
                    _g73 = (_g73 + 1)
                    if ((p4.indexedJoints[id] if id >= 0 and id < len(p4.indexedJoints) else None) is not None):
                        ok = False
                        break
                if ok:
                    j4.j.splitIndex = id
                    _g9 = 0
                    _g10 = j4.pl
                    while (_g9 < len(_g10)):
                        p5 = (_g10[_g9] if _g9 >= 0 and _g9 < len(_g10) else None)
                        _g9 = (_g9 + 1)
                        python_internal_ArrayImpl._set(p5.indexedJoints, id, j4.j)
                    break
            if (j4.j.splitIndex < 0):
                raise _HxException("Failed to assign index while spliting skin")
        self.splitJoints = []
        _g82 = 0
        while (_g82 < len(permuts)):
            p6 = (permuts[_g82] if _g82 >= 0 and _g82 < len(permuts) else None)
            _g82 = (_g82 + 1)
            jl1 = []
            _g83 = 0
            _g91 = len(p6.indexedJoints)
            while (_g83 < _g91):
                i3 = _g83
                _g83 = (_g83 + 1)
                j5 = (p6.indexedJoints[i3] if i3 >= 0 and i3 < len(p6.indexedJoints) else None)
                if (j5 is None):
                    j5 = (self.boundJoints[0] if 0 < len(self.boundJoints) else None)
                jl1.append(j5)
            _this4 = self.splitJoints
            x2 = _hx_AnonObject({'material': p6.material, 'joints': jl1})
            _this4.append(x2)
        _g92 = 0
        _g101 = len(self.vertexJoints)
        while (_g92 < _g101):
            i4 = _g92
            _g92 = (_g92 + 1)
            this2 = self.vertexJoints
            val = python_internal_ArrayImpl._get(self.boundJoints, self.vertexJoints[i4]).splitIndex
            this2[i4] = val
        return True

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.name = None
        _hx_o.vertexCount = None
        _hx_o.bonesPerVertex = None
        _hx_o.vertexJoints = None
        _hx_o.vertexWeights = None
        _hx_o.rootJoints = None
        _hx_o.namedJoints = None
        _hx_o.allJoints = None
        _hx_o.boundJoints = None
        _hx_o.primitive = None
        _hx_o.splitJoints = None
        _hx_o.triangleGroups = None
        _hx_o.envelop = None
h3d_anim_Skin._hx_class = h3d_anim_Skin
_hx_classes["h3d.anim.Skin"] = h3d_anim_Skin


class h3d_col_Collider:
    _hx_class_name = "h3d.col.Collider"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_methods = ["rayIntersection", "contains", "inFrustum", "inSphere"]
    _hx_interfaces = [hxd_impl__Serializable_NoSerializeSupport]
h3d_col_Collider._hx_class = h3d_col_Collider
_hx_classes["h3d.col.Collider"] = h3d_col_Collider


class h3d_col_Bounds:
    _hx_class_name = "h3d.col.Bounds"
    _hx_is_interface = "False"
    __slots__ = ("xMin", "xMax", "yMin", "yMax", "zMin", "zMax")
    _hx_fields = ["xMin", "xMax", "yMin", "yMax", "zMin", "zMax"]
    _hx_methods = ["inFrustum", "inSphere", "testPlane", "rayIntersection", "inFrustumDetails", "transform3x3", "transform", "collide", "contains", "add", "addPoint", "addPos", "intersection", "offset", "setMin", "setMax", "load", "scalePivot", "scaleCenter", "getMin", "getCenter", "getSize", "getMax", "get_xSize", "get_ySize", "get_zSize", "set_xSize", "set_ySize", "set_zSize", "isEmpty", "empty", "all", "clone", "toString", "toSphere"]
    _hx_statics = ["fromPoints", "fromValues"]
    _hx_interfaces = [h3d_col_Collider]

    def __init__(self):
        self.xMin = 1e20
        self.xMax = -1e20
        self.yMin = 1e20
        self.yMax = -1e20
        self.zMin = 1e20
        self.zMax = -1e20

    def inFrustum(self,f,m = None):
        if (m is not None):
            raise _HxException("Not implemented")
        return f.hasBounds(self)

    def inSphere(self,s):
        x = s.x
        y = s.y
        z = s.z
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        c_x = x
        c_y = y
        c_z = z
        a = self.xMin
        a1 = s.x
        b = self.xMax
        b1 = (b if ((a1 > b)) else a1)
        x1 = (b1 if ((a < b1)) else a)
        a2 = self.yMin
        a3 = s.y
        b2 = self.yMax
        b3 = (b2 if ((a3 > b2)) else a3)
        y1 = (b3 if ((a2 < b3)) else a2)
        a4 = self.zMin
        a5 = s.z
        b4 = self.zMax
        b5 = (b4 if ((a5 > b4)) else a5)
        z1 = (b5 if ((a4 < b5)) else a4)
        if (z1 is None):
            z1 = 0.
        if (y1 is None):
            y1 = 0.
        if (x1 is None):
            x1 = 0.
        p_x = x1
        p_y = y1
        p_z = z1
        dx = (p_x - c_x)
        dy = (p_y - c_y)
        dz = (p_z - c_z)
        return ((((dx * dx) + ((dy * dy))) + ((dz * dz))) < ((s.r * s.r)))

    def testPlane(self,p):
        a = p.nx
        b = p.ny
        c = p.nz
        dd = (((a * ((self.xMax + self.xMin))) + ((b * ((self.yMax + self.yMin))))) + ((c * ((self.zMax + self.zMin)))))
        if (a < 0):
            a = -a
        if (b < 0):
            b = -b
        if (c < 0):
            c = -c
        rr = (((a * ((self.xMax - self.xMin))) + ((b * ((self.yMax - self.yMin))))) + ((c * ((self.zMax - self.zMin)))))
        return ((dd + rr) - ((p.d * 2)))

    def rayIntersection(self,r,bestMatch):
        minTx = (((self.xMin - r.px)) / r.lx)
        minTy = (((self.yMin - r.py)) / r.ly)
        minTz = (((self.zMin - r.pz)) / r.lz)
        maxTx = (((self.xMax - r.px)) / r.lx)
        maxTy = (((self.yMax - r.py)) / r.ly)
        maxTz = (((self.zMax - r.pz)) / r.lz)
        realMinTx = (maxTx if ((minTx > maxTx)) else minTx)
        realMinTy = (maxTy if ((minTy > maxTy)) else minTy)
        realMinTz = (maxTz if ((minTz > maxTz)) else minTz)
        realMaxTx = (maxTx if ((minTx < maxTx)) else minTx)
        realMaxTy = (maxTy if ((minTy < maxTy)) else minTy)
        realMaxTz = (maxTz if ((minTz < maxTz)) else minTz)
        a = (realMaxTy if ((realMaxTx > realMaxTy)) else realMaxTx)
        minmax = (realMaxTz if ((a > realMaxTz)) else a)
        a1 = (realMinTy if ((realMinTx < realMinTy)) else realMinTx)
        maxmin = (realMinTz if ((a1 < realMinTz)) else a1)
        if (minmax < maxmin):
            return -1
        return maxmin

    def inFrustumDetails(self,mvp,checkZ = None):
        if (checkZ is None):
            checkZ = True
        ret = 1
        p_nx = (mvp._14 + mvp._11)
        p_ny = (mvp._24 + mvp._21)
        p_nz = (mvp._34 + mvp._31)
        p_d = (mvp._44 + mvp._41)
        m = (((p_nx * ((self.xMax if ((p_nx > 0)) else self.xMin))) + ((p_ny * ((self.yMax if ((p_ny > 0)) else self.yMin))))) + ((p_nz * ((self.zMax if ((p_nz > 0)) else self.zMin)))))
        if ((m + p_d) < 0):
            return -1
        n = (((p_nx * ((self.xMin if ((p_nx > 0)) else self.xMax))) + ((p_ny * ((self.yMin if ((p_ny > 0)) else self.yMax))))) + ((p_nz * ((self.zMin if ((p_nz > 0)) else self.zMax)))))
        if ((n + p_d) < 0):
            ret = 0
        p_nx1 = (mvp._14 - mvp._11)
        p_ny1 = (mvp._24 - mvp._21)
        p_nz1 = (mvp._34 - mvp._31)
        p_d1 = (mvp._44 - mvp._41)
        m1 = (((p_nx1 * ((self.xMax if ((p_nx1 > 0)) else self.xMin))) + ((p_ny1 * ((self.yMax if ((p_ny1 > 0)) else self.yMin))))) + ((p_nz1 * ((self.zMax if ((p_nz1 > 0)) else self.zMin)))))
        if ((m1 + p_d1) < 0):
            return -1
        n1 = (((p_nx1 * ((self.xMin if ((p_nx1 > 0)) else self.xMax))) + ((p_ny1 * ((self.yMin if ((p_ny1 > 0)) else self.yMax))))) + ((p_nz1 * ((self.zMin if ((p_nz1 > 0)) else self.zMax)))))
        if ((n1 + p_d1) < 0):
            ret = 0
        p_nx2 = (mvp._14 + mvp._12)
        p_ny2 = (mvp._24 + mvp._22)
        p_nz2 = (mvp._34 + mvp._32)
        p_d2 = (mvp._44 + mvp._42)
        m2 = (((p_nx2 * ((self.xMax if ((p_nx2 > 0)) else self.xMin))) + ((p_ny2 * ((self.yMax if ((p_ny2 > 0)) else self.yMin))))) + ((p_nz2 * ((self.zMax if ((p_nz2 > 0)) else self.zMin)))))
        if ((m2 + p_d2) < 0):
            return -1
        n2 = (((p_nx2 * ((self.xMin if ((p_nx2 > 0)) else self.xMax))) + ((p_ny2 * ((self.yMin if ((p_ny2 > 0)) else self.yMax))))) + ((p_nz2 * ((self.zMin if ((p_nz2 > 0)) else self.zMax)))))
        if ((n2 + p_d2) < 0):
            ret = 0
        p_nx3 = (mvp._14 - mvp._12)
        p_ny3 = (mvp._24 - mvp._22)
        p_nz3 = (mvp._34 - mvp._32)
        p_d3 = (mvp._44 - mvp._42)
        m3 = (((p_nx3 * ((self.xMax if ((p_nx3 > 0)) else self.xMin))) + ((p_ny3 * ((self.yMax if ((p_ny3 > 0)) else self.yMin))))) + ((p_nz3 * ((self.zMax if ((p_nz3 > 0)) else self.zMin)))))
        if ((m3 + p_d3) < 0):
            return -1
        n3 = (((p_nx3 * ((self.xMin if ((p_nx3 > 0)) else self.xMax))) + ((p_ny3 * ((self.yMin if ((p_ny3 > 0)) else self.yMax))))) + ((p_nz3 * ((self.zMin if ((p_nz3 > 0)) else self.zMax)))))
        if ((n3 + p_d3) < 0):
            ret = 0
        if checkZ:
            p_nx4 = mvp._13
            p_ny4 = mvp._23
            p_nz4 = mvp._33
            p_d4 = mvp._43
            m4 = (((p_nx4 * ((self.xMax if ((p_nx4 > 0)) else self.xMin))) + ((p_ny4 * ((self.yMax if ((p_ny4 > 0)) else self.yMin))))) + ((p_nz4 * ((self.zMax if ((p_nz4 > 0)) else self.zMin)))))
            if ((m4 + p_d4) < 0):
                return -1
            n4 = (((p_nx4 * ((self.xMin if ((p_nx4 > 0)) else self.xMax))) + ((p_ny4 * ((self.yMin if ((p_ny4 > 0)) else self.yMax))))) + ((p_nz4 * ((self.zMin if ((p_nz4 > 0)) else self.zMax)))))
            if ((n4 + p_d4) < 0):
                ret = 0
            p_nx5 = (mvp._14 - mvp._13)
            p_ny5 = (mvp._24 - mvp._23)
            p_nz5 = (mvp._34 - mvp._33)
            p_d5 = (mvp._44 - mvp._43)
            m5 = (((p_nx5 * ((self.xMax if ((p_nx5 > 0)) else self.xMin))) + ((p_ny5 * ((self.yMax if ((p_ny5 > 0)) else self.yMin))))) + ((p_nz5 * ((self.zMax if ((p_nz5 > 0)) else self.zMin)))))
            if ((m5 + p_d5) < 0):
                return -1
            n5 = (((p_nx5 * ((self.xMin if ((p_nx5 > 0)) else self.xMax))) + ((p_ny5 * ((self.yMin if ((p_ny5 > 0)) else self.yMax))))) + ((p_nz5 * ((self.zMin if ((p_nz5 > 0)) else self.zMax)))))
            if ((n5 + p_d5) < 0):
                ret = 0
        return ret

    def transform3x3(self,m):
        xMin = self.xMin
        yMin = self.yMin
        zMin = self.zMin
        xMax = self.xMax
        yMax = self.yMax
        zMax = self.zMax
        self.xMin = 1e20
        self.xMax = -1e20
        self.yMin = 1e20
        self.yMax = -1e20
        self.zMin = 1e20
        self.zMax = -1e20
        v_x = 0.
        v_y = 0.
        v_z = 0.
        v_x = xMin
        v_y = yMin
        v_z = zMin
        px = (((v_x * m._11) + ((v_y * m._21))) + ((v_z * m._31)))
        py = (((v_x * m._12) + ((v_y * m._22))) + ((v_z * m._32)))
        pz = (((v_x * m._13) + ((v_y * m._23))) + ((v_z * m._33)))
        v_x = px
        v_y = py
        v_z = pz
        if (v_x < self.xMin):
            self.xMin = v_x
        if (v_x > self.xMax):
            self.xMax = v_x
        if (v_y < self.yMin):
            self.yMin = v_y
        if (v_y > self.yMax):
            self.yMax = v_y
        if (v_z < self.zMin):
            self.zMin = v_z
        if (v_z > self.zMax):
            self.zMax = v_z
        v_x = xMin
        v_y = yMin
        v_z = zMax
        px1 = (((v_x * m._11) + ((v_y * m._21))) + ((v_z * m._31)))
        py1 = (((v_x * m._12) + ((v_y * m._22))) + ((v_z * m._32)))
        pz1 = (((v_x * m._13) + ((v_y * m._23))) + ((v_z * m._33)))
        v_x = px1
        v_y = py1
        v_z = pz1
        if (v_x < self.xMin):
            self.xMin = v_x
        if (v_x > self.xMax):
            self.xMax = v_x
        if (v_y < self.yMin):
            self.yMin = v_y
        if (v_y > self.yMax):
            self.yMax = v_y
        if (v_z < self.zMin):
            self.zMin = v_z
        if (v_z > self.zMax):
            self.zMax = v_z
        v_x = xMin
        v_y = yMax
        v_z = zMin
        px2 = (((v_x * m._11) + ((v_y * m._21))) + ((v_z * m._31)))
        py2 = (((v_x * m._12) + ((v_y * m._22))) + ((v_z * m._32)))
        pz2 = (((v_x * m._13) + ((v_y * m._23))) + ((v_z * m._33)))
        v_x = px2
        v_y = py2
        v_z = pz2
        if (v_x < self.xMin):
            self.xMin = v_x
        if (v_x > self.xMax):
            self.xMax = v_x
        if (v_y < self.yMin):
            self.yMin = v_y
        if (v_y > self.yMax):
            self.yMax = v_y
        if (v_z < self.zMin):
            self.zMin = v_z
        if (v_z > self.zMax):
            self.zMax = v_z
        v_x = xMin
        v_y = yMax
        v_z = zMax
        px3 = (((v_x * m._11) + ((v_y * m._21))) + ((v_z * m._31)))
        py3 = (((v_x * m._12) + ((v_y * m._22))) + ((v_z * m._32)))
        pz3 = (((v_x * m._13) + ((v_y * m._23))) + ((v_z * m._33)))
        v_x = px3
        v_y = py3
        v_z = pz3
        if (v_x < self.xMin):
            self.xMin = v_x
        if (v_x > self.xMax):
            self.xMax = v_x
        if (v_y < self.yMin):
            self.yMin = v_y
        if (v_y > self.yMax):
            self.yMax = v_y
        if (v_z < self.zMin):
            self.zMin = v_z
        if (v_z > self.zMax):
            self.zMax = v_z
        v_x = xMax
        v_y = yMin
        v_z = zMin
        px4 = (((v_x * m._11) + ((v_y * m._21))) + ((v_z * m._31)))
        py4 = (((v_x * m._12) + ((v_y * m._22))) + ((v_z * m._32)))
        pz4 = (((v_x * m._13) + ((v_y * m._23))) + ((v_z * m._33)))
        v_x = px4
        v_y = py4
        v_z = pz4
        if (v_x < self.xMin):
            self.xMin = v_x
        if (v_x > self.xMax):
            self.xMax = v_x
        if (v_y < self.yMin):
            self.yMin = v_y
        if (v_y > self.yMax):
            self.yMax = v_y
        if (v_z < self.zMin):
            self.zMin = v_z
        if (v_z > self.zMax):
            self.zMax = v_z
        v_x = xMax
        v_y = yMin
        v_z = zMax
        px5 = (((v_x * m._11) + ((v_y * m._21))) + ((v_z * m._31)))
        py5 = (((v_x * m._12) + ((v_y * m._22))) + ((v_z * m._32)))
        pz5 = (((v_x * m._13) + ((v_y * m._23))) + ((v_z * m._33)))
        v_x = px5
        v_y = py5
        v_z = pz5
        if (v_x < self.xMin):
            self.xMin = v_x
        if (v_x > self.xMax):
            self.xMax = v_x
        if (v_y < self.yMin):
            self.yMin = v_y
        if (v_y > self.yMax):
            self.yMax = v_y
        if (v_z < self.zMin):
            self.zMin = v_z
        if (v_z > self.zMax):
            self.zMax = v_z
        v_x = xMax
        v_y = yMax
        v_z = zMin
        px6 = (((v_x * m._11) + ((v_y * m._21))) + ((v_z * m._31)))
        py6 = (((v_x * m._12) + ((v_y * m._22))) + ((v_z * m._32)))
        pz6 = (((v_x * m._13) + ((v_y * m._23))) + ((v_z * m._33)))
        v_x = px6
        v_y = py6
        v_z = pz6
        if (v_x < self.xMin):
            self.xMin = v_x
        if (v_x > self.xMax):
            self.xMax = v_x
        if (v_y < self.yMin):
            self.yMin = v_y
        if (v_y > self.yMax):
            self.yMax = v_y
        if (v_z < self.zMin):
            self.zMin = v_z
        if (v_z > self.zMax):
            self.zMax = v_z
        v_x = xMax
        v_y = yMax
        v_z = zMax
        px7 = (((v_x * m._11) + ((v_y * m._21))) + ((v_z * m._31)))
        py7 = (((v_x * m._12) + ((v_y * m._22))) + ((v_z * m._32)))
        pz7 = (((v_x * m._13) + ((v_y * m._23))) + ((v_z * m._33)))
        v_x = px7
        v_y = py7
        v_z = pz7
        if (v_x < self.xMin):
            self.xMin = v_x
        if (v_x > self.xMax):
            self.xMax = v_x
        if (v_y < self.yMin):
            self.yMin = v_y
        if (v_y > self.yMax):
            self.yMax = v_y
        if (v_z < self.zMin):
            self.zMin = v_z
        if (v_z > self.zMax):
            self.zMax = v_z

    def transform(self,m):
        xMin = self.xMin
        yMin = self.yMin
        zMin = self.zMin
        xMax = self.xMax
        yMax = self.yMax
        zMax = self.zMax
        self.xMin = 1e20
        self.xMax = -1e20
        self.yMin = 1e20
        self.yMax = -1e20
        self.zMin = 1e20
        self.zMax = -1e20
        if (((xMax < xMin) and ((yMax < yMin))) and ((zMax < zMin))):
            return
        v_x = 0.
        v_y = 0.
        v_z = 0.
        v_x = xMin
        v_y = yMin
        v_z = zMin
        px = ((((v_x * m._11) + ((v_y * m._21))) + ((v_z * m._31))) + m._41)
        py = ((((v_x * m._12) + ((v_y * m._22))) + ((v_z * m._32))) + m._42)
        pz = ((((v_x * m._13) + ((v_y * m._23))) + ((v_z * m._33))) + m._43)
        v_x = px
        v_y = py
        v_z = pz
        if (v_x < self.xMin):
            self.xMin = v_x
        if (v_x > self.xMax):
            self.xMax = v_x
        if (v_y < self.yMin):
            self.yMin = v_y
        if (v_y > self.yMax):
            self.yMax = v_y
        if (v_z < self.zMin):
            self.zMin = v_z
        if (v_z > self.zMax):
            self.zMax = v_z
        v_x = xMin
        v_y = yMin
        v_z = zMax
        px1 = ((((v_x * m._11) + ((v_y * m._21))) + ((v_z * m._31))) + m._41)
        py1 = ((((v_x * m._12) + ((v_y * m._22))) + ((v_z * m._32))) + m._42)
        pz1 = ((((v_x * m._13) + ((v_y * m._23))) + ((v_z * m._33))) + m._43)
        v_x = px1
        v_y = py1
        v_z = pz1
        if (v_x < self.xMin):
            self.xMin = v_x
        if (v_x > self.xMax):
            self.xMax = v_x
        if (v_y < self.yMin):
            self.yMin = v_y
        if (v_y > self.yMax):
            self.yMax = v_y
        if (v_z < self.zMin):
            self.zMin = v_z
        if (v_z > self.zMax):
            self.zMax = v_z
        v_x = xMin
        v_y = yMax
        v_z = zMin
        px2 = ((((v_x * m._11) + ((v_y * m._21))) + ((v_z * m._31))) + m._41)
        py2 = ((((v_x * m._12) + ((v_y * m._22))) + ((v_z * m._32))) + m._42)
        pz2 = ((((v_x * m._13) + ((v_y * m._23))) + ((v_z * m._33))) + m._43)
        v_x = px2
        v_y = py2
        v_z = pz2
        if (v_x < self.xMin):
            self.xMin = v_x
        if (v_x > self.xMax):
            self.xMax = v_x
        if (v_y < self.yMin):
            self.yMin = v_y
        if (v_y > self.yMax):
            self.yMax = v_y
        if (v_z < self.zMin):
            self.zMin = v_z
        if (v_z > self.zMax):
            self.zMax = v_z
        v_x = xMin
        v_y = yMax
        v_z = zMax
        px3 = ((((v_x * m._11) + ((v_y * m._21))) + ((v_z * m._31))) + m._41)
        py3 = ((((v_x * m._12) + ((v_y * m._22))) + ((v_z * m._32))) + m._42)
        pz3 = ((((v_x * m._13) + ((v_y * m._23))) + ((v_z * m._33))) + m._43)
        v_x = px3
        v_y = py3
        v_z = pz3
        if (v_x < self.xMin):
            self.xMin = v_x
        if (v_x > self.xMax):
            self.xMax = v_x
        if (v_y < self.yMin):
            self.yMin = v_y
        if (v_y > self.yMax):
            self.yMax = v_y
        if (v_z < self.zMin):
            self.zMin = v_z
        if (v_z > self.zMax):
            self.zMax = v_z
        v_x = xMax
        v_y = yMin
        v_z = zMin
        px4 = ((((v_x * m._11) + ((v_y * m._21))) + ((v_z * m._31))) + m._41)
        py4 = ((((v_x * m._12) + ((v_y * m._22))) + ((v_z * m._32))) + m._42)
        pz4 = ((((v_x * m._13) + ((v_y * m._23))) + ((v_z * m._33))) + m._43)
        v_x = px4
        v_y = py4
        v_z = pz4
        if (v_x < self.xMin):
            self.xMin = v_x
        if (v_x > self.xMax):
            self.xMax = v_x
        if (v_y < self.yMin):
            self.yMin = v_y
        if (v_y > self.yMax):
            self.yMax = v_y
        if (v_z < self.zMin):
            self.zMin = v_z
        if (v_z > self.zMax):
            self.zMax = v_z
        v_x = xMax
        v_y = yMin
        v_z = zMax
        px5 = ((((v_x * m._11) + ((v_y * m._21))) + ((v_z * m._31))) + m._41)
        py5 = ((((v_x * m._12) + ((v_y * m._22))) + ((v_z * m._32))) + m._42)
        pz5 = ((((v_x * m._13) + ((v_y * m._23))) + ((v_z * m._33))) + m._43)
        v_x = px5
        v_y = py5
        v_z = pz5
        if (v_x < self.xMin):
            self.xMin = v_x
        if (v_x > self.xMax):
            self.xMax = v_x
        if (v_y < self.yMin):
            self.yMin = v_y
        if (v_y > self.yMax):
            self.yMax = v_y
        if (v_z < self.zMin):
            self.zMin = v_z
        if (v_z > self.zMax):
            self.zMax = v_z
        v_x = xMax
        v_y = yMax
        v_z = zMin
        px6 = ((((v_x * m._11) + ((v_y * m._21))) + ((v_z * m._31))) + m._41)
        py6 = ((((v_x * m._12) + ((v_y * m._22))) + ((v_z * m._32))) + m._42)
        pz6 = ((((v_x * m._13) + ((v_y * m._23))) + ((v_z * m._33))) + m._43)
        v_x = px6
        v_y = py6
        v_z = pz6
        if (v_x < self.xMin):
            self.xMin = v_x
        if (v_x > self.xMax):
            self.xMax = v_x
        if (v_y < self.yMin):
            self.yMin = v_y
        if (v_y > self.yMax):
            self.yMax = v_y
        if (v_z < self.zMin):
            self.zMin = v_z
        if (v_z > self.zMax):
            self.zMax = v_z
        v_x = xMax
        v_y = yMax
        v_z = zMax
        px7 = ((((v_x * m._11) + ((v_y * m._21))) + ((v_z * m._31))) + m._41)
        py7 = ((((v_x * m._12) + ((v_y * m._22))) + ((v_z * m._32))) + m._42)
        pz7 = ((((v_x * m._13) + ((v_y * m._23))) + ((v_z * m._33))) + m._43)
        v_x = px7
        v_y = py7
        v_z = pz7
        if (v_x < self.xMin):
            self.xMin = v_x
        if (v_x > self.xMax):
            self.xMax = v_x
        if (v_y < self.yMin):
            self.yMin = v_y
        if (v_y > self.yMax):
            self.yMax = v_y
        if (v_z < self.zMin):
            self.zMin = v_z
        if (v_z > self.zMax):
            self.zMax = v_z

    def collide(self,b):
        return (not (((((((self.xMin > b.xMax) or ((self.yMin > b.yMax))) or ((self.zMin > b.zMax))) or ((self.xMax < b.xMin))) or ((self.yMax < b.yMin))) or ((self.zMax < b.zMin)))))

    def contains(self,p):
        if (((((p.x >= self.xMin) and ((p.x < self.xMax))) and ((p.y >= self.yMin))) and ((p.y < self.yMax))) and ((p.z >= self.zMin))):
            return (p.z < self.zMax)
        else:
            return False

    def add(self,b):
        if (b.xMin < self.xMin):
            self.xMin = b.xMin
        if (b.xMax > self.xMax):
            self.xMax = b.xMax
        if (b.yMin < self.yMin):
            self.yMin = b.yMin
        if (b.yMax > self.yMax):
            self.yMax = b.yMax
        if (b.zMin < self.zMin):
            self.zMin = b.zMin
        if (b.zMax > self.zMax):
            self.zMax = b.zMax

    def addPoint(self,p):
        if (p.x < self.xMin):
            self.xMin = p.x
        if (p.x > self.xMax):
            self.xMax = p.x
        if (p.y < self.yMin):
            self.yMin = p.y
        if (p.y > self.yMax):
            self.yMax = p.y
        if (p.z < self.zMin):
            self.zMin = p.z
        if (p.z > self.zMax):
            self.zMax = p.z

    def addPos(self,x,y,z):
        if (x < self.xMin):
            self.xMin = x
        if (x > self.xMax):
            self.xMax = x
        if (y < self.yMin):
            self.yMin = y
        if (y > self.yMax):
            self.yMax = y
        if (z < self.zMin):
            self.zMin = z
        if (z > self.zMax):
            self.zMax = z

    def intersection(self,a,b):
        a1 = a.xMin
        b1 = b.xMin
        xMin = (b1 if ((a1 < b1)) else a1)
        a2 = a.yMin
        b2 = b.yMin
        yMin = (b2 if ((a2 < b2)) else a2)
        a3 = a.zMin
        b3 = b.zMin
        zMin = (b3 if ((a3 < b3)) else a3)
        a4 = a.xMax
        b4 = b.xMax
        xMax = (b4 if ((a4 > b4)) else a4)
        a5 = a.yMax
        b5 = b.yMax
        yMax = (b5 if ((a5 > b5)) else a5)
        a6 = a.zMax
        b6 = b.zMax
        zMax = (b6 if ((a6 > b6)) else a6)
        self.xMin = xMin
        self.xMax = xMax
        self.yMin = yMin
        self.yMax = yMax
        self.zMin = zMin
        self.zMax = zMax

    def offset(self,dx,dy,dz):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.xMin
        _hx_local_0.xMin = (_hx_local_1 + dx)
        _hx_local_0.xMin
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.xMax
        _hx_local_2.xMax = (_hx_local_3 + dx)
        _hx_local_2.xMax
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.yMin
        _hx_local_4.yMin = (_hx_local_5 + dy)
        _hx_local_4.yMin
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6.yMax
        _hx_local_6.yMax = (_hx_local_7 + dy)
        _hx_local_6.yMax
        _hx_local_8 = self
        _hx_local_9 = _hx_local_8.zMin
        _hx_local_8.zMin = (_hx_local_9 + dz)
        _hx_local_8.zMin
        _hx_local_10 = self
        _hx_local_11 = _hx_local_10.zMax
        _hx_local_10.zMax = (_hx_local_11 + dz)
        _hx_local_10.zMax

    def setMin(self,p):
        self.xMin = p.x
        self.yMin = p.y
        self.zMin = p.z

    def setMax(self,p):
        self.xMax = p.x
        self.yMax = p.y
        self.zMax = p.z

    def load(self,b):
        self.xMin = b.xMin
        self.xMax = b.xMax
        self.yMin = b.yMin
        self.yMax = b.yMax
        self.zMin = b.zMin
        self.zMax = b.zMax

    def scalePivot(self,v):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.xMin
        _hx_local_0.xMin = (_hx_local_1 * v)
        _hx_local_0.xMin
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.yMin
        _hx_local_2.yMin = (_hx_local_3 * v)
        _hx_local_2.yMin
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.zMin
        _hx_local_4.zMin = (_hx_local_5 * v)
        _hx_local_4.zMin
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6.xMax
        _hx_local_6.xMax = (_hx_local_7 * v)
        _hx_local_6.xMax
        _hx_local_8 = self
        _hx_local_9 = _hx_local_8.yMax
        _hx_local_8.yMax = (_hx_local_9 * v)
        _hx_local_8.yMax
        _hx_local_10 = self
        _hx_local_11 = _hx_local_10.zMax
        _hx_local_10.zMax = (_hx_local_11 * v)
        _hx_local_10.zMax

    def scaleCenter(self,v):
        dx = ((((self.xMax - self.xMin)) * 0.5) * v)
        dy = ((((self.yMax - self.yMin)) * 0.5) * v)
        dz = ((((self.zMax - self.zMin)) * 0.5) * v)
        mx = (((self.xMax + self.xMin)) * 0.5)
        my = (((self.yMax + self.yMin)) * 0.5)
        mz = (((self.zMax + self.zMin)) * 0.5)
        self.xMin = (mx - dx)
        self.yMin = (my - dy)
        self.zMin = (mz - dz)
        self.xMax = (mx + dx)
        self.yMax = (my + dy)
        self.zMax = (mz + dz)

    def getMin(self):
        return h3d_col_Point(self.xMin,self.yMin,self.zMin)

    def getCenter(self):
        return h3d_col_Point((((self.xMin + self.xMax)) * 0.5),(((self.yMin + self.yMax)) * 0.5),(((self.zMin + self.zMax)) * 0.5))

    def getSize(self):
        return h3d_col_Point((self.xMax - self.xMin),(self.yMax - self.yMin),(self.zMax - self.zMin))

    def getMax(self):
        return h3d_col_Point(self.xMax,self.yMax,self.zMax)

    def get_xSize(self):
        return (self.xMax - self.xMin)

    def get_ySize(self):
        return (self.yMax - self.yMin)

    def get_zSize(self):
        return (self.zMax - self.zMin)

    def set_xSize(self,v):
        self.xMax = (self.xMin + v)
        return v

    def set_ySize(self,v):
        self.yMax = (self.yMin + v)
        return v

    def set_zSize(self,v):
        self.zMax = (self.zMin + v)
        return v

    def isEmpty(self):
        if (not (((self.xMax < self.xMin) or ((self.yMax < self.yMin))))):
            return (self.zMax < self.zMin)
        else:
            return True

    def empty(self):
        self.xMin = 1e20
        self.xMax = -1e20
        self.yMin = 1e20
        self.yMax = -1e20
        self.zMin = 1e20
        self.zMax = -1e20

    def all(self):
        self.xMin = -1e20
        self.xMax = 1e20
        self.yMin = -1e20
        self.yMax = 1e20
        self.zMin = -1e20
        self.zMax = 1e20

    def clone(self):
        b = h3d_col_Bounds()
        b.xMin = self.xMin
        b.xMax = self.xMax
        b.yMin = self.yMin
        b.yMax = self.yMax
        b.zMin = self.zMin
        b.zMax = self.zMax
        return b

    def toString(self):
        return (((("Bounds{" + Std.string(h3d_col_Point(self.xMin,self.yMin,self.zMin))) + ",") + Std.string(h3d_col_Point((self.xMax - self.xMin),(self.yMax - self.yMin),(self.zMax - self.zMin)))) + "}")

    def toSphere(self):
        dx = (self.xMax - self.xMin)
        dy = (self.yMax - self.yMin)
        dz = (self.zMax - self.zMin)
        f = (((dx * dx) + ((dy * dy))) + ((dz * dz)))
        return h3d_col_Sphere((((self.xMin + self.xMax)) * 0.5),(((self.yMin + self.yMax)) * 0.5),(((self.zMin + self.zMax)) * 0.5),(((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))) * 0.5))

    @staticmethod
    def fromPoints(_hx_min,_hx_max):
        b = h3d_col_Bounds()
        b.xMin = _hx_min.x
        b.yMin = _hx_min.y
        b.zMin = _hx_min.z
        b.xMax = _hx_max.x
        b.yMax = _hx_max.y
        b.zMax = _hx_max.z
        return b

    @staticmethod
    def fromValues(x,y,z,dx,dy,dz):
        b = h3d_col_Bounds()
        b.xMin = x
        b.yMin = y
        b.zMin = z
        b.xMax = (x + dx)
        b.yMax = (y + dy)
        b.zMax = (z + dz)
        return b

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.xMin = None
        _hx_o.xMax = None
        _hx_o.yMin = None
        _hx_o.yMax = None
        _hx_o.zMin = None
        _hx_o.zMax = None
h3d_col_Bounds._hx_class = h3d_col_Bounds
_hx_classes["h3d.col.Bounds"] = h3d_col_Bounds


class h3d_col_OptimizedCollider:
    _hx_class_name = "h3d.col.OptimizedCollider"
    _hx_is_interface = "False"
    __slots__ = ("a", "b")
    _hx_fields = ["a", "b"]
    _hx_methods = ["rayIntersection", "contains", "inFrustum", "inSphere"]
    _hx_interfaces = [h3d_col_Collider, hxd_impl__Serializable_NoSerializeSupport]

    def __init__(self,a,b):
        self.a = a
        self.b = b

    def rayIntersection(self,r,bestMatch):
        if (self.a.rayIntersection(r,bestMatch) < 0):
            return -1
        return self.b.rayIntersection(r,bestMatch)

    def contains(self,p):
        if self.a.contains(p):
            return self.b.contains(p)
        else:
            return False

    def inFrustum(self,f,m = None):
        if self.a.inFrustum(f,m):
            return self.b.inFrustum(f,m)
        else:
            return False

    def inSphere(self,s):
        if self.a.inSphere(s):
            return self.b.inSphere(s)
        else:
            return False

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.a = None
        _hx_o.b = None
h3d_col_OptimizedCollider._hx_class = h3d_col_OptimizedCollider
_hx_classes["h3d.col.OptimizedCollider"] = h3d_col_OptimizedCollider


class h3d_col_GroupCollider:
    _hx_class_name = "h3d.col.GroupCollider"
    _hx_is_interface = "False"
    __slots__ = ("colliders",)
    _hx_fields = ["colliders"]
    _hx_methods = ["rayIntersection", "contains", "inFrustum", "inSphere"]
    _hx_interfaces = [h3d_col_Collider]

    def __init__(self,colliders):
        self.colliders = colliders

    def rayIntersection(self,r,bestMatch):
        best = -1.
        _g = 0
        _g1 = self.colliders
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            d = c.rayIntersection(r,bestMatch)
            if (d >= 0):
                if (not bestMatch):
                    return d
                if ((best < 0) or ((d < best))):
                    best = d
        return best

    def contains(self,p):
        _g = 0
        _g1 = self.colliders
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if c.contains(p):
                return True
        return False

    def inFrustum(self,f,m = None):
        _g = 0
        _g1 = self.colliders
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if c.inFrustum(f,m):
                return True
        return False

    def inSphere(self,s):
        _g = 0
        _g1 = self.colliders
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if c.inSphere(s):
                return True
        return False

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.colliders = None
h3d_col_GroupCollider._hx_class = h3d_col_GroupCollider
_hx_classes["h3d.col.GroupCollider"] = h3d_col_GroupCollider


class h3d_col_FPoint:
    _hx_class_name = "h3d.col.FPoint"
    _hx_is_interface = "False"
    __slots__ = ("x", "y", "z")
    _hx_fields = ["x", "y", "z"]
    _hx_methods = ["sub", "add", "cross", "dot", "toString"]

    def __init__(self,x = None,y = None,z = None):
        if (x is None):
            x = 0.
        if (y is None):
            y = 0.
        if (z is None):
            z = 0.
        self.x = x
        self.y = y
        self.z = z

    def sub(self,p):
        return h3d_col_FPoint((self.x - p.x),(self.y - p.y),(self.z - p.z))

    def add(self,p):
        return h3d_col_FPoint((self.x + p.x),(self.y + p.y),(self.z + p.z))

    def cross(self,p):
        return h3d_col_FPoint(((self.y * p.z) - ((self.z * p.y))),((self.z * p.x) - ((self.x * p.z))),((self.x * p.y) - ((self.y * p.x))))

    def dot(self,p):
        return (((self.x * p.x) + ((self.y * p.y))) + ((self.z * p.z)))

    def toString(self):
        return (((((("FPoint{" + Std.string(hxd_Math.fmt(self.x))) + ",") + Std.string(hxd_Math.fmt(self.y))) + ",") + Std.string(hxd_Math.fmt(self.z))) + "}")

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.x = None
        _hx_o.y = None
        _hx_o.z = None
h3d_col_FPoint._hx_class = h3d_col_FPoint
_hx_classes["h3d.col.FPoint"] = h3d_col_FPoint


class h3d_col_Frustum:
    _hx_class_name = "h3d.col.Frustum"
    _hx_is_interface = "False"
    __slots__ = ("pleft", "pright", "ptop", "pbottom", "pnear", "pfar", "checkNearFar")
    _hx_fields = ["pleft", "pright", "ptop", "pbottom", "pnear", "pfar", "checkNearFar"]
    _hx_methods = ["clone", "loadMatrix", "transform", "transform3x3", "hasPoint", "hasSphere", "hasBounds"]

    def __init__(self,mvp = None):
        self.checkNearFar = True
        self.pleft = h3d_col_Plane(1,0,0,0.0)
        self.pright = h3d_col_Plane(1,0,0,0.0)
        self.ptop = h3d_col_Plane(1,0,0,0.0)
        self.pbottom = h3d_col_Plane(1,0,0,0.0)
        self.pnear = h3d_col_Plane(1,0,0,0.0)
        self.pfar = h3d_col_Plane(1,0,0,0.0)
        if (mvp is not None):
            self.loadMatrix(mvp)

    def clone(self):
        f = h3d_col_Frustum()
        _this = f.pleft
        p = self.pleft
        _this.nx = p.nx
        _this.ny = p.ny
        _this.nz = p.nz
        _this.d = p.d
        _this1 = f.pright
        p1 = self.pright
        _this1.nx = p1.nx
        _this1.ny = p1.ny
        _this1.nz = p1.nz
        _this1.d = p1.d
        _this2 = f.ptop
        p2 = self.ptop
        _this2.nx = p2.nx
        _this2.ny = p2.ny
        _this2.nz = p2.nz
        _this2.d = p2.d
        _this3 = f.pbottom
        p3 = self.pbottom
        _this3.nx = p3.nx
        _this3.ny = p3.ny
        _this3.nz = p3.nz
        _this3.d = p3.d
        _this4 = f.pnear
        p4 = self.pnear
        _this4.nx = p4.nx
        _this4.ny = p4.ny
        _this4.nz = p4.nz
        _this4.d = p4.d
        _this5 = f.pfar
        p5 = self.pfar
        _this5.nx = p5.nx
        _this5.ny = p5.ny
        _this5.nz = p5.nz
        _this5.d = p5.d
        f.checkNearFar = self.checkNearFar
        return f

    def loadMatrix(self,mvp):
        _this = self.pleft
        p_nx = (mvp._14 + mvp._11)
        p_ny = (mvp._24 + mvp._21)
        p_nz = (mvp._34 + mvp._31)
        p_d = -((mvp._44 + mvp._41))
        _this.nx = p_nx
        _this.ny = p_ny
        _this.nz = p_nz
        _this.d = p_d
        _this1 = self.pright
        p_nx1 = (mvp._14 - mvp._11)
        p_ny1 = (mvp._24 - mvp._21)
        p_nz1 = (mvp._34 - mvp._31)
        p_d1 = (mvp._41 - mvp._44)
        _this1.nx = p_nx1
        _this1.ny = p_ny1
        _this1.nz = p_nz1
        _this1.d = p_d1
        _this2 = self.ptop
        p_nx2 = (mvp._14 - mvp._12)
        p_ny2 = (mvp._24 - mvp._22)
        p_nz2 = (mvp._34 - mvp._32)
        p_d2 = (mvp._42 - mvp._44)
        _this2.nx = p_nx2
        _this2.ny = p_ny2
        _this2.nz = p_nz2
        _this2.d = p_d2
        _this3 = self.pbottom
        p_nx3 = (mvp._14 + mvp._12)
        p_ny3 = (mvp._24 + mvp._22)
        p_nz3 = (mvp._34 + mvp._32)
        p_d3 = -((mvp._44 + mvp._42))
        _this3.nx = p_nx3
        _this3.ny = p_ny3
        _this3.nz = p_nz3
        _this3.d = p_d3
        _this4 = self.pnear
        p_nx4 = mvp._13
        p_ny4 = mvp._23
        p_nz4 = mvp._33
        p_d4 = -mvp._43
        _this4.nx = p_nx4
        _this4.ny = p_ny4
        _this4.nz = p_nz4
        _this4.d = p_d4
        _this5 = self.pfar
        p_nx5 = (mvp._14 - mvp._13)
        p_ny5 = (mvp._24 - mvp._23)
        p_nz5 = (mvp._34 - mvp._33)
        p_d5 = (mvp._43 - mvp._44)
        _this5.nx = p_nx5
        _this5.ny = p_ny5
        _this5.nz = p_nz5
        _this5.d = p_d5
        _this6 = self.pleft
        f = (((_this6.nx * _this6.nx) + ((_this6.ny * _this6.ny))) + ((_this6.nz * _this6.nz)))
        _hx_len = (1. / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
        _this6.nx = (_this6.nx * _hx_len)
        _this6.ny = (_this6.ny * _hx_len)
        _this6.nz = (_this6.nz * _hx_len)
        _this6.d = (_this6.d * _hx_len)
        _this7 = self.pright
        f1 = (((_this7.nx * _this7.nx) + ((_this7.ny * _this7.ny))) + ((_this7.nz * _this7.nz)))
        len1 = (1. / ((Math.NaN if ((f1 < 0)) else python_lib_Math.sqrt(f1))))
        _this7.nx = (_this7.nx * len1)
        _this7.ny = (_this7.ny * len1)
        _this7.nz = (_this7.nz * len1)
        _this7.d = (_this7.d * len1)
        _this8 = self.ptop
        f2 = (((_this8.nx * _this8.nx) + ((_this8.ny * _this8.ny))) + ((_this8.nz * _this8.nz)))
        len2 = (1. / ((Math.NaN if ((f2 < 0)) else python_lib_Math.sqrt(f2))))
        _this8.nx = (_this8.nx * len2)
        _this8.ny = (_this8.ny * len2)
        _this8.nz = (_this8.nz * len2)
        _this8.d = (_this8.d * len2)
        _this9 = self.pbottom
        f3 = (((_this9.nx * _this9.nx) + ((_this9.ny * _this9.ny))) + ((_this9.nz * _this9.nz)))
        len3 = (1. / ((Math.NaN if ((f3 < 0)) else python_lib_Math.sqrt(f3))))
        _this9.nx = (_this9.nx * len3)
        _this9.ny = (_this9.ny * len3)
        _this9.nz = (_this9.nz * len3)
        _this9.d = (_this9.d * len3)
        _this10 = self.pnear
        f4 = (((_this10.nx * _this10.nx) + ((_this10.ny * _this10.ny))) + ((_this10.nz * _this10.nz)))
        len4 = (1. / ((Math.NaN if ((f4 < 0)) else python_lib_Math.sqrt(f4))))
        _this10.nx = (_this10.nx * len4)
        _this10.ny = (_this10.ny * len4)
        _this10.nz = (_this10.nz * len4)
        _this10.d = (_this10.d * len4)
        _this11 = self.pfar
        f5 = (((_this11.nx * _this11.nx) + ((_this11.ny * _this11.ny))) + ((_this11.nz * _this11.nz)))
        len5 = (1. / ((Math.NaN if ((f5 < 0)) else python_lib_Math.sqrt(f5))))
        _this11.nx = (_this11.nx * len5)
        _this11.ny = (_this11.ny * len5)
        _this11.nz = (_this11.nz * len5)
        _this11.d = (_this11.d * len5)

    def transform(self,m):
        m2 = h3d_Matrix()
        m2.initInverse(m)
        m2.transpose()
        _this = self.pleft
        x = _this.nx
        y = _this.ny
        z = _this.nz
        w = -_this.d
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        v_w = w
        px = ((((v_x * m2._11) + ((v_y * m2._21))) + ((v_z * m2._31))) + ((v_w * m2._41)))
        py = ((((v_x * m2._12) + ((v_y * m2._22))) + ((v_z * m2._32))) + ((v_w * m2._42)))
        pz = ((((v_x * m2._13) + ((v_y * m2._23))) + ((v_z * m2._33))) + ((v_w * m2._43)))
        pw = ((((v_x * m2._14) + ((v_y * m2._24))) + ((v_z * m2._34))) + ((v_w * m2._44)))
        v_x = px
        v_y = py
        v_z = pz
        v_w = pw
        _this.nx = v_x
        _this.ny = v_y
        _this.nz = v_z
        _this.d = -v_w
        _this1 = self.pright
        x1 = _this1.nx
        y1 = _this1.ny
        z1 = _this1.nz
        w1 = -_this1.d
        if (w1 is None):
            w1 = 1.
        if (z1 is None):
            z1 = 0.
        if (y1 is None):
            y1 = 0.
        if (x1 is None):
            x1 = 0.
        v_x1 = x1
        v_y1 = y1
        v_z1 = z1
        v_w1 = w1
        px1 = ((((v_x1 * m2._11) + ((v_y1 * m2._21))) + ((v_z1 * m2._31))) + ((v_w1 * m2._41)))
        py1 = ((((v_x1 * m2._12) + ((v_y1 * m2._22))) + ((v_z1 * m2._32))) + ((v_w1 * m2._42)))
        pz1 = ((((v_x1 * m2._13) + ((v_y1 * m2._23))) + ((v_z1 * m2._33))) + ((v_w1 * m2._43)))
        pw1 = ((((v_x1 * m2._14) + ((v_y1 * m2._24))) + ((v_z1 * m2._34))) + ((v_w1 * m2._44)))
        v_x1 = px1
        v_y1 = py1
        v_z1 = pz1
        v_w1 = pw1
        _this1.nx = v_x1
        _this1.ny = v_y1
        _this1.nz = v_z1
        _this1.d = -v_w1
        _this2 = self.ptop
        x2 = _this2.nx
        y2 = _this2.ny
        z2 = _this2.nz
        w2 = -_this2.d
        if (w2 is None):
            w2 = 1.
        if (z2 is None):
            z2 = 0.
        if (y2 is None):
            y2 = 0.
        if (x2 is None):
            x2 = 0.
        v_x2 = x2
        v_y2 = y2
        v_z2 = z2
        v_w2 = w2
        px2 = ((((v_x2 * m2._11) + ((v_y2 * m2._21))) + ((v_z2 * m2._31))) + ((v_w2 * m2._41)))
        py2 = ((((v_x2 * m2._12) + ((v_y2 * m2._22))) + ((v_z2 * m2._32))) + ((v_w2 * m2._42)))
        pz2 = ((((v_x2 * m2._13) + ((v_y2 * m2._23))) + ((v_z2 * m2._33))) + ((v_w2 * m2._43)))
        pw2 = ((((v_x2 * m2._14) + ((v_y2 * m2._24))) + ((v_z2 * m2._34))) + ((v_w2 * m2._44)))
        v_x2 = px2
        v_y2 = py2
        v_z2 = pz2
        v_w2 = pw2
        _this2.nx = v_x2
        _this2.ny = v_y2
        _this2.nz = v_z2
        _this2.d = -v_w2
        _this3 = self.pbottom
        x3 = _this3.nx
        y3 = _this3.ny
        z3 = _this3.nz
        w3 = -_this3.d
        if (w3 is None):
            w3 = 1.
        if (z3 is None):
            z3 = 0.
        if (y3 is None):
            y3 = 0.
        if (x3 is None):
            x3 = 0.
        v_x3 = x3
        v_y3 = y3
        v_z3 = z3
        v_w3 = w3
        px3 = ((((v_x3 * m2._11) + ((v_y3 * m2._21))) + ((v_z3 * m2._31))) + ((v_w3 * m2._41)))
        py3 = ((((v_x3 * m2._12) + ((v_y3 * m2._22))) + ((v_z3 * m2._32))) + ((v_w3 * m2._42)))
        pz3 = ((((v_x3 * m2._13) + ((v_y3 * m2._23))) + ((v_z3 * m2._33))) + ((v_w3 * m2._43)))
        pw3 = ((((v_x3 * m2._14) + ((v_y3 * m2._24))) + ((v_z3 * m2._34))) + ((v_w3 * m2._44)))
        v_x3 = px3
        v_y3 = py3
        v_z3 = pz3
        v_w3 = pw3
        _this3.nx = v_x3
        _this3.ny = v_y3
        _this3.nz = v_z3
        _this3.d = -v_w3
        _this4 = self.pfar
        x4 = _this4.nx
        y4 = _this4.ny
        z4 = _this4.nz
        w4 = -_this4.d
        if (w4 is None):
            w4 = 1.
        if (z4 is None):
            z4 = 0.
        if (y4 is None):
            y4 = 0.
        if (x4 is None):
            x4 = 0.
        v_x4 = x4
        v_y4 = y4
        v_z4 = z4
        v_w4 = w4
        px4 = ((((v_x4 * m2._11) + ((v_y4 * m2._21))) + ((v_z4 * m2._31))) + ((v_w4 * m2._41)))
        py4 = ((((v_x4 * m2._12) + ((v_y4 * m2._22))) + ((v_z4 * m2._32))) + ((v_w4 * m2._42)))
        pz4 = ((((v_x4 * m2._13) + ((v_y4 * m2._23))) + ((v_z4 * m2._33))) + ((v_w4 * m2._43)))
        pw4 = ((((v_x4 * m2._14) + ((v_y4 * m2._24))) + ((v_z4 * m2._34))) + ((v_w4 * m2._44)))
        v_x4 = px4
        v_y4 = py4
        v_z4 = pz4
        v_w4 = pw4
        _this4.nx = v_x4
        _this4.ny = v_y4
        _this4.nz = v_z4
        _this4.d = -v_w4
        _this5 = self.pnear
        x5 = _this5.nx
        y5 = _this5.ny
        z5 = _this5.nz
        w5 = -_this5.d
        if (w5 is None):
            w5 = 1.
        if (z5 is None):
            z5 = 0.
        if (y5 is None):
            y5 = 0.
        if (x5 is None):
            x5 = 0.
        v_x5 = x5
        v_y5 = y5
        v_z5 = z5
        v_w5 = w5
        px5 = ((((v_x5 * m2._11) + ((v_y5 * m2._21))) + ((v_z5 * m2._31))) + ((v_w5 * m2._41)))
        py5 = ((((v_x5 * m2._12) + ((v_y5 * m2._22))) + ((v_z5 * m2._32))) + ((v_w5 * m2._42)))
        pz5 = ((((v_x5 * m2._13) + ((v_y5 * m2._23))) + ((v_z5 * m2._33))) + ((v_w5 * m2._43)))
        pw5 = ((((v_x5 * m2._14) + ((v_y5 * m2._24))) + ((v_z5 * m2._34))) + ((v_w5 * m2._44)))
        v_x5 = px5
        v_y5 = py5
        v_z5 = pz5
        v_w5 = pw5
        _this5.nx = v_x5
        _this5.ny = v_y5
        _this5.nz = v_z5
        _this5.d = -v_w5
        _this6 = self.pleft
        f = (((_this6.nx * _this6.nx) + ((_this6.ny * _this6.ny))) + ((_this6.nz * _this6.nz)))
        _hx_len = (1. / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
        _this6.nx = (_this6.nx * _hx_len)
        _this6.ny = (_this6.ny * _hx_len)
        _this6.nz = (_this6.nz * _hx_len)
        _this6.d = (_this6.d * _hx_len)
        _this7 = self.pright
        f1 = (((_this7.nx * _this7.nx) + ((_this7.ny * _this7.ny))) + ((_this7.nz * _this7.nz)))
        len1 = (1. / ((Math.NaN if ((f1 < 0)) else python_lib_Math.sqrt(f1))))
        _this7.nx = (_this7.nx * len1)
        _this7.ny = (_this7.ny * len1)
        _this7.nz = (_this7.nz * len1)
        _this7.d = (_this7.d * len1)
        _this8 = self.ptop
        f2 = (((_this8.nx * _this8.nx) + ((_this8.ny * _this8.ny))) + ((_this8.nz * _this8.nz)))
        len2 = (1. / ((Math.NaN if ((f2 < 0)) else python_lib_Math.sqrt(f2))))
        _this8.nx = (_this8.nx * len2)
        _this8.ny = (_this8.ny * len2)
        _this8.nz = (_this8.nz * len2)
        _this8.d = (_this8.d * len2)
        _this9 = self.pbottom
        f3 = (((_this9.nx * _this9.nx) + ((_this9.ny * _this9.ny))) + ((_this9.nz * _this9.nz)))
        len3 = (1. / ((Math.NaN if ((f3 < 0)) else python_lib_Math.sqrt(f3))))
        _this9.nx = (_this9.nx * len3)
        _this9.ny = (_this9.ny * len3)
        _this9.nz = (_this9.nz * len3)
        _this9.d = (_this9.d * len3)
        _this10 = self.pnear
        f4 = (((_this10.nx * _this10.nx) + ((_this10.ny * _this10.ny))) + ((_this10.nz * _this10.nz)))
        len4 = (1. / ((Math.NaN if ((f4 < 0)) else python_lib_Math.sqrt(f4))))
        _this10.nx = (_this10.nx * len4)
        _this10.ny = (_this10.ny * len4)
        _this10.nz = (_this10.nz * len4)
        _this10.d = (_this10.d * len4)
        _this11 = self.pfar
        f5 = (((_this11.nx * _this11.nx) + ((_this11.ny * _this11.ny))) + ((_this11.nz * _this11.nz)))
        len5 = (1. / ((Math.NaN if ((f5 < 0)) else python_lib_Math.sqrt(f5))))
        _this11.nx = (_this11.nx * len5)
        _this11.ny = (_this11.ny * len5)
        _this11.nz = (_this11.nz * len5)
        _this11.d = (_this11.d * len5)

    def transform3x3(self,m):
        m2 = h3d_Matrix()
        m2.initInverse3x3(m)
        m2.transpose()
        _this = self.pleft
        x = _this.nx
        y = _this.ny
        z = _this.nz
        w = -_this.d
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        v_w = w
        px = ((((v_x * m2._11) + ((v_y * m2._21))) + ((v_z * m2._31))) + ((v_w * m2._41)))
        py = ((((v_x * m2._12) + ((v_y * m2._22))) + ((v_z * m2._32))) + ((v_w * m2._42)))
        pz = ((((v_x * m2._13) + ((v_y * m2._23))) + ((v_z * m2._33))) + ((v_w * m2._43)))
        pw = ((((v_x * m2._14) + ((v_y * m2._24))) + ((v_z * m2._34))) + ((v_w * m2._44)))
        v_x = px
        v_y = py
        v_z = pz
        v_w = pw
        _this.nx = v_x
        _this.ny = v_y
        _this.nz = v_z
        _this.d = -v_w
        _this1 = self.pright
        x1 = _this1.nx
        y1 = _this1.ny
        z1 = _this1.nz
        w1 = -_this1.d
        if (w1 is None):
            w1 = 1.
        if (z1 is None):
            z1 = 0.
        if (y1 is None):
            y1 = 0.
        if (x1 is None):
            x1 = 0.
        v_x1 = x1
        v_y1 = y1
        v_z1 = z1
        v_w1 = w1
        px1 = ((((v_x1 * m2._11) + ((v_y1 * m2._21))) + ((v_z1 * m2._31))) + ((v_w1 * m2._41)))
        py1 = ((((v_x1 * m2._12) + ((v_y1 * m2._22))) + ((v_z1 * m2._32))) + ((v_w1 * m2._42)))
        pz1 = ((((v_x1 * m2._13) + ((v_y1 * m2._23))) + ((v_z1 * m2._33))) + ((v_w1 * m2._43)))
        pw1 = ((((v_x1 * m2._14) + ((v_y1 * m2._24))) + ((v_z1 * m2._34))) + ((v_w1 * m2._44)))
        v_x1 = px1
        v_y1 = py1
        v_z1 = pz1
        v_w1 = pw1
        _this1.nx = v_x1
        _this1.ny = v_y1
        _this1.nz = v_z1
        _this1.d = -v_w1
        _this2 = self.ptop
        x2 = _this2.nx
        y2 = _this2.ny
        z2 = _this2.nz
        w2 = -_this2.d
        if (w2 is None):
            w2 = 1.
        if (z2 is None):
            z2 = 0.
        if (y2 is None):
            y2 = 0.
        if (x2 is None):
            x2 = 0.
        v_x2 = x2
        v_y2 = y2
        v_z2 = z2
        v_w2 = w2
        px2 = ((((v_x2 * m2._11) + ((v_y2 * m2._21))) + ((v_z2 * m2._31))) + ((v_w2 * m2._41)))
        py2 = ((((v_x2 * m2._12) + ((v_y2 * m2._22))) + ((v_z2 * m2._32))) + ((v_w2 * m2._42)))
        pz2 = ((((v_x2 * m2._13) + ((v_y2 * m2._23))) + ((v_z2 * m2._33))) + ((v_w2 * m2._43)))
        pw2 = ((((v_x2 * m2._14) + ((v_y2 * m2._24))) + ((v_z2 * m2._34))) + ((v_w2 * m2._44)))
        v_x2 = px2
        v_y2 = py2
        v_z2 = pz2
        v_w2 = pw2
        _this2.nx = v_x2
        _this2.ny = v_y2
        _this2.nz = v_z2
        _this2.d = -v_w2
        _this3 = self.pbottom
        x3 = _this3.nx
        y3 = _this3.ny
        z3 = _this3.nz
        w3 = -_this3.d
        if (w3 is None):
            w3 = 1.
        if (z3 is None):
            z3 = 0.
        if (y3 is None):
            y3 = 0.
        if (x3 is None):
            x3 = 0.
        v_x3 = x3
        v_y3 = y3
        v_z3 = z3
        v_w3 = w3
        px3 = ((((v_x3 * m2._11) + ((v_y3 * m2._21))) + ((v_z3 * m2._31))) + ((v_w3 * m2._41)))
        py3 = ((((v_x3 * m2._12) + ((v_y3 * m2._22))) + ((v_z3 * m2._32))) + ((v_w3 * m2._42)))
        pz3 = ((((v_x3 * m2._13) + ((v_y3 * m2._23))) + ((v_z3 * m2._33))) + ((v_w3 * m2._43)))
        pw3 = ((((v_x3 * m2._14) + ((v_y3 * m2._24))) + ((v_z3 * m2._34))) + ((v_w3 * m2._44)))
        v_x3 = px3
        v_y3 = py3
        v_z3 = pz3
        v_w3 = pw3
        _this3.nx = v_x3
        _this3.ny = v_y3
        _this3.nz = v_z3
        _this3.d = -v_w3
        _this4 = self.pfar
        x4 = _this4.nx
        y4 = _this4.ny
        z4 = _this4.nz
        w4 = -_this4.d
        if (w4 is None):
            w4 = 1.
        if (z4 is None):
            z4 = 0.
        if (y4 is None):
            y4 = 0.
        if (x4 is None):
            x4 = 0.
        v_x4 = x4
        v_y4 = y4
        v_z4 = z4
        v_w4 = w4
        px4 = ((((v_x4 * m2._11) + ((v_y4 * m2._21))) + ((v_z4 * m2._31))) + ((v_w4 * m2._41)))
        py4 = ((((v_x4 * m2._12) + ((v_y4 * m2._22))) + ((v_z4 * m2._32))) + ((v_w4 * m2._42)))
        pz4 = ((((v_x4 * m2._13) + ((v_y4 * m2._23))) + ((v_z4 * m2._33))) + ((v_w4 * m2._43)))
        pw4 = ((((v_x4 * m2._14) + ((v_y4 * m2._24))) + ((v_z4 * m2._34))) + ((v_w4 * m2._44)))
        v_x4 = px4
        v_y4 = py4
        v_z4 = pz4
        v_w4 = pw4
        _this4.nx = v_x4
        _this4.ny = v_y4
        _this4.nz = v_z4
        _this4.d = -v_w4
        _this5 = self.pnear
        x5 = _this5.nx
        y5 = _this5.ny
        z5 = _this5.nz
        w5 = -_this5.d
        if (w5 is None):
            w5 = 1.
        if (z5 is None):
            z5 = 0.
        if (y5 is None):
            y5 = 0.
        if (x5 is None):
            x5 = 0.
        v_x5 = x5
        v_y5 = y5
        v_z5 = z5
        v_w5 = w5
        px5 = ((((v_x5 * m2._11) + ((v_y5 * m2._21))) + ((v_z5 * m2._31))) + ((v_w5 * m2._41)))
        py5 = ((((v_x5 * m2._12) + ((v_y5 * m2._22))) + ((v_z5 * m2._32))) + ((v_w5 * m2._42)))
        pz5 = ((((v_x5 * m2._13) + ((v_y5 * m2._23))) + ((v_z5 * m2._33))) + ((v_w5 * m2._43)))
        pw5 = ((((v_x5 * m2._14) + ((v_y5 * m2._24))) + ((v_z5 * m2._34))) + ((v_w5 * m2._44)))
        v_x5 = px5
        v_y5 = py5
        v_z5 = pz5
        v_w5 = pw5
        _this5.nx = v_x5
        _this5.ny = v_y5
        _this5.nz = v_z5
        _this5.d = -v_w5
        _this6 = self.pleft
        f = (((_this6.nx * _this6.nx) + ((_this6.ny * _this6.ny))) + ((_this6.nz * _this6.nz)))
        _hx_len = (1. / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
        _this6.nx = (_this6.nx * _hx_len)
        _this6.ny = (_this6.ny * _hx_len)
        _this6.nz = (_this6.nz * _hx_len)
        _this6.d = (_this6.d * _hx_len)
        _this7 = self.pright
        f1 = (((_this7.nx * _this7.nx) + ((_this7.ny * _this7.ny))) + ((_this7.nz * _this7.nz)))
        len1 = (1. / ((Math.NaN if ((f1 < 0)) else python_lib_Math.sqrt(f1))))
        _this7.nx = (_this7.nx * len1)
        _this7.ny = (_this7.ny * len1)
        _this7.nz = (_this7.nz * len1)
        _this7.d = (_this7.d * len1)
        _this8 = self.ptop
        f2 = (((_this8.nx * _this8.nx) + ((_this8.ny * _this8.ny))) + ((_this8.nz * _this8.nz)))
        len2 = (1. / ((Math.NaN if ((f2 < 0)) else python_lib_Math.sqrt(f2))))
        _this8.nx = (_this8.nx * len2)
        _this8.ny = (_this8.ny * len2)
        _this8.nz = (_this8.nz * len2)
        _this8.d = (_this8.d * len2)
        _this9 = self.pbottom
        f3 = (((_this9.nx * _this9.nx) + ((_this9.ny * _this9.ny))) + ((_this9.nz * _this9.nz)))
        len3 = (1. / ((Math.NaN if ((f3 < 0)) else python_lib_Math.sqrt(f3))))
        _this9.nx = (_this9.nx * len3)
        _this9.ny = (_this9.ny * len3)
        _this9.nz = (_this9.nz * len3)
        _this9.d = (_this9.d * len3)
        _this10 = self.pnear
        f4 = (((_this10.nx * _this10.nx) + ((_this10.ny * _this10.ny))) + ((_this10.nz * _this10.nz)))
        len4 = (1. / ((Math.NaN if ((f4 < 0)) else python_lib_Math.sqrt(f4))))
        _this10.nx = (_this10.nx * len4)
        _this10.ny = (_this10.ny * len4)
        _this10.nz = (_this10.nz * len4)
        _this10.d = (_this10.d * len4)
        _this11 = self.pfar
        f5 = (((_this11.nx * _this11.nx) + ((_this11.ny * _this11.ny))) + ((_this11.nz * _this11.nz)))
        len5 = (1. / ((Math.NaN if ((f5 < 0)) else python_lib_Math.sqrt(f5))))
        _this11.nx = (_this11.nx * len5)
        _this11.ny = (_this11.ny * len5)
        _this11.nz = (_this11.nz * len5)
        _this11.d = (_this11.d * len5)

    def hasPoint(self,p):
        _this = self.pleft
        if (((((_this.nx * p.x) + ((_this.ny * p.y))) + ((_this.nz * p.z))) - _this.d) < 0):
            return False
        _this1 = self.pright
        if (((((_this1.nx * p.x) + ((_this1.ny * p.y))) + ((_this1.nz * p.z))) - _this1.d) < 0):
            return False
        _this2 = self.ptop
        if (((((_this2.nx * p.x) + ((_this2.ny * p.y))) + ((_this2.nz * p.z))) - _this2.d) < 0):
            return False
        _this3 = self.pbottom
        if (((((_this3.nx * p.x) + ((_this3.ny * p.y))) + ((_this3.nz * p.z))) - _this3.d) < 0):
            return False
        if self.checkNearFar:
            _this4 = self.pnear
            if (((((_this4.nx * p.x) + ((_this4.ny * p.y))) + ((_this4.nz * p.z))) - _this4.d) < 0):
                return False
            _this5 = self.pfar
            if (((((_this5.nx * p.x) + ((_this5.ny * p.y))) + ((_this5.nz * p.z))) - _this5.d) < 0):
                return False
        return True

    def hasSphere(self,s):
        x = s.x
        y = s.y
        z = s.z
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        p_x = x
        p_y = y
        p_z = z
        _this = self.pleft
        if (((((_this.nx * p_x) + ((_this.ny * p_y))) + ((_this.nz * p_z))) - _this.d) < -s.r):
            return False
        _this1 = self.pright
        if (((((_this1.nx * p_x) + ((_this1.ny * p_y))) + ((_this1.nz * p_z))) - _this1.d) < -s.r):
            return False
        _this2 = self.ptop
        if (((((_this2.nx * p_x) + ((_this2.ny * p_y))) + ((_this2.nz * p_z))) - _this2.d) < -s.r):
            return False
        _this3 = self.pbottom
        if (((((_this3.nx * p_x) + ((_this3.ny * p_y))) + ((_this3.nz * p_z))) - _this3.d) < -s.r):
            return False
        if self.checkNearFar:
            _this4 = self.pnear
            if (((((_this4.nx * p_x) + ((_this4.ny * p_y))) + ((_this4.nz * p_z))) - _this4.d) < -s.r):
                return False
            _this5 = self.pfar
            if (((((_this5.nx * p_x) + ((_this5.ny * p_y))) + ((_this5.nz * p_z))) - _this5.d) < -s.r):
                return False
        return True

    def hasBounds(self,b):
        p = self.pleft
        a = p.nx
        b1 = p.ny
        c = p.nz
        dd = (((a * ((b.xMax + b.xMin))) + ((b1 * ((b.yMax + b.yMin))))) + ((c * ((b.zMax + b.zMin)))))
        if (a < 0):
            a = -a
        if (b1 < 0):
            b1 = -b1
        if (c < 0):
            c = -c
        rr = (((a * ((b.xMax - b.xMin))) + ((b1 * ((b.yMax - b.yMin))))) + ((c * ((b.zMax - b.zMin)))))
        if (((dd + rr) - ((p.d * 2))) < 0):
            return False
        p1 = self.pright
        a1 = p1.nx
        b2 = p1.ny
        c1 = p1.nz
        dd1 = (((a1 * ((b.xMax + b.xMin))) + ((b2 * ((b.yMax + b.yMin))))) + ((c1 * ((b.zMax + b.zMin)))))
        if (a1 < 0):
            a1 = -a1
        if (b2 < 0):
            b2 = -b2
        if (c1 < 0):
            c1 = -c1
        rr1 = (((a1 * ((b.xMax - b.xMin))) + ((b2 * ((b.yMax - b.yMin))))) + ((c1 * ((b.zMax - b.zMin)))))
        if (((dd1 + rr1) - ((p1.d * 2))) < 0):
            return False
        p2 = self.ptop
        a2 = p2.nx
        b3 = p2.ny
        c2 = p2.nz
        dd2 = (((a2 * ((b.xMax + b.xMin))) + ((b3 * ((b.yMax + b.yMin))))) + ((c2 * ((b.zMax + b.zMin)))))
        if (a2 < 0):
            a2 = -a2
        if (b3 < 0):
            b3 = -b3
        if (c2 < 0):
            c2 = -c2
        rr2 = (((a2 * ((b.xMax - b.xMin))) + ((b3 * ((b.yMax - b.yMin))))) + ((c2 * ((b.zMax - b.zMin)))))
        if (((dd2 + rr2) - ((p2.d * 2))) < 0):
            return False
        p3 = self.ptop
        a3 = p3.nx
        b4 = p3.ny
        c3 = p3.nz
        dd3 = (((a3 * ((b.xMax + b.xMin))) + ((b4 * ((b.yMax + b.yMin))))) + ((c3 * ((b.zMax + b.zMin)))))
        if (a3 < 0):
            a3 = -a3
        if (b4 < 0):
            b4 = -b4
        if (c3 < 0):
            c3 = -c3
        rr3 = (((a3 * ((b.xMax - b.xMin))) + ((b4 * ((b.yMax - b.yMin))))) + ((c3 * ((b.zMax - b.zMin)))))
        if (((dd3 + rr3) - ((p3.d * 2))) < 0):
            return False
        p4 = self.pnear
        a4 = p4.nx
        b5 = p4.ny
        c4 = p4.nz
        dd4 = (((a4 * ((b.xMax + b.xMin))) + ((b5 * ((b.yMax + b.yMin))))) + ((c4 * ((b.zMax + b.zMin)))))
        if (a4 < 0):
            a4 = -a4
        if (b5 < 0):
            b5 = -b5
        if (c4 < 0):
            c4 = -c4
        rr4 = (((a4 * ((b.xMax - b.xMin))) + ((b5 * ((b.yMax - b.yMin))))) + ((c4 * ((b.zMax - b.zMin)))))
        if (((dd4 + rr4) - ((p4.d * 2))) < 0):
            return False
        p5 = self.pfar
        a5 = p5.nx
        b6 = p5.ny
        c5 = p5.nz
        dd5 = (((a5 * ((b.xMax + b.xMin))) + ((b6 * ((b.yMax + b.yMin))))) + ((c5 * ((b.zMax + b.zMin)))))
        if (a5 < 0):
            a5 = -a5
        if (b6 < 0):
            b6 = -b6
        if (c5 < 0):
            c5 = -c5
        rr5 = (((a5 * ((b.xMax - b.xMin))) + ((b6 * ((b.yMax - b.yMin))))) + ((c5 * ((b.zMax - b.zMin)))))
        if (((dd5 + rr5) - ((p5.d * 2))) < 0):
            return False
        return True

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.pleft = None
        _hx_o.pright = None
        _hx_o.ptop = None
        _hx_o.pbottom = None
        _hx_o.pnear = None
        _hx_o.pfar = None
        _hx_o.checkNearFar = None
h3d_col_Frustum._hx_class = h3d_col_Frustum
_hx_classes["h3d.col.Frustum"] = h3d_col_Frustum


class h3d_col_Ray:
    _hx_class_name = "h3d.col.Ray"
    _hx_is_interface = "False"
    __slots__ = ("px", "py", "pz", "lx", "ly", "lz")
    _hx_fields = ["px", "py", "pz", "lx", "ly", "lz"]
    _hx_methods = ["clone", "load", "normalize", "transform", "getPos", "getDir", "getPoint", "toString", "intersect", "collideFrustum", "collide"]
    _hx_statics = ["fromPoints", "fromValues"]

    def __init__(self):
        self.lz = None
        self.ly = None
        self.lx = None
        self.pz = None
        self.py = None
        self.px = None

    def clone(self):
        r = h3d_col_Ray()
        r.px = self.px
        r.py = self.py
        r.pz = self.pz
        r.lx = self.lx
        r.ly = self.ly
        r.lz = self.lz
        return r

    def load(self,r):
        self.px = r.px
        self.py = r.py
        self.pz = r.pz
        self.lx = r.lx
        self.ly = r.ly
        self.lz = r.lz

    def normalize(self):
        l = (((self.lx * self.lx) + ((self.ly * self.ly))) + ((self.lz * self.lz)))
        if (l == 1.):
            return
        if (l < 1e-10):
            l = 0
        else:
            l = (1. / ((Math.NaN if ((l < 0)) else python_lib_Math.sqrt(l))))
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.lx
        _hx_local_0.lx = (_hx_local_1 * l)
        _hx_local_0.lx
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.ly
        _hx_local_2.ly = (_hx_local_3 * l)
        _hx_local_2.ly
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.lz
        _hx_local_4.lz = (_hx_local_5 * l)
        _hx_local_4.lz

    def transform(self,m):
        x = self.px
        y = self.py
        z = self.pz
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        p_x = x
        p_y = y
        p_z = z
        p_w = 1.
        px = ((((p_x * m._11) + ((p_y * m._21))) + ((p_z * m._31))) + ((p_w * m._41)))
        py = ((((p_x * m._12) + ((p_y * m._22))) + ((p_z * m._32))) + ((p_w * m._42)))
        pz = ((((p_x * m._13) + ((p_y * m._23))) + ((p_z * m._33))) + ((p_w * m._43)))
        p_x = px
        p_y = py
        p_z = pz
        self.px = p_x
        self.py = p_y
        self.pz = p_z
        x1 = self.lx
        y1 = self.ly
        z1 = self.lz
        if (z1 is None):
            z1 = 0.
        if (y1 is None):
            y1 = 0.
        if (x1 is None):
            x1 = 0.
        l_x = x1
        l_y = y1
        l_z = z1
        l_w = 1.
        px1 = (((l_x * m._11) + ((l_y * m._21))) + ((l_z * m._31)))
        py1 = (((l_x * m._12) + ((l_y * m._22))) + ((l_z * m._32)))
        pz1 = (((l_x * m._13) + ((l_y * m._23))) + ((l_z * m._33)))
        l_x = px1
        l_y = py1
        l_z = pz1
        self.lx = l_x
        self.ly = l_y
        self.lz = l_z
        self.normalize()

    def getPos(self):
        return h3d_col_Point(self.px,self.py,self.pz)

    def getDir(self):
        return h3d_col_Point(self.lx,self.ly,self.lz)

    def getPoint(self,distance):
        return h3d_col_Point((self.px + ((distance * self.lx))),(self.py + ((distance * self.ly))),(self.pz + ((distance * self.lz))))

    def toString(self):
        return (((("Ray{" + Std.string(h3d_col_Point(self.px,self.py,self.pz))) + ",") + Std.string(h3d_col_Point(self.lx,self.ly,self.lz))) + "}")

    def intersect(self,p):
        d = (((self.lx * p.nx) + ((self.ly * p.ny))) + ((self.lz * p.nz)))
        nd = (p.d - ((((self.px * p.nx) + ((self.py * p.ny))) + ((self.pz * p.nz)))))
        if (((-d if ((d < 0)) else d)) < 1e-10):
            if (((-nd if ((nd < 0)) else nd)) < 1e-10):
                return h3d_col_Point(self.px,self.py,self.pz)
            else:
                return None
        else:
            k = (nd / d)
            return h3d_col_Point((self.px + ((self.lx * k))),(self.py + ((self.ly * k))),(self.pz + ((self.lz * k))))

    def collideFrustum(self,mvp):
        x = self.px
        y = self.py
        z = self.pz
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        a_x = x
        a_y = y
        a_z = z
        a_w = 1.
        px = ((((a_x * mvp._11) + ((a_y * mvp._21))) + ((a_z * mvp._31))) + ((a_w * mvp._41)))
        py = ((((a_x * mvp._12) + ((a_y * mvp._22))) + ((a_z * mvp._32))) + ((a_w * mvp._42)))
        pz = ((((a_x * mvp._13) + ((a_y * mvp._23))) + ((a_z * mvp._33))) + ((a_w * mvp._43)))
        iw = (1 / (((((a_x * mvp._14) + ((a_y * mvp._24))) + ((a_z * mvp._34))) + ((a_w * mvp._44)))))
        a_x = (px * iw)
        a_y = (py * iw)
        a_z = (pz * iw)
        a_w = 1
        x1 = (self.px + self.lx)
        y1 = (self.py + self.ly)
        z1 = (self.pz + self.lz)
        if (z1 is None):
            z1 = 0.
        if (y1 is None):
            y1 = 0.
        if (x1 is None):
            x1 = 0.
        b_x = x1
        b_y = y1
        b_z = z1
        b_w = 1.
        px1 = ((((b_x * mvp._11) + ((b_y * mvp._21))) + ((b_z * mvp._31))) + ((b_w * mvp._41)))
        py1 = ((((b_x * mvp._12) + ((b_y * mvp._22))) + ((b_z * mvp._32))) + ((b_w * mvp._42)))
        pz1 = ((((b_x * mvp._13) + ((b_y * mvp._23))) + ((b_z * mvp._33))) + ((b_w * mvp._43)))
        iw1 = (1 / (((((b_x * mvp._14) + ((b_y * mvp._24))) + ((b_z * mvp._34))) + ((b_w * mvp._44)))))
        b_x = (px1 * iw1)
        b_y = (py1 * iw1)
        b_z = (pz1 * iw1)
        b_w = 1
        lx = (b_x - a_x)
        ly = (b_y - a_y)
        lz = (b_z - a_z)
        dx = (1 / lx)
        dy = (1 / ly)
        dz = (1 / lz)
        t1 = (((-1 - a_x)) * dx)
        t2 = (((1 - a_x)) * dx)
        t3 = (((-1 - a_y)) * dy)
        t4 = (((1 - a_y)) * dy)
        t5 = (((0 - a_z)) * dz)
        t6 = (((1 - a_z)) * dz)
        a = (t2 if ((t1 > t2)) else t1)
        b = (t4 if ((t3 > t4)) else t3)
        a1 = (b if ((a < b)) else a)
        b1 = (t6 if ((t5 > t6)) else t5)
        tmin = (b1 if ((a1 < b1)) else a1)
        a2 = (t2 if ((t1 < t2)) else t1)
        b2 = (t4 if ((t3 < t4)) else t3)
        a3 = (b2 if ((a2 > b2)) else a2)
        b3 = (t6 if ((t5 < t6)) else t5)
        tmax = (b3 if ((a3 > b3)) else a3)
        return (not (((tmax < 0) or ((tmin > tmax)))))

    def collide(self,b):
        dx = (1 / self.lx)
        dy = (1 / self.ly)
        dz = (1 / self.lz)
        t1 = (((b.xMin - self.px)) * dx)
        t2 = (((b.xMax - self.px)) * dx)
        t3 = (((b.yMin - self.py)) * dy)
        t4 = (((b.yMax - self.py)) * dy)
        t5 = (((b.zMin - self.pz)) * dz)
        t6 = (((b.zMax - self.pz)) * dz)
        a = (t2 if ((t1 > t2)) else t1)
        b1 = (t4 if ((t3 > t4)) else t3)
        a1 = (b1 if ((a < b1)) else a)
        b2 = (t6 if ((t5 > t6)) else t5)
        tmin = (b2 if ((a1 < b2)) else a1)
        a2 = (t2 if ((t1 < t2)) else t1)
        b3 = (t4 if ((t3 < t4)) else t3)
        a3 = (b3 if ((a2 > b3)) else a2)
        b4 = (t6 if ((t5 < t6)) else t5)
        tmax = (b4 if ((a3 > b4)) else a3)
        if (tmax < 0):
            return False
        elif (tmin > tmax):
            return False
        else:
            return True

    @staticmethod
    def fromPoints(p1,p2):
        r = h3d_col_Ray()
        r.px = p1.x
        r.py = p1.y
        r.pz = p1.z
        r.lx = (p2.x - p1.x)
        r.ly = (p2.y - p1.y)
        r.lz = (p2.z - p1.z)
        r.normalize()
        return r

    @staticmethod
    def fromValues(x,y,z,dx,dy,dz):
        r = h3d_col_Ray()
        r.px = x
        r.py = y
        r.pz = z
        r.lx = dx
        r.ly = dy
        r.lz = dz
        r.normalize()
        return r

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.px = None
        _hx_o.py = None
        _hx_o.pz = None
        _hx_o.lx = None
        _hx_o.ly = None
        _hx_o.lz = None
h3d_col_Ray._hx_class = h3d_col_Ray
_hx_classes["h3d.col.Ray"] = h3d_col_Ray


class h3d_col_ObjectCollider:
    _hx_class_name = "h3d.col.ObjectCollider"
    _hx_is_interface = "False"
    __slots__ = ("obj", "collider")
    _hx_fields = ["obj", "collider"]
    _hx_methods = ["rayIntersection", "contains", "inFrustum", "inSphere"]
    _hx_statics = ["TMP_RAY", "TMP_MAT"]
    _hx_interfaces = [hxd_impl__Serializable_NoSerializeSupport, h3d_col_Collider]

    def __init__(self,obj,collider):
        self.obj = obj
        self.collider = collider

    def rayIntersection(self,r,bestMatch):
        tmpRay = h3d_col_ObjectCollider.TMP_RAY
        h3d_col_ObjectCollider.TMP_RAY = None
        tmpRay.px = r.px
        tmpRay.py = r.py
        tmpRay.pz = r.pz
        tmpRay.lx = r.lx
        tmpRay.ly = r.ly
        tmpRay.lz = r.lz
        m = self.obj.getInvPos()
        x = r.px
        y = r.py
        z = r.pz
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        p_x = x
        p_y = y
        p_z = z
        p_w = 1.
        px = ((((p_x * m._11) + ((p_y * m._21))) + ((p_z * m._31))) + ((p_w * m._41)))
        py = ((((p_x * m._12) + ((p_y * m._22))) + ((p_z * m._32))) + ((p_w * m._42)))
        pz = ((((p_x * m._13) + ((p_y * m._23))) + ((p_z * m._33))) + ((p_w * m._43)))
        p_x = px
        p_y = py
        p_z = pz
        r.px = p_x
        r.py = p_y
        r.pz = p_z
        x1 = r.lx
        y1 = r.ly
        z1 = r.lz
        if (z1 is None):
            z1 = 0.
        if (y1 is None):
            y1 = 0.
        if (x1 is None):
            x1 = 0.
        l_x = x1
        l_y = y1
        l_z = z1
        l_w = 1.
        px1 = (((l_x * m._11) + ((l_y * m._21))) + ((l_z * m._31)))
        py1 = (((l_x * m._12) + ((l_y * m._22))) + ((l_z * m._32)))
        pz1 = (((l_x * m._13) + ((l_y * m._23))) + ((l_z * m._33)))
        l_x = px1
        l_y = py1
        l_z = pz1
        r.lx = l_x
        r.ly = l_y
        r.lz = l_z
        r.normalize()
        hit = self.collider.rayIntersection(r,bestMatch)
        if (hit < 0):
            r.px = tmpRay.px
            r.py = tmpRay.py
            r.pz = tmpRay.pz
            r.lx = tmpRay.lx
            r.ly = tmpRay.ly
            r.lz = tmpRay.lz
            h3d_col_ObjectCollider.TMP_RAY = tmpRay
            return hit
        x2 = (r.px + ((hit * r.lx)))
        y2 = (r.py + ((hit * r.ly)))
        z2 = (r.pz + ((hit * r.lz)))
        if (z2 is None):
            z2 = 0.
        if (y2 is None):
            y2 = 0.
        if (x2 is None):
            x2 = 0.
        pt_x = x2
        pt_y = y2
        pt_z = z2
        m1 = self.obj.absPos
        px2 = ((((pt_x * m1._11) + ((pt_y * m1._21))) + ((pt_z * m1._31))) + m1._41)
        py2 = ((((pt_x * m1._12) + ((pt_y * m1._22))) + ((pt_z * m1._32))) + m1._42)
        pz2 = ((((pt_x * m1._13) + ((pt_y * m1._23))) + ((pt_z * m1._33))) + m1._43)
        pt_x = px2
        pt_y = py2
        pt_z = pz2
        r.px = tmpRay.px
        r.py = tmpRay.py
        r.pz = tmpRay.pz
        r.lx = tmpRay.lx
        r.ly = tmpRay.ly
        r.lz = tmpRay.lz
        h3d_col_ObjectCollider.TMP_RAY = tmpRay
        dx = (pt_x - r.px)
        dy = (pt_y - r.py)
        dz = (pt_z - r.pz)
        if (dz is None):
            dz = 0.
        dz1 = dz
        if (dz1 is None):
            dz1 = 0.
        f = (((dx * dx) + ((dy * dy))) + ((dz1 * dz1)))
        if (f < 0):
            return Math.NaN
        else:
            return python_lib_Math.sqrt(f)

    def contains(self,p):
        x = p.x
        y = p.y
        z = p.z
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        ptmp_x = x
        ptmp_y = y
        ptmp_z = z
        m = self.obj.getInvPos()
        px = ((((p.x * m._11) + ((p.y * m._21))) + ((p.z * m._31))) + m._41)
        py = ((((p.x * m._12) + ((p.y * m._22))) + ((p.z * m._32))) + m._42)
        pz = ((((p.x * m._13) + ((p.y * m._23))) + ((p.z * m._33))) + m._43)
        p.x = px
        p.y = py
        p.z = pz
        b = self.collider.contains(p)
        p.x = ptmp_x
        p.y = ptmp_y
        p.z = ptmp_z
        return b

    def inFrustum(self,f,m = None):
        if (m is None):
            return self.collider.inFrustum(f,self.obj.getAbsPos())
        mat = h3d_col_ObjectCollider.TMP_MAT
        b = self.obj.getAbsPos()
        m11 = m._11
        m12 = m._12
        m13 = m._13
        m21 = m._21
        m22 = m._22
        m23 = m._23
        a31 = m._31
        a32 = m._32
        a33 = m._33
        a41 = m._41
        a42 = m._42
        a43 = m._43
        b11 = b._11
        b12 = b._12
        b13 = b._13
        b21 = b._21
        b22 = b._22
        b23 = b._23
        b31 = b._31
        b32 = b._32
        b33 = b._33
        b41 = b._41
        b42 = b._42
        b43 = b._43
        mat._11 = (((m11 * b11) + ((m12 * b21))) + ((m13 * b31)))
        mat._12 = (((m11 * b12) + ((m12 * b22))) + ((m13 * b32)))
        mat._13 = (((m11 * b13) + ((m12 * b23))) + ((m13 * b33)))
        mat._14 = 0
        mat._21 = (((m21 * b11) + ((m22 * b21))) + ((m23 * b31)))
        mat._22 = (((m21 * b12) + ((m22 * b22))) + ((m23 * b32)))
        mat._23 = (((m21 * b13) + ((m22 * b23))) + ((m23 * b33)))
        mat._24 = 0
        mat._31 = (((a31 * b11) + ((a32 * b21))) + ((a33 * b31)))
        mat._32 = (((a31 * b12) + ((a32 * b22))) + ((a33 * b32)))
        mat._33 = (((a31 * b13) + ((a32 * b23))) + ((a33 * b33)))
        mat._34 = 0
        mat._41 = ((((a41 * b11) + ((a42 * b21))) + ((a43 * b31))) + b41)
        mat._42 = ((((a41 * b12) + ((a42 * b22))) + ((a43 * b32))) + b42)
        mat._43 = ((((a41 * b13) + ((a42 * b23))) + ((a43 * b33))) + b43)
        mat._44 = 1
        return self.collider.inFrustum(f,mat)

    def inSphere(self,s):
        invMat = self.obj.getInvPos()
        oldX = s.x
        oldY = s.y
        oldZ = s.z
        oldR = s.r
        x = s.x
        y = s.y
        z = s.z
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        center_x = x
        center_y = y
        center_z = z
        px = ((((center_x * invMat._11) + ((center_y * invMat._21))) + ((center_z * invMat._31))) + invMat._41)
        py = ((((center_x * invMat._12) + ((center_y * invMat._22))) + ((center_z * invMat._32))) + invMat._42)
        pz = ((((center_x * invMat._13) + ((center_y * invMat._23))) + ((center_z * invMat._33))) + invMat._43)
        center_x = px
        center_y = py
        center_z = pz
        v = None
        if (v is None):
            v = h3d_Vector()
        f = (((invMat._11 * invMat._11) + ((invMat._12 * invMat._12))) + ((invMat._13 * invMat._13)))
        v.x = (Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))
        f1 = (((invMat._21 * invMat._21) + ((invMat._22 * invMat._22))) + ((invMat._23 * invMat._23)))
        v.y = (Math.NaN if ((f1 < 0)) else python_lib_Math.sqrt(f1))
        f2 = (((invMat._31 * invMat._31) + ((invMat._32 * invMat._32))) + ((invMat._33 * invMat._33)))
        v.z = (Math.NaN if ((f2 < 0)) else python_lib_Math.sqrt(f2))
        if ((((invMat._11 * (((invMat._22 * invMat._33) - ((invMat._23 * invMat._32))))) + ((invMat._12 * (((invMat._23 * invMat._31) - ((invMat._21 * invMat._33))))))) + ((invMat._13 * (((invMat._21 * invMat._32) - ((invMat._22 * invMat._31))))))) < 0):
            v.x = (v.x * -1)
            v.y = (v.y * -1)
            v.z = (v.z * -1)
        scale = v
        s.x = center_x
        s.y = center_y
        s.z = center_z
        s1 = s
        s2 = s1.r
        a = scale.x
        b = scale.y
        a1 = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else max(a,b)))
        b1 = scale.z
        s1.r = (s2 * ((a1 if (python_lib_Math.isnan(a1)) else (b1 if (python_lib_Math.isnan(b1)) else max(a1,b1)))))
        res = self.collider.inSphere(s)
        s.x = oldX
        s.y = oldY
        s.z = oldZ
        s.r = oldR
        return res

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.obj = None
        _hx_o.collider = None
h3d_col_ObjectCollider._hx_class = h3d_col_ObjectCollider
_hx_classes["h3d.col.ObjectCollider"] = h3d_col_ObjectCollider


class h3d_col_Plane:
    _hx_class_name = "h3d.col.Plane"
    _hx_is_interface = "False"
    __slots__ = ("nx", "ny", "nz", "d")
    _hx_fields = ["nx", "ny", "nz", "d"]
    _hx_methods = ["getNormal", "getNormalDistance", "load", "transform", "transform3x3", "transformInverseTranspose", "normalize", "toString", "distance", "side", "project", "projectTo"]
    _hx_statics = ["fromPoints", "fromNormalPoint", "X", "Y", "Z", "frustumLeft", "frustumRight", "frustumBottom", "frustumTop", "frustumNear", "frustumFar"]

    def __init__(self,nx,ny,nz,d):
        self.nx = nx
        self.ny = ny
        self.nz = nz
        self.d = d

    def getNormal(self):
        return h3d_col_Point(self.nx,self.ny,self.nz)

    def getNormalDistance(self):
        return self.d

    def load(self,p):
        self.nx = p.nx
        self.ny = p.ny
        self.nz = p.nz
        self.d = p.d

    def transform(self,m):
        m2 = h3d_Matrix()
        m2.initInverse(m)
        m2.transpose()
        x = self.nx
        y = self.ny
        z = self.nz
        w = -self.d
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        v_w = w
        px = ((((v_x * m2._11) + ((v_y * m2._21))) + ((v_z * m2._31))) + ((v_w * m2._41)))
        py = ((((v_x * m2._12) + ((v_y * m2._22))) + ((v_z * m2._32))) + ((v_w * m2._42)))
        pz = ((((v_x * m2._13) + ((v_y * m2._23))) + ((v_z * m2._33))) + ((v_w * m2._43)))
        pw = ((((v_x * m2._14) + ((v_y * m2._24))) + ((v_z * m2._34))) + ((v_w * m2._44)))
        v_x = px
        v_y = py
        v_z = pz
        v_w = pw
        self.nx = v_x
        self.ny = v_y
        self.nz = v_z
        self.d = -v_w

    def transform3x3(self,m):
        m2 = h3d_Matrix()
        m2.initInverse3x3(m)
        m2.transpose()
        x = self.nx
        y = self.ny
        z = self.nz
        w = -self.d
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        v_w = w
        px = ((((v_x * m2._11) + ((v_y * m2._21))) + ((v_z * m2._31))) + ((v_w * m2._41)))
        py = ((((v_x * m2._12) + ((v_y * m2._22))) + ((v_z * m2._32))) + ((v_w * m2._42)))
        pz = ((((v_x * m2._13) + ((v_y * m2._23))) + ((v_z * m2._33))) + ((v_w * m2._43)))
        pw = ((((v_x * m2._14) + ((v_y * m2._24))) + ((v_z * m2._34))) + ((v_w * m2._44)))
        v_x = px
        v_y = py
        v_z = pz
        v_w = pw
        self.nx = v_x
        self.ny = v_y
        self.nz = v_z
        self.d = -v_w

    def transformInverseTranspose(self,m):
        x = self.nx
        y = self.ny
        z = self.nz
        w = -self.d
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        v_w = w
        px = ((((v_x * m._11) + ((v_y * m._21))) + ((v_z * m._31))) + ((v_w * m._41)))
        py = ((((v_x * m._12) + ((v_y * m._22))) + ((v_z * m._32))) + ((v_w * m._42)))
        pz = ((((v_x * m._13) + ((v_y * m._23))) + ((v_z * m._33))) + ((v_w * m._43)))
        pw = ((((v_x * m._14) + ((v_y * m._24))) + ((v_z * m._34))) + ((v_w * m._44)))
        v_x = px
        v_y = py
        v_z = pz
        v_w = pw
        self.nx = v_x
        self.ny = v_y
        self.nz = v_z
        self.d = -v_w

    def normalize(self):
        f = (((self.nx * self.nx) + ((self.ny * self.ny))) + ((self.nz * self.nz)))
        _hx_len = (1. / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.nx
        _hx_local_0.nx = (_hx_local_1 * _hx_len)
        _hx_local_0.nx
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.ny
        _hx_local_2.ny = (_hx_local_3 * _hx_len)
        _hx_local_2.ny
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.nz
        _hx_local_4.nz = (_hx_local_5 * _hx_len)
        _hx_local_4.nz
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6.d
        _hx_local_6.d = (_hx_local_7 * _hx_len)
        _hx_local_6.d

    def toString(self):
        return (((("Plane{" + Std.string(h3d_col_Point(self.nx,self.ny,self.nz))) + ",") + Std.string(hxd_Math.fmt(self.d))) + "}")

    def distance(self,p):
        return ((((self.nx * p.x) + ((self.ny * p.y))) + ((self.nz * p.z))) - self.d)

    def side(self,p):
        return (((((self.nx * p.x) + ((self.ny * p.y))) + ((self.nz * p.z))) - self.d) >= 0)

    def project(self,p):
        d = ((((self.nx * p.x) + ((self.ny * p.y))) + ((self.nz * p.z))) - self.d)
        return h3d_col_Point((p.x - ((d * self.nx))),(p.y - ((d * self.ny))),(p.z - ((d * self.nz))))

    def projectTo(self,p,out):
        d = ((((self.nx * p.x) + ((self.ny * p.y))) + ((self.nz * p.z))) - self.d)
        out.x = (p.x - ((d * self.nx)))
        out.y = (p.y - ((d * self.ny)))
        out.z = (p.z - ((d * self.nz)))

    @staticmethod
    def fromPoints(p0,p1,p2):
        x = (p1.x - p0.x)
        y = (p1.y - p0.y)
        z = (p1.z - p0.z)
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        d1_x = x
        d1_y = y
        d1_z = z
        x1 = (p2.x - p0.x)
        y1 = (p2.y - p0.y)
        z1 = (p2.z - p0.z)
        if (z1 is None):
            z1 = 0.
        if (y1 is None):
            y1 = 0.
        if (x1 is None):
            x1 = 0.
        d2_x = x1
        d2_y = y1
        d2_z = z1
        x2 = ((d1_y * d2_z) - ((d1_z * d2_y)))
        y2 = ((d1_z * d2_x) - ((d1_x * d2_z)))
        z2 = ((d1_x * d2_y) - ((d1_y * d2_x)))
        if (z2 is None):
            z2 = 0.
        if (y2 is None):
            y2 = 0.
        if (x2 is None):
            x2 = 0.
        n_x = x2
        n_y = y2
        n_z = z2
        return h3d_col_Plane(n_x,n_y,n_z,(((n_x * p0.x) + ((n_y * p0.y))) + ((n_z * p0.z))))

    @staticmethod
    def fromNormalPoint(n,p):
        return h3d_col_Plane(n.x,n.y,n.z,(((n.x * p.x) + ((n.y * p.y))) + ((n.z * p.z))))

    @staticmethod
    def X(v = None):
        if (v is None):
            v = 0.0
        return h3d_col_Plane(1,0,0,v)

    @staticmethod
    def Y(v = None):
        if (v is None):
            v = 0.0
        return h3d_col_Plane(0,1,0,v)

    @staticmethod
    def Z(v = None):
        if (v is None):
            v = 0.0
        return h3d_col_Plane(0,0,1,v)

    @staticmethod
    def frustumLeft(mvp):
        return h3d_col_Plane((mvp._14 + mvp._11),(mvp._24 + mvp._21),(mvp._34 + mvp._31),-((mvp._44 + mvp._41)))

    @staticmethod
    def frustumRight(mvp):
        return h3d_col_Plane((mvp._14 - mvp._11),(mvp._24 - mvp._21),(mvp._34 - mvp._31),(mvp._41 - mvp._44))

    @staticmethod
    def frustumBottom(mvp):
        return h3d_col_Plane((mvp._14 + mvp._12),(mvp._24 + mvp._22),(mvp._34 + mvp._32),-((mvp._44 + mvp._42)))

    @staticmethod
    def frustumTop(mvp):
        return h3d_col_Plane((mvp._14 - mvp._12),(mvp._24 - mvp._22),(mvp._34 - mvp._32),(mvp._42 - mvp._44))

    @staticmethod
    def frustumNear(mvp):
        return h3d_col_Plane(mvp._13,mvp._23,mvp._33,-mvp._43)

    @staticmethod
    def frustumFar(mvp):
        return h3d_col_Plane((mvp._14 - mvp._13),(mvp._24 - mvp._23),(mvp._34 - mvp._33),(mvp._43 - mvp._44))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.nx = None
        _hx_o.ny = None
        _hx_o.nz = None
        _hx_o.d = None
h3d_col_Plane._hx_class = h3d_col_Plane
_hx_classes["h3d.col.Plane"] = h3d_col_Plane


class h3d_col_Point:
    _hx_class_name = "h3d.col.Point"
    _hx_is_interface = "False"
    __slots__ = ("x", "y", "z")
    _hx_fields = ["x", "y", "z"]
    _hx_methods = ["scale", "inFrustum", "set", "multiply", "sub", "add", "cross", "equals", "lengthSq", "setLength", "length", "dot", "distanceSq", "distance", "normalize", "normalizeFast", "lerp", "transform", "transform3x3", "toVector", "clone", "load", "toString"]

    def __init__(self,x = None,y = None,z = None):
        if (x is None):
            x = 0.
        if (y is None):
            y = 0.
        if (z is None):
            z = 0.
        self.x = x
        self.y = y
        self.z = z

    def scale(self,v):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.x
        _hx_local_0.x = (_hx_local_1 * v)
        _hx_local_0.x
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.y
        _hx_local_2.y = (_hx_local_3 * v)
        _hx_local_2.y
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.z
        _hx_local_4.z = (_hx_local_5 * v)
        _hx_local_4.z

    def inFrustum(self,f,m = None):
        return f.hasPoint(self)

    def set(self,x,y,z):
        self.x = x
        self.y = y
        self.z = z

    def multiply(self,f):
        return h3d_col_Point((self.x * f),(self.y * f),(self.z * f))

    def sub(self,p):
        return h3d_col_Point((self.x - p.x),(self.y - p.y),(self.z - p.z))

    def add(self,p):
        return h3d_col_Point((self.x + p.x),(self.y + p.y),(self.z + p.z))

    def cross(self,p):
        return h3d_col_Point(((self.y * p.z) - ((self.z * p.y))),((self.z * p.x) - ((self.x * p.z))),((self.x * p.y) - ((self.y * p.x))))

    def equals(self,other):
        if ((self.x == other.x) and ((self.y == other.y))):
            return (self.z == other.z)
        else:
            return False

    def lengthSq(self):
        return (((self.x * self.x) + ((self.y * self.y))) + ((self.z * self.z)))

    def setLength(self,_hx_len):
        k = (((self.x * self.x) + ((self.y * self.y))) + ((self.z * self.z)))
        k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.x
        _hx_local_0.x = (_hx_local_1 * k)
        _hx_local_0.x
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.y
        _hx_local_2.y = (_hx_local_3 * k)
        _hx_local_2.y
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.z
        _hx_local_4.z = (_hx_local_5 * k)
        _hx_local_4.z
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6.x
        _hx_local_6.x = (_hx_local_7 * _hx_len)
        _hx_local_6.x
        _hx_local_8 = self
        _hx_local_9 = _hx_local_8.y
        _hx_local_8.y = (_hx_local_9 * _hx_len)
        _hx_local_8.y
        _hx_local_10 = self
        _hx_local_11 = _hx_local_10.z
        _hx_local_10.z = (_hx_local_11 * _hx_len)
        _hx_local_10.z

    def length(self):
        f = (((self.x * self.x) + ((self.y * self.y))) + ((self.z * self.z)))
        if (f < 0):
            return Math.NaN
        else:
            return python_lib_Math.sqrt(f)

    def dot(self,p):
        return (((self.x * p.x) + ((self.y * p.y))) + ((self.z * p.z)))

    def distanceSq(self,p):
        dx = (p.x - self.x)
        dy = (p.y - self.y)
        dz = (p.z - self.z)
        return (((dx * dx) + ((dy * dy))) + ((dz * dz)))

    def distance(self,p):
        dx = (p.x - self.x)
        dy = (p.y - self.y)
        dz = (p.z - self.z)
        f = (((dx * dx) + ((dy * dy))) + ((dz * dz)))
        if (f < 0):
            return Math.NaN
        else:
            return python_lib_Math.sqrt(f)

    def normalize(self):
        k = (((self.x * self.x) + ((self.y * self.y))) + ((self.z * self.z)))
        if (k < 1e-10):
            k = 0
        else:
            k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.x
        _hx_local_0.x = (_hx_local_1 * k)
        _hx_local_0.x
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.y
        _hx_local_2.y = (_hx_local_3 * k)
        _hx_local_2.y
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.z
        _hx_local_4.z = (_hx_local_5 * k)
        _hx_local_4.z
        return self

    def normalizeFast(self):
        k = (((self.x * self.x) + ((self.y * self.y))) + ((self.z * self.z)))
        k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.x
        _hx_local_0.x = (_hx_local_1 * k)
        _hx_local_0.x
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.y
        _hx_local_2.y = (_hx_local_3 * k)
        _hx_local_2.y
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.z
        _hx_local_4.z = (_hx_local_5 * k)
        _hx_local_4.z
        return self

    def lerp(self,p1,p2,k):
        a = p1.x
        x = (a + ((k * ((p2.x - a)))))
        a1 = p1.y
        y = (a1 + ((k * ((p2.y - a1)))))
        a2 = p1.z
        z = (a2 + ((k * ((p2.z - a2)))))
        self.x = x
        self.y = y
        self.z = z

    def transform(self,m):
        px = ((((self.x * m._11) + ((self.y * m._21))) + ((self.z * m._31))) + m._41)
        py = ((((self.x * m._12) + ((self.y * m._22))) + ((self.z * m._32))) + m._42)
        pz = ((((self.x * m._13) + ((self.y * m._23))) + ((self.z * m._33))) + m._43)
        self.x = px
        self.y = py
        self.z = pz

    def transform3x3(self,m):
        px = (((self.x * m._11) + ((self.y * m._21))) + ((self.z * m._31)))
        py = (((self.x * m._12) + ((self.y * m._22))) + ((self.z * m._32)))
        pz = (((self.x * m._13) + ((self.y * m._23))) + ((self.z * m._33)))
        self.x = px
        self.y = py
        self.z = pz

    def toVector(self):
        return h3d_Vector(self.x,self.y,self.z)

    def clone(self):
        return h3d_col_Point(self.x,self.y,self.z)

    def load(self,p):
        self.x = p.x
        self.y = p.y
        self.z = p.z

    def toString(self):
        return (((((("Point{" + Std.string(hxd_Math.fmt(self.x))) + ",") + Std.string(hxd_Math.fmt(self.y))) + ",") + Std.string(hxd_Math.fmt(self.z))) + "}")

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.x = None
        _hx_o.y = None
        _hx_o.z = None
h3d_col_Point._hx_class = h3d_col_Point
_hx_classes["h3d.col.Point"] = h3d_col_Point


class h3d_col_TriPlane:
    _hx_class_name = "h3d.col.TriPlane"
    _hx_is_interface = "False"
    __slots__ = ("next", "p0x", "p0y", "p0z", "d1x", "d1y", "d1z", "d2x", "d2y", "d2z", "dot00", "dot01", "dot11", "invDenom", "nx", "ny", "nz", "d")
    _hx_fields = ["next", "p0x", "p0y", "p0z", "d1x", "d1y", "d1z", "d2x", "d2y", "d2z", "dot00", "dot01", "dot11", "invDenom", "nx", "ny", "nz", "d"]
    _hx_methods = ["init", "clone", "load", "transform", "contains", "side", "inFrustum", "inSphere", "rayIntersection", "isPointInTriangle", "getPoints"]
    _hx_interfaces = [h3d_col_Collider]

    def __init__(self):
        self.d = None
        self.nz = None
        self.ny = None
        self.nx = None
        self.invDenom = None
        self.dot11 = None
        self.dot01 = None
        self.dot00 = None
        self.d2z = None
        self.d2y = None
        self.d2x = None
        self.d1z = None
        self.d1y = None
        self.d1x = None
        self.p0z = None
        self.p0y = None
        self.p0x = None
        self.next = None

    def init(self,p0,p1,p2):
        self.p0x = p0.x
        self.p0y = p0.y
        self.p0z = p0.z
        x = (p1.x - p0.x)
        y = (p1.y - p0.y)
        z = (p1.z - p0.z)
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        d1_x = x
        d1_y = y
        d1_z = z
        x1 = (p2.x - p0.x)
        y1 = (p2.y - p0.y)
        z1 = (p2.z - p0.z)
        if (z1 is None):
            z1 = 0.
        if (y1 is None):
            y1 = 0.
        if (x1 is None):
            x1 = 0.
        d2_x = x1
        d2_y = y1
        d2_z = z1
        x2 = ((d1_y * d2_z) - ((d1_z * d2_y)))
        y2 = ((d1_z * d2_x) - ((d1_x * d2_z)))
        z2 = ((d1_x * d2_y) - ((d1_y * d2_x)))
        if (z2 is None):
            z2 = 0.
        if (y2 is None):
            y2 = 0.
        if (x2 is None):
            x2 = 0.
        n_x = x2
        n_y = y2
        n_z = z2
        self.d = (((n_x * p0.x) + ((n_y * p0.y))) + ((n_z * p0.z)))
        self.nx = n_x
        self.ny = n_y
        self.nz = n_z
        self.d1x = d1_x
        self.d1y = d1_y
        self.d1z = d1_z
        self.d2x = d2_x
        self.d2y = d2_y
        self.d2z = d2_z
        self.dot00 = (((d1_x * d1_x) + ((d1_y * d1_y))) + ((d1_z * d1_z)))
        self.dot01 = (((d1_x * d2_x) + ((d1_y * d2_y))) + ((d1_z * d2_z)))
        self.dot11 = (((d2_x * d2_x) + ((d2_y * d2_y))) + ((d2_z * d2_z)))
        self.invDenom = (1 / (((self.dot00 * self.dot11) - ((self.dot01 * self.dot01)))))

    def clone(self):
        clone = h3d_col_TriPlane()
        clone.p0x = self.p0x
        clone.p0y = self.p0y
        clone.p0z = self.p0z
        clone.d1x = self.d1x
        clone.d1y = self.d1y
        clone.d1z = self.d1z
        clone.d2x = self.d2x
        clone.d2y = self.d2y
        clone.d2z = self.d2z
        clone.dot00 = self.dot00
        clone.dot01 = self.dot01
        clone.dot11 = self.dot11
        clone.invDenom = self.invDenom
        clone.nx = self.nx
        clone.ny = self.ny
        clone.nz = self.nz
        clone.d = self.d
        if (self.next is not None):
            clone.next = self.next.clone()
        return clone

    def load(self,tp):
        self.p0x = tp.p0x
        self.p0y = tp.p0y
        self.p0z = tp.p0z
        self.d1x = tp.d1x
        self.d1y = tp.d1y
        self.d1z = tp.d1z
        self.d2x = tp.d2x
        self.d2y = tp.d2y
        self.d2z = tp.d2z
        self.dot00 = tp.dot00
        self.dot01 = tp.dot01
        self.dot11 = tp.dot11
        self.invDenom = tp.invDenom
        self.nx = tp.nx
        self.ny = tp.ny
        self.nz = tp.nz
        self.d = tp.d

    def transform(self,m):
        x = self.p0x
        y = self.p0y
        z = self.p0z
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        p0_x = x
        p0_y = y
        p0_z = z
        x1 = (self.d1x + self.p0x)
        y1 = (self.d1y + self.p0y)
        z1 = (self.d1z + self.p0z)
        if (z1 is None):
            z1 = 0.
        if (y1 is None):
            y1 = 0.
        if (x1 is None):
            x1 = 0.
        p1_x = x1
        p1_y = y1
        p1_z = z1
        x2 = (self.d2x + self.p0x)
        y2 = (self.d2y + self.p0y)
        z2 = (self.d2z + self.p0z)
        if (z2 is None):
            z2 = 0.
        if (y2 is None):
            y2 = 0.
        if (x2 is None):
            x2 = 0.
        p2_x = x2
        p2_y = y2
        p2_z = z2
        px = ((((p0_x * m._11) + ((p0_y * m._21))) + ((p0_z * m._31))) + m._41)
        py = ((((p0_x * m._12) + ((p0_y * m._22))) + ((p0_z * m._32))) + m._42)
        pz = ((((p0_x * m._13) + ((p0_y * m._23))) + ((p0_z * m._33))) + m._43)
        p0_x = px
        p0_y = py
        p0_z = pz
        px1 = ((((p1_x * m._11) + ((p1_y * m._21))) + ((p1_z * m._31))) + m._41)
        py1 = ((((p1_x * m._12) + ((p1_y * m._22))) + ((p1_z * m._32))) + m._42)
        pz1 = ((((p1_x * m._13) + ((p1_y * m._23))) + ((p1_z * m._33))) + m._43)
        p1_x = px1
        p1_y = py1
        p1_z = pz1
        px2 = ((((p2_x * m._11) + ((p2_y * m._21))) + ((p2_z * m._31))) + m._41)
        py2 = ((((p2_x * m._12) + ((p2_y * m._22))) + ((p2_z * m._32))) + m._42)
        pz2 = ((((p2_x * m._13) + ((p2_y * m._23))) + ((p2_z * m._33))) + m._43)
        p2_x = px2
        p2_y = py2
        p2_z = pz2
        self.p0x = p0_x
        self.p0y = p0_y
        self.p0z = p0_z
        x3 = (p1_x - p0_x)
        y3 = (p1_y - p0_y)
        z3 = (p1_z - p0_z)
        if (z3 is None):
            z3 = 0.
        if (y3 is None):
            y3 = 0.
        if (x3 is None):
            x3 = 0.
        d1_x = x3
        d1_y = y3
        d1_z = z3
        x4 = (p2_x - p0_x)
        y4 = (p2_y - p0_y)
        z4 = (p2_z - p0_z)
        if (z4 is None):
            z4 = 0.
        if (y4 is None):
            y4 = 0.
        if (x4 is None):
            x4 = 0.
        d2_x = x4
        d2_y = y4
        d2_z = z4
        x5 = ((d1_y * d2_z) - ((d1_z * d2_y)))
        y5 = ((d1_z * d2_x) - ((d1_x * d2_z)))
        z5 = ((d1_x * d2_y) - ((d1_y * d2_x)))
        if (z5 is None):
            z5 = 0.
        if (y5 is None):
            y5 = 0.
        if (x5 is None):
            x5 = 0.
        n_x = x5
        n_y = y5
        n_z = z5
        self.d = (((n_x * p0_x) + ((n_y * p0_y))) + ((n_z * p0_z)))
        self.nx = n_x
        self.ny = n_y
        self.nz = n_z
        self.d1x = d1_x
        self.d1y = d1_y
        self.d1z = d1_z
        self.d2x = d2_x
        self.d2y = d2_y
        self.d2z = d2_z
        self.dot00 = (((d1_x * d1_x) + ((d1_y * d1_y))) + ((d1_z * d1_z)))
        self.dot01 = (((d1_x * d2_x) + ((d1_y * d2_y))) + ((d1_z * d2_z)))
        self.dot11 = (((d2_x * d2_x) + ((d2_y * d2_y))) + ((d2_z * d2_z)))
        self.invDenom = (1 / (((self.dot00 * self.dot11) - ((self.dot01 * self.dot01)))))

    def contains(self,p):
        x = (p.x - self.p0x)
        y = (p.y - self.p0y)
        z = (p.z - self.p0z)
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v2_x = x
        v2_y = y
        v2_z = z
        dot02 = (((self.d1x * v2_x) + ((self.d1y * v2_y))) + ((self.d1z * v2_z)))
        dot12 = (((self.d2x * v2_x) + ((self.d2y * v2_y))) + ((self.d2z * v2_z)))
        u = ((((self.dot11 * dot02) - ((self.dot01 * dot12)))) * self.invDenom)
        v = ((((self.dot00 * dot12) - ((self.dot01 * dot02)))) * self.invDenom)
        if ((u >= 0) and ((v >= 0))):
            return ((u + v) < 1)
        else:
            return False

    def side(self,p):
        return (((((self.nx * p.x) + ((self.ny * p.y))) + ((self.nz * p.z))) - self.d) >= 0)

    def inFrustum(self,f,m = None):
        raise _HxException("Not implemented")

    def inSphere(self,s):
        raise _HxException("Not implemented")

    def rayIntersection(self,r,bestMatch):
        dr = (((r.lx * self.nx) + ((r.ly * self.ny))) + ((r.lz * self.nz)))
        if (dr >= 0):
            return -1.
        nd = (self.d - ((((r.px * self.nx) + ((r.py * self.ny))) + ((r.pz * self.nz)))))
        k = (nd / dr)
        if (k < 0):
            return -1
        px = (r.px + ((r.lx * k)))
        py = (r.py + ((r.ly * k)))
        pz = (r.pz + ((r.lz * k)))
        x = (px - self.p0x)
        y = (py - self.p0y)
        z = (pz - self.p0z)
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v2_x = x
        v2_y = y
        v2_z = z
        dot02 = (((self.d1x * v2_x) + ((self.d1y * v2_y))) + ((self.d1z * v2_z)))
        dot12 = (((self.d2x * v2_x) + ((self.d2y * v2_y))) + ((self.d2z * v2_z)))
        u = ((((self.dot11 * dot02) - ((self.dot01 * dot12)))) * self.invDenom)
        v = ((((self.dot00 * dot12) - ((self.dot01 * dot02)))) * self.invDenom)
        if (not ((((u >= 0) and ((v >= 0))) and (((u + v) < 1))))):
            return -1
        return k

    def isPointInTriangle(self,x,y,z):
        x1 = (x - self.p0x)
        y1 = (y - self.p0y)
        z1 = (z - self.p0z)
        if (z1 is None):
            z1 = 0.
        if (y1 is None):
            y1 = 0.
        if (x1 is None):
            x1 = 0.
        v2_x = x1
        v2_y = y1
        v2_z = z1
        dot02 = (((self.d1x * v2_x) + ((self.d1y * v2_y))) + ((self.d1z * v2_z)))
        dot12 = (((self.d2x * v2_x) + ((self.d2y * v2_y))) + ((self.d2z * v2_z)))
        u = ((((self.dot11 * dot02) - ((self.dot01 * dot12)))) * self.invDenom)
        v = ((((self.dot00 * dot12) - ((self.dot01 * dot02)))) * self.invDenom)
        if ((u >= 0) and ((v >= 0))):
            return ((u + v) < 1)
        else:
            return False

    def getPoints(self):
        return [h3d_col_Point(self.p0x,self.p0y,self.p0z), h3d_col_Point((self.d1x + self.p0x),(self.d1y + self.p0y),(self.d1z + self.p0z)), h3d_col_Point((self.d2x + self.p0x),(self.d2y + self.p0y),(self.d2z + self.p0z))]

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.next = None
        _hx_o.p0x = None
        _hx_o.p0y = None
        _hx_o.p0z = None
        _hx_o.d1x = None
        _hx_o.d1y = None
        _hx_o.d1z = None
        _hx_o.d2x = None
        _hx_o.d2y = None
        _hx_o.d2z = None
        _hx_o.dot00 = None
        _hx_o.dot01 = None
        _hx_o.dot11 = None
        _hx_o.invDenom = None
        _hx_o.nx = None
        _hx_o.ny = None
        _hx_o.nz = None
        _hx_o.d = None
h3d_col_TriPlane._hx_class = h3d_col_TriPlane
_hx_classes["h3d.col.TriPlane"] = h3d_col_TriPlane


class h3d_col_Polygon:
    _hx_class_name = "h3d.col.Polygon"
    _hx_is_interface = "False"
    __slots__ = ("triPlanes",)
    _hx_fields = ["triPlanes"]
    _hx_methods = ["addBuffers", "isConvex", "clone", "transform", "getPoints", "getBounds", "contains", "rayIntersection", "inFrustum", "inSphere"]
    _hx_interfaces = [h3d_col_Collider]

    def __init__(self):
        self.triPlanes = None

    def addBuffers(self,vertexes,indexes,stride = None):
        if (stride is None):
            stride = 3
        _g = 0
        x = (len(indexes) / 3)
        _g1 = None
        try:
            _g1 = int(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            _g1 = None
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            k = (i * 3)
            t = h3d_col_TriPlane()
            i0 = (indexes[k] * stride)
            i1 = (indexes[(k + 1)] * stride)
            i2 = (indexes[(k + 2)] * stride)
            x1 = vertexes[i0]
            y = vertexes[(i0 + 1)]
            z = vertexes[(i0 + 2)]
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x1 is None):
                x1 = 0.
            p0_x = x1
            p0_y = y
            p0_z = z
            x2 = vertexes[i1]
            y1 = vertexes[(i1 + 1)]
            z1 = vertexes[(i1 + 2)]
            if (z1 is None):
                z1 = 0.
            if (y1 is None):
                y1 = 0.
            if (x2 is None):
                x2 = 0.
            p1_x = x2
            p1_y = y1
            p1_z = z1
            x3 = vertexes[i2]
            y2 = vertexes[(i2 + 1)]
            z2 = vertexes[(i2 + 2)]
            if (z2 is None):
                z2 = 0.
            if (y2 is None):
                y2 = 0.
            if (x3 is None):
                x3 = 0.
            p2_x = x3
            p2_y = y2
            p2_z = z2
            t.p0x = p0_x
            t.p0y = p0_y
            t.p0z = p0_z
            x4 = (p1_x - p0_x)
            y3 = (p1_y - p0_y)
            z3 = (p1_z - p0_z)
            if (z3 is None):
                z3 = 0.
            if (y3 is None):
                y3 = 0.
            if (x4 is None):
                x4 = 0.
            d1_x = x4
            d1_y = y3
            d1_z = z3
            x5 = (p2_x - p0_x)
            y4 = (p2_y - p0_y)
            z4 = (p2_z - p0_z)
            if (z4 is None):
                z4 = 0.
            if (y4 is None):
                y4 = 0.
            if (x5 is None):
                x5 = 0.
            d2_x = x5
            d2_y = y4
            d2_z = z4
            x6 = ((d1_y * d2_z) - ((d1_z * d2_y)))
            y5 = ((d1_z * d2_x) - ((d1_x * d2_z)))
            z5 = ((d1_x * d2_y) - ((d1_y * d2_x)))
            if (z5 is None):
                z5 = 0.
            if (y5 is None):
                y5 = 0.
            if (x6 is None):
                x6 = 0.
            n_x = x6
            n_y = y5
            n_z = z5
            t.d = (((n_x * p0_x) + ((n_y * p0_y))) + ((n_z * p0_z)))
            t.nx = n_x
            t.ny = n_y
            t.nz = n_z
            t.d1x = d1_x
            t.d1y = d1_y
            t.d1z = d1_z
            t.d2x = d2_x
            t.d2y = d2_y
            t.d2z = d2_z
            t.dot00 = (((d1_x * d1_x) + ((d1_y * d1_y))) + ((d1_z * d1_z)))
            t.dot01 = (((d1_x * d2_x) + ((d1_y * d2_y))) + ((d1_z * d2_z)))
            t.dot11 = (((d2_x * d2_x) + ((d2_y * d2_y))) + ((d2_z * d2_z)))
            t.invDenom = (1 / (((t.dot00 * t.dot11) - ((t.dot01 * t.dot01)))))
            t.next = self.triPlanes
            self.triPlanes = t

    def isConvex(self):
        return True

    def clone(self):
        clone = h3d_col_Polygon()
        clone.triPlanes = h3d_col_TriPlane()
        _this = self.triPlanes
        clone1 = h3d_col_TriPlane()
        clone1.p0x = _this.p0x
        clone1.p0y = _this.p0y
        clone1.p0z = _this.p0z
        clone1.d1x = _this.d1x
        clone1.d1y = _this.d1y
        clone1.d1z = _this.d1z
        clone1.d2x = _this.d2x
        clone1.d2y = _this.d2y
        clone1.d2z = _this.d2z
        clone1.dot00 = _this.dot00
        clone1.dot01 = _this.dot01
        clone1.dot11 = _this.dot11
        clone1.invDenom = _this.invDenom
        clone1.nx = _this.nx
        clone1.ny = _this.ny
        clone1.nz = _this.nz
        clone1.d = _this.d
        if (_this.next is not None):
            _this1 = _this.next
            clone2 = h3d_col_TriPlane()
            clone2.p0x = _this1.p0x
            clone2.p0y = _this1.p0y
            clone2.p0z = _this1.p0z
            clone2.d1x = _this1.d1x
            clone2.d1y = _this1.d1y
            clone2.d1z = _this1.d1z
            clone2.d2x = _this1.d2x
            clone2.d2y = _this1.d2y
            clone2.d2z = _this1.d2z
            clone2.dot00 = _this1.dot00
            clone2.dot01 = _this1.dot01
            clone2.dot11 = _this1.dot11
            clone2.invDenom = _this1.invDenom
            clone2.nx = _this1.nx
            clone2.ny = _this1.ny
            clone2.nz = _this1.nz
            clone2.d = _this1.d
            if (_this1.next is not None):
                clone2.next = _this1.next.clone()
            clone1.next = clone2
        clone.triPlanes = clone1
        return clone

    def transform(self,m):
        t = self.triPlanes
        while (t is not None):
            t.transform(m)
            t = t.next

    def getPoints(self):
        ret = []
        t = self.triPlanes
        while (t is not None):
            ret = (ret + t.getPoints())
            t = t.next
        return ret

    def getBounds(self,bnds = None):
        if (bnds is None):
            bnds = h3d_col_Bounds()
        bnds.xMin = 1e20
        bnds.xMax = -1e20
        bnds.yMin = 1e20
        bnds.yMax = -1e20
        bnds.zMin = 1e20
        bnds.zMax = -1e20
        t = self.triPlanes
        while (t is not None):
            x = t.p0x
            y = t.p0y
            z = t.p0z
            if (x < bnds.xMin):
                bnds.xMin = x
            if (x > bnds.xMax):
                bnds.xMax = x
            if (y < bnds.yMin):
                bnds.yMin = y
            if (y > bnds.yMax):
                bnds.yMax = y
            if (z < bnds.zMin):
                bnds.zMin = z
            if (z > bnds.zMax):
                bnds.zMax = z
            x1 = (t.d1x + t.p0x)
            y1 = (t.d1y + t.p0y)
            z1 = (t.d1z + t.p0z)
            if (x1 < bnds.xMin):
                bnds.xMin = x1
            if (x1 > bnds.xMax):
                bnds.xMax = x1
            if (y1 < bnds.yMin):
                bnds.yMin = y1
            if (y1 > bnds.yMax):
                bnds.yMax = y1
            if (z1 < bnds.zMin):
                bnds.zMin = z1
            if (z1 > bnds.zMax):
                bnds.zMax = z1
            x2 = (t.d2x + t.p0x)
            y2 = (t.d2y + t.p0y)
            z2 = (t.d2z + t.p0z)
            if (x2 < bnds.xMin):
                bnds.xMin = x2
            if (x2 > bnds.xMax):
                bnds.xMax = x2
            if (y2 < bnds.yMin):
                bnds.yMin = y2
            if (y2 > bnds.yMax):
                bnds.yMax = y2
            if (z2 < bnds.zMin):
                bnds.zMin = z2
            if (z2 > bnds.zMax):
                bnds.zMax = z2
            t = t.next
        return bnds

    def contains(self,p):
        if (not self.isConvex()):
            raise _HxException("Not implemented for concave polygon")
        t = self.triPlanes
        while (t is not None):
            if (((((t.nx * p.x) + ((t.ny * p.y))) + ((t.nz * p.z))) - t.d) >= 0):
                return False
            t = t.next
        return True

    def rayIntersection(self,r,bestMatch):
        t = self.triPlanes
        best = -1.
        while (t is not None):
            dr = (((r.lx * t.nx) + ((r.ly * t.ny))) + ((r.lz * t.nz)))
            d = None
            if (dr >= 0):
                d = -1.
            else:
                nd = (t.d - ((((r.px * t.nx) + ((r.py * t.ny))) + ((r.pz * t.nz)))))
                k = (nd / dr)
                if (k < 0):
                    d = -1
                else:
                    px = (r.px + ((r.lx * k)))
                    py = (r.py + ((r.ly * k)))
                    pz = (r.pz + ((r.lz * k)))
                    x = (px - t.p0x)
                    y = (py - t.p0y)
                    z = (pz - t.p0z)
                    if (z is None):
                        z = 0.
                    if (y is None):
                        y = 0.
                    if (x is None):
                        x = 0.
                    v2_x = x
                    v2_y = y
                    v2_z = z
                    dot02 = (((t.d1x * v2_x) + ((t.d1y * v2_y))) + ((t.d1z * v2_z)))
                    dot12 = (((t.d2x * v2_x) + ((t.d2y * v2_y))) + ((t.d2z * v2_z)))
                    u = ((((t.dot11 * dot02) - ((t.dot01 * dot12)))) * t.invDenom)
                    v = ((((t.dot00 * dot12) - ((t.dot01 * dot02)))) * t.invDenom)
                    d = (-1 if ((not ((((u >= 0) and ((v >= 0))) and (((u + v) < 1)))))) else k)
            if (d >= 0):
                if (not bestMatch):
                    return d
                if ((best < 0) or ((d < best))):
                    best = d
            t = t.next
        return best

    def inFrustum(self,f,m = None):
        raise _HxException("Not implemented")

    def inSphere(self,s):
        raise _HxException("Not implemented")

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.triPlanes = None
h3d_col_Polygon._hx_class = h3d_col_Polygon
_hx_classes["h3d.col.Polygon"] = h3d_col_Polygon


class h3d_col_PolygonBuffer:
    _hx_class_name = "h3d.col.PolygonBuffer"
    _hx_is_interface = "False"
    __slots__ = ("buffer", "indexes", "startIndex", "triCount", "source")
    _hx_fields = ["buffer", "indexes", "startIndex", "triCount", "source"]
    _hx_methods = ["setData", "contains", "inFrustum", "inSphere", "rayIntersection"]
    _hx_interfaces = [h3d_col_Collider]

    def __init__(self):
        self.source = None
        self.triCount = None
        self.startIndex = None
        self.indexes = None
        self.buffer = None

    def setData(self,buffer,indexes,startIndex = None,triCount = None):
        if (startIndex is None):
            startIndex = 0
        if (triCount is None):
            triCount = -1
        self.buffer = buffer
        self.indexes = indexes
        self.startIndex = startIndex
        tmp = None
        if (triCount >= 0):
            tmp = triCount
        else:
            x = (((len(indexes) - startIndex)) / 3)
            try:
                tmp = int(x)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                tmp = None
        self.triCount = tmp

    def contains(self,p):
        i = self.startIndex
        x = p.x
        y = p.y
        z = p.z
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        p_x = x
        p_y = y
        p_z = z
        _g = 0
        _g1 = self.triCount
        while (_g < _g1):
            t = _g
            _g = (_g + 1)
            index = i
            i = (i + 1)
            i0 = (self.indexes[index] * 3)
            index1 = i0
            i0 = (i0 + 1)
            x1 = self.buffer[index1]
            index2 = i0
            i0 = (i0 + 1)
            y1 = self.buffer[index2]
            z1 = self.buffer[i0]
            if (z1 is None):
                z1 = 0.
            if (y1 is None):
                y1 = 0.
            if (x1 is None):
                x1 = 0.
            p0_x = x1
            p0_y = y1
            p0_z = z1
            index3 = i
            i = (i + 1)
            i1 = (self.indexes[index3] * 3)
            index4 = i1
            i1 = (i1 + 1)
            x2 = self.buffer[index4]
            index5 = i1
            i1 = (i1 + 1)
            y2 = self.buffer[index5]
            z2 = self.buffer[i1]
            if (z2 is None):
                z2 = 0.
            if (y2 is None):
                y2 = 0.
            if (x2 is None):
                x2 = 0.
            p1_x = x2
            p1_y = y2
            p1_z = z2
            index6 = i
            i = (i + 1)
            i2 = (self.indexes[index6] * 3)
            index7 = i2
            i2 = (i2 + 1)
            x3 = self.buffer[index7]
            index8 = i2
            i2 = (i2 + 1)
            y3 = self.buffer[index8]
            z3 = self.buffer[i2]
            if (z3 is None):
                z3 = 0.
            if (y3 is None):
                y3 = 0.
            if (x3 is None):
                x3 = 0.
            p2_x = x3
            p2_y = y3
            p2_z = z3
            x4 = (p1_x - p0_x)
            y4 = (p1_y - p0_y)
            z4 = (p1_z - p0_z)
            if (z4 is None):
                z4 = 0.
            if (y4 is None):
                y4 = 0.
            if (x4 is None):
                x4 = 0.
            d1_x = x4
            d1_y = y4
            d1_z = z4
            x5 = (p2_x - p0_x)
            y5 = (p2_y - p0_y)
            z5 = (p2_z - p0_z)
            if (z5 is None):
                z5 = 0.
            if (y5 is None):
                y5 = 0.
            if (x5 is None):
                x5 = 0.
            d2_x = x5
            d2_y = y5
            d2_z = z5
            x6 = ((d1_y * d2_z) - ((d1_z * d2_y)))
            y6 = ((d1_z * d2_x) - ((d1_x * d2_z)))
            z6 = ((d1_x * d2_y) - ((d1_y * d2_x)))
            if (z6 is None):
                z6 = 0.
            if (y6 is None):
                y6 = 0.
            if (x6 is None):
                x6 = 0.
            n_x = x6
            n_y = y6
            n_z = z6
            d = (((n_x * p0_x) + ((n_y * p0_y))) + ((n_z * p0_z)))
            if ((((n_x * p_x) + ((n_y * p_y))) + ((n_z * p_z))) >= d):
                return False
        return True

    def inFrustum(self,f,m = None):
        raise _HxException("Not implemented")

    def inSphere(self,s):
        raise _HxException("Not implemented")

    def rayIntersection(self,r,bestMatch):
        i = self.startIndex
        x = r.lx
        y = r.ly
        z = r.lz
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        rdir_x = x
        rdir_y = y
        rdir_z = z
        x1 = r.px
        y1 = r.py
        z1 = r.pz
        if (z1 is None):
            z1 = 0.
        if (y1 is None):
            y1 = 0.
        if (x1 is None):
            x1 = 0.
        r0_x = x1
        r0_y = y1
        r0_z = z1
        best = -1.
        _g = 0
        _g1 = self.triCount
        while (_g < _g1):
            t = _g
            _g = (_g + 1)
            index = i
            i = (i + 1)
            i0 = (self.indexes[index] * 3)
            index1 = i0
            i0 = (i0 + 1)
            x2 = self.buffer[index1]
            index2 = i0
            i0 = (i0 + 1)
            y2 = self.buffer[index2]
            z2 = self.buffer[i0]
            if (z2 is None):
                z2 = 0.
            if (y2 is None):
                y2 = 0.
            if (x2 is None):
                x2 = 0.
            p0_x = x2
            p0_y = y2
            p0_z = z2
            index3 = i
            i = (i + 1)
            i1 = (self.indexes[index3] * 3)
            index4 = i1
            i1 = (i1 + 1)
            x3 = self.buffer[index4]
            index5 = i1
            i1 = (i1 + 1)
            y3 = self.buffer[index5]
            z3 = self.buffer[i1]
            if (z3 is None):
                z3 = 0.
            if (y3 is None):
                y3 = 0.
            if (x3 is None):
                x3 = 0.
            p1_x = x3
            p1_y = y3
            p1_z = z3
            index6 = i
            i = (i + 1)
            i2 = (self.indexes[index6] * 3)
            index7 = i2
            i2 = (i2 + 1)
            x4 = self.buffer[index7]
            index8 = i2
            i2 = (i2 + 1)
            y4 = self.buffer[index8]
            z4 = self.buffer[i2]
            if (z4 is None):
                z4 = 0.
            if (y4 is None):
                y4 = 0.
            if (x4 is None):
                x4 = 0.
            p2_x = x4
            p2_y = y4
            p2_z = z4
            x5 = (p1_x - p0_x)
            y5 = (p1_y - p0_y)
            z5 = (p1_z - p0_z)
            if (z5 is None):
                z5 = 0.
            if (y5 is None):
                y5 = 0.
            if (x5 is None):
                x5 = 0.
            e1_x = x5
            e1_y = y5
            e1_z = z5
            x6 = (p2_x - p0_x)
            y6 = (p2_y - p0_y)
            z6 = (p2_z - p0_z)
            if (z6 is None):
                z6 = 0.
            if (y6 is None):
                y6 = 0.
            if (x6 is None):
                x6 = 0.
            e2_x = x6
            e2_y = y6
            e2_z = z6
            x7 = ((rdir_y * e2_z) - ((rdir_z * e2_y)))
            y7 = ((rdir_z * e2_x) - ((rdir_x * e2_z)))
            z7 = ((rdir_x * e2_y) - ((rdir_y * e2_x)))
            if (z7 is None):
                z7 = 0.
            if (y7 is None):
                y7 = 0.
            if (x7 is None):
                x7 = 0.
            p_x = x7
            p_y = y7
            p_z = z7
            det = (((e1_x * p_x) + ((e1_y * p_y))) + ((e1_z * p_z)))
            if (det < 1e-10):
                continue
            invDet = (1 / det)
            x8 = (r0_x - p0_x)
            y8 = (r0_y - p0_y)
            z8 = (r0_z - p0_z)
            if (z8 is None):
                z8 = 0.
            if (y8 is None):
                y8 = 0.
            if (x8 is None):
                x8 = 0.
            T_x = x8
            T_y = y8
            T_z = z8
            u = (((((T_x * p_x) + ((T_y * p_y))) + ((T_z * p_z)))) * invDet)
            if ((u < 0) or ((u > 1))):
                continue
            x9 = ((T_y * e1_z) - ((T_z * e1_y)))
            y9 = ((T_z * e1_x) - ((T_x * e1_z)))
            z9 = ((T_x * e1_y) - ((T_y * e1_x)))
            if (z9 is None):
                z9 = 0.
            if (y9 is None):
                y9 = 0.
            if (x9 is None):
                x9 = 0.
            q_x = x9
            q_y = y9
            q_z = z9
            v = (((((rdir_x * q_x) + ((rdir_y * q_y))) + ((rdir_z * q_z)))) * invDet)
            if ((v < 0) or (((u + v) > 1))):
                continue
            t1 = (((((e2_x * q_x) + ((e2_y * q_y))) + ((e2_z * q_z)))) * invDet)
            if (t1 < 1e-10):
                continue
            if (not bestMatch):
                return t1
            if ((best < 0) or ((t1 < best))):
                best = t1
        return best

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.buffer = None
        _hx_o.indexes = None
        _hx_o.startIndex = None
        _hx_o.triCount = None
        _hx_o.source = None
h3d_col_PolygonBuffer._hx_class = h3d_col_PolygonBuffer
_hx_classes["h3d.col.PolygonBuffer"] = h3d_col_PolygonBuffer


class h3d_col_SkinCollider:
    _hx_class_name = "h3d.col.SkinCollider"
    _hx_is_interface = "False"
    __slots__ = ("obj", "col", "transform", "lastFrame")
    _hx_fields = ["obj", "col", "transform", "lastFrame"]
    _hx_methods = ["contains", "inFrustum", "inSphere", "rayIntersection", "applyTransform"]
    _hx_interfaces = [h3d_col_Collider, hxd_impl__Serializable_NoSerializeSupport]

    def __init__(self,obj,col):
        self.lastFrame = None
        self.obj = obj
        self.col = col
        self.transform = h3d_col_PolygonBuffer()
        tmp = self.transform
        this1 = col.buffer
        this2 = [None]*len(this1)
        r = this2
        haxe_ds__Vector_Vector_Impl_.blit(this1,0,r,0,len(this1))
        tmp.setData(r,col.indexes,col.startIndex,col.triCount)

    def contains(self,p):
        self.applyTransform()
        return self.transform.contains(p)

    def inFrustum(self,p,m = None):
        if (m is not None):
            raise _HxException("Not implemented")
        self.applyTransform()
        return self.transform.inFrustum(p)

    def inSphere(self,s):
        raise _HxException("Not implemented")

    def rayIntersection(self,r,bestMatch):
        self.applyTransform()
        return self.transform.rayIntersection(r,bestMatch)

    def applyTransform(self):
        if ((not self.obj.jointsUpdated) and ((self.lastFrame == self.obj.lastFrame))):
            return
        self.lastFrame = self.obj.lastFrame
        self.obj.syncJoints()
        j = 0
        v = 0
        nbones = self.obj.skinData.bonesPerVertex
        _g = 0
        _g1 = self.obj.skinData.vertexCount
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            px = 0.
            py = 0.
            pz = 0.
            x = self.col.buffer[v]
            y = self.col.buffer[(v + 1)]
            z = self.col.buffer[(v + 2)]
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            p_x = x
            p_y = y
            p_z = z
            _g2 = 0
            _g11 = nbones
            while (_g2 < _g11):
                k = _g2
                _g2 = (_g2 + 1)
                w = self.obj.skinData.vertexWeights[j]
                if (w == 0):
                    j = (j + 1)
                    continue
                index = j
                j = (j + 1)
                bid = self.obj.skinData.vertexJoints[index]
                x1 = p_x
                y1 = p_y
                z1 = p_z
                if (z1 is None):
                    z1 = 0.
                if (y1 is None):
                    y1 = 0.
                if (x1 is None):
                    x1 = 0.
                p2_x = x1
                p2_y = y1
                p2_z = z1
                m = python_internal_ArrayImpl._get(self.obj.currentPalette, bid)
                px1 = ((((p2_x * m._11) + ((p2_y * m._21))) + ((p2_z * m._31))) + m._41)
                py1 = ((((p2_x * m._12) + ((p2_y * m._22))) + ((p2_z * m._32))) + m._42)
                pz1 = ((((p2_x * m._13) + ((p2_y * m._23))) + ((p2_z * m._33))) + m._43)
                p2_x = px1
                p2_y = py1
                p2_z = pz1
                px = (px + ((p2_x * w)))
                py = (py + ((p2_y * w)))
                pz = (pz + ((p2_z * w)))
            index1 = v
            v = (v + 1)
            self.transform.buffer[index1] = px
            index2 = v
            v = (v + 1)
            self.transform.buffer[index2] = py
            index3 = v
            v = (v + 1)
            self.transform.buffer[index3] = pz

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.obj = None
        _hx_o.col = None
        _hx_o.transform = None
        _hx_o.lastFrame = None
h3d_col_SkinCollider._hx_class = h3d_col_SkinCollider
_hx_classes["h3d.col.SkinCollider"] = h3d_col_SkinCollider


class h3d_col_Sphere:
    _hx_class_name = "h3d.col.Sphere"
    _hx_is_interface = "False"
    __slots__ = ("x", "y", "z", "r")
    _hx_fields = ["x", "y", "z", "r"]
    _hx_methods = ["load", "getCenter", "contains", "rayIntersection", "inFrustum", "inFrustumMatrix", "inSphere", "toString"]
    _hx_interfaces = [h3d_col_Collider]

    def __init__(self,x = None,y = None,z = None,r = None):
        if (x is None):
            x = 0.
        if (y is None):
            y = 0.
        if (z is None):
            z = 0.
        if (r is None):
            r = 0.
        sx = x
        sy = y
        sz = z
        sr = r
        if (sr is None):
            sr = 0.
        if (sz is None):
            sz = 0.
        if (sy is None):
            sy = 0.
        if (sx is None):
            sx = 0.
        self.x = sx
        self.y = sy
        self.z = sz
        self.r = sr

    def load(self,sx = None,sy = None,sz = None,sr = None):
        if (sx is None):
            sx = 0.
        if (sy is None):
            sy = 0.
        if (sz is None):
            sz = 0.
        if (sr is None):
            sr = 0.
        self.x = sx
        self.y = sy
        self.z = sz
        self.r = sr

    def getCenter(self):
        return h3d_col_Point(self.x,self.y,self.z)

    def contains(self,p):
        dx = (p.x - self.x)
        dy = (p.y - self.y)
        dz = (p.z - self.z)
        return ((((dx * dx) + ((dy * dy))) + ((dz * dz))) < ((self.r * self.r)))

    def rayIntersection(self,r,bestMatch):
        r2 = (self.r * self.r)
        px = (r.px + r.lx)
        py = (r.py + r.ly)
        pz = (r.pz + r.lz)
        a = (((r.lx * r.lx) + ((r.ly * r.ly))) + ((r.lz * r.lz)))
        b = ((((2 * r.lx) * ((self.x - px))) + (((2 * r.ly) * ((self.y - py))))) + (((2 * r.lz) * ((self.z - pz)))))
        c = ((((((self.x * self.x) + ((self.y * self.y))) + ((self.z * self.z))) + ((((px * px) + ((py * py))) + ((pz * pz))))) - ((2 * ((((self.x * px) + ((self.y * py))) + ((self.z * pz))))))) - r2)
        d = ((b * b) - (((4 * a) * c)))
        if (d < 0):
            return -1
        d = (Math.NaN if ((d < 0)) else python_lib_Math.sqrt(d))
        t = (((-b + d)) / ((2 * a)))
        return (1 - t)

    def inFrustum(self,f,m = None):
        if (m is not None):
            return self.inFrustumMatrix(f,m)
        return f.hasSphere(self)

    def inFrustumMatrix(self,f,m):
        oldX = self.x
        oldY = self.y
        oldZ = self.z
        oldR = self.r
        x = self.x
        y = self.y
        z = self.z
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        px = ((((v_x * m._11) + ((v_y * m._21))) + ((v_z * m._31))) + m._41)
        py = ((((v_x * m._12) + ((v_y * m._22))) + ((v_z * m._32))) + m._42)
        pz = ((((v_x * m._13) + ((v_y * m._23))) + ((v_z * m._33))) + m._43)
        v_x = px
        v_y = py
        v_z = pz
        self.x = v_x
        self.y = v_y
        self.z = v_z
        v = None
        if (v is None):
            v = h3d_Vector()
        f1 = (((m._11 * m._11) + ((m._12 * m._12))) + ((m._13 * m._13)))
        v.x = (Math.NaN if ((f1 < 0)) else python_lib_Math.sqrt(f1))
        f2 = (((m._21 * m._21) + ((m._22 * m._22))) + ((m._23 * m._23)))
        v.y = (Math.NaN if ((f2 < 0)) else python_lib_Math.sqrt(f2))
        f3 = (((m._31 * m._31) + ((m._32 * m._32))) + ((m._33 * m._33)))
        v.z = (Math.NaN if ((f3 < 0)) else python_lib_Math.sqrt(f3))
        if ((((m._11 * (((m._22 * m._33) - ((m._23 * m._32))))) + ((m._12 * (((m._23 * m._31) - ((m._21 * m._33))))))) + ((m._13 * (((m._21 * m._32) - ((m._22 * m._31))))))) < 0):
            v.x = (v.x * -1)
            v.y = (v.y * -1)
            v.z = (v.z * -1)
        scale = v
        tmp = self
        tmp1 = tmp.r
        a = scale.x
        b = scale.y
        a1 = (a if (python_lib_Math.isnan(a)) else (b if (python_lib_Math.isnan(b)) else max(a,b)))
        b1 = scale.z
        tmp.r = (tmp1 * ((a1 if (python_lib_Math.isnan(a1)) else (b1 if (python_lib_Math.isnan(b1)) else max(a1,b1)))))
        res = f.hasSphere(self)
        self.x = oldX
        self.y = oldY
        self.z = oldZ
        self.r = oldR
        return res

    def inSphere(self,s):
        x = self.x
        y = self.y
        z = self.z
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this_x = x
        _this_y = y
        _this_z = z
        x1 = s.x
        y1 = s.y
        z1 = s.z
        if (z1 is None):
            z1 = 0.
        if (y1 is None):
            y1 = 0.
        if (x1 is None):
            x1 = 0.
        p_x = x1
        p_y = y1
        p_z = z1
        dx = (p_x - _this_x)
        dy = (p_y - _this_y)
        dz = (p_z - _this_z)
        return ((((dx * dx) + ((dy * dy))) + ((dz * dz))) < ((((s.r + self.r)) * ((s.r + self.r)))))

    def toString(self):
        return (((("Sphere{" + Std.string(h3d_col_Point(self.x,self.y,self.z))) + ",") + Std.string(hxd_Math.fmt(self.r))) + "}")

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.x = None
        _hx_o.y = None
        _hx_o.z = None
        _hx_o.r = None
h3d_col_Sphere._hx_class = h3d_col_Sphere
_hx_classes["h3d.col.Sphere"] = h3d_col_Sphere

class h3d_impl_Feature(Enum):
    __slots__ = ()
    _hx_class_name = "h3d.impl.Feature"
    _hx_constructs = ["StandardDerivatives", "FloatTextures", "AllocDepthBuffer", "HardwareAccelerated", "MultipleRenderTargets", "Queries", "SRGBTextures", "ShaderModel3", "BottomLeftCoords", "Wireframe", "InstancedRendering"]
h3d_impl_Feature.StandardDerivatives = h3d_impl_Feature("StandardDerivatives", 0, ())
h3d_impl_Feature.FloatTextures = h3d_impl_Feature("FloatTextures", 1, ())
h3d_impl_Feature.AllocDepthBuffer = h3d_impl_Feature("AllocDepthBuffer", 2, ())
h3d_impl_Feature.HardwareAccelerated = h3d_impl_Feature("HardwareAccelerated", 3, ())
h3d_impl_Feature.MultipleRenderTargets = h3d_impl_Feature("MultipleRenderTargets", 4, ())
h3d_impl_Feature.Queries = h3d_impl_Feature("Queries", 5, ())
h3d_impl_Feature.SRGBTextures = h3d_impl_Feature("SRGBTextures", 6, ())
h3d_impl_Feature.ShaderModel3 = h3d_impl_Feature("ShaderModel3", 7, ())
h3d_impl_Feature.BottomLeftCoords = h3d_impl_Feature("BottomLeftCoords", 8, ())
h3d_impl_Feature.Wireframe = h3d_impl_Feature("Wireframe", 9, ())
h3d_impl_Feature.InstancedRendering = h3d_impl_Feature("InstancedRendering", 10, ())
h3d_impl_Feature._hx_class = h3d_impl_Feature
_hx_classes["h3d.impl.Feature"] = h3d_impl_Feature

class h3d_impl_QueryKind(Enum):
    __slots__ = ()
    _hx_class_name = "h3d.impl.QueryKind"
    _hx_constructs = ["TimeStamp", "Samples"]
h3d_impl_QueryKind.TimeStamp = h3d_impl_QueryKind("TimeStamp", 0, ())
h3d_impl_QueryKind.Samples = h3d_impl_QueryKind("Samples", 1, ())
h3d_impl_QueryKind._hx_class = h3d_impl_QueryKind
_hx_classes["h3d.impl.QueryKind"] = h3d_impl_QueryKind

class h3d_impl_RenderFlag(Enum):
    __slots__ = ()
    _hx_class_name = "h3d.impl.RenderFlag"
    _hx_constructs = ["CameraHandness"]
h3d_impl_RenderFlag.CameraHandness = h3d_impl_RenderFlag("CameraHandness", 0, ())
h3d_impl_RenderFlag._hx_class = h3d_impl_RenderFlag
_hx_classes["h3d.impl.RenderFlag"] = h3d_impl_RenderFlag


class h3d_impl_InputNames:
    _hx_class_name = "h3d.impl.InputNames"
    _hx_is_interface = "False"
    __slots__ = ("id", "names")
    _hx_fields = ["id", "names"]
    _hx_statics = ["UID", "CACHE", "get"]

    def __init__(self,names):
        def _hx_local_2():
            _hx_local_0 = h3d_impl_InputNames
            _hx_local_1 = _hx_local_0.UID
            _hx_local_0.UID = (_hx_local_1 + 1)
            return _hx_local_1
        self.id = _hx_local_2()
        self.names = names

    @staticmethod
    def get(names):
        key = "|".join([python_Boot.toString1(x1,'') for x1 in names])
        i = h3d_impl_InputNames.CACHE.h.get(key,None)
        if (i is None):
            i = h3d_impl_InputNames(list(names))
            h3d_impl_InputNames.CACHE.h[key] = i
        return i

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.id = None
        _hx_o.names = None
h3d_impl_InputNames._hx_class = h3d_impl_InputNames
_hx_classes["h3d.impl.InputNames"] = h3d_impl_InputNames


class h3d_impl_Driver:
    _hx_class_name = "h3d.impl.Driver"
    _hx_is_interface = "False"
    __slots__ = ("logEnable",)
    _hx_fields = ["logEnable"]
    _hx_methods = ["hasFeature", "setRenderFlag", "isSupportedFormat", "isDisposed", "dispose", "begin", "log", "generateMipMaps", "getNativeShaderCode", "logImpl", "clear", "captureRenderBuffer", "capturePixels", "getDriverName", "init", "resize", "selectShader", "selectMaterial", "uploadShaderBuffers", "getShaderInputNames", "selectBuffer", "selectMultiBuffers", "draw", "drawInstanced", "setRenderZone", "setRenderTarget", "setRenderTargets", "allocDepthBuffer", "disposeDepthBuffer", "getDefaultDepthBuffer", "present", "end", "setDebug", "allocTexture", "allocIndexes", "allocVertexes", "allocInstanceBuffer", "disposeTexture", "disposeIndexes", "disposeVertexes", "disposeInstanceBuffer", "uploadIndexBuffer", "uploadIndexBytes", "uploadVertexBuffer", "uploadVertexBytes", "uploadTextureBitmap", "uploadTexturePixels", "readVertexBytes", "readIndexBytes", "copyTexture", "allocQuery", "deleteQuery", "beginQuery", "endQuery", "queryResultAvailable", "queryResult"]

    def hasFeature(self,f):
        return False

    def setRenderFlag(self,r,value):
        pass

    def isSupportedFormat(self,fmt):
        return False

    def isDisposed(self):
        return True

    def dispose(self):
        pass

    def begin(self,frame):
        pass

    def log(self,_hx_str):
        pass

    def generateMipMaps(self,texture):
        raise _HxException("Mipmaps auto generation is not supported on this platform")

    def getNativeShaderCode(self,shader):
        return None

    def logImpl(self,_hx_str):
        pass

    def clear(self,color = None,depth = None,stencil = None):
        pass

    def captureRenderBuffer(self,pixels):
        pass

    def capturePixels(self,tex,layer,mipLevel,region = None):
        raise _HxException("Can't capture pixels on this platform")

    def getDriverName(self,details):
        return "Not available"

    def init(self,onCreate,forceSoftware = None):
        if (forceSoftware is None):
            forceSoftware = False

    def resize(self,width,height):
        pass

    def selectShader(self,shader):
        return False

    def selectMaterial(self,_hx_pass):
        pass

    def uploadShaderBuffers(self,buffers,which):
        pass

    def getShaderInputNames(self):
        return None

    def selectBuffer(self,buffer):
        pass

    def selectMultiBuffers(self,buffers):
        pass

    def draw(self,ibuf,startIndex,ntriangles):
        pass

    def drawInstanced(self,ibuf,commands):
        pass

    def setRenderZone(self,x,y,width,height):
        pass

    def setRenderTarget(self,tex,layer = None,mipLevel = None):
        if (layer is None):
            layer = 0
        if (mipLevel is None):
            mipLevel = 0

    def setRenderTargets(self,textures):
        pass

    def allocDepthBuffer(self,b):
        return None

    def disposeDepthBuffer(self,b):
        pass

    def getDefaultDepthBuffer(self):
        return None

    def present(self):
        pass

    def end(self):
        pass

    def setDebug(self,b):
        pass

    def allocTexture(self,t):
        return None

    def allocIndexes(self,count,is32):
        return None

    def allocVertexes(self,m):
        return None

    def allocInstanceBuffer(self,b,_hx_bytes):
        pass

    def disposeTexture(self,t):
        pass

    def disposeIndexes(self,i):
        pass

    def disposeVertexes(self,v):
        pass

    def disposeInstanceBuffer(self,b):
        pass

    def uploadIndexBuffer(self,i,startIndice,indiceCount,buf,bufPos):
        pass

    def uploadIndexBytes(self,i,startIndice,indiceCount,buf,bufPos):
        pass

    def uploadVertexBuffer(self,v,startVertex,vertexCount,buf,bufPos):
        pass

    def uploadVertexBytes(self,v,startVertex,vertexCount,buf,bufPos):
        pass

    def uploadTextureBitmap(self,t,bmp,mipLevel,side):
        pass

    def uploadTexturePixels(self,t,pixels,mipLevel,side):
        pass

    def readVertexBytes(self,v,startVertex,vertexCount,buf,bufPos):
        raise _HxException("Driver does not allow to read vertex bytes")

    def readIndexBytes(self,v,startVertex,vertexCount,buf,bufPos):
        raise _HxException("Driver does not allow to read index bytes")

    def copyTexture(self,_hx_from,to):
        return False

    def allocQuery(self,queryKind):
        return None

    def deleteQuery(self,q):
        pass

    def beginQuery(self,q):
        pass

    def endQuery(self,q):
        pass

    def queryResultAvailable(self,q):
        return True

    def queryResult(self,q):
        return 0.

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.logEnable = None
h3d_impl_Driver._hx_class = h3d_impl_Driver
_hx_classes["h3d.impl.Driver"] = h3d_impl_Driver


class h3d_impl_InstanceBuffer:
    _hx_class_name = "h3d.impl.InstanceBuffer"
    _hx_is_interface = "False"
    __slots__ = ("data", "driver", "indexCount", "triCount", "commandCount")
    _hx_fields = ["data", "driver", "indexCount", "triCount", "commandCount"]
    _hx_methods = ["setCommand", "setBuffer", "dispose"]

    def __init__(self):
        self.commandCount = None
        self.driver = None
        self.data = None
        self.triCount = 0
        self.indexCount = 0

    def setCommand(self,commandCount,indexCount):
        self.commandCount = commandCount
        self.indexCount = indexCount
        tmp = None
        try:
            tmp = int(((commandCount * indexCount) / 3))
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            tmp = None
        self.triCount = tmp

    def setBuffer(self,commandCount,_hx_bytes):
        self.dispose()
        _g = 0
        _g1 = commandCount
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            pos = (i * 20)
            v = (((_hx_bytes.b[pos] | ((_hx_bytes.b[(pos + 1)] << 8))) | ((_hx_bytes.b[(pos + 2)] << 16))) | ((_hx_bytes.b[(pos + 3)] << 24)))
            idxCount = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
            pos1 = ((i * 20) + 4)
            v1 = (((_hx_bytes.b[pos1] | ((_hx_bytes.b[(pos1 + 1)] << 8))) | ((_hx_bytes.b[(pos1 + 2)] << 16))) | ((_hx_bytes.b[(pos1 + 3)] << 24)))
            instCount = ((v1 | -2147483648) if ((((v1 & -2147483648)) != 0)) else v1)
            tri = None
            try:
                tri = int(((idxCount * instCount) / 3))
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                tri = None
            tri1 = tri
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.triCount
            _hx_local_0.triCount = (_hx_local_1 + tri1)
            _hx_local_0.triCount
        self.commandCount = commandCount
        self.indexCount = 0
        self.driver = h3d_Engine.CURRENT.driver
        self.driver.allocInstanceBuffer(self,_hx_bytes)

    def dispose(self):
        if (self.data is not None):
            self.driver.disposeInstanceBuffer(self)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.data = None
        _hx_o.driver = None
        _hx_o.indexCount = None
        _hx_o.triCount = None
        _hx_o.commandCount = None
h3d_impl_InstanceBuffer._hx_class = h3d_impl_InstanceBuffer
_hx_classes["h3d.impl.InstanceBuffer"] = h3d_impl_InstanceBuffer


class h3d_impl_LogDriver(h3d_impl_Driver):
    _hx_class_name = "h3d.impl.LogDriver"
    _hx_is_interface = "False"
    __slots__ = ("d", "loggedShaders", "currentShader", "logLines")
    _hx_fields = ["d", "loggedShaders", "currentShader", "logLines"]
    _hx_methods = ["logImpl", "hasFeature", "isSupportedFormat", "isDisposed", "dispose", "begin", "clear", "captureRenderBuffer", "getDriverName", "init", "resize", "selectShader", "getNativeShaderCode", "selectMaterial", "sizeOf", "uploadShaderBuffers", "textureInfos", "getShaderInputNames", "selectBuffer", "selectMultiBuffers", "draw", "setRenderZone", "setRenderTarget", "setRenderTargets", "end", "present", "setDebug", "allocTexture", "allocIndexes", "allocVertexes", "disposeTexture", "disposeIndexes", "disposeVertexes", "uploadIndexBuffer", "uploadIndexBytes", "uploadVertexBuffer", "uploadVertexBytes", "uploadTextureBitmap", "uploadTexturePixels"]
    _hx_statics = ["debug"]
    _hx_interfaces = []
    _hx_super = h3d_impl_Driver


    def __init__(self,driver):
        self.currentShader = None
        self.logLines = None
        self.loggedShaders = haxe_ds_IntMap()
        self.d = driver
        self.logEnable = True
        driver.logEnable = True

    def logImpl(self,_hx_str):
        if (self.logLines is None):
            self.d.logImpl(_hx_str)
        else:
            _this = self.logLines
            _this.append(_hx_str)

    def hasFeature(self,f):
        return self.d.hasFeature(f)

    def isSupportedFormat(self,fmt):
        return self.d.isSupportedFormat(fmt)

    def isDisposed(self):
        return self.d.isDisposed()

    def dispose(self):
        self.d.dispose()

    def begin(self,frame):
        self.d.begin(frame)

    def clear(self,color = None,depth = None,stencil = None):
        _hx_str = ((((("Clear color=" + Std.string(color)) + " depth=") + Std.string(depth)) + " stencil=") + Std.string(stencil))
        self.d.clear(color,depth,stencil)

    def captureRenderBuffer(self,pixels):
        self.d.captureRenderBuffer(pixels)

    def getDriverName(self,details):
        return self.d.getDriverName(details)

    def init(self,onCreate,forceSoftware = None):
        if (forceSoftware is None):
            forceSoftware = False
        _gthis = self
        def _hx_local_0(b):
            _hx_str = ("OnCreate " + Std.string(b))
            onCreate(b)
        self.d.init(_hx_local_0,forceSoftware)

    def resize(self,width,height):
        self.d.resize(width,height)

    def selectShader(self,shader):
        self.currentShader = shader
        ret = self.d.selectShader(shader)
        if (not self.loggedShaders.h.get(shader.id,None)):
            def _hx_local_8(shader1):
                _hx_str = hxsl_Printer.shaderToString(shader1.data)
                def _hx_local_2(r):
                    name = None
                    cid = (Std.parseInt(r.matchObj.group(4)) << 2)
                    swiz = r.matchObj.group(5)
                    if (swiz is not None):
                        d = (HxString.charCodeAt(swiz,1) - 120)
                        cid = (cid + d)
                        _g = []
                        _g1 = 1
                        _g2 = len(swiz)
                        while (_g1 < _g2):
                            i = _g1
                            _g1 = (_g1 + 1)
                            code = (HxString.charCodeAt(swiz,i) - d)
                            x = "".join(map(chr,[code]))
                            _g.append(x)
                        swiz = ("." + HxOverrides.stringOrNull("".join([python_Boot.toString1(x1,'') for x1 in _g])))
                    g = shader1.globals
                    while (g is not None):
                        str1 = None
                        if ((g.path == "__consts__") and ((cid >= g.pos))):
                            _g3 = g.type
                            str2 = None
                            if (_g3.index == 15):
                                _g21 = _g3.params[1]
                                if (_g3.params[0].index == 3):
                                    if (_g21.index == 0):
                                        n = _g21.params[0]
                                        str2 = n
                                    else:
                                        str2 = 0
                                else:
                                    str2 = 0
                            else:
                                str2 = 0
                            str1 = (cid < ((g.pos + str2)))
                        else:
                            str1 = False
                        if (str1 and ((swiz == ".x"))):
                            swiz = None
                            name = ("" + Std.string(python_internal_ArrayImpl._get(shader1.consts, (cid - g.pos))))
                            break
                        if (g.pos == cid):
                            name = g.path
                            break
                        g = g.next
                    if (name is None):
                        return r.matchObj.group(0)
                    if (swiz is not None):
                        name = (("null" if name is None else name) + ("null" if swiz is None else swiz))
                    return name
                _hx_str = EReg("((fragment)|(vertex))Globals\\[([0-9]+)\\](.[xyz]+)?","g").map(_hx_str,_hx_local_2)
                def _hx_local_5(r1):
                    name1 = None
                    cid1 = (Std.parseInt(r1.matchObj.group(4)) << 2)
                    swiz1 = r1.matchObj.group(5)
                    if (swiz1 is not None):
                        d1 = (HxString.charCodeAt(swiz1,1) - 120)
                        cid1 = (cid1 + d1)
                        _g4 = []
                        _g11 = 1
                        _g22 = len(swiz1)
                        while (_g11 < _g22):
                            i1 = _g11
                            _g11 = (_g11 + 1)
                            code1 = (HxString.charCodeAt(swiz1,i1) - d1)
                            x1 = "".join(map(chr,[code1]))
                            _g4.append(x1)
                        swiz1 = ("." + HxOverrides.stringOrNull("".join([python_Boot.toString1(x1,'') for x1 in _g4])))
                    p = shader1.params
                    while (p is not None):
                        if (p.pos == cid1):
                            name1 = p.name
                            break
                        p = p.next
                    if (name1 is None):
                        return r1.matchObj.group(0)
                    if (swiz1 is not None):
                        name1 = (("null" if name1 is None else name1) + ("null" if swiz1 is None else swiz1))
                    return name1
                _hx_str = EReg("((fragment)|(vertex))Params\\[([0-9]+)\\](.[xyz]+)?","g").map(_hx_str,_hx_local_5)
                def _hx_local_6(r2):
                    name2 = None
                    cid2 = Std.parseInt(r2.matchObj.group(4))
                    t = shader1.textures
                    while (t is not None):
                        if ((t.pos == cid2) and ((t.type == hxsl_Type.TSampler2D))):
                            return t.name
                        t = t.next
                    return r2.matchObj.group(0)
                _hx_str = EReg("((fragment)|(vertex))Textures\\[([0-9]+)\\]","g").map(_hx_str,_hx_local_6)
                def _hx_local_7(r3):
                    name3 = None
                    cid3 = Std.parseInt(r3.matchObj.group(4))
                    t1 = shader1.textures
                    while (t1 is not None):
                        if ((t1.pos == cid3) and ((t1.type == hxsl_Type.TSamplerCube))):
                            return t1.name
                        t1 = t1.next
                    return r3.matchObj.group(0)
                _hx_str = EReg("((fragment)|(vertex))TexturesCube\\[([0-9]+)\\]","g").map(_hx_str,_hx_local_7)
                return _hx_str
            fmt = _hx_local_8
            str3 = ((HxOverrides.stringOrNull(fmt(shader.vertex)) + "\n") + HxOverrides.stringOrNull(fmt(shader.fragment)))
            _this = str3.split("\n")
            str4 = ("\t" + HxOverrides.stringOrNull("\n\t".join([python_Boot.toString1(x1,'') for x1 in _this])))
            str5 = self.getNativeShaderCode(shader)
            if (str5 is not None):
                _this1 = str5.split("\n")
                str6 = ("\t" + HxOverrides.stringOrNull("\n\t".join([python_Boot.toString1(x1,'') for x1 in _this1])))
            self.loggedShaders.set(shader.id,True)
        return ret

    def getNativeShaderCode(self,shader):
        return self.d.getNativeShaderCode(shader)

    def selectMaterial(self,_hx_pass):
        _hx_str = (((((((((("Select Material Cull=" + Std.string(_hx_pass.culling)) + " depth=") + Std.string(_hx_pass.depthTest)) + HxOverrides.stringOrNull((("" if (_hx_pass.depthWrite) else " nowrite")))) + " blend=") + Std.string(_hx_pass.blendSrc)) + ",") + Std.string(_hx_pass.blendDst)) + " color=") + Std.string(_hx_pass.colorMask))
        self.d.selectMaterial(_hx_pass)

    def sizeOf(self,t):
        tmp = t.index
        if (tmp == 0):
            return 0
        elif ((tmp == 3) or ((tmp == 1))):
            return 1
        elif (tmp == 5):
            _g1 = t.params[1]
            n = t.params[0]
            return n
        elif (tmp == 6):
            return 9
        elif (tmp == 7):
            return 16
        elif (tmp == 8):
            return 12
        elif (tmp == 15):
            _g3 = t.params[1]
            if (_g3.index == 0):
                t1 = t.params[0]
                n1 = _g3.params[0]
                return (self.sizeOf(t1) * n1)
            else:
                raise _HxException(("assert " + Std.string(t)))
        else:
            raise _HxException(("assert " + Std.string(t)))

    def uploadShaderBuffers(self,buffers,which):
        _gthis = self
        which1 = which
        if (which1 == 0):
            s = self.currentShader.vertex
            buf = buffers.vertex
            if (s.globalsSize != 0):
                g = s.globals
                while (g is not None):
                    _hx_str = (((("\t@" + Std.string(g.pos)) + " ") + HxOverrides.stringOrNull(g.path)) + "=")
                    _g = []
                    _g1 = 0
                    _g2 = _gthis.sizeOf(g.type)
                    while (_g1 < _g2):
                        i = _g1
                        _g1 = (_g1 + 1)
                        x = hxd_Math.fmt(buf.globals[(g.pos + i)])
                        _g.append(x)
                    str1 = (("null" if _hx_str is None else _hx_str) + Std.string(_g))
                    g = g.next
            s1 = self.currentShader.fragment
            buf1 = buffers.fragment
            if (s1.globalsSize != 0):
                g1 = s1.globals
                while (g1 is not None):
                    str2 = (((("\t@" + Std.string(g1.pos)) + " ") + HxOverrides.stringOrNull(g1.path)) + "=")
                    _g3 = []
                    _g11 = 0
                    _g21 = _gthis.sizeOf(g1.type)
                    while (_g11 < _g21):
                        i1 = _g11
                        _g11 = (_g11 + 1)
                        x1 = hxd_Math.fmt(buf1.globals[(g1.pos + i1)])
                        _g3.append(x1)
                    str3 = (("null" if str2 is None else str2) + Std.string(_g3))
                    g1 = g1.next
        elif (which1 == 1):
            s2 = self.currentShader.vertex
            buf2 = buffers.vertex
            if (s2.paramsSize != 0):
                p = s2.params
                while (p is not None):
                    pos = p.pos
                    str4 = (((("\t@" + Std.string(pos)) + " ") + HxOverrides.stringOrNull(p.name)) + "=")
                    _g4 = []
                    _g12 = 0
                    _g22 = _gthis.sizeOf(p.type)
                    while (_g12 < _g22):
                        i2 = _g12
                        _g12 = (_g12 + 1)
                        x2 = hxd_Math.fmt(buf2.params[(p.pos + i2)])
                        _g4.append(x2)
                    str5 = (("null" if str4 is None else str4) + Std.string(_g4))
                    p = p.next
            s3 = self.currentShader.fragment
            buf3 = buffers.fragment
            if (s3.paramsSize != 0):
                p1 = s3.params
                while (p1 is not None):
                    pos1 = p1.pos
                    str6 = (((("\t@" + Std.string(pos1)) + " ") + HxOverrides.stringOrNull(p1.name)) + "=")
                    _g5 = []
                    _g13 = 0
                    _g23 = _gthis.sizeOf(p1.type)
                    while (_g13 < _g23):
                        i3 = _g13
                        _g13 = (_g13 + 1)
                        x3 = hxd_Math.fmt(buf3.params[(p1.pos + i3)])
                        _g5.append(x3)
                    str7 = (("null" if str6 is None else str6) + Std.string(_g5))
                    p1 = p1.next
        elif (which1 == 2):
            s4 = self.currentShader.vertex
            buf4 = buffers.vertex
            t = s4.textures
            while (t is not None):
                str8 = ((((((("Set " + HxOverrides.stringOrNull((("Vertex" if (s4.vertex) else "Fragment")))) + " Texture@") + Std.string(t.pos)) + " ") + HxOverrides.stringOrNull(t.name)) + "=") + HxOverrides.stringOrNull(_gthis.textureInfos(buf4.tex,t.pos)))
                t = t.next
            s5 = self.currentShader.fragment
            buf5 = buffers.fragment
            t1 = s5.textures
            while (t1 is not None):
                str9 = ((((((("Set " + HxOverrides.stringOrNull((("Vertex" if (s5.vertex) else "Fragment")))) + " Texture@") + Std.string(t1.pos)) + " ") + HxOverrides.stringOrNull(t1.name)) + "=") + HxOverrides.stringOrNull(_gthis.textureInfos(buf5.tex,t1.pos)))
                t1 = t1.next
        elif (which1 == 3):
            pass
        else:
            pass
        self.d.uploadShaderBuffers(buffers,which)

    def textureInfos(self,buf,tid):
        if ((tid < 0) or ((tid >= len(buf)))):
            return "OUT OF BOUNDS"
        t = buf[tid]
        if (t is None):
            return "NULL"
        inf = ("" + Std.string(t))
        if (t.wrap != h3d_mat_Wrap.Clamp):
            inf = (("null" if inf is None else inf) + ((" wrap=" + Std.string(t.wrap))))
        if (t.mipMap != h3d_mat_MipMap._hx_None):
            inf = (("null" if inf is None else inf) + ((" mip=" + Std.string(t.mipMap))))
        return inf

    def getShaderInputNames(self):
        return self.d.getShaderInputNames()

    def selectBuffer(self,buffer):
        self.d.selectBuffer(buffer)

    def selectMultiBuffers(self,buffers):
        self.d.selectMultiBuffers(buffers)

    def draw(self,ibuf,startIndex,ntriangles):
        self.d.draw(ibuf,startIndex,ntriangles)

    def setRenderZone(self,x,y,width,height):
        self.d.setRenderZone(x,y,width,height)

    def setRenderTarget(self,tex,face = None,mipMap = None):
        if (face is None):
            face = 0
        if (mipMap is None):
            mipMap = 0
        _hx_str = ((((("SetRenderTarget " + Std.string(tex)) + " ") + Std.string(face)) + " ") + Std.string(mipMap))
        self.d.setRenderTarget(tex,face)

    def setRenderTargets(self,textures):
        _hx_str = ("SetRenderTargets " + Std.string(textures))
        self.d.setRenderTargets(textures)

    def end(self):
        self.d.end()

    def present(self):
        self.d.present()

    def setDebug(self,b):
        _hx_str = ("SetDebug " + Std.string(b))
        self.d.setDebug(b)

    def allocTexture(self,t):
        _hx_str = ("AllocTexture " + Std.string(t))
        return self.d.allocTexture(t)

    def allocIndexes(self,count,is32):
        _hx_str = ((("AllocIndexes " + Std.string(count)) + " ") + Std.string(is32))
        return self.d.allocIndexes(count,is32)

    def allocVertexes(self,m):
        return self.d.allocVertexes(m)

    def disposeTexture(self,t):
        self.d.disposeTexture(t)

    def disposeIndexes(self,i):
        self.d.disposeIndexes(i)

    def disposeVertexes(self,v):
        self.d.disposeVertexes(v)

    def uploadIndexBuffer(self,i,startIndice,indiceCount,buf,bufPos):
        self.d.uploadIndexBuffer(i,startIndice,indiceCount,buf,bufPos)

    def uploadIndexBytes(self,i,startIndice,indiceCount,buf,bufPos):
        self.d.uploadIndexBytes(i,startIndice,indiceCount,buf,bufPos)

    def uploadVertexBuffer(self,v,startVertex,vertexCount,buf,bufPos):
        self.d.uploadVertexBuffer(v,startVertex,vertexCount,buf,bufPos)

    def uploadVertexBytes(self,v,startVertex,vertexCount,buf,bufPos):
        self.d.uploadVertexBytes(v,startVertex,vertexCount,buf,bufPos)

    def uploadTextureBitmap(self,t,bmp,mipLevel,side):
        _hx_str = ((((("UploadTextureBitmap " + Std.string(t)) + " mip=") + Std.string(mipLevel)) + " side=") + Std.string(side))
        self.d.uploadTextureBitmap(t,bmp,mipLevel,side)

    def uploadTexturePixels(self,t,pixels,mipLevel,side):
        _hx_str = ((((("UploadTexturePixels " + Std.string(t)) + " mip=") + Std.string(mipLevel)) + " side=") + Std.string(side))
        self.d.uploadTexturePixels(t,pixels,mipLevel,side)

    @staticmethod
    def debug(f):
        raise _HxException("Requires -debug")

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.d = None
        _hx_o.loggedShaders = None
        _hx_o.currentShader = None
        _hx_o.logLines = None
h3d_impl_LogDriver._hx_class = h3d_impl_LogDriver
_hx_classes["h3d.impl.LogDriver"] = h3d_impl_LogDriver


class h3d_impl__ManagedBuffer_FreeCell:
    _hx_class_name = "h3d.impl._ManagedBuffer.FreeCell"
    _hx_is_interface = "False"
    __slots__ = ("pos", "count", "next")
    _hx_fields = ["pos", "count", "next"]

    def __init__(self,pos,count,next):
        self.pos = pos
        self.count = count
        self.next = next

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.pos = None
        _hx_o.count = None
        _hx_o.next = None
h3d_impl__ManagedBuffer_FreeCell._hx_class = h3d_impl__ManagedBuffer_FreeCell
_hx_classes["h3d.impl._ManagedBuffer.FreeCell"] = h3d_impl__ManagedBuffer_FreeCell


class h3d_impl_ManagedBuffer:
    _hx_class_name = "h3d.impl.ManagedBuffer"
    _hx_is_interface = "False"
    __slots__ = ("mem", "stride", "size", "flags", "vbuf", "freeList", "next")
    _hx_fields = ["mem", "stride", "size", "flags", "vbuf", "freeList", "next"]
    _hx_methods = ["uploadVertexBuffer", "uploadVertexBytes", "readVertexBytes", "alloc", "getFreeVertices", "allocPosition", "allocBuffer", "freeBuffer", "dispose", "isDisposed"]

    def __init__(self,stride,size,flags = None):
        self.next = None
        self.vbuf = None
        this1 = 0
        self.flags = this1
        if (flags is not None):
            _g = 0
            while (_g < len(flags)):
                f = (flags[_g] if _g >= 0 and _g < len(flags) else None)
                _g = (_g + 1)
                _hx_local_1 = self
                _hx_local_2 = _hx_local_1.flags
                _hx_local_1.flags = (_hx_local_2 | ((1 << f.index)))
                _hx_local_1.flags
        self.size = size
        self.stride = stride
        self.freeList = h3d_impl__ManagedBuffer_FreeCell(0,size,None)
        self.mem = h3d_Engine.CURRENT.mem
        self.mem.allocManaged(self)

    def uploadVertexBuffer(self,start,vertices,buf,bufPos = None):
        if (bufPos is None):
            bufPos = 0
        self.mem.driver.uploadVertexBuffer(self.vbuf,start,vertices,buf,bufPos)

    def uploadVertexBytes(self,start,vertices,data,dataPos = None):
        if (dataPos is None):
            dataPos = 0
        self.mem.driver.uploadVertexBytes(self.vbuf,start,vertices,data,dataPos)

    def readVertexBytes(self,start,vertices,data,dataPos = None):
        if (dataPos is None):
            dataPos = 0
        self.mem.driver.readVertexBytes(self.vbuf,start,vertices,data,dataPos)

    def alloc(self,vertices,align):
        p = self.allocPosition(vertices,align)
        if (p < 0):
            return None
        b = h3d_Buffer(vertices,self.stride,[h3d_BufferFlag.NoAlloc])
        b.position = p
        b.buffer = self
        return b

    def getFreeVertices(self):
        m = 0
        l = self.freeList
        while (l is not None):
            m = (m + l.count)
            l = l.next
        return m

    def allocPosition(self,nvert,align):
        free = self.freeList
        while (free is not None):
            if (free.count >= nvert):
                d = HxOverrides.mod(((align - (HxOverrides.mod(free.pos, align)))), align)
                if (d == 0):
                    break
                if (free.count >= ((nvert + d))):
                    free.next = h3d_impl__ManagedBuffer_FreeCell((free.pos + d),(free.count - d),free.next)
                    free.count = d
                    free = free.next
                    break
            free = free.next
        if (free is None):
            return -1
        pos = free.pos
        free.pos = (free.pos + nvert)
        free.count = (free.count - nvert)
        return pos

    def allocBuffer(self,b):
        align = (4 if ((((b.flags & ((1 << h3d_BufferFlag.Quads.index)))) != 0)) else (3 if ((((b.flags & ((1 << h3d_BufferFlag.Triangles.index)))) != 0)) else 1))
        p = self.allocPosition(b.vertices,align)
        if (p < 0):
            return False
        b.position = p
        b.buffer = self
        return True

    def freeBuffer(self,b):
        prev = None
        f = self.freeList
        nvert = b.vertices
        end = (b.position + nvert)
        while (f is not None):
            if (f.pos == end):
                f.pos = (f.pos - nvert)
                f.count = (f.count + nvert)
                if ((prev is not None) and (((prev.pos + prev.count) == f.pos))):
                    prev.count = (prev.count + f.count)
                    prev.next = f.next
                nvert = 0
                break
            if (f.pos > end):
                if ((prev is not None) and (((prev.pos + prev.count) == b.position))):
                    prev.count = (prev.count + nvert)
                else:
                    n = h3d_impl__ManagedBuffer_FreeCell(b.position,nvert,f)
                    if (prev is None):
                        self.freeList = n
                    else:
                        prev.next = n
                nvert = 0
                break
            prev = f
            f = f.next
        if (nvert != 0):
            raise _HxException("assert")
        if ((self.freeList.count == self.size) and ((((self.flags & ((1 << h3d_BufferFlag.Managed.index)))) == 0))):
            self.dispose()

    def dispose(self):
        self.mem.freeManaged(self)

    def isDisposed(self):
        return (self.vbuf is None)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.mem = None
        _hx_o.stride = None
        _hx_o.size = None
        _hx_o.flags = None
        _hx_o.vbuf = None
        _hx_o.freeList = None
        _hx_o.next = None
h3d_impl_ManagedBuffer._hx_class = h3d_impl_ManagedBuffer
_hx_classes["h3d.impl.ManagedBuffer"] = h3d_impl_ManagedBuffer


class python_Boot:
    _hx_class_name = "python.Boot"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["keywords", "toString1", "fields", "simpleField", "hasField", "field", "getInstanceFields", "getSuperClass", "getClassFields", "prefixLength", "unhandleKeywords"]

    @staticmethod
    def toString1(o,s):
        if (o is None):
            return "null"
        if isinstance(o,str):
            return o
        if (s is None):
            s = ""
        if (len(s) >= 5):
            return "<...>"
        if isinstance(o,bool):
            if o:
                return "true"
            else:
                return "false"
        if (isinstance(o,int) and (not isinstance(o,bool))):
            return str(o)
        if isinstance(o,float):
            try:
                if (o == int(o)):
                    return str(Math.floor((o + 0.5)))
                else:
                    return str(o)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                return str(o)
        if isinstance(o,list):
            o1 = o
            l = len(o1)
            st = "["
            s = (("null" if s is None else s) + "\t")
            _g = 0
            _g1 = l
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                prefix = ""
                if (i > 0):
                    prefix = ","
                st = (("null" if st is None else st) + HxOverrides.stringOrNull(((("null" if prefix is None else prefix) + HxOverrides.stringOrNull(python_Boot.toString1((o1[i] if i >= 0 and i < len(o1) else None),s))))))
            st = (("null" if st is None else st) + "]")
            return st
        try:
            if hasattr(o,"toString"):
                return o.toString()
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            pass
        if hasattr(o,"__class__"):
            if isinstance(o,_hx_AnonObject):
                toStr = None
                try:
                    fields = python_Boot.fields(o)
                    _g2 = []
                    _g11 = 0
                    while (_g11 < len(fields)):
                        f = (fields[_g11] if _g11 >= 0 and _g11 < len(fields) else None)
                        _g11 = (_g11 + 1)
                        x = ((("" + ("null" if f is None else f)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),(("null" if s is None else s) + "\t"))))
                        _g2.append(x)
                    fieldsStr = _g2
                    toStr = (("{ " + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr]))) + " }")
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e2 = _hx_e1
                    return "{ ... }"
                if (toStr is None):
                    return "{ ... }"
                else:
                    return toStr
            if isinstance(o,Enum):
                o2 = o
                l1 = len(o2.params)
                hasParams = (l1 > 0)
                if hasParams:
                    paramsStr = ""
                    _g3 = 0
                    _g12 = l1
                    while (_g3 < _g12):
                        i1 = _g3
                        _g3 = (_g3 + 1)
                        prefix1 = ""
                        if (i1 > 0):
                            prefix1 = ","
                        paramsStr = (("null" if paramsStr is None else paramsStr) + HxOverrides.stringOrNull(((("null" if prefix1 is None else prefix1) + HxOverrides.stringOrNull(python_Boot.toString1(o2.params[i1],s))))))
                    return (((HxOverrides.stringOrNull(o2.tag) + "(") + ("null" if paramsStr is None else paramsStr)) + ")")
                else:
                    return o2.tag
            if hasattr(o,"_hx_class_name"):
                if (o.__class__.__name__ != "type"):
                    fields1 = python_Boot.getInstanceFields(o)
                    _g4 = []
                    _g13 = 0
                    while (_g13 < len(fields1)):
                        f1 = (fields1[_g13] if _g13 >= 0 and _g13 < len(fields1) else None)
                        _g13 = (_g13 + 1)
                        x1 = ((("" + ("null" if f1 is None else f1)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f1),(("null" if s is None else s) + "\t"))))
                        _g4.append(x1)
                    fieldsStr1 = _g4
                    toStr1 = (((HxOverrides.stringOrNull(o._hx_class_name) + "( ") + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr1]))) + " )")
                    return toStr1
                else:
                    fields2 = python_Boot.getClassFields(o)
                    _g5 = []
                    _g14 = 0
                    while (_g14 < len(fields2)):
                        f2 = (fields2[_g14] if _g14 >= 0 and _g14 < len(fields2) else None)
                        _g14 = (_g14 + 1)
                        x2 = ((("" + ("null" if f2 is None else f2)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f2),(("null" if s is None else s) + "\t"))))
                        _g5.append(x2)
                    fieldsStr2 = _g5
                    toStr2 = (((("#" + HxOverrides.stringOrNull(o._hx_class_name)) + "( ") + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr2]))) + " )")
                    return toStr2
            if (o == str):
                return "#String"
            if (o == list):
                return "#Array"
            if callable(o):
                return "function"
            try:
                if hasattr(o,"__repr__"):
                    return o.__repr__()
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                pass
            if hasattr(o,"__str__"):
                return o.__str__([])
            if hasattr(o,"__name__"):
                return o.__name__
            return "???"
        else:
            return str(o)

    @staticmethod
    def fields(o):
        a = []
        if (o is not None):
            if hasattr(o,"_hx_fields"):
                fields = o._hx_fields
                if (fields is not None):
                    return list(fields)
            if isinstance(o,_hx_AnonObject):
                d = o.__dict__
                keys = d.keys()
                handler = python_Boot.unhandleKeywords
                for k in keys:
                    if (k != '_hx_disable_getattr'):
                        a.append(handler(k))
            elif hasattr(o,"__dict__"):
                d1 = o.__dict__
                keys1 = d1.keys()
                for k in keys1:
                    a.append(k)
        return a

    @staticmethod
    def simpleField(o,field):
        if (field is None):
            return None
        field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
        if hasattr(o,field1):
            return getattr(o,field1)
        else:
            return None

    @staticmethod
    def hasField(o,field):
        if isinstance(o,_hx_AnonObject):
            return o._hx_hasattr(field)
        return hasattr(o,(("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field)))

    @staticmethod
    def field(o,field):
        if (field is None):
            return None
        if isinstance(o,str):
            field1 = field
            _hx_local_0 = len(field1)
            if (_hx_local_0 == 10):
                if (field1 == "charCodeAt"):
                    return python_internal_MethodClosure(o,HxString.charCodeAt)
                else:
                    field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field2) if (hasattr(o,field2)) else None)
            elif (_hx_local_0 == 11):
                if (field1 == "lastIndexOf"):
                    return python_internal_MethodClosure(o,HxString.lastIndexOf)
                elif (field1 == "toLowerCase"):
                    return python_internal_MethodClosure(o,HxString.toLowerCase)
                elif (field1 == "toUpperCase"):
                    return python_internal_MethodClosure(o,HxString.toUpperCase)
                else:
                    field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field2) if (hasattr(o,field2)) else None)
            elif (_hx_local_0 == 9):
                if (field1 == "substring"):
                    return python_internal_MethodClosure(o,HxString.substring)
                else:
                    field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field2) if (hasattr(o,field2)) else None)
            elif (_hx_local_0 == 5):
                if (field1 == "split"):
                    return python_internal_MethodClosure(o,HxString.split)
                else:
                    field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field2) if (hasattr(o,field2)) else None)
            elif (_hx_local_0 == 7):
                if (field1 == "indexOf"):
                    return python_internal_MethodClosure(o,HxString.indexOf)
                else:
                    field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field2) if (hasattr(o,field2)) else None)
            elif (_hx_local_0 == 8):
                if (field1 == "toString"):
                    return python_internal_MethodClosure(o,HxString.toString)
                else:
                    field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field2) if (hasattr(o,field2)) else None)
            elif (_hx_local_0 == 6):
                if (field1 == "charAt"):
                    return python_internal_MethodClosure(o,HxString.charAt)
                elif (field1 == "length"):
                    return len(o)
                elif (field1 == "substr"):
                    return python_internal_MethodClosure(o,HxString.substr)
                else:
                    field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field2) if (hasattr(o,field2)) else None)
            else:
                field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                return (getattr(o,field2) if (hasattr(o,field2)) else None)
        elif isinstance(o,list):
            field3 = field
            _hx_local_1 = len(field3)
            if (_hx_local_1 == 11):
                if (field3 == "lastIndexOf"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.lastIndexOf)
                else:
                    field4 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field4) if (hasattr(o,field4)) else None)
            elif (_hx_local_1 == 4):
                if (field3 == "copy"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.copy)
                elif (field3 == "join"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.join)
                elif (field3 == "push"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.push)
                elif (field3 == "sort"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.sort)
                else:
                    field4 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field4) if (hasattr(o,field4)) else None)
            elif (_hx_local_1 == 5):
                if (field3 == "shift"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.shift)
                elif (field3 == "slice"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.slice)
                else:
                    field4 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field4) if (hasattr(o,field4)) else None)
            elif (_hx_local_1 == 7):
                if (field3 == "indexOf"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.indexOf)
                elif (field3 == "reverse"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.reverse)
                elif (field3 == "unshift"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.unshift)
                else:
                    field4 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field4) if (hasattr(o,field4)) else None)
            elif (_hx_local_1 == 3):
                if (field3 == "map"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.map)
                elif (field3 == "pop"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.pop)
                else:
                    field4 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field4) if (hasattr(o,field4)) else None)
            elif (_hx_local_1 == 8):
                if (field3 == "iterator"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.iterator)
                elif (field3 == "toString"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.toString)
                else:
                    field4 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field4) if (hasattr(o,field4)) else None)
            elif (_hx_local_1 == 6):
                if (field3 == "concat"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.concat)
                elif (field3 == "filter"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.filter)
                elif (field3 == "insert"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.insert)
                elif (field3 == "length"):
                    return len(o)
                elif (field3 == "remove"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.remove)
                elif (field3 == "splice"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.splice)
                else:
                    field4 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field4) if (hasattr(o,field4)) else None)
            else:
                field4 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                return (getattr(o,field4) if (hasattr(o,field4)) else None)
        else:
            field5 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
            return (getattr(o,field5) if (hasattr(o,field5)) else None)

    @staticmethod
    def getInstanceFields(c):
        f = (list(c._hx_fields) if (hasattr(c,"_hx_fields")) else [])
        if hasattr(c,"_hx_methods"):
            f = (f + c._hx_methods)
        sc = python_Boot.getSuperClass(c)
        if (sc is None):
            return f
        else:
            scArr = python_Boot.getInstanceFields(sc)
            scMap = set(scArr)
            _g = 0
            while (_g < len(f)):
                f1 = (f[_g] if _g >= 0 and _g < len(f) else None)
                _g = (_g + 1)
                if (not (f1 in scMap)):
                    scArr.append(f1)
            return scArr

    @staticmethod
    def getSuperClass(c):
        if (c is None):
            return None
        try:
            if hasattr(c,"_hx_super"):
                return c._hx_super
            return None
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            pass
        return None

    @staticmethod
    def getClassFields(c):
        if hasattr(c,"_hx_statics"):
            x = c._hx_statics
            return list(x)
        else:
            return []

    @staticmethod
    def unhandleKeywords(name):
        if (HxString.substr(name,0,python_Boot.prefixLength) == "_hx_"):
            real = HxString.substr(name,python_Boot.prefixLength,None)
            if (real in python_Boot.keywords):
                return real
        return name
python_Boot._hx_class = python_Boot
_hx_classes["python.Boot"] = python_Boot


class HxString:
    _hx_class_name = "HxString"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["split", "charCodeAt", "charAt", "lastIndexOf", "toUpperCase", "toLowerCase", "indexOf", "toString", "substring", "substr"]

    @staticmethod
    def split(s,d):
        if (d == ""):
            return list(s)
        else:
            return s.split(d)

    @staticmethod
    def charCodeAt(s,index):
        if ((((s is None) or ((len(s) == 0))) or ((index < 0))) or ((index >= len(s)))):
            return None
        else:
            return ord(s[index])

    @staticmethod
    def charAt(s,index):
        if ((index < 0) or ((index >= len(s)))):
            return ""
        else:
            return s[index]

    @staticmethod
    def lastIndexOf(s,_hx_str,startIndex = None):
        if (startIndex is None):
            return s.rfind(_hx_str, 0, len(s))
        else:
            i = s.rfind(_hx_str, 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len(_hx_str))) if ((i == -1)) else (i + 1))
            check = s.find(_hx_str, startLeft, len(s))
            if ((check > i) and ((check <= startIndex))):
                return check
            else:
                return i

    @staticmethod
    def toUpperCase(s):
        return s.upper()

    @staticmethod
    def toLowerCase(s):
        return s.lower()

    @staticmethod
    def indexOf(s,_hx_str,startIndex = None):
        if (startIndex is None):
            return s.find(_hx_str)
        else:
            return s.find(_hx_str, startIndex)

    @staticmethod
    def toString(s):
        return s

    @staticmethod
    def substring(s,startIndex,endIndex = None):
        if (startIndex < 0):
            startIndex = 0
        if (endIndex is None):
            return s[startIndex:]
        else:
            if (endIndex < 0):
                endIndex = 0
            if (endIndex < startIndex):
                return s[endIndex:startIndex]
            else:
                return s[startIndex:endIndex]

    @staticmethod
    def substr(s,startIndex,_hx_len = None):
        if (_hx_len is None):
            return s[startIndex:]
        else:
            if (_hx_len == 0):
                return ""
            if (startIndex < 0):
                startIndex = (len(s) + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            return s[startIndex:(startIndex + _hx_len)]
HxString._hx_class = HxString
_hx_classes["HxString"] = HxString


class python_internal_MethodClosure:
    _hx_class_name = "python.internal.MethodClosure"
    _hx_is_interface = "False"
    __slots__ = ("obj", "func")
    _hx_fields = ["obj", "func"]
    _hx_methods = ["__call__"]

    def __init__(self,obj,func):
        self.obj = obj
        self.func = func

    def __call__(self,*args):
        return self.func(self.obj,*args)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.obj = None
        _hx_o.func = None
python_internal_MethodClosure._hx_class = python_internal_MethodClosure
_hx_classes["python.internal.MethodClosure"] = python_internal_MethodClosure


class python_internal_ArrayImpl:
    _hx_class_name = "python.internal.ArrayImpl"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["concat", "copy", "iterator", "indexOf", "lastIndexOf", "join", "toString", "pop", "push", "unshift", "remove", "shift", "slice", "sort", "splice", "map", "filter", "insert", "reverse", "_get", "_set"]

    @staticmethod
    def concat(a1,a2):
        return (a1 + a2)

    @staticmethod
    def copy(x):
        return list(x)

    @staticmethod
    def iterator(x):
        return python_HaxeIterator(x.__iter__())

    @staticmethod
    def indexOf(a,x,fromIndex = None):
        _hx_len = len(a)
        l = (0 if ((fromIndex is None)) else ((_hx_len + fromIndex) if ((fromIndex < 0)) else fromIndex))
        if (l < 0):
            l = 0
        _g = l
        _g1 = _hx_len
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if HxOverrides.eq(a[i],x):
                return i
        return -1

    @staticmethod
    def lastIndexOf(a,x,fromIndex = None):
        _hx_len = len(a)
        l = (_hx_len if ((fromIndex is None)) else (((_hx_len + fromIndex) + 1) if ((fromIndex < 0)) else (fromIndex + 1)))
        if (l > _hx_len):
            l = _hx_len
        while True:
            l = (l - 1)
            tmp = l
            if (not ((tmp > -1))):
                break
            if HxOverrides.eq(a[l],x):
                return l
        return -1

    @staticmethod
    def join(x,sep):
        return sep.join([python_Boot.toString1(x1,'') for x1 in x])

    @staticmethod
    def toString(x):
        return (("[" + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in x]))) + "]")

    @staticmethod
    def pop(x):
        if (len(x) == 0):
            return None
        else:
            return x.pop()

    @staticmethod
    def push(x,e):
        x.append(e)
        return len(x)

    @staticmethod
    def unshift(x,e):
        x.insert(0, e)

    @staticmethod
    def remove(x,e):
        try:
            x.remove(e)
            return True
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e1 = _hx_e1
            return False

    @staticmethod
    def shift(x):
        if (len(x) == 0):
            return None
        return x.pop(0)

    @staticmethod
    def slice(x,pos,end = None):
        return x[pos:end]

    @staticmethod
    def sort(x,f):
        x.sort(key= python_lib_Functools.cmp_to_key(f))

    @staticmethod
    def splice(x,pos,_hx_len):
        if (pos < 0):
            pos = (len(x) + pos)
        if (pos < 0):
            pos = 0
        res = x[pos:(pos + _hx_len)]
        del x[pos:(pos + _hx_len)]
        return res

    @staticmethod
    def map(x,f):
        return list(map(f,x))

    @staticmethod
    def filter(x,f):
        return list(filter(f,x))

    @staticmethod
    def insert(a,pos,x):
        a.insert(pos, x)

    @staticmethod
    def reverse(a):
        a.reverse()

    @staticmethod
    def _get(x,idx):
        if ((idx > -1) and ((idx < len(x)))):
            return x[idx]
        else:
            return None

    @staticmethod
    def _set(x,idx,v):
        l = len(x)
        while (l < idx):
            x.append(None)
            l = (l + 1)
        if (l == idx):
            x.append(v)
        else:
            x[idx] = v
        return v
python_internal_ArrayImpl._hx_class = python_internal_ArrayImpl
_hx_classes["python.internal.ArrayImpl"] = python_internal_ArrayImpl


class h3d_impl_MemoryManager:
    _hx_class_name = "h3d.impl.MemoryManager"
    _hx_is_interface = "False"
    _hx_fields = ["driver", "buffers", "indexes", "textures", "depths", "triIndexes", "quadIndexes", "usedMemory", "texMemory", "bufferCount"]
    _hx_methods = ["init", "initIndexes", "garbage", "cleanManagedBuffers", "allocManaged", "freeManaged", "allocBuffer", "deleteIndexes", "allocIndexes", "bpp", "cleanTextures", "sortByLRU", "deleteTexture", "allocTexture", "allocDepth", "deleteDepth", "onContextLost", "dispose", "freeMemorySize", "stats", "allocStats"]
    _hx_statics = ["MAX_MEMORY", "MAX_BUFFERS", "SIZE", "ALL_FLAGS"]

    def __init__(self,driver):
        self.quadIndexes = None
        self.triIndexes = None
        self.depths = None
        self.textures = None
        self.indexes = None
        self.buffers = None
        self.bufferCount = 0
        self.texMemory = 0
        self.usedMemory = 0
        self.driver = driver

    def init(self):
        self.indexes = list()
        self.textures = list()
        self.buffers = list()
        self.depths = list()
        self.initIndexes()

    def initIndexes(self):
        this1 = list()
        indices = this1
        _g = 0
        while (_g < 65533):
            i = _g
            _g = (_g + 1)
            indices.append(i)
        self.triIndexes = h3d_Indexes.alloc(indices)
        this2 = list()
        indices1 = this2
        p = 0
        _g1 = 0
        _g2 = 16383
        while (_g1 < _g2):
            i1 = _g1
            _g1 = (_g1 + 1)
            k = (i1 << 2)
            indices1.append(k)
            indices1.append((k + 1))
            indices1.append((k + 2))
            indices1.append((k + 2))
            indices1.append((k + 1))
            indices1.append((k + 3))
        indices1.append(65533)
        self.quadIndexes = h3d_Indexes.alloc(indices1)

    def garbage(self):
        pass

    def cleanManagedBuffers(self):
        _g = 1
        _g1 = len(self.buffers)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            b = (self.buffers[i] if i >= 0 and i < len(self.buffers) else None)
            prev = None
            while (b is not None):
                if (b.freeList.count == b.size):
                    b.dispose()
                    if (prev is None):
                        python_internal_ArrayImpl._set(self.buffers, i, b.next)
                    else:
                        prev.next = b.next
                else:
                    prev = b
                b = b.next

    def allocManaged(self,m):
        if (m.vbuf is not None):
            return
        mem = ((m.size * m.stride) * 4)
        if (mem == 0):
            return
        def _hx_local_0():
            m.vbuf = self.driver.allocVertexes(m)
            return m.vbuf
        while ((((self.usedMemory + mem) > 4294967296.) or ((self.bufferCount >= 65536))) or (((_hx_local_0()) is None))):
            if self.driver.isDisposed():
                return
            size = (self.usedMemory - self.freeMemorySize())
            self.garbage()
            self.cleanManagedBuffers()
            if ((self.usedMemory - self.freeMemorySize()) == size):
                if (self.bufferCount >= 65536):
                    raise _HxException("Too many buffers")
                v = (size / 1024)
                raise _HxException((((("Memory full (" + Std.string(((v if (((v == Math.POSITIVE_INFINITY) or ((v == Math.NEGATIVE_INFINITY)))) else (Math.NaN if (python_lib_Math.isnan(v)) else Math.ceil(v)))))) + " KB,") + Std.string(self.bufferCount)) + " buffers)"))
        _hx_local_1 = self
        _hx_local_2 = _hx_local_1.usedMemory
        _hx_local_1.usedMemory = (_hx_local_2 + mem)
        _hx_local_1.usedMemory
        _hx_local_3 = self
        _hx_local_4 = _hx_local_3.bufferCount
        _hx_local_3.bufferCount = (_hx_local_4 + 1)
        _hx_local_4

    def freeManaged(self,m):
        if (m.vbuf is None):
            return
        self.driver.disposeVertexes(m.vbuf)
        m.vbuf = None
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.usedMemory
        _hx_local_0.usedMemory = (_hx_local_1 - (((m.size * m.stride) * 4)))
        _hx_local_0.usedMemory
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.bufferCount
        _hx_local_2.bufferCount = (_hx_local_3 - 1)
        _hx_local_3
        if (((m.flags & ((1 << h3d_BufferFlag.Managed.index)))) == 0):
            c = (self.buffers[0] if 0 < len(self.buffers) else None)
            prev = None
            while (c is not None):
                if (c == m):
                    if (prev is None):
                        python_internal_ArrayImpl._set(self.buffers, 0, m.next)
                    else:
                        prev.next = m.next
                    break
                prev = c
                c = c.next

    def allocBuffer(self,b,stride):
        _hx_max = (65532 if ((((b.flags & ((1 << h3d_BufferFlag.Quads.index)))) != 0)) else (65533 if ((((b.flags & ((1 << h3d_BufferFlag.Triangles.index)))) != 0)) else 65534))
        if (b.vertices > _hx_max):
            if (_hx_max == 65534):
                raise _HxException((("Cannot split buffer with " + Std.string(b.vertices)) + " vertices if it's not Quads/Triangles"))
            rem = (b.vertices - _hx_max)
            b.vertices = _hx_max
            self.allocBuffer(b,stride)
            n = b
            while (n.next is not None):
                n = n.next
            flags = []
            _g = 0
            _g1 = h3d_impl_MemoryManager.ALL_FLAGS
            while (_g < len(_g1)):
                f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (((b.flags & ((1 << f.index)))) != 0):
                    flags.append(f)
            n.next = h3d_Buffer(rem,stride,flags)
            return
        if (((b.flags & ((1 << h3d_BufferFlag.Managed.index)))) == 0):
            flags1 = None
            if (((b.flags & ((1 << h3d_BufferFlag.Dynamic.index)))) != 0):
                if (flags1 is None):
                    flags1 = []
                flags1.append(h3d_BufferFlag.Dynamic)
            if (((b.flags & ((1 << h3d_BufferFlag.UniformBuffer.index)))) != 0):
                if (flags1 is None):
                    flags1 = []
                flags1.append(h3d_BufferFlag.UniformBuffer)
            m = h3d_impl_ManagedBuffer(stride,b.vertices,flags1)
            m.next = (self.buffers[0] if 0 < len(self.buffers) else None)
            python_internal_ArrayImpl._set(self.buffers, 0, m)
            if (not m.allocBuffer(b)):
                raise _HxException("assert")
            return
        m1 = (self.buffers[stride] if stride >= 0 and stride < len(self.buffers) else None)
        prev = None
        while (m1 is not None):
            if m1.allocBuffer(b):
                return
            prev = m1
            m1 = m1.next
        align = (3 if ((((b.flags & ((1 << h3d_BufferFlag.Triangles.index)))) != 0)) else (4 if ((((b.flags & ((1 << h3d_BufferFlag.Quads.index)))) != 0)) else 0))
        if ((m1 is None) and ((align > 0))):
            total = b.vertices
            size = total
            while (size > 2048):
                m1 = (self.buffers[stride] if stride >= 0 and stride < len(self.buffers) else None)
                size = (size >> 1)
                size = (size - (HxOverrides.mod(size, align)))
                b.vertices = size
                while (m1 is not None):
                    if m1.allocBuffer(b):
                        flags2 = []
                        _g2 = 0
                        _g11 = h3d_impl_MemoryManager.ALL_FLAGS
                        while (_g2 < len(_g11)):
                            f1 = (_g11[_g2] if _g2 >= 0 and _g2 < len(_g11) else None)
                            _g2 = (_g2 + 1)
                            if (((b.flags & ((1 << f1.index)))) != 0):
                                flags2.append(f1)
                        b.next = h3d_Buffer((total - size),stride,flags2)
                        return
                    m1 = m1.next
            b.vertices = total
        m1 = h3d_impl_ManagedBuffer(stride,65533,[h3d_BufferFlag.Managed])
        if (prev is None):
            python_internal_ArrayImpl._set(self.buffers, stride, m1)
        else:
            prev.next = m1
        if (not m1.allocBuffer(b)):
            raise _HxException("assert")

    def deleteIndexes(self,i):
        python_internal_ArrayImpl.remove(self.indexes,i)
        self.driver.disposeIndexes(i.ibuf)
        i.ibuf = None
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.usedMemory
        _hx_local_0.usedMemory = (_hx_local_1 - ((i.count * ((4 if (i.is32) else 2)))))
        _hx_local_0.usedMemory

    def allocIndexes(self,i):
        i.ibuf = self.driver.allocIndexes(i.count,i.is32)
        _this = self.indexes
        _this.append(i)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.usedMemory
        _hx_local_0.usedMemory = (_hx_local_1 + ((i.count * ((4 if (i.is32) else 2)))))
        _hx_local_0.usedMemory

    def bpp(self,t):
        return 4

    def cleanTextures(self,force = None):
        if (force is None):
            force = True
        self.textures.sort(key= python_lib_Functools.cmp_to_key(self.sortByLRU))
        _g = 0
        _g1 = self.textures
        while (_g < len(_g1)):
            t = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if ((t.realloc is None) or (((t.t is None) and ((t.realloc is None))))):
                continue
            if (force or ((t.get_lastFrame() < ((hxd_Timer.frameCount - 3600))))):
                t.dispose()
                return True
        return False

    def sortByLRU(self,t1,t2):
        return (t1.get_lastFrame() - t2.get_lastFrame())

    def deleteTexture(self,t):
        if (not python_internal_ArrayImpl.remove(self.textures,t)):
            return
        self.driver.disposeTexture(t)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.texMemory
        _hx_local_0.texMemory = (_hx_local_1 - (((t.width * t.height) * self.bpp(t))))
        _hx_local_0.texMemory

    def allocTexture(self,t):
        free = self.cleanTextures(False)
        t.t = self.driver.allocTexture(t)
        if (t.t is None):
            if self.driver.isDisposed():
                return
            if (not self.cleanTextures(True)):
                raise _HxException("Maximum texture memory reached")
            self.allocTexture(t)
            return
        _this = self.textures
        _this.append(t)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.texMemory
        _hx_local_0.texMemory = (_hx_local_1 + (((t.width * t.height) * self.bpp(t))))
        _hx_local_0.texMemory

    def allocDepth(self,b):
        free = self.cleanTextures(False)
        b.b = self.driver.allocDepthBuffer(b)
        if (b.b is None):
            if self.driver.isDisposed():
                return
            if (not self.cleanTextures(True)):
                raise _HxException("Maximum texture memory reached")
            self.allocDepth(b)
            return
        _this = self.depths
        _this.append(b)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.texMemory
        _hx_local_0.texMemory = (_hx_local_1 + (((b.width * b.height) * 4)))
        _hx_local_0.texMemory

    def deleteDepth(self,b):
        if (not python_internal_ArrayImpl.remove(self.depths,b)):
            return
        self.driver.disposeDepthBuffer(b)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.texMemory
        _hx_local_0.texMemory = (_hx_local_1 - (((b.width * b.height) * 4)))
        _hx_local_0.texMemory

    def onContextLost(self):
        self.dispose()
        self.initIndexes()

    def dispose(self):
        if (self.triIndexes is not None):
            self.triIndexes.dispose()
        if (self.quadIndexes is not None):
            self.quadIndexes.dispose()
        self.triIndexes = None
        self.quadIndexes = None
        _g = 0
        _g1 = list(self.textures)
        while (_g < len(_g1)):
            t = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            t.dispose()
        _g2 = 0
        _g3 = list(self.depths)
        while (_g2 < len(_g3)):
            b = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
            _g2 = (_g2 + 1)
            b.dispose()
        _g4 = 0
        _g5 = list(self.buffers)
        while (_g4 < len(_g5)):
            b1 = (_g5[_g4] if _g4 >= 0 and _g4 < len(_g5) else None)
            _g4 = (_g4 + 1)
            b2 = b1
            while (b2 is not None):
                b2.dispose()
                b2 = b2.next
        _g6 = 0
        _g7 = list(self.indexes)
        while (_g6 < len(_g7)):
            i = (_g7[_g6] if _g6 >= 0 and _g6 < len(_g7) else None)
            _g6 = (_g6 + 1)
            i.dispose()
        self.buffers = []
        self.indexes = []
        self.textures = []
        self.bufferCount = 0
        self.usedMemory = 0
        self.texMemory = 0

    def freeMemorySize(self):
        size = 0
        _g = 0
        _g1 = self.buffers
        while (_g < len(_g1)):
            b = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            b1 = b
            while (b1 is not None):
                free = b1.freeList
                while (free is not None):
                    size = (size + (((free.count * b1.stride) * 4)))
                    free = free.next
                b1 = b1.next
        return size

    def stats(self):
        total = 0
        free = 0
        count = 0
        _g = 0
        _g1 = self.buffers
        while (_g < len(_g1)):
            b = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            b1 = b
            while (b1 is not None):
                total = (total + (((b1.stride * b1.size) * 4)))
                f = b1.freeList
                while (f is not None):
                    free = (free + (((f.count * b1.stride) * 4)))
                    f = f.next
                count = (count + 1)
                b1 = b1.next
        return _hx_AnonObject({'bufferCount': self.bufferCount, 'freeManagedMemory': free, 'managedMemory': total, 'totalMemory': (self.usedMemory + self.texMemory), 'textureCount': len(self.textures), 'textureMemory': self.texMemory})

    def allocStats(self):
        return []

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.driver = None
        _hx_o.buffers = None
        _hx_o.indexes = None
        _hx_o.textures = None
        _hx_o.depths = None
        _hx_o.triIndexes = None
        _hx_o.quadIndexes = None
        _hx_o.usedMemory = None
        _hx_o.texMemory = None
        _hx_o.bufferCount = None
h3d_impl_MemoryManager._hx_class = h3d_impl_MemoryManager
_hx_classes["h3d.impl.MemoryManager"] = h3d_impl_MemoryManager


class h3d_impl_NullDriver(h3d_impl_Driver):
    _hx_class_name = "h3d.impl.NullDriver"
    _hx_is_interface = "False"
    __slots__ = ("cur",)
    _hx_fields = ["cur"]
    _hx_methods = ["hasFeature", "isSupportedFormat", "logImpl", "isDisposed", "getDriverName", "init", "selectShader", "getShaderInputNames", "allocTexture", "allocIndexes", "allocVertexes"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_impl_Driver


    def __init__(self):
        self.cur = None

    def hasFeature(self,f):
        return True

    def isSupportedFormat(self,fmt):
        return True

    def logImpl(self,_hx_str):
        str1 = Std.string(_hx_str)
        python_Lib.printString((("" + ("null" if str1 is None else str1)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))

    def isDisposed(self):
        return False

    def getDriverName(self,details):
        return "NullDriver"

    def init(self,onCreate,forceSoftware = None):
        if (forceSoftware is None):
            forceSoftware = False
        onCreate(False)

    def selectShader(self,shader):
        if (self.cur == shader):
            return False
        self.cur = shader
        return True

    def getShaderInputNames(self):
        names = []
        _g = 0
        _g1 = self.cur.vertex.data.vars
        while (_g < len(_g1)):
            v = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (v.kind == hxsl_VarKind.Input):
                x = v.name
                names.append(x)
        return h3d_impl_InputNames.get(names)

    def allocTexture(self,t):
        return _hx_AnonObject({})

    def allocIndexes(self,count,is32):
        return _hx_AnonObject({})

    def allocVertexes(self,m):
        return _hx_AnonObject({})

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.cur = None
h3d_impl_NullDriver._hx_class = h3d_impl_NullDriver
_hx_classes["h3d.impl.NullDriver"] = h3d_impl_NullDriver

class h3d_impl_Step(Enum):
    __slots__ = ()
    _hx_class_name = "h3d.impl.Step"
    _hx_constructs = ["BeforeLighting", "BeforeTonemappingFX", "BeforeTonemapping", "AfterTonemapping", "AfterUI"]
h3d_impl_Step.BeforeLighting = h3d_impl_Step("BeforeLighting", 0, ())
h3d_impl_Step.BeforeTonemappingFX = h3d_impl_Step("BeforeTonemappingFX", 1, ())
h3d_impl_Step.BeforeTonemapping = h3d_impl_Step("BeforeTonemapping", 2, ())
h3d_impl_Step.AfterTonemapping = h3d_impl_Step("AfterTonemapping", 3, ())
h3d_impl_Step.AfterUI = h3d_impl_Step("AfterUI", 4, ())
h3d_impl_Step._hx_class = h3d_impl_Step
_hx_classes["h3d.impl.Step"] = h3d_impl_Step


class h3d_impl_RendererFX:
    _hx_class_name = "h3d.impl.RendererFX"
    _hx_is_interface = "True"
    __slots__ = ("enabled",)
    _hx_fields = ["enabled"]
    _hx_methods = ["apply", "dispose"]
h3d_impl_RendererFX._hx_class = h3d_impl_RendererFX
_hx_classes["h3d.impl.RendererFX"] = h3d_impl_RendererFX


class h3d_impl_TextureCache:
    _hx_class_name = "h3d.impl.TextureCache"
    _hx_is_interface = "False"
    __slots__ = ("cache", "position", "defaultDepthBuffer", "ctx", "defaultFormat")
    _hx_fields = ["cache", "position", "defaultDepthBuffer", "ctx", "defaultFormat"]
    _hx_methods = ["get", "getNamed", "set", "begin", "lookupTarget", "allocTarget", "allocTargetScale", "allocTileTarget", "dispose"]

    def __init__(self,ctx):
        self.position = 0
        self.ctx = ctx
        self.cache = []
        engine = h3d_Engine.CURRENT
        self.defaultFormat = h3d_mat_Texture.nativeFormat
        self.defaultDepthBuffer = h3d_mat_DepthBuffer.getDefault()

    def get(self,index = None):
        if (index is None):
            index = 0
        return (self.cache[index] if index >= 0 and index < len(self.cache) else None)

    def getNamed(self,name):
        _g = 0
        _g1 = self.position
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if ((self.cache[i] if i >= 0 and i < len(self.cache) else None).name == name):
                return (self.cache[i] if i >= 0 and i < len(self.cache) else None)
        return None

    def set(self,t,index):
        python_internal_ArrayImpl._set(self.cache, index, t)

    def begin(self):
        while (len(self.cache) > self.position):
            _this = self.cache
            t = (None if ((len(_this) == 0)) else _this.pop())
            if (t is not None):
                t.dispose()
        self.position = 0

    def lookupTarget(self,name,width,height,format,isCube):
        t = python_internal_ArrayImpl._get(self.cache, self.position)
        _g = (self.position + 1)
        _g1 = len(self.cache)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            t2 = (self.cache[i] if i >= 0 and i < len(self.cache) else None)
            if ((((((t2 is not None) and (not (((t2.t is None) and ((t2.realloc is None)))))) and ((t2.width == width))) and ((t2.height == height))) and ((t2.format == format))) and ((isCube == ((((t2.flags & ((1 << h3d_mat_TextureFlags.Cube.index)))) != 0))))):
                python_internal_ArrayImpl._set(self.cache, self.position, t2)
                python_internal_ArrayImpl._set(self.cache, i, t)
                return t2
        if ((t is not None) and ((t.name == name))):
            t.dispose()
            t = None
        flags = [h3d_mat_TextureFlags.Target]
        if isCube:
            flags.append(h3d_mat_TextureFlags.Cube)
        newt = h3d_mat_Texture(width,height,flags,format)
        if (t is not None):
            pos = self.position
            self.cache.insert(pos, newt)
        else:
            python_internal_ArrayImpl._set(self.cache, self.position, newt)
        return newt

    def allocTarget(self,name,width,height,defaultDepth = None,format = None,isCube = None):
        if (defaultDepth is None):
            defaultDepth = True
        if (isCube is None):
            isCube = False
        t = python_internal_ArrayImpl._get(self.cache, self.position)
        if (format is None):
            format = self.defaultFormat
        if ((((((t is None) or (((t.t is None) and ((t.realloc is None))))) or ((t.width != width))) or ((t.height != height))) or ((t.format != format))) or ((isCube != ((((t.flags & ((1 << h3d_mat_TextureFlags.Cube.index)))) != 0))))):
            t = self.lookupTarget(name,width,height,format,isCube)
        t.depthBuffer = (self.defaultDepthBuffer if defaultDepth else None)
        t.setName(name)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.position
        _hx_local_0.position = (_hx_local_1 + 1)
        _hx_local_1
        return t

    def allocTargetScale(self,name,scale,defaultDepth = None,format = None):
        if (defaultDepth is None):
            defaultDepth = True
        e = h3d_Engine.CURRENT
        return self.allocTarget(name,Math.ceil((e.width * scale)),Math.ceil((e.height * scale)),defaultDepth,format)

    def allocTileTarget(self,name,tile,defaultDepth = None,format = None):
        if (defaultDepth is None):
            defaultDepth = False
        return self.allocTarget(name,(Math.ceil((tile.width + tile.x)) - Math.floor(tile.x)),(Math.ceil((tile.height + tile.y)) - Math.floor(tile.y)),defaultDepth,format)

    def dispose(self):
        _g = 0
        _g1 = self.cache
        while (_g < len(_g1)):
            t = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            t.dispose()
        self.cache = []

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.cache = None
        _hx_o.position = None
        _hx_o.defaultDepthBuffer = None
        _hx_o.ctx = None
        _hx_o.defaultFormat = None
h3d_impl_TextureCache._hx_class = h3d_impl_TextureCache
_hx_classes["h3d.impl.TextureCache"] = h3d_impl_TextureCache


class hxd_impl_AnyProps:
    _hx_class_name = "hxd.impl.AnyProps"
    _hx_is_interface = "False"
    __slots__ = ("props",)
    _hx_fields = ["props"]
    _hx_methods = ["set_props", "setDefaultProps", "getDefaultProps", "refreshProps"]

    def set_props(self,p):
        self.props = p
        self.refreshProps()
        return p

    def setDefaultProps(self,kind):
        self.set_props(self.getDefaultProps(kind))

    def getDefaultProps(self,kind = None):
        return _hx_AnonObject({})

    def refreshProps(self):
        pass

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.props = None
hxd_impl_AnyProps._hx_class = hxd_impl_AnyProps
_hx_classes["hxd.impl.AnyProps"] = hxd_impl_AnyProps


class h3d_mat_BaseMaterial(hxd_impl_AnyProps):
    _hx_class_name = "h3d.mat.BaseMaterial"
    _hx_is_interface = "False"
    __slots__ = ("passes", "name")
    _hx_fields = ["passes", "name"]
    _hx_methods = ["addPass", "removePass", "get_mainPass", "getPasses", "getPass", "allocPass", "clone"]
    _hx_statics = []
    _hx_interfaces = [hxd_impl__Serializable_NoSerializeSupport]
    _hx_super = hxd_impl_AnyProps


    def __init__(self,shader = None):
        self.name = None
        self.passes = None
        if (shader is not None):
            self.addPass(h3d_mat_Pass("default",None)).addShader(shader)

    def addPass(self,p):
        prev = None
        cur = self.passes
        while (cur is not None):
            prev = cur
            cur = cur.nextPass
        if (prev is None):
            self.passes = p
        else:
            prev.nextPass = p
        p.nextPass = None
        return p

    def removePass(self,p):
        prev = None
        cur = self.passes
        while (cur is not None):
            if (cur == p):
                if (prev is None):
                    self.passes = p.nextPass
                else:
                    prev.nextPass = p.nextPass
                p.nextPass = None
                return True
            prev = cur
            cur = cur.nextPass
        return False

    def get_mainPass(self):
        return self.passes

    def getPasses(self):
        p = self.passes
        out = []
        while (p is not None):
            out.append(p)
            p = p.nextPass
        return out

    def getPass(self,name):
        p = self.passes
        while (p is not None):
            if (p.name == name):
                return p
            p = p.nextPass
        return None

    def allocPass(self,name,inheritMain = None):
        if (inheritMain is None):
            inheritMain = True
        p = self.getPass(name)
        if (p is not None):
            return p
        p1 = h3d_mat_Pass(name,None,(self.passes if inheritMain else None))
        self.addPass(p1)
        return p1

    def clone(self,m = None):
        if (m is None):
            m = h3d_mat_BaseMaterial()
        m.passes.load(self.passes)
        m.name = self.name
        m.set_props(self.props)
        return m

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.passes = None
        _hx_o.name = None
h3d_mat_BaseMaterial._hx_class = h3d_mat_BaseMaterial
_hx_classes["h3d.mat.BaseMaterial"] = h3d_mat_BaseMaterial

class h3d_mat_Face(Enum):
    __slots__ = ()
    _hx_class_name = "h3d.mat.Face"
    _hx_constructs = ["None", "Back", "Front", "Both"]
h3d_mat_Face._hx_None = h3d_mat_Face("None", 0, ())
h3d_mat_Face.Back = h3d_mat_Face("Back", 1, ())
h3d_mat_Face.Front = h3d_mat_Face("Front", 2, ())
h3d_mat_Face.Both = h3d_mat_Face("Both", 3, ())
h3d_mat_Face._hx_class = h3d_mat_Face
_hx_classes["h3d.mat.Face"] = h3d_mat_Face

class h3d_mat_Blend(Enum):
    __slots__ = ()
    _hx_class_name = "h3d.mat.Blend"
    _hx_constructs = ["One", "Zero", "SrcAlpha", "SrcColor", "DstAlpha", "DstColor", "OneMinusSrcAlpha", "OneMinusSrcColor", "OneMinusDstAlpha", "OneMinusDstColor", "ConstantColor", "ConstantAlpha", "OneMinusConstantColor", "OneMinusConstantAlpha", "SrcAlphaSaturate"]
h3d_mat_Blend.One = h3d_mat_Blend("One", 0, ())
h3d_mat_Blend.Zero = h3d_mat_Blend("Zero", 1, ())
h3d_mat_Blend.SrcAlpha = h3d_mat_Blend("SrcAlpha", 2, ())
h3d_mat_Blend.SrcColor = h3d_mat_Blend("SrcColor", 3, ())
h3d_mat_Blend.DstAlpha = h3d_mat_Blend("DstAlpha", 4, ())
h3d_mat_Blend.DstColor = h3d_mat_Blend("DstColor", 5, ())
h3d_mat_Blend.OneMinusSrcAlpha = h3d_mat_Blend("OneMinusSrcAlpha", 6, ())
h3d_mat_Blend.OneMinusSrcColor = h3d_mat_Blend("OneMinusSrcColor", 7, ())
h3d_mat_Blend.OneMinusDstAlpha = h3d_mat_Blend("OneMinusDstAlpha", 8, ())
h3d_mat_Blend.OneMinusDstColor = h3d_mat_Blend("OneMinusDstColor", 9, ())
h3d_mat_Blend.ConstantColor = h3d_mat_Blend("ConstantColor", 10, ())
h3d_mat_Blend.ConstantAlpha = h3d_mat_Blend("ConstantAlpha", 11, ())
h3d_mat_Blend.OneMinusConstantColor = h3d_mat_Blend("OneMinusConstantColor", 12, ())
h3d_mat_Blend.OneMinusConstantAlpha = h3d_mat_Blend("OneMinusConstantAlpha", 13, ())
h3d_mat_Blend.SrcAlphaSaturate = h3d_mat_Blend("SrcAlphaSaturate", 14, ())
h3d_mat_Blend._hx_class = h3d_mat_Blend
_hx_classes["h3d.mat.Blend"] = h3d_mat_Blend

class h3d_mat_Compare(Enum):
    __slots__ = ()
    _hx_class_name = "h3d.mat.Compare"
    _hx_constructs = ["Always", "Never", "Equal", "NotEqual", "Greater", "GreaterEqual", "Less", "LessEqual"]
h3d_mat_Compare.Always = h3d_mat_Compare("Always", 0, ())
h3d_mat_Compare.Never = h3d_mat_Compare("Never", 1, ())
h3d_mat_Compare.Equal = h3d_mat_Compare("Equal", 2, ())
h3d_mat_Compare.NotEqual = h3d_mat_Compare("NotEqual", 3, ())
h3d_mat_Compare.Greater = h3d_mat_Compare("Greater", 4, ())
h3d_mat_Compare.GreaterEqual = h3d_mat_Compare("GreaterEqual", 5, ())
h3d_mat_Compare.Less = h3d_mat_Compare("Less", 6, ())
h3d_mat_Compare.LessEqual = h3d_mat_Compare("LessEqual", 7, ())
h3d_mat_Compare._hx_class = h3d_mat_Compare
_hx_classes["h3d.mat.Compare"] = h3d_mat_Compare

class h3d_mat_StencilOp(Enum):
    __slots__ = ()
    _hx_class_name = "h3d.mat.StencilOp"
    _hx_constructs = ["Keep", "Zero", "Replace", "Increment", "IncrementWrap", "Decrement", "DecrementWrap", "Invert"]
h3d_mat_StencilOp.Keep = h3d_mat_StencilOp("Keep", 0, ())
h3d_mat_StencilOp.Zero = h3d_mat_StencilOp("Zero", 1, ())
h3d_mat_StencilOp.Replace = h3d_mat_StencilOp("Replace", 2, ())
h3d_mat_StencilOp.Increment = h3d_mat_StencilOp("Increment", 3, ())
h3d_mat_StencilOp.IncrementWrap = h3d_mat_StencilOp("IncrementWrap", 4, ())
h3d_mat_StencilOp.Decrement = h3d_mat_StencilOp("Decrement", 5, ())
h3d_mat_StencilOp.DecrementWrap = h3d_mat_StencilOp("DecrementWrap", 6, ())
h3d_mat_StencilOp.Invert = h3d_mat_StencilOp("Invert", 7, ())
h3d_mat_StencilOp._hx_class = h3d_mat_StencilOp
_hx_classes["h3d.mat.StencilOp"] = h3d_mat_StencilOp

class h3d_mat_MipMap(Enum):
    __slots__ = ()
    _hx_class_name = "h3d.mat.MipMap"
    _hx_constructs = ["None", "Nearest", "Linear"]
h3d_mat_MipMap._hx_None = h3d_mat_MipMap("None", 0, ())
h3d_mat_MipMap.Nearest = h3d_mat_MipMap("Nearest", 1, ())
h3d_mat_MipMap.Linear = h3d_mat_MipMap("Linear", 2, ())
h3d_mat_MipMap._hx_class = h3d_mat_MipMap
_hx_classes["h3d.mat.MipMap"] = h3d_mat_MipMap

class h3d_mat_Filter(Enum):
    __slots__ = ()
    _hx_class_name = "h3d.mat.Filter"
    _hx_constructs = ["Nearest", "Linear"]
h3d_mat_Filter.Nearest = h3d_mat_Filter("Nearest", 0, ())
h3d_mat_Filter.Linear = h3d_mat_Filter("Linear", 1, ())
h3d_mat_Filter._hx_class = h3d_mat_Filter
_hx_classes["h3d.mat.Filter"] = h3d_mat_Filter

class h3d_mat_Wrap(Enum):
    __slots__ = ()
    _hx_class_name = "h3d.mat.Wrap"
    _hx_constructs = ["Clamp", "Repeat"]
h3d_mat_Wrap.Clamp = h3d_mat_Wrap("Clamp", 0, ())
h3d_mat_Wrap.Repeat = h3d_mat_Wrap("Repeat", 1, ())
h3d_mat_Wrap._hx_class = h3d_mat_Wrap
_hx_classes["h3d.mat.Wrap"] = h3d_mat_Wrap

class h3d_mat_Operation(Enum):
    __slots__ = ()
    _hx_class_name = "h3d.mat.Operation"
    _hx_constructs = ["Add", "Sub", "ReverseSub", "Min", "Max"]
h3d_mat_Operation.Add = h3d_mat_Operation("Add", 0, ())
h3d_mat_Operation.Sub = h3d_mat_Operation("Sub", 1, ())
h3d_mat_Operation.ReverseSub = h3d_mat_Operation("ReverseSub", 2, ())
h3d_mat_Operation.Min = h3d_mat_Operation("Min", 3, ())
h3d_mat_Operation.Max = h3d_mat_Operation("Max", 4, ())
h3d_mat_Operation._hx_class = h3d_mat_Operation
_hx_classes["h3d.mat.Operation"] = h3d_mat_Operation

class h3d_mat_TextureFlags(Enum):
    __slots__ = ()
    _hx_class_name = "h3d.mat.TextureFlags"
    _hx_constructs = ["Target", "Cube", "MipMapped", "ManualMipMapGen", "IsNPOT", "NoAlloc", "Dynamic", "AlphaPremultiplied", "WasCleared", "Loading", "Serialize", "IsArray"]
h3d_mat_TextureFlags.Target = h3d_mat_TextureFlags("Target", 0, ())
h3d_mat_TextureFlags.Cube = h3d_mat_TextureFlags("Cube", 1, ())
h3d_mat_TextureFlags.MipMapped = h3d_mat_TextureFlags("MipMapped", 2, ())
h3d_mat_TextureFlags.ManualMipMapGen = h3d_mat_TextureFlags("ManualMipMapGen", 3, ())
h3d_mat_TextureFlags.IsNPOT = h3d_mat_TextureFlags("IsNPOT", 4, ())
h3d_mat_TextureFlags.NoAlloc = h3d_mat_TextureFlags("NoAlloc", 5, ())
h3d_mat_TextureFlags.Dynamic = h3d_mat_TextureFlags("Dynamic", 6, ())
h3d_mat_TextureFlags.AlphaPremultiplied = h3d_mat_TextureFlags("AlphaPremultiplied", 7, ())
h3d_mat_TextureFlags.WasCleared = h3d_mat_TextureFlags("WasCleared", 8, ())
h3d_mat_TextureFlags.Loading = h3d_mat_TextureFlags("Loading", 9, ())
h3d_mat_TextureFlags.Serialize = h3d_mat_TextureFlags("Serialize", 10, ())
h3d_mat_TextureFlags.IsArray = h3d_mat_TextureFlags("IsArray", 11, ())
h3d_mat_TextureFlags._hx_class = h3d_mat_TextureFlags
_hx_classes["h3d.mat.TextureFlags"] = h3d_mat_TextureFlags


class h3d_mat_Defaults:
    _hx_class_name = "h3d.mat.Defaults"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["defaultKillAlphaThreshold", "loadingTextureColor", "shadowShader", "get_shadowShader", "set_shadowShader", "makeVolumeDecal"]
    shadowShader = None

    @staticmethod
    def get_shadowShader():
        s = h3d_mat_Defaults.shadowShader
        if (s is None):
            s = h3d_shader_Shadow()
            h3d_mat_Defaults.set_shadowShader(s)
            h3d_mat_Defaults.shadowShader.setPriority(-1)
        return s

    @staticmethod
    def set_shadowShader(s):
        def _hx_local_1():
            def _hx_local_0():
                h3d_mat_Defaults.shadowShader = s
                return h3d_mat_Defaults.shadowShader
            return _hx_local_0()
        return _hx_local_1()

    @staticmethod
    def makeVolumeDecal(bounds):
        return h3d_shader_VolumeDecal((bounds.xMax - bounds.xMin),(bounds.yMax - bounds.yMin))
h3d_mat_Defaults._hx_class = h3d_mat_Defaults
_hx_classes["h3d.mat.Defaults"] = h3d_mat_Defaults

class h3d_mat_DepthFormat(Enum):
    __slots__ = ()
    _hx_class_name = "h3d.mat.DepthFormat"
    _hx_constructs = ["Depth16", "Depth24", "Depth24Stencil8"]
h3d_mat_DepthFormat.Depth16 = h3d_mat_DepthFormat("Depth16", 0, ())
h3d_mat_DepthFormat.Depth24 = h3d_mat_DepthFormat("Depth24", 1, ())
h3d_mat_DepthFormat.Depth24Stencil8 = h3d_mat_DepthFormat("Depth24Stencil8", 2, ())
h3d_mat_DepthFormat._hx_class = h3d_mat_DepthFormat
_hx_classes["h3d.mat.DepthFormat"] = h3d_mat_DepthFormat


class h3d_mat_DepthBuffer:
    _hx_class_name = "h3d.mat.DepthBuffer"
    _hx_is_interface = "False"
    __slots__ = ("b", "width", "height", "format")
    _hx_fields = ["b", "width", "height", "format"]
    _hx_methods = ["hasStencil", "alloc", "dispose", "isDisposed"]
    _hx_statics = ["getDefault"]

    def __init__(self,width,height,format = None):
        self.b = None
        self.width = width
        self.height = height
        self.format = format
        if (width > 0):
            self.alloc()

    def hasStencil(self):
        tmp = self.format.index
        if ((tmp == 1) or ((tmp == 0))):
            return False
        elif (tmp == 2):
            return True
        else:
            pass

    def alloc(self):
        h3d_Engine.CURRENT.mem.allocDepth(self)

    def dispose(self):
        if (self.b is not None):
            h3d_Engine.CURRENT.mem.deleteDepth(self)
            self.b = None

    def isDisposed(self):
        return (self.b is None)

    @staticmethod
    def getDefault():
        return h3d_Engine.CURRENT.driver.getDefaultDepthBuffer()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.b = None
        _hx_o.width = None
        _hx_o.height = None
        _hx_o.format = None
h3d_mat_DepthBuffer._hx_class = h3d_mat_DepthBuffer
_hx_classes["h3d.mat.DepthBuffer"] = h3d_mat_DepthBuffer


class h3d_mat_Material(h3d_mat_BaseMaterial):
    _hx_class_name = "h3d.mat.Material"
    _hx_is_interface = "False"
    __slots__ = ("mshader", "normalShader", "model", "castShadows", "receiveShadows", "staticShadows", "textureShader", "specularShader", "blendMode")
    _hx_fields = ["mshader", "normalShader", "model", "castShadows", "receiveShadows", "staticShadows", "textureShader", "specularShader", "blendMode"]
    _hx_methods = ["get_specularPower", "set_specularPower", "get_specularAmount", "set_specularAmount", "get_color", "set_color", "get_shadows", "set_shadows", "set_castShadows", "set_receiveShadows", "set_staticShadows", "clone", "set_blendMode", "get_specularTexture", "get_texture", "set_texture", "get_normalMap", "set_normalMap", "set_specularTexture", "getDefaultModelProps", "getDefaultProps", "refreshProps"]
    _hx_statics = ["create"]
    _hx_interfaces = []
    _hx_super = h3d_mat_BaseMaterial


    def __init__(self,texture = None):
        self.blendMode = None
        self.specularShader = None
        self.textureShader = None
        self.staticShadows = None
        self.receiveShadows = None
        self.castShadows = None
        self.model = None
        self.normalShader = None
        self.mshader = h3d_shader_BaseMesh()
        self.set_blendMode(h2d_BlendMode._hx_None)
        super().__init__(self.mshader)
        self.set_texture(texture)

    def get_specularPower(self):
        return self.mshader.specularPower__

    def set_specularPower(self,v):
        def _hx_local_1():
            def _hx_local_0():
                self.mshader.specularPower__ = v
                return self.mshader.specularPower__
            return _hx_local_0()
        return _hx_local_1()

    def get_specularAmount(self):
        return self.mshader.specularAmount__

    def set_specularAmount(self,v):
        def _hx_local_1():
            def _hx_local_0():
                self.mshader.specularAmount__ = v
                return self.mshader.specularAmount__
            return _hx_local_0()
        return _hx_local_1()

    def get_color(self):
        return self.mshader.color__

    def set_color(self,v):
        def _hx_local_1():
            def _hx_local_0():
                self.mshader.color__ = v
                return self.mshader.color__
            return _hx_local_0()
        return _hx_local_1()

    def get_shadows(self):
        if self.castShadows:
            return self.receiveShadows
        else:
            return False

    def set_shadows(self,v):
        self.set_castShadows(v)
        self.set_receiveShadows(v)
        return v

    def set_castShadows(self,v):
        if (self.castShadows == v):
            return v
        if (self.passes is not None):
            if v:
                self.addPass(h3d_mat_Pass("shadow",None,self.passes)).set_isStatic(self.staticShadows)
            else:
                self.removePass(self.getPass("shadow"))
        def _hx_local_1():
            def _hx_local_0():
                self.castShadows = v
                return self.castShadows
            return _hx_local_0()
        return _hx_local_1()

    def set_receiveShadows(self,v):
        if (v == self.receiveShadows):
            return v
        if (self.passes is not None):
            shadows = h3d_mat_Defaults.get_shadowShader()
            if v:
                self.passes.addShader(shadows)
            else:
                self.passes.removeShader(shadows)
        def _hx_local_1():
            def _hx_local_0():
                self.receiveShadows = v
                return self.receiveShadows
            return _hx_local_0()
        return _hx_local_1()

    def set_staticShadows(self,v):
        p = self.getPass("shadow")
        if (p is not None):
            p.set_isStatic(v)
        def _hx_local_1():
            def _hx_local_0():
                self.staticShadows = v
                return self.staticShadows
            return _hx_local_0()
        return _hx_local_1()

    def clone(self,m = None):
        m1 = (h3d_mat_Material() if ((m is None)) else m)
        super().clone(m1)
        m1.set_castShadows(self.castShadows)
        m1.set_receiveShadows(self.receiveShadows)
        m1.set_texture(self.get_texture())
        m1.set_specularTexture(self.get_specularTexture())
        m1.set_normalMap(self.get_normalMap())
        if (self.textureShader is not None):
            _this = m1.textureShader
            _this.constModified = True
            _this.additive__ = self.textureShader.additive__
            _this1 = m1.textureShader
            _this1.constModified = True
            _this1.killAlpha__ = self.textureShader.killAlpha__
            m1.textureShader.killAlphaThreshold__ = self.textureShader.killAlphaThreshold__
        m1.mshader.color__ = self.mshader.color__
        m1.set_blendMode(self.blendMode)
        return m1

    def set_blendMode(self,v):
        if (self.passes is not None):
            self.passes.setBlendMode(v)
            tmp = v.index
            if (tmp == 0):
                self.passes.set_depthWrite(True)
                self.passes.setPassName("default")
            elif (tmp == 1):
                self.passes.set_depthWrite(True)
                self.passes.setPassName("alpha")
            elif ((((((((((tmp == 11) or ((tmp == 10))) or ((tmp == 9))) or ((tmp == 8))) or ((tmp == 7))) or ((tmp == 6))) or ((tmp == 5))) or ((tmp == 4))) or ((tmp == 3))) or ((tmp == 2))):
                self.passes.set_depthWrite(False)
                self.passes.setPassName("additive")
            else:
                pass
        def _hx_local_1():
            def _hx_local_0():
                self.blendMode = v
                return self.blendMode
            return _hx_local_0()
        return _hx_local_1()

    def get_specularTexture(self):
        if (self.specularShader is None):
            return None
        else:
            return self.specularShader.texture__

    def get_texture(self):
        if (self.textureShader is None):
            return None
        else:
            return self.textureShader.texture__

    def set_texture(self,t):
        if (t is None):
            if (self.textureShader is not None):
                self.passes.removeShader(self.textureShader)
                self.textureShader = None
        else:
            if (self.textureShader is None):
                self.textureShader = h3d_shader_Texture()
                self.passes.addShader(self.textureShader)
            self.textureShader.texture__ = t
        return t

    def get_normalMap(self):
        if (self.normalShader is None):
            return None
        else:
            return self.normalShader.texture__

    def set_normalMap(self,t):
        if (t is None):
            if (self.normalShader is not None):
                self.passes.removeShader(self.normalShader)
                self.normalShader = None
        else:
            if (self.normalShader is None):
                self.normalShader = h3d_shader_NormalMap()
                if (self.textureShader is not None):
                    self.passes.addShaderAtIndex(self.normalShader,(self.passes.getShaderIndex(self.textureShader) + 1))
                else:
                    self.passes.addShader(self.normalShader)
            self.normalShader.texture__ = t
        return t

    def set_specularTexture(self,t):
        if (t is None):
            if (self.specularShader is not None):
                self.passes.removeShader(self.specularShader)
                self.specularShader = None
        else:
            if (self.specularShader is None):
                self.specularShader = h3d_shader_SpecularTexture()
                self.passes.addShader(self.specularShader)
            self.specularShader.texture__ = t
        return t

    def getDefaultModelProps(self):
        props = self.getDefaultProps()
        tmp = self.blendMode.index
        if (tmp == 0):
            pass
        elif (tmp == 1):
            props.kind = "Alpha"
        elif (tmp == 2):
            props.kind = "Add"
            props.culling = False
            props.shadows = False
            props.light = False
        else:
            raise _HxException(("Unsupported HMD material " + Std.string(self.blendMode)))
        return props

    def getDefaultProps(self,_hx_type = None):
        props = None
        if (_hx_type is None):
            props = _hx_AnonObject({'kind': "Opaque", 'shadows': True, 'culling': True, 'light': True})
        else:
            type1 = _hx_type
            _hx_local_0 = len(type1)
            if (_hx_local_0 == 11):
                if (type1 == "particles3D"):
                    props = _hx_AnonObject({'kind': "Alpha", 'shadows': False, 'culling': False, 'light': True})
                else:
                    props = _hx_AnonObject({'kind': "Opaque", 'shadows': True, 'culling': True, 'light': True})
            elif (_hx_local_0 == 7):
                if (type1 == "trail3D"):
                    props = _hx_AnonObject({'kind': "Alpha", 'shadows': False, 'culling': False, 'light': True})
                else:
                    props = _hx_AnonObject({'kind': "Opaque", 'shadows': True, 'culling': True, 'light': True})
            elif (_hx_local_0 == 2):
                if (type1 == "ui"):
                    props = _hx_AnonObject({'kind': "Alpha", 'shadows': False, 'culling': False, 'light': False})
                else:
                    props = _hx_AnonObject({'kind': "Opaque", 'shadows': True, 'culling': True, 'light': True})
            else:
                props = _hx_AnonObject({'kind': "Opaque", 'shadows': True, 'culling': True, 'light': True})
        return props

    def refreshProps(self):
        if ((self.props is None) or ((self.passes is None))):
            return
        props = self.props
        _g = props.kind
        if (_g == "Add"):
            self.set_blendMode(h2d_BlendMode.Add)
        elif (_g == "Alpha"):
            self.set_blendMode(h2d_BlendMode.Alpha)
        elif (((_g == "Opaque") or ((_g == "Hidden"))) or ((_g == "AlphaKill"))):
            self.set_blendMode(h2d_BlendMode._hx_None)
        elif (_g == "SoftAdd"):
            self.set_blendMode(h2d_BlendMode.SoftAdd)
        else:
            pass
        tshader = self.textureShader
        if (tshader is not None):
            tshader.constModified = True
            tshader.killAlpha__ = (props.kind == "AlphaKill")
            tshader.killAlphaThreshold__ = 0.5
        self.passes.set_culling((h3d_mat_Face.Both if ((props.kind == "Hidden")) else (h3d_mat_Face.Back if (props.culling) else h3d_mat_Face._hx_None)))
        self.passes.set_enableLights(props.light)
        v = props.shadows
        self.set_castShadows(v)
        self.set_receiveShadows(v)
        if (self.castShadows and self.receiveShadows):
            self.getPass("shadow").set_culling(self.passes.culling)

    @staticmethod
    def create(tex = None):
        mat = h3d_mat_MaterialSetup.current.createMaterial()
        mat.set_texture(tex)
        mat.set_props(mat.getDefaultProps())
        return mat

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.mshader = None
        _hx_o.normalShader = None
        _hx_o.model = None
        _hx_o.castShadows = None
        _hx_o.receiveShadows = None
        _hx_o.staticShadows = None
        _hx_o.textureShader = None
        _hx_o.specularShader = None
        _hx_o.blendMode = None
h3d_mat_Material._hx_class = h3d_mat_Material
_hx_classes["h3d.mat.Material"] = h3d_mat_Material


class h3d_mat_MaterialDatabase:
    _hx_class_name = "h3d.mat.MaterialDatabase"
    _hx_is_interface = "False"
    __slots__ = ("db",)
    _hx_fields = ["db"]
    _hx_methods = ["getFilePath", "getModelData", "saveData", "loadMatProps", "saveMatProps"]

    def __init__(self):
        self.db = haxe_ds_StringMap()

    def getFilePath(self,model):
        return (HxOverrides.stringOrNull(model.entry.get_directory()) + "/materials.props")

    def getModelData(self,model):
        if (model is None):
            return None
        this1 = self.db
        key = model.entry.get_directory()
        cached = this1.h.get(key,None)
        if (cached is not None):
            return cached.v
        file = self.getFilePath(model)
        value = None
        try:
            value = python_lib_Json.loads(hxd_res_Loader.currentInstance.load(file).toText(),**python__KwArgs_KwArgs_Impl_.fromT(_hx_AnonObject({'object_hook': python_Lib.dictToAnon})))
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            if isinstance(_hx_e1, hxd_fs_NotFound):
                e = _hx_e1
                value = _hx_AnonObject({})
            else:
                raise _hx_e
        this2 = self.db
        key1 = model.entry.get_directory()
        this2.h[key1] = _hx_AnonObject({'v': value})
        return value

    def saveData(self,model,data):
        file = self.getFilePath(model)
        fs = Std.downcast(hxd_res_Loader.currentInstance.fs,hxd_fs_LocalFileSystem)
        if ((fs is not None) and (not haxe_io_Path.isAbsolute(file))):
            file = (HxOverrides.stringOrNull(fs.baseDir) + ("null" if file is None else file))
        if (data is None):
            try:
                sys_FileSystem.deleteFile(file)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                pass
        else:
            sys_io_File.saveContent(file,haxe_format_JsonPrinter.print(data,None,"\t"))

    def loadMatProps(self,material,setup):
        p = self.getModelData(material.model)
        if (p is None):
            return p
        p = Reflect.field(p,"materials")
        if (p is None):
            return p
        p = Reflect.field(p,setup.name)
        if (p is None):
            return p
        return Reflect.field(p,material.name)

    def saveMatProps(self,material,setup):
        path = ["materials", setup.name, material.name]
        root = self.getModelData(material.model)
        if (root is None):
            return
        realRoot = root
        prevs = []
        _g = 0
        _g1 = (len(path) - 1)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            next = Reflect.field(root,(path[i] if i >= 0 and i < len(path) else None))
            if (next is None):
                next = _hx_AnonObject({})
                field = (path[i] if i >= 0 and i < len(path) else None)
                setattr(root,(("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field)),next)
            prevs.append(root)
            root = next
        name = (None if ((len(path) == 0)) else path.pop())
        Reflect.deleteField(root,name)
        currentProps = material.props
        defaultProps = material.getDefaultProps()
        if ((currentProps is None) or ((Std.string(defaultProps) == Std.string(currentProps)))):
            while (len(path) > 0):
                name1 = (None if ((len(path) == 0)) else path.pop())
                root1 = (None if ((len(prevs) == 0)) else prevs.pop())
                if (len(python_Boot.fields(Reflect.field(root1,name1))) != 0):
                    break
                Reflect.deleteField(root1,name1)
        else:
            setattr(root,(("_hx_" + name) if ((name in python_Boot.keywords)) else (("_hx_" + name) if (((((len(name) > 2) and ((ord(name[0]) == 95))) and ((ord(name[1]) == 95))) and ((ord(name[(len(name) - 1)]) != 95)))) else name)),currentProps)
        file = self.getFilePath(material.model)
        if (len(python_Boot.fields(realRoot)) == 0):
            realRoot = None
        self.saveData(material.model,realRoot)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.db = None
h3d_mat_MaterialDatabase._hx_class = h3d_mat_MaterialDatabase
_hx_classes["h3d.mat.MaterialDatabase"] = h3d_mat_MaterialDatabase


class h3d_mat_MaterialSetup:
    _hx_class_name = "h3d.mat.MaterialSetup"
    _hx_is_interface = "False"
    __slots__ = ("name", "database", "emptyMat")
    _hx_fields = ["name", "database", "emptyMat"]
    _hx_methods = ["createRenderer", "createLightSystem", "createMaterial", "getDefaults", "loadMaterialProps", "saveMaterialProps", "customMeshInit"]
    _hx_statics = ["current"]

    def __init__(self,name):
        self.emptyMat = None
        self.database = None
        self.name = None
        if (self.database is None):
            self.database = h3d_mat_MaterialDatabase()
        self.name = name

    def createRenderer(self):
        return h3d_scene_fwd_Renderer()

    def createLightSystem(self):
        return h3d_scene_fwd_LightSystem()

    def createMaterial(self):
        return h3d_mat_Material()

    def getDefaults(self,kind = None):
        if (self.emptyMat is None):
            self.emptyMat = self.createMaterial()
        return self.emptyMat.getDefaultProps(kind)

    def loadMaterialProps(self,material):
        return self.database.loadMatProps(material,self)

    def saveMaterialProps(self,material):
        self.database.saveMatProps(material,self)

    def customMeshInit(self,mesh):
        pass

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.name = None
        _hx_o.database = None
        _hx_o.emptyMat = None
h3d_mat_MaterialSetup._hx_class = h3d_mat_MaterialSetup
_hx_classes["h3d.mat.MaterialSetup"] = h3d_mat_MaterialSetup


class h3d_mat_Pass:
    _hx_class_name = "h3d.mat.Pass"
    _hx_is_interface = "False"
    __slots__ = ("name", "flags", "passId", "bits", "parentPass", "parentShaders", "shaders", "nextPass", "enableLights", "dynamicParameters", "isStatic", "batchMode", "culling", "depthWrite", "depthTest", "blendSrc", "blendDst", "blendAlphaSrc", "blendAlphaDst", "blendOp", "blendAlphaOp", "wireframe", "colorMask", "layer", "stencil", "reserved")
    _hx_fields = ["name", "flags", "passId", "bits", "parentPass", "parentShaders", "shaders", "nextPass", "enableLights", "dynamicParameters", "isStatic", "batchMode", "culling", "depthWrite", "depthTest", "blendSrc", "blendDst", "blendAlphaSrc", "blendAlphaDst", "blendOp", "blendAlphaOp", "wireframe", "colorMask", "layer", "stencil", "reserved"]
    _hx_methods = ["load", "setPassName", "blend", "setBlendMode", "depth", "setColorMask", "setColorChannel", "addShader", "addShaderAtIndex", "getShaderIndex", "removeShader", "getShader", "getShaderByName", "getShaders", "getShadersRec", "clone", "getDebugShaderCode", "set_enableLights", "set_dynamicParameters", "set_isStatic", "set_batchMode", "set_culling", "set_depthWrite", "set_depthTest", "set_blendSrc", "set_blendDst", "set_blendAlphaSrc", "set_blendAlphaDst", "set_blendOp", "set_blendAlphaOp", "set_wireframe", "set_reserved", "loadFlags", "loadBits"]
    _hx_statics = ["getEnableLights", "enableLights_bits", "enableLights_offset", "enableLights_mask", "getDynamicParameters", "dynamicParameters_bits", "dynamicParameters_offset", "dynamicParameters_mask", "getIsStatic", "isStatic_bits", "isStatic_offset", "isStatic_mask", "getBatchMode", "batchMode_bits", "batchMode_offset", "batchMode_mask", "getCulling", "culling_bits", "culling_offset", "culling_mask", "getDepthWrite", "depthWrite_bits", "depthWrite_offset", "depthWrite_mask", "getDepthTest", "depthTest_bits", "depthTest_offset", "depthTest_mask", "getBlendSrc", "blendSrc_bits", "blendSrc_offset", "blendSrc_mask", "getBlendDst", "blendDst_bits", "blendDst_offset", "blendDst_mask", "getBlendAlphaSrc", "blendAlphaSrc_bits", "blendAlphaSrc_offset", "blendAlphaSrc_mask", "getBlendAlphaDst", "blendAlphaDst_bits", "blendAlphaDst_offset", "blendAlphaDst_mask", "getBlendOp", "blendOp_bits", "blendOp_offset", "blendOp_mask", "getBlendAlphaOp", "blendAlphaOp_bits", "blendAlphaOp_offset", "blendAlphaOp_mask", "getWireframe", "wireframe_bits", "wireframe_offset", "wireframe_mask", "getReserved", "reserved_bits", "reserved_offset", "reserved_mask"]
    _hx_interfaces = [hxd_impl__Serializable_NoSerializeSupport]

    def __init__(self,name,shaders = None,parent = None):
        self.reserved = None
        self.stencil = None
        self.colorMask = None
        self.wireframe = None
        self.blendAlphaOp = None
        self.blendOp = None
        self.blendAlphaDst = None
        self.blendAlphaSrc = None
        self.blendDst = None
        self.blendSrc = None
        self.depthTest = None
        self.depthWrite = None
        self.culling = None
        self.batchMode = None
        self.isStatic = None
        self.dynamicParameters = None
        self.enableLights = None
        self.nextPass = None
        self.parentShaders = None
        self.passId = None
        self.flags = None
        self.name = None
        self.layer = 0
        self.bits = 0
        self.parentPass = parent
        self.shaders = shaders
        self.setPassName(name)
        self.set_culling(h3d_mat_Face.Back)
        src = h3d_mat_Blend.One
        dst = h3d_mat_Blend.Zero
        self.set_blendSrc(src)
        self.set_blendAlphaSrc(src)
        self.set_blendDst(dst)
        self.set_blendAlphaDst(dst)
        self.depth(True,h3d_mat_Compare.Less)
        self.set_blendOp(self.set_blendAlphaOp(h3d_mat_Operation.Add))
        self.colorMask = 15

    def load(self,p):
        self.name = p.name
        self.passId = p.passId
        self.bits = p.bits
        self.set_enableLights(p.enableLights)
        self.set_dynamicParameters(p.dynamicParameters)
        self.set_culling(p.culling)
        self.set_depthWrite(p.depthWrite)
        self.set_depthTest(p.depthTest)
        self.set_blendSrc(p.blendSrc)
        self.set_blendDst(p.blendDst)
        self.set_blendOp(p.blendOp)
        self.set_blendAlphaSrc(p.blendAlphaSrc)
        self.set_blendAlphaDst(p.blendAlphaDst)
        self.set_blendAlphaOp(p.blendAlphaOp)
        self.colorMask = p.colorMask
        if (p.stencil is not None):
            if (self.stencil is None):
                self.stencil = h3d_mat_Stencil()
            self.stencil.load(p.stencil)

    def setPassName(self,name):
        self.name = name
        self.passId = hxsl_Globals.allocID(name)

    def blend(self,src,dst):
        self.set_blendSrc(src)
        self.set_blendAlphaSrc(src)
        self.set_blendDst(dst)
        self.set_blendAlphaDst(dst)

    def setBlendMode(self,b):
        tmp = b.index
        if (tmp == 0):
            src = h3d_mat_Blend.One
            dst = h3d_mat_Blend.Zero
            self.set_blendSrc(src)
            self.set_blendAlphaSrc(src)
            self.set_blendDst(dst)
            self.set_blendAlphaDst(dst)
            self.set_blendOp(h3d_mat_Operation.Add)
            self.set_blendAlphaOp(h3d_mat_Operation.Add)
        elif (tmp == 1):
            src1 = h3d_mat_Blend.SrcAlpha
            dst1 = h3d_mat_Blend.OneMinusSrcAlpha
            self.set_blendSrc(src1)
            self.set_blendAlphaSrc(src1)
            self.set_blendDst(dst1)
            self.set_blendAlphaDst(dst1)
            self.set_blendOp(h3d_mat_Operation.Add)
            self.set_blendAlphaOp(h3d_mat_Operation.Add)
        elif (tmp == 2):
            src2 = h3d_mat_Blend.SrcAlpha
            dst2 = h3d_mat_Blend.One
            self.set_blendSrc(src2)
            self.set_blendAlphaSrc(src2)
            self.set_blendDst(dst2)
            self.set_blendAlphaDst(dst2)
            self.set_blendOp(h3d_mat_Operation.Add)
            self.set_blendAlphaOp(h3d_mat_Operation.Add)
        elif (tmp == 3):
            src3 = h3d_mat_Blend.One
            dst3 = h3d_mat_Blend.OneMinusSrcAlpha
            self.set_blendSrc(src3)
            self.set_blendAlphaSrc(src3)
            self.set_blendDst(dst3)
            self.set_blendAlphaDst(dst3)
            self.set_blendOp(h3d_mat_Operation.Add)
            self.set_blendAlphaOp(h3d_mat_Operation.Add)
        elif (tmp == 4):
            src4 = h3d_mat_Blend.OneMinusDstColor
            dst4 = h3d_mat_Blend.One
            self.set_blendSrc(src4)
            self.set_blendAlphaSrc(src4)
            self.set_blendDst(dst4)
            self.set_blendAlphaDst(dst4)
            self.set_blendOp(h3d_mat_Operation.Add)
            self.set_blendAlphaOp(h3d_mat_Operation.Add)
        elif (tmp == 5):
            src5 = h3d_mat_Blend.DstColor
            dst5 = h3d_mat_Blend.Zero
            self.set_blendSrc(src5)
            self.set_blendAlphaSrc(src5)
            self.set_blendDst(dst5)
            self.set_blendAlphaDst(dst5)
            self.set_blendOp(h3d_mat_Operation.Add)
            self.set_blendAlphaOp(h3d_mat_Operation.Add)
        elif (tmp == 6):
            src6 = h3d_mat_Blend.DstColor
            dst6 = h3d_mat_Blend.OneMinusSrcAlpha
            self.set_blendSrc(src6)
            self.set_blendAlphaSrc(src6)
            self.set_blendDst(dst6)
            self.set_blendAlphaDst(dst6)
            self.set_blendOp(h3d_mat_Operation.Add)
            self.set_blendAlphaOp(h3d_mat_Operation.Add)
        elif (tmp == 7):
            src7 = h3d_mat_Blend.Zero
            dst7 = h3d_mat_Blend.OneMinusSrcColor
            self.set_blendSrc(src7)
            self.set_blendAlphaSrc(src7)
            self.set_blendDst(dst7)
            self.set_blendAlphaDst(dst7)
            self.set_blendOp(h3d_mat_Operation.Add)
            self.set_blendAlphaOp(h3d_mat_Operation.Add)
        elif (tmp == 8):
            src8 = h3d_mat_Blend.One
            dst8 = h3d_mat_Blend.OneMinusSrcColor
            self.set_blendSrc(src8)
            self.set_blendAlphaSrc(src8)
            self.set_blendDst(dst8)
            self.set_blendAlphaDst(dst8)
            self.set_blendOp(h3d_mat_Operation.Add)
            self.set_blendAlphaOp(h3d_mat_Operation.Add)
        elif (tmp == 9):
            src9 = h3d_mat_Blend.SrcAlpha
            dst9 = h3d_mat_Blend.One
            self.set_blendSrc(src9)
            self.set_blendAlphaSrc(src9)
            self.set_blendDst(dst9)
            self.set_blendAlphaDst(dst9)
            self.set_blendOp(h3d_mat_Operation.ReverseSub)
            self.set_blendAlphaOp(h3d_mat_Operation.ReverseSub)
        elif (tmp == 10):
            self.set_blendSrc(h3d_mat_Blend.Zero)
            self.set_blendAlphaSrc(h3d_mat_Blend.Zero)
            self.set_blendDst(h3d_mat_Blend.Zero)
            self.set_blendAlphaDst(h3d_mat_Blend.Zero)
            self.set_blendAlphaSrc(h3d_mat_Blend.Zero)
            self.set_blendAlphaDst(h3d_mat_Blend.Zero)
            self.set_blendAlphaOp(h3d_mat_Operation.Max)
            self.set_blendOp(h3d_mat_Operation.Max)
        elif (tmp == 11):
            self.set_blendSrc(h3d_mat_Blend.Zero)
            self.set_blendAlphaSrc(h3d_mat_Blend.Zero)
            self.set_blendDst(h3d_mat_Blend.Zero)
            self.set_blendAlphaDst(h3d_mat_Blend.Zero)
            self.set_blendAlphaSrc(h3d_mat_Blend.Zero)
            self.set_blendAlphaDst(h3d_mat_Blend.Zero)
            self.set_blendAlphaOp(h3d_mat_Operation.Min)
            self.set_blendOp(h3d_mat_Operation.Min)
        else:
            pass

    def depth(self,write,test):
        self.set_depthWrite(write)
        self.set_depthTest(test)

    def setColorMask(self,r,g,b,a):
        self.colorMask = (((((1 if r else 0)) | ((2 if g else 0))) | ((4 if b else 0))) | ((8 if a else 0)))

    def setColorChannel(self,c):
        tmp = c.index
        if (tmp == 1):
            self.setColorMask(True,False,False,False)
        elif (tmp == 2):
            self.setColorMask(False,True,False,False)
        elif (tmp == 3):
            self.setColorMask(False,False,True,False)
        elif (tmp == 4):
            self.setColorMask(False,False,False,True)
        else:
            raise _HxException(("Unsupported channel " + Std.string(c)))

    def addShader(self,s):
        if (s is None):
            return None
        self.shaders = hxsl_ShaderList.addSort(s,self.shaders)
        return s

    def addShaderAtIndex(self,s,index):
        prev = None
        cur = self.shaders
        while ((index > 0) and ((cur != self.parentShaders))):
            prev = cur
            cur = cur.next
            index = (index - 1)
        if (prev is None):
            self.shaders = hxsl_ShaderList(s,cur)
        else:
            prev.next = hxsl_ShaderList(s,cur)
        return s

    def getShaderIndex(self,s):
        index = 0
        cur = self.shaders
        while (cur != self.parentShaders):
            if (cur.s == s):
                return index
            cur = cur.next
            index = (index + 1)
        return -1

    def removeShader(self,s):
        sl = self.shaders
        prev = None
        while (sl is not None):
            if (sl.s == s):
                if (prev is None):
                    self.shaders = sl.next
                else:
                    prev.next = sl.next
                return True
            prev = sl
            sl = sl.next
        return False

    def getShader(self,t):
        s = self.shaders
        while (s != self.parentShaders):
            sh = Std.downcast(s.s,t)
            if (sh is not None):
                return sh
            s = s.next
        return None

    def getShaderByName(self,name):
        s = self.shaders
        while (s != self.parentShaders):
            if (s.s.shader.data.name == name):
                return s.s
            s = s.next
        return None

    def getShaders(self):
        return hxsl__ShaderList_ShaderIterator(self.shaders,self.parentShaders)

    def getShadersRec(self):
        if ((self.parentPass is None) or ((self.parentShaders == self.parentPass.shaders))):
            return self.shaders
        s = self.shaders
        prev = None
        while ((s is not None) and ((s != self.parentShaders))):
            prev = s
            s = s.next
        self.parentShaders = self.parentPass.shaders
        if (prev is None):
            self.shaders = self.parentShaders
        else:
            prev.next = self.parentShaders
        return self.shaders

    def clone(self):
        p = h3d_mat_Pass(self.name,self.shaders.clone())
        p.bits = self.bits
        p.set_enableLights(self.enableLights)
        if (self.stencil is not None):
            p.stencil = self.stencil.clone()
        return p

    def getDebugShaderCode(self,scene,toHxsl = None):
        if (toHxsl is None):
            toHxsl = True
        shader = scene.renderer.debugCompileShader(self)
        if toHxsl:
            def _hx_local_0(s):
                return hxsl_Printer.shaderToString(s,True)
            toString = _hx_local_0
            return ((("// vertex:\n" + HxOverrides.stringOrNull(toString(shader.vertex.data))) + "\n\nfragment:\n") + HxOverrides.stringOrNull(toString(shader.fragment.data)))
        else:
            return h3d_Engine.CURRENT.driver.getNativeShaderCode(shader)

    def set_enableLights(self,v):
        self.flags = ((self.flags & -2) | ((1 if v else 0)))
        def _hx_local_1():
            def _hx_local_0():
                self.enableLights = v
                return self.enableLights
            return _hx_local_0()
        return _hx_local_1()

    def set_dynamicParameters(self,v):
        self.flags = ((self.flags & -3) | ((((1 if v else 0)) << 1)))
        def _hx_local_1():
            def _hx_local_0():
                self.dynamicParameters = v
                return self.dynamicParameters
            return _hx_local_0()
        return _hx_local_1()

    def set_isStatic(self,v):
        self.flags = ((self.flags & -5) | ((((1 if v else 0)) << 2)))
        def _hx_local_1():
            def _hx_local_0():
                self.isStatic = v
                return self.isStatic
            return _hx_local_0()
        return _hx_local_1()

    def set_batchMode(self,v):
        self.flags = ((self.flags & -9) | ((((1 if v else 0)) << 3)))
        def _hx_local_1():
            def _hx_local_0():
                self.batchMode = v
                return self.batchMode
            return _hx_local_0()
        return _hx_local_1()

    def set_culling(self,v):
        self.bits = ((self.bits & -4) | v.index)
        def _hx_local_1():
            def _hx_local_0():
                self.culling = v
                return self.culling
            return _hx_local_0()
        return _hx_local_1()

    def set_depthWrite(self,v):
        self.bits = ((self.bits & -5) | ((((1 if v else 0)) << 2)))
        def _hx_local_1():
            def _hx_local_0():
                self.depthWrite = v
                return self.depthWrite
            return _hx_local_0()
        return _hx_local_1()

    def set_depthTest(self,v):
        self.bits = ((self.bits & -57) | ((v.index << 3)))
        def _hx_local_1():
            def _hx_local_0():
                self.depthTest = v
                return self.depthTest
            return _hx_local_0()
        return _hx_local_1()

    def set_blendSrc(self,v):
        self.bits = ((self.bits & -961) | ((v.index << 6)))
        def _hx_local_1():
            def _hx_local_0():
                self.blendSrc = v
                return self.blendSrc
            return _hx_local_0()
        return _hx_local_1()

    def set_blendDst(self,v):
        self.bits = ((self.bits & -15361) | ((v.index << 10)))
        def _hx_local_1():
            def _hx_local_0():
                self.blendDst = v
                return self.blendDst
            return _hx_local_0()
        return _hx_local_1()

    def set_blendAlphaSrc(self,v):
        self.bits = ((self.bits & -245761) | ((v.index << 14)))
        def _hx_local_1():
            def _hx_local_0():
                self.blendAlphaSrc = v
                return self.blendAlphaSrc
            return _hx_local_0()
        return _hx_local_1()

    def set_blendAlphaDst(self,v):
        self.bits = ((self.bits & -3932161) | ((v.index << 18)))
        def _hx_local_1():
            def _hx_local_0():
                self.blendAlphaDst = v
                return self.blendAlphaDst
            return _hx_local_0()
        return _hx_local_1()

    def set_blendOp(self,v):
        self.bits = ((self.bits & -29360129) | ((v.index << 22)))
        def _hx_local_1():
            def _hx_local_0():
                self.blendOp = v
                return self.blendOp
            return _hx_local_0()
        return _hx_local_1()

    def set_blendAlphaOp(self,v):
        self.bits = ((self.bits & -234881025) | ((v.index << 25)))
        def _hx_local_1():
            def _hx_local_0():
                self.blendAlphaOp = v
                return self.blendAlphaOp
            return _hx_local_0()
        return _hx_local_1()

    def set_wireframe(self,v):
        self.bits = ((self.bits & -268435457) | ((((1 if v else 0)) << 28)))
        def _hx_local_1():
            def _hx_local_0():
                self.wireframe = v
                return self.wireframe
            return _hx_local_0()
        return _hx_local_1()

    def set_reserved(self,v):
        self.bits = ((self.bits & -536870913) | ((((1 if v else 0)) << 29)))
        def _hx_local_1():
            def _hx_local_0():
                self.reserved = v
                return self.reserved
            return _hx_local_0()
        return _hx_local_1()

    def loadFlags(self,bits):
        self.flags = bits
        self.set_enableLights((((self.flags & 1)) != 0))
        self.set_dynamicParameters(((((self.flags >> 1) & 1)) != 0))
        self.set_isStatic(((((self.flags >> 2) & 1)) != 0))
        self.set_batchMode(((((self.flags >> 3) & 1)) != 0))

    def loadBits(self,bits):
        self.bits = bits
        self.set_culling(Type.createEnumIndex(h3d_mat_Face,(self.bits & 3)))
        self.set_depthWrite(((((self.bits >> 2) & 1)) != 0))
        self.set_depthTest(Type.createEnumIndex(h3d_mat_Compare,((self.bits >> 3) & 7)))
        self.set_blendSrc(Type.createEnumIndex(h3d_mat_Blend,((self.bits >> 6) & 15)))
        self.set_blendDst(Type.createEnumIndex(h3d_mat_Blend,((self.bits >> 10) & 15)))
        self.set_blendAlphaSrc(Type.createEnumIndex(h3d_mat_Blend,((self.bits >> 14) & 15)))
        self.set_blendAlphaDst(Type.createEnumIndex(h3d_mat_Blend,((self.bits >> 18) & 15)))
        self.set_blendOp(Type.createEnumIndex(h3d_mat_Operation,((self.bits >> 22) & 7)))
        self.set_blendAlphaOp(Type.createEnumIndex(h3d_mat_Operation,((self.bits >> 25) & 7)))
        self.set_wireframe(((((self.bits >> 28) & 1)) != 0))
        self.set_reserved(((((self.bits >> 29) & 1)) != 0))

    @staticmethod
    def getEnableLights(v):
        return (v & 1)

    @staticmethod
    def getDynamicParameters(v):
        return ((v >> 1) & 1)

    @staticmethod
    def getIsStatic(v):
        return ((v >> 2) & 1)

    @staticmethod
    def getBatchMode(v):
        return ((v >> 3) & 1)

    @staticmethod
    def getCulling(v):
        return (v & 3)

    @staticmethod
    def getDepthWrite(v):
        return ((v >> 2) & 1)

    @staticmethod
    def getDepthTest(v):
        return ((v >> 3) & 7)

    @staticmethod
    def getBlendSrc(v):
        return ((v >> 6) & 15)

    @staticmethod
    def getBlendDst(v):
        return ((v >> 10) & 15)

    @staticmethod
    def getBlendAlphaSrc(v):
        return ((v >> 14) & 15)

    @staticmethod
    def getBlendAlphaDst(v):
        return ((v >> 18) & 15)

    @staticmethod
    def getBlendOp(v):
        return ((v >> 22) & 7)

    @staticmethod
    def getBlendAlphaOp(v):
        return ((v >> 25) & 7)

    @staticmethod
    def getWireframe(v):
        return ((v >> 28) & 1)

    @staticmethod
    def getReserved(v):
        return ((v >> 29) & 1)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.name = None
        _hx_o.flags = None
        _hx_o.passId = None
        _hx_o.bits = None
        _hx_o.parentPass = None
        _hx_o.parentShaders = None
        _hx_o.shaders = None
        _hx_o.nextPass = None
        _hx_o.enableLights = None
        _hx_o.dynamicParameters = None
        _hx_o.isStatic = None
        _hx_o.batchMode = None
        _hx_o.culling = None
        _hx_o.depthWrite = None
        _hx_o.depthTest = None
        _hx_o.blendSrc = None
        _hx_o.blendDst = None
        _hx_o.blendAlphaSrc = None
        _hx_o.blendAlphaDst = None
        _hx_o.blendOp = None
        _hx_o.blendAlphaOp = None
        _hx_o.wireframe = None
        _hx_o.colorMask = None
        _hx_o.layer = None
        _hx_o.stencil = None
        _hx_o.reserved = None
h3d_mat_Pass._hx_class = h3d_mat_Pass
_hx_classes["h3d.mat.Pass"] = h3d_mat_Pass


class h3d_mat_Stencil:
    _hx_class_name = "h3d.mat.Stencil"
    _hx_is_interface = "False"
    __slots__ = ("maskBits", "opBits", "readMask", "writeMask", "reference", "frontTest", "frontPass", "frontSTfail", "frontDPfail", "backTest", "backPass", "backSTfail", "backDPfail")
    _hx_fields = ["maskBits", "opBits", "readMask", "writeMask", "reference", "frontTest", "frontPass", "frontSTfail", "frontDPfail", "backTest", "backPass", "backSTfail", "backDPfail"]
    _hx_methods = ["setFront", "setBack", "setOp", "setFunc", "clone", "load", "set_readMask", "set_writeMask", "set_reference", "set_frontTest", "set_frontPass", "set_frontSTfail", "set_frontDPfail", "set_backTest", "set_backPass", "set_backSTfail", "set_backDPfail", "loadOpBits", "loadMaskBits"]
    _hx_statics = ["getReadMask", "readMask_bits", "readMask_offset", "readMask_mask", "getWriteMask", "writeMask_bits", "writeMask_offset", "writeMask_mask", "getReference", "reference_bits", "reference_offset", "reference_mask", "getFrontTest", "frontTest_bits", "frontTest_offset", "frontTest_mask", "getFrontPass", "frontPass_bits", "frontPass_offset", "frontPass_mask", "getFrontSTfail", "frontSTfail_bits", "frontSTfail_offset", "frontSTfail_mask", "getFrontDPfail", "frontDPfail_bits", "frontDPfail_offset", "frontDPfail_mask", "getBackTest", "backTest_bits", "backTest_offset", "backTest_mask", "getBackPass", "backPass_bits", "backPass_offset", "backPass_mask", "getBackSTfail", "backSTfail_bits", "backSTfail_offset", "backSTfail_mask", "getBackDPfail", "backDPfail_bits", "backDPfail_offset", "backDPfail_mask"]
    _hx_interfaces = [hxd_impl__Serializable_NoSerializeSupport]

    def __init__(self):
        self.backDPfail = None
        self.backSTfail = None
        self.backPass = None
        self.backTest = None
        self.frontDPfail = None
        self.frontSTfail = None
        self.frontPass = None
        self.frontTest = None
        self.reference = None
        self.writeMask = None
        self.readMask = None
        self.opBits = 0
        self.maskBits = 0
        self.setOp(h3d_mat_StencilOp.Keep,h3d_mat_StencilOp.Keep,h3d_mat_StencilOp.Keep)
        self.setFunc(h3d_mat_Compare.Always)

    def setFront(self,stfail,dpfail,_hx_pass):
        self.set_frontSTfail(stfail)
        self.set_frontDPfail(dpfail)
        self.set_frontPass(_hx_pass)

    def setBack(self,stfail,dpfail,_hx_pass):
        self.set_backSTfail(stfail)
        self.set_backDPfail(dpfail)
        self.set_backPass(_hx_pass)

    def setOp(self,stfail,dpfail,_hx_pass):
        self.setFront(stfail,dpfail,_hx_pass)
        self.setBack(stfail,dpfail,_hx_pass)

    def setFunc(self,f,reference = None,readMask = None,writeMask = None):
        if (reference is None):
            reference = 0
        if (readMask is None):
            readMask = 255
        if (writeMask is None):
            writeMask = 255
        self.set_frontTest(self.set_backTest(f))
        self.set_reference(reference)
        self.set_readMask(readMask)
        self.set_writeMask(writeMask)

    def clone(self):
        s = h3d_mat_Stencil()
        s.opBits = self.opBits
        s.maskBits = self.maskBits
        return s

    def load(self,s):
        self.opBits = s.opBits
        self.maskBits = s.maskBits

    def set_readMask(self,v):
        self.maskBits = ((self.maskBits & -256) | ((v & 255)))
        def _hx_local_1():
            def _hx_local_0():
                self.readMask = v
                return self.readMask
            return _hx_local_0()
        return _hx_local_1()

    def set_writeMask(self,v):
        self.maskBits = ((self.maskBits & -65281) | ((((v & 255)) << 8)))
        def _hx_local_1():
            def _hx_local_0():
                self.writeMask = v
                return self.writeMask
            return _hx_local_0()
        return _hx_local_1()

    def set_reference(self,v):
        self.maskBits = ((self.maskBits & -16711681) | ((((v & 255)) << 16)))
        def _hx_local_1():
            def _hx_local_0():
                self.reference = v
                return self.reference
            return _hx_local_0()
        return _hx_local_1()

    def set_frontTest(self,v):
        self.opBits = ((self.opBits & -8) | v.index)
        def _hx_local_1():
            def _hx_local_0():
                self.frontTest = v
                return self.frontTest
            return _hx_local_0()
        return _hx_local_1()

    def set_frontPass(self,v):
        self.opBits = ((self.opBits & -57) | ((v.index << 3)))
        def _hx_local_1():
            def _hx_local_0():
                self.frontPass = v
                return self.frontPass
            return _hx_local_0()
        return _hx_local_1()

    def set_frontSTfail(self,v):
        self.opBits = ((self.opBits & -449) | ((v.index << 6)))
        def _hx_local_1():
            def _hx_local_0():
                self.frontSTfail = v
                return self.frontSTfail
            return _hx_local_0()
        return _hx_local_1()

    def set_frontDPfail(self,v):
        self.opBits = ((self.opBits & -3585) | ((v.index << 9)))
        def _hx_local_1():
            def _hx_local_0():
                self.frontDPfail = v
                return self.frontDPfail
            return _hx_local_0()
        return _hx_local_1()

    def set_backTest(self,v):
        self.opBits = ((self.opBits & -28673) | ((v.index << 12)))
        def _hx_local_1():
            def _hx_local_0():
                self.backTest = v
                return self.backTest
            return _hx_local_0()
        return _hx_local_1()

    def set_backPass(self,v):
        self.opBits = ((self.opBits & -229377) | ((v.index << 15)))
        def _hx_local_1():
            def _hx_local_0():
                self.backPass = v
                return self.backPass
            return _hx_local_0()
        return _hx_local_1()

    def set_backSTfail(self,v):
        self.opBits = ((self.opBits & -1835009) | ((v.index << 18)))
        def _hx_local_1():
            def _hx_local_0():
                self.backSTfail = v
                return self.backSTfail
            return _hx_local_0()
        return _hx_local_1()

    def set_backDPfail(self,v):
        self.opBits = ((self.opBits & -14680065) | ((v.index << 21)))
        def _hx_local_1():
            def _hx_local_0():
                self.backDPfail = v
                return self.backDPfail
            return _hx_local_0()
        return _hx_local_1()

    def loadOpBits(self,bits):
        self.opBits = bits
        self.set_frontTest(Type.createEnumIndex(h3d_mat_Compare,(self.opBits & 7)))
        self.set_frontPass(Type.createEnumIndex(h3d_mat_StencilOp,((self.opBits >> 3) & 7)))
        self.set_frontSTfail(Type.createEnumIndex(h3d_mat_StencilOp,((self.opBits >> 6) & 7)))
        self.set_frontDPfail(Type.createEnumIndex(h3d_mat_StencilOp,((self.opBits >> 9) & 7)))
        self.set_backTest(Type.createEnumIndex(h3d_mat_Compare,((self.opBits >> 12) & 7)))
        self.set_backPass(Type.createEnumIndex(h3d_mat_StencilOp,((self.opBits >> 15) & 7)))
        self.set_backSTfail(Type.createEnumIndex(h3d_mat_StencilOp,((self.opBits >> 18) & 7)))
        self.set_backDPfail(Type.createEnumIndex(h3d_mat_StencilOp,((self.opBits >> 21) & 7)))

    def loadMaskBits(self,bits):
        self.maskBits = bits
        self.set_readMask((self.maskBits & 255))
        self.set_writeMask(((self.maskBits >> 8) & 255))
        self.set_reference(((self.maskBits >> 16) & 255))

    @staticmethod
    def getReadMask(v):
        return (v & 255)

    @staticmethod
    def getWriteMask(v):
        return ((v >> 8) & 255)

    @staticmethod
    def getReference(v):
        return ((v >> 16) & 255)

    @staticmethod
    def getFrontTest(v):
        return (v & 7)

    @staticmethod
    def getFrontPass(v):
        return ((v >> 3) & 7)

    @staticmethod
    def getFrontSTfail(v):
        return ((v >> 6) & 7)

    @staticmethod
    def getFrontDPfail(v):
        return ((v >> 9) & 7)

    @staticmethod
    def getBackTest(v):
        return ((v >> 12) & 7)

    @staticmethod
    def getBackPass(v):
        return ((v >> 15) & 7)

    @staticmethod
    def getBackSTfail(v):
        return ((v >> 18) & 7)

    @staticmethod
    def getBackDPfail(v):
        return ((v >> 21) & 7)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.maskBits = None
        _hx_o.opBits = None
        _hx_o.readMask = None
        _hx_o.writeMask = None
        _hx_o.reference = None
        _hx_o.frontTest = None
        _hx_o.frontPass = None
        _hx_o.frontSTfail = None
        _hx_o.frontDPfail = None
        _hx_o.backTest = None
        _hx_o.backPass = None
        _hx_o.backSTfail = None
        _hx_o.backDPfail = None
h3d_mat_Stencil._hx_class = h3d_mat_Stencil
_hx_classes["h3d.mat.Stencil"] = h3d_mat_Stencil

class hxd_PixelFormat(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.PixelFormat"
    _hx_constructs = ["ARGB", "BGRA", "RGBA", "RGBA16F", "RGBA32F", "R8", "R16F", "R32F", "RG8", "RG16F", "RG32F", "RGB8", "RGB16F", "RGB32F", "SRGB", "SRGB_ALPHA", "RGB10A2", "RG11B10UF", "S3TC"]

    @staticmethod
    def S3TC(v):
        return hxd_PixelFormat("S3TC", 18, (v,))
hxd_PixelFormat.ARGB = hxd_PixelFormat("ARGB", 0, ())
hxd_PixelFormat.BGRA = hxd_PixelFormat("BGRA", 1, ())
hxd_PixelFormat.RGBA = hxd_PixelFormat("RGBA", 2, ())
hxd_PixelFormat.RGBA16F = hxd_PixelFormat("RGBA16F", 3, ())
hxd_PixelFormat.RGBA32F = hxd_PixelFormat("RGBA32F", 4, ())
hxd_PixelFormat.R8 = hxd_PixelFormat("R8", 5, ())
hxd_PixelFormat.R16F = hxd_PixelFormat("R16F", 6, ())
hxd_PixelFormat.R32F = hxd_PixelFormat("R32F", 7, ())
hxd_PixelFormat.RG8 = hxd_PixelFormat("RG8", 8, ())
hxd_PixelFormat.RG16F = hxd_PixelFormat("RG16F", 9, ())
hxd_PixelFormat.RG32F = hxd_PixelFormat("RG32F", 10, ())
hxd_PixelFormat.RGB8 = hxd_PixelFormat("RGB8", 11, ())
hxd_PixelFormat.RGB16F = hxd_PixelFormat("RGB16F", 12, ())
hxd_PixelFormat.RGB32F = hxd_PixelFormat("RGB32F", 13, ())
hxd_PixelFormat.SRGB = hxd_PixelFormat("SRGB", 14, ())
hxd_PixelFormat.SRGB_ALPHA = hxd_PixelFormat("SRGB_ALPHA", 15, ())
hxd_PixelFormat.RGB10A2 = hxd_PixelFormat("RGB10A2", 16, ())
hxd_PixelFormat.RG11B10UF = hxd_PixelFormat("RG11B10UF", 17, ())
hxd_PixelFormat._hx_class = hxd_PixelFormat
_hx_classes["hxd.PixelFormat"] = hxd_PixelFormat


class h3d_mat_Texture:
    _hx_class_name = "h3d.mat.Texture"
    _hx_is_interface = "False"
    __slots__ = ("t", "mem", "id", "name", "width", "height", "flags", "format", "bits", "waitLoads", "mipMap", "filter", "wrap", "realloc", "depthBuffer", "_lastFrame")
    _hx_fields = ["t", "mem", "id", "name", "width", "height", "flags", "format", "bits", "waitLoads", "mipMap", "filter", "wrap", "realloc", "depthBuffer", "_lastFrame"]
    _hx_methods = ["set_lastFrame", "get_lastFrame", "get_layerCount", "alloc", "isSRGB", "checkAlloc", "clone", "preventAutoDispose", "waitLoad", "toString", "setName", "set_mipMap", "set_filter", "set_wrap", "isDisposed", "resize", "clearF", "clear", "checkSize", "checkMipMapGen", "uploadBitmap", "uploadPixels", "dispose", "swapTexture", "capturePixels"]
    _hx_statics = ["UID", "PREVENT_AUTO_DISPOSE", "nativeFormat", "fromBitmap", "fromPixels", "fromColor", "genDisc", "genTexture", "drawGenTexture", "defaultCubeTexture", "genChecker", "checkerTextureKeys", "noiseTextureKeys", "genTextureKeys", "genNoise", "allocNoise", "allocChecker"]

    def __init__(self,w,h,flags = None,format = None):
        self._lastFrame = None
        self.depthBuffer = None
        self.realloc = None
        self.wrap = None
        self.filter = None
        self.mipMap = None
        self.waitLoads = None
        self.bits = None
        self.height = None
        self.width = None
        self.name = None
        self.t = None
        engine = h3d_Engine.CURRENT
        self.mem = engine.mem
        if (format is None):
            format = h3d_mat_Texture.nativeFormat
        def _hx_local_2():
            _hx_local_0 = h3d_mat_Texture
            _hx_local_1 = _hx_local_0.UID
            _hx_local_0.UID = (_hx_local_1 + 1)
            return _hx_local_0.UID
        self.id = _hx_local_2()
        self.format = format
        this1 = 0
        self.flags = this1
        if (flags is not None):
            _g = 0
            while (_g < len(flags)):
                f = (flags[_g] if _g >= 0 and _g < len(flags) else None)
                _g = (_g + 1)
                _hx_local_4 = self
                _hx_local_5 = _hx_local_4.flags
                _hx_local_4.flags = (_hx_local_5 | ((1 << f.index)))
                _hx_local_4.flags
        tw = 1
        th = 1
        while (tw < w):
            tw = (tw << 1)
        while (th < h):
            th = (th << 1)
        if ((tw != w) or ((th != h))):
            _hx_local_8 = self
            _hx_local_9 = _hx_local_8.flags
            _hx_local_8.flags = (_hx_local_9 | ((1 << h3d_mat_TextureFlags.IsNPOT.index)))
            _hx_local_8.flags
        if (((self.flags & ((1 << h3d_mat_TextureFlags.Target.index)))) != 0):
            def _hx_local_10():
                pass
            self.realloc = _hx_local_10
        self.width = w
        self.height = h
        self.set_mipMap((h3d_mat_MipMap.Nearest if ((((self.flags & ((1 << h3d_mat_TextureFlags.MipMapped.index)))) != 0)) else h3d_mat_MipMap._hx_None))
        self.set_filter(h3d_mat_Filter.Linear)
        self.set_wrap(h3d_mat_Wrap.Clamp)
        _hx_local_11 = self
        _hx_local_12 = _hx_local_11.bits
        _hx_local_11.bits = (_hx_local_12 & 32767)
        _hx_local_11.bits
        if (((self.flags & ((1 << h3d_mat_TextureFlags.NoAlloc.index)))) == 0):
            self.alloc()

    def set_lastFrame(self,lf):
        if (self._lastFrame != h3d_mat_Texture.PREVENT_AUTO_DISPOSE):
            self._lastFrame = lf
        return self._lastFrame

    def get_lastFrame(self):
        return self._lastFrame

    def get_layerCount(self):
        if (((self.flags & ((1 << h3d_mat_TextureFlags.Cube.index)))) != 0):
            return 6
        else:
            return 1

    def alloc(self):
        if (self.t is None):
            self.mem.allocTexture(self)

    def isSRGB(self):
        tmp = self.format.index
        if ((tmp == 15) or ((tmp == 14))):
            return True
        else:
            return False

    def checkAlloc(self):
        if ((self.t is None) and ((self.realloc is not None))):
            self.alloc()
            self.realloc()

    def clone(self):
        self.checkAlloc()
        if (self.t is None):
            raise _HxException("Can't clone disposed texture")
        old = self.get_lastFrame()
        self.preventAutoDispose()
        flags = []
        f = h3d_mat_TextureFlags.Target
        if (((self.flags & ((1 << f.index)))) != 0):
            flags.append(f)
        f1 = h3d_mat_TextureFlags.Cube
        if (((self.flags & ((1 << f1.index)))) != 0):
            flags.append(f1)
        f2 = h3d_mat_TextureFlags.MipMapped
        if (((self.flags & ((1 << f2.index)))) != 0):
            flags.append(f2)
        f3 = h3d_mat_TextureFlags.IsArray
        if (((self.flags & ((1 << f3.index)))) != 0):
            flags.append(f3)
        t = h3d_mat_Texture(self.width,self.height,flags,self.format)
        t.name = self.name
        if (((self.flags & ((1 << h3d_mat_TextureFlags.Cube.index)))) != 0):
            h3d_pass_CubeCopy.run(self,t)
        else:
            h3d_pass_Copy.run(self,t)
        self.set_lastFrame(old)
        return t

    def preventAutoDispose(self):
        self.set_lastFrame(h3d_mat_Texture.PREVENT_AUTO_DISPOSE)

    def waitLoad(self,f):
        if (((self.flags & ((1 << h3d_mat_TextureFlags.Loading.index)))) == 0):
            f()
            return
        if (self.waitLoads is None):
            self.waitLoads = []
        _this = self.waitLoads
        _this.append(f)

    def toString(self):
        _hx_str = self.name
        if (self.name is None):
            _hx_str = ("Texture_" + Std.string(self.id))
        return (((((("null" if _hx_str is None else _hx_str) + "(") + Std.string(self.width)) + "x") + Std.string(self.height)) + ")")

    def setName(self,n):
        self.name = n

    def set_mipMap(self,m):
        self.bits = ((self.bits & -4) | m.index)
        def _hx_local_1():
            def _hx_local_0():
                self.mipMap = m
                return self.mipMap
            return _hx_local_0()
        return _hx_local_1()

    def set_filter(self,f):
        self.bits = ((self.bits & -25) | ((f.index << 3)))
        def _hx_local_1():
            def _hx_local_0():
                self.filter = f
                return self.filter
            return _hx_local_0()
        return _hx_local_1()

    def set_wrap(self,w):
        self.bits = ((self.bits & -193) | ((w.index << 6)))
        def _hx_local_1():
            def _hx_local_0():
                self.wrap = w
                return self.wrap
            return _hx_local_0()
        return _hx_local_1()

    def isDisposed(self):
        if (self.t is None):
            return (self.realloc is None)
        else:
            return False

    def resize(self,width,height):
        self.dispose()
        tw = 1
        th = 1
        while (tw < width):
            tw = (tw << 1)
        while (th < height):
            th = (th << 1)
        if ((tw != width) or ((th != height))):
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 | ((1 << h3d_mat_TextureFlags.IsNPOT.index)))
            _hx_local_2.flags
        else:
            _hx_local_4 = self
            _hx_local_5 = _hx_local_4.flags
            _hx_local_4.flags = (_hx_local_5 & ((-1 - ((1 << h3d_mat_TextureFlags.IsNPOT.index)))))
            _hx_local_4.flags
        self.width = width
        self.height = height
        if (((self.flags & ((1 << h3d_mat_TextureFlags.NoAlloc.index)))) == 0):
            self.alloc()

    def clearF(self,r = None,g = None,b = None,a = None,layer = None):
        if (r is None):
            r = 0.
        if (g is None):
            g = 0.
        if (b is None):
            b = 0.
        if (a is None):
            a = 0.
        if (layer is None):
            layer = -1
        self.alloc()
        if (((self.flags & ((1 << h3d_mat_TextureFlags.Target.index)))) == 0):
            raise _HxException("Texture should be target")
        engine = h3d_Engine.CURRENT
        color = h3d_Vector(r,g,b,a)
        if (layer < 0):
            _g = 0
            _g1 = self.get_layerCount()
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                engine.pushTarget(self,i)
                engine.clearF(color)
                engine.popTarget()
        else:
            engine.pushTarget(self,layer)
            engine.clearF(color)
            engine.popTarget()

    def clear(self,color,alpha = None,layer = None):
        if (alpha is None):
            alpha = 1.
        if (layer is None):
            layer = -1
        self.alloc()
        if ((((self.flags & ((1 << h3d_mat_TextureFlags.Target.index)))) != 0) and (((self.width != 1) or ((self.height != 1))))):
            engine = h3d_Engine.CURRENT
            color1 = None
            try:
                color1 = int((((0. if ((alpha < 0.)) else (1. if ((alpha > 1.)) else alpha))) * 255))
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                color1 = None
            color = (color | ((color1 << 24)))
            if (layer < 0):
                _g = 0
                _g1 = self.get_layerCount()
                while (_g < _g1):
                    i = _g
                    _g = (_g + 1)
                    engine.pushTarget(self,i)
                    engine.clear(color)
                    engine.popTarget()
            else:
                engine.pushTarget(self,layer)
                engine.clear(color)
                engine.popTarget()
        else:
            p = hxd_Pixels.alloc(self.width,self.height,h3d_mat_Texture.nativeFormat)
            k = 0
            b = (color & 255)
            g = ((color >> 8) & 255)
            r = ((color >> 16) & 255)
            a = None
            try:
                a = int((alpha * 255))
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e1 = _hx_e1
                a = None
            a1 = a
            if (a1 < 0):
                a1 = 0
            elif (a1 > 255):
                a1 = 255
            tmp = h3d_mat_Texture.nativeFormat.index
            if (tmp == 1):
                tmp1 = r
                r = b
                b = tmp1
            elif (tmp == 2):
                pass
            else:
                raise _HxException("TODO")
            _g11 = 0
            _g2 = (self.width * self.height)
            while (_g11 < _g2):
                i1 = _g11
                _g11 = (_g11 + 1)
                pos = k
                k = (k + 1)
                p.bytes.b[pos] = (r & 255)
                pos1 = k
                k = (k + 1)
                p.bytes.b[pos1] = (g & 255)
                pos2 = k
                k = (k + 1)
                p.bytes.b[pos2] = (b & 255)
                pos3 = k
                k = (k + 1)
                p.bytes.b[pos3] = (a1 & 255)
            if (layer < 0):
                _g3 = 0
                _g4 = self.get_layerCount()
                while (_g3 < _g4):
                    i2 = _g3
                    _g3 = (_g3 + 1)
                    self.uploadPixels(p,0,i2)
            else:
                self.uploadPixels(p,0,layer)
            p.dispose()

    def checkSize(self,width,height,mip):
        if ((width != ((self.width >> mip))) or ((height != ((self.height >> mip))))):
            raise _HxException(((((((("Invalid upload size : " + Std.string(width)) + "x") + Std.string(height)) + " should be ") + Std.string(((self.width >> mip)))) + "x") + Std.string(((self.height >> mip)))))

    def checkMipMapGen(self,mipLevel,layer):
        if ((((mipLevel == 0) and ((((self.flags & ((1 << h3d_mat_TextureFlags.MipMapped.index)))) != 0))) and ((((self.flags & ((1 << h3d_mat_TextureFlags.ManualMipMapGen.index)))) == 0))) and (((((self.flags & ((1 << h3d_mat_TextureFlags.Cube.index)))) == 0) or ((layer == 5))))):
            self.mem.driver.generateMipMaps(self)

    def uploadBitmap(self,bmp,mipLevel = None,layer = None):
        if (mipLevel is None):
            mipLevel = 0
        if (layer is None):
            layer = 0
        self.alloc()
        width = bmp.data.width
        height = bmp.data.height
        if ((width != ((self.width >> mipLevel))) or ((height != ((self.height >> mipLevel))))):
            raise _HxException(((((((("Invalid upload size : " + Std.string(width)) + "x") + Std.string(height)) + " should be ") + Std.string(((self.width >> mipLevel)))) + "x") + Std.string(((self.height >> mipLevel)))))
        self.mem.driver.uploadTextureBitmap(self,bmp,mipLevel,layer)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.flags
        _hx_local_0.flags = (_hx_local_1 | ((1 << h3d_mat_TextureFlags.WasCleared.index)))
        _hx_local_0.flags
        self.checkMipMapGen(mipLevel,layer)

    def uploadPixels(self,pixels,mipLevel = None,layer = None):
        if (mipLevel is None):
            mipLevel = 0
        if (layer is None):
            layer = 0
        self.alloc()
        width = pixels.width
        height = pixels.height
        if ((width != ((self.width >> mipLevel))) or ((height != ((self.height >> mipLevel))))):
            raise _HxException(((((((("Invalid upload size : " + Std.string(width)) + "x") + Std.string(height)) + " should be ") + Std.string(((self.width >> mipLevel)))) + "x") + Std.string(((self.height >> mipLevel)))))
        self.mem.driver.uploadTexturePixels(self,pixels,mipLevel,layer)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.flags
        _hx_local_0.flags = (_hx_local_1 | ((1 << h3d_mat_TextureFlags.WasCleared.index)))
        _hx_local_0.flags
        self.checkMipMapGen(mipLevel,layer)

    def dispose(self):
        if (self.t is not None):
            self.mem.deleteTexture(self)

    def swapTexture(self,t):
        self.checkAlloc()
        t.checkAlloc()
        if (((self.t is None) and ((self.realloc is None))) or (((t.t is None) and ((t.realloc is None))))):
            raise _HxException("One of the two texture is disposed")
        tmp = self.t
        self.t = t.t
        t.t = tmp

    def capturePixels(self,face = None,mipLevel = None,region = None):
        if (face is None):
            face = 0
        if (mipLevel is None):
            mipLevel = 0
        old = self.get_lastFrame()
        self.preventAutoDispose()
        pix = self.mem.driver.capturePixels(self,face,mipLevel,region)
        self.set_lastFrame(old)
        return pix

    @staticmethod
    def fromBitmap(bmp):
        t = h3d_mat_Texture(bmp.data.width,bmp.data.height)
        t.uploadBitmap(bmp)
        return t

    @staticmethod
    def fromPixels(pixels):
        t = h3d_mat_Texture(pixels.width,pixels.height)
        t.uploadPixels(pixels)
        return t

    @staticmethod
    def fromColor(color,alpha = None):
        if (alpha is None):
            alpha = 1.
        engine = h3d_Engine.CURRENT
        aval = None
        try:
            aval = int((alpha * 255))
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            aval = None
        aval1 = aval
        if (aval1 < 0):
            aval1 = 0
        elif (aval1 > 255):
            aval1 = 255
        key = ((color & 16777215) | ((aval1 << 24)))
        t = engine.textureColorCache.h.get(key,None)
        if (t is not None):
            return t
        t1 = h3d_mat_Texture(1,1,None)
        t1.clear(color,alpha)
        def _hx_local_0():
            t1.clear(color,alpha)
        t1.realloc = _hx_local_0
        engine.textureColorCache.set(key,t1)
        return t1

    @staticmethod
    def genDisc(size,color,alpha = None):
        if (alpha is None):
            alpha = 1.
        return h3d_mat_Texture.genTexture(0,size,color,alpha)

    @staticmethod
    def genTexture(mode,size,color,alpha):
        engine = h3d_Engine.CURRENT
        aval = None
        try:
            aval = int((alpha * 255))
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            aval = None
        aval1 = aval
        if (aval1 < 0):
            aval1 = 0
        elif (aval1 > 255):
            aval1 = 255
        color = ((color & 16777215) | ((aval1 << 24)))
        key = ((Std.string((((size << 16) | mode))) + ",") + Std.string(color))
        k = h3d_mat_Texture.genTextureKeys.h.get(key,None)
        t = (None if ((k is None)) else engine.resCache.h.get(k,None))
        if (t is not None):
            return t
        if (k is None):
            k = _hx_AnonObject({})
            h3d_mat_Texture.genTextureKeys.h[key] = k
        t = h3d_mat_Texture(size,size,[h3d_mat_TextureFlags.Target])
        def _hx_local_0():
            h3d_mat_Texture.drawGenTexture(t,color,mode)
        t.realloc = _hx_local_0
        h3d_mat_Texture.drawGenTexture(t,color,mode)
        engine.resCache.set(k,t)
        return t

    @staticmethod
    def drawGenTexture(t,color,mode):
        s = h3d_pass_ScreenFx(h3d_shader_GenTexture())
        engine = h3d_Engine.CURRENT
        _this = s.shader
        _this.constModified = True
        _this.mode__ = mode
        _this1 = s.shader.color__
        _this1.x = ((((color >> 16) & 255)) / 255)
        _this1.y = ((((color >> 8) & 255)) / 255)
        _this1.z = (((color & 255)) / 255)
        _this1.w = ((HxOverrides.rshift(color, 24)) / 255)
        engine.pushTarget(t)
        s.render()
        engine.popTarget()

    @staticmethod
    def defaultCubeTexture():
        engine = h3d_Engine.CURRENT
        t = engine.resCache.h.get(h3d_mat_Texture,None)
        if (t is not None):
            return t
        t = h3d_mat_Texture(1,1,[h3d_mat_TextureFlags.Cube])
        t.clear(2105376)
        def _hx_local_0():
            t.clear(2105376)
        t.realloc = _hx_local_0
        engine.resCache.set(h3d_mat_Texture,t)
        return t

    @staticmethod
    def genChecker(size):
        engine = h3d_Engine.CURRENT
        k = h3d_mat_Texture.checkerTextureKeys.h.get(size,None)
        t = (None if ((k is None)) else engine.resCache.h.get(k,None))
        if ((t is not None) and (not (((t.t is None) and ((t.realloc is None)))))):
            return t
        if (k is None):
            k = _hx_AnonObject({})
            h3d_mat_Texture.checkerTextureKeys.set(size,k)
        t1 = h3d_mat_Texture(size,size,[h3d_mat_TextureFlags.NoAlloc])
        t2 = t1
        size1 = size
        def _hx_local_0():
            h3d_mat_Texture.allocChecker(t2,size1)
        t1.realloc = _hx_local_0
        engine.resCache.set(k,t1)
        return t1

    @staticmethod
    def genNoise(size):
        engine = h3d_Engine.CURRENT
        k = h3d_mat_Texture.noiseTextureKeys.h.get(size,None)
        t = (None if ((k is None)) else engine.resCache.h.get(k,None))
        if ((t is not None) and (not (((t.t is None) and ((t.realloc is None)))))):
            return t
        if (k is None):
            k = _hx_AnonObject({})
            h3d_mat_Texture.noiseTextureKeys.set(size,k)
        t1 = h3d_mat_Texture(size,size,[h3d_mat_TextureFlags.NoAlloc])
        t2 = t1
        size1 = size
        def _hx_local_0():
            h3d_mat_Texture.allocNoise(t2,size1)
        t1.realloc = _hx_local_0
        engine.resCache.set(k,t1)
        return t1

    @staticmethod
    def allocNoise(t,size):
        b = hxd_BitmapData(size,size)
        _g = 0
        _g1 = size
        while (_g < _g1):
            x = _g
            _g = (_g + 1)
            _g2 = 0
            _g11 = size
            while (_g2 < _g11):
                y = _g2
                _g2 = (_g2 + 1)
                n = int((python_lib_Random.random() * 256))
                b.setPixel(x,y,(((-16777216 | n) | ((n << 8))) | ((n << 16))))
        t.uploadBitmap(b)
        b.data = None

    @staticmethod
    def allocChecker(t,size):
        b = hxd_BitmapData(size,size)
        b.clear(-1)
        _g = 0
        _g1 = (size >> 1)
        while (_g < _g1):
            x = _g
            _g = (_g + 1)
            _g2 = 0
            _g11 = (size >> 1)
            while (_g2 < _g11):
                y = _g2
                _g2 = (_g2 + 1)
                b.setPixel(x,y,-16777216)
                b.setPixel((x + ((size >> 1))),(y + ((size >> 1))),-16777216)
        t.uploadBitmap(b)
        b.data = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.t = None
        _hx_o.mem = None
        _hx_o.id = None
        _hx_o.name = None
        _hx_o.width = None
        _hx_o.height = None
        _hx_o.flags = None
        _hx_o.format = None
        _hx_o.bits = None
        _hx_o.waitLoads = None
        _hx_o.mipMap = None
        _hx_o.filter = None
        _hx_o.wrap = None
        _hx_o.realloc = None
        _hx_o.depthBuffer = None
        _hx_o._lastFrame = None
h3d_mat_Texture._hx_class = h3d_mat_Texture
_hx_classes["h3d.mat.Texture"] = h3d_mat_Texture


class h3d_mat_TextureArray(h3d_mat_Texture):
    _hx_class_name = "h3d.mat.TextureArray"
    _hx_is_interface = "False"
    __slots__ = ("layers",)
    _hx_fields = ["layers"]
    _hx_methods = ["get_layerCount", "clone", "toString"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_mat_Texture


    def __init__(self,w,h,layers,flags = None,format = None):
        self.layers = layers
        if (flags is None):
            flags = []
        flags.append(h3d_mat_TextureFlags.IsArray)
        super().__init__(w,h,flags,format)

    def get_layerCount(self):
        return self.layers

    def clone(self):
        old = self.get_lastFrame()
        self.preventAutoDispose()
        t = h3d_mat_TextureArray(self.width,self.height,self.layers,None,self.format)
        h3d_pass_Copy.run(self,t)
        self.set_lastFrame(old)
        return t

    def toString(self):
        return (((HxOverrides.stringOrNull(super().toString()) + "[") + Std.string(self.layers)) + "]")

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.layers = None
h3d_mat_TextureArray._hx_class = h3d_mat_TextureArray
_hx_classes["h3d.mat.TextureArray"] = h3d_mat_TextureArray


class h3d_pass_Base:
    _hx_class_name = "h3d.pass.Base"
    _hx_is_interface = "False"
    __slots__ = ("ctx", "name")
    _hx_fields = ["ctx", "name"]
    _hx_methods = ["compileShader", "setContext", "dispose", "draw"]

    def __init__(self,name):
        self.ctx = None
        self.name = name

    def compileShader(self,p):
        raise _HxException("Not implemented for this pass")

    def setContext(self,ctx):
        self.ctx = ctx

    def dispose(self):
        pass

    def draw(self,passes,sort = None):
        pass

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.ctx = None
        _hx_o.name = None
h3d_pass_Base._hx_class = h3d_pass_Base
_hx_classes["h3d.pass.Base"] = h3d_pass_Base


class h3d_pass_ScreenFx:
    _hx_class_name = "h3d.pass.ScreenFx"
    _hx_is_interface = "False"
    __slots__ = ("shader", "_hx_pass", "primitive", "manager", "_engine", "shaders", "buffers")
    _hx_fields = ["shader", "pass", "primitive", "manager", "_engine", "shaders", "buffers"]
    _hx_methods = ["get_engine", "copy", "setGlobals", "addShader", "removeShader", "getShader", "render", "dispose"]
    _hx_statics = ["run"]

    def __init__(self,shader,output = None):
        self.buffers = None
        self._engine = None
        self.primitive = None
        self.shader = shader
        self.shaders = hxsl_ShaderList(shader)
        self.manager = h3d_pass_ShaderManager(output)
        self._hx_pass = h3d_mat_Pass("screenfx",hxsl_ShaderList(shader))
        self._hx_pass.set_culling(h3d_mat_Face._hx_None)
        self._hx_pass.depth(False,h3d_mat_Compare.Always)

    def get_engine(self):
        if (self._engine is None):
            self._engine = h3d_Engine.CURRENT
        return self._engine

    def copy(self,src,dst):
        h3d_pass_Copy.run(src,dst)

    def setGlobals(self,ctx):
        _g = 0
        _g1 = ctx.sharedGlobals
        while (_g < len(_g1)):
            g = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            self.manager.globals.map.set(g.gid,g.value)

    def addShader(self,s):
        self.shaders = hxsl_ShaderList.addSort(s,self.shaders)
        return self._hx_pass.addShader(s)

    def removeShader(self,s):
        prev = None
        cur = self.shaders
        while (cur is not None):
            if (cur.s == s):
                if (prev is None):
                    self.shaders = cur.next
                else:
                    prev.next = cur.next
                return True
            prev = cur
            cur = cur.next
        return False

    def getShader(self,cl):
        _g_l = self.shaders
        _g_last = None
        while (_g_l != _g_last):
            s = _g_l.s
            _g_l = _g_l.next
            s1 = s
            si = Std.downcast(s1,cl)
            if (si is not None):
                return si
        return None

    def render(self):
        if (self.primitive is None):
            self.primitive = h3d_prim_Plane2D.get()
        self.shader.flipY__ = (-1 if ((self.get_engine().driver.hasFeature(h3d_impl_Feature.BottomLeftCoords) and ((self.get_engine().getCurrentTarget() is not None)))) else 1)
        rts = self.manager.compileShaders(self.shaders)
        self.get_engine().selectMaterial(self._hx_pass)
        self.get_engine().selectShader(rts)
        if (self.buffers is None):
            self.buffers = h3d_shader_Buffers(rts)
        else:
            _this = self.buffers
            _this.vertex.grow(rts.vertex)
            _this.fragment.grow(rts.fragment)
        self.manager.fillGlobals(self.buffers,rts)
        self.manager.fillParams(self.buffers,rts,self.shaders)
        self.get_engine().uploadShaderBuffers(self.buffers,0)
        self.get_engine().uploadShaderBuffers(self.buffers,1)
        self.get_engine().uploadShaderBuffers(self.buffers,2)
        self.primitive.render(self.get_engine())

    def dispose(self):
        pass

    @staticmethod
    def run(shader,output,layer = None):
        engine = h3d_Engine.CURRENT
        engine.pushTarget(output,layer)
        h3d_pass_ScreenFx(shader).render()
        engine.popTarget()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.shader = None
        _hx_o._hx_pass = None
        _hx_o.primitive = None
        _hx_o.manager = None
        _hx_o._engine = None
        _hx_o.shaders = None
        _hx_o.buffers = None
h3d_pass_ScreenFx._hx_class = h3d_pass_ScreenFx
_hx_classes["h3d.pass.ScreenFx"] = h3d_pass_ScreenFx


class h3d_pass_Blur(h3d_pass_ScreenFx):
    _hx_class_name = "h3d.pass.Blur"
    _hx_is_interface = "False"
    __slots__ = ("cubeDir", "radius", "gain", "linear", "quality", "values", "offsets")
    _hx_fields = ["cubeDir", "radius", "gain", "linear", "quality", "values", "offsets"]
    _hx_methods = ["set_radius", "set_quality", "set_gain", "set_linear", "gauss", "calcValues", "getKernelSize", "apply"]
    _hx_statics = ["__meta__"]
    _hx_interfaces = []
    _hx_super = h3d_pass_ScreenFx


    def __init__(self,radius = None,gain = None,linear = None,quality = None):
        if (radius is None):
            radius = 1.
        if (gain is None):
            gain = 1.
        if (linear is None):
            linear = 0.
        if (quality is None):
            quality = 1.
        self.offsets = None
        self.values = None
        self.quality = None
        self.linear = None
        self.gain = None
        self.radius = None
        self.cubeDir = [h3d_Matrix.L([0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 0]), h3d_Matrix.L([0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, 0]), h3d_Matrix.L([1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0]), h3d_Matrix.L([1, 0, 0, 0, 0, 0, -1, 0, 0, -1, 0, 0]), h3d_Matrix.L([1, 0, 0, 0, 0, -1, 0, 0, 0, 1, 0, 0]), h3d_Matrix.L([-1, 0, 0, 0, 0, -1, 0, 0, 0, 0, -1, 0])]
        super().__init__(h3d_shader_Blur())
        self.set_radius(radius)
        self.set_quality(quality)
        self.set_gain(gain)
        self.set_linear(linear)

    def set_radius(self,r):
        if (self.radius == r):
            return r
        self.values = None
        def _hx_local_1():
            def _hx_local_0():
                self.radius = r
                return self.radius
            return _hx_local_0()
        return _hx_local_1()

    def set_quality(self,q):
        if (self.quality == q):
            return q
        self.values = None
        def _hx_local_1():
            def _hx_local_0():
                self.quality = q
                return self.quality
            return _hx_local_0()
        return _hx_local_1()

    def set_gain(self,s):
        if (self.gain == s):
            return s
        self.values = None
        def _hx_local_1():
            def _hx_local_0():
                self.gain = s
                return self.gain
            return _hx_local_0()
        return _hx_local_1()

    def set_linear(self,b):
        if (self.linear == b):
            return b
        self.values = None
        def _hx_local_1():
            def _hx_local_0():
                self.linear = b
                return self.linear
            return _hx_local_0()
        return _hx_local_1()

    def gauss(self,x,s):
        if (s <= 0):
            if (x == 0):
                return 1
            else:
                return 0
        sq = (s * s)
        p = Math.pow(2.718281828459,(-((x * x)) / ((2 * sq))))
        v = ((2 * Math.PI) * sq)
        return (p / ((Math.NaN if ((v < 0)) else python_lib_Math.sqrt(v))))

    def calcValues(self):
        self.values = []
        self.offsets = []
        tot = 0.
        f = self.quality
        qadj = ((((0. if ((f < 0.)) else (1. if ((f > 1.)) else f))) * 0.7) + 0.3)
        width = None
        if (self.radius > 0):
            a = (self.radius - 1)
            width = Math.ceil(((((1 if ((a < 1)) else a)) * qadj) / 2))
        else:
            width = 0
        v = self.radius
        sigma = (Math.NaN if ((v < 0)) else python_lib_Math.sqrt(v))
        _g = 0
        _g1 = (width + 1)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            i1 = (i * 2)
            i2 = (0 if ((i == 0)) else ((i * 2) - 1))
            g1 = self.gauss(i1,sigma)
            g2 = self.gauss(i2,sigma)
            g = (g1 + g2)
            python_internal_ArrayImpl._set(self.values, i, g)
            python_internal_ArrayImpl._set(self.offsets, i, (0 if ((i == 0)) else ((((g1 * i1) + ((g2 * i2)))) / (((g * i) * ((Math.NaN if ((qadj < 0)) else python_lib_Math.sqrt(qadj))))))))
            tot = (tot + g)
            if (i > 0):
                tot = (tot + g)
        minVal = ((self.values[0] if 0 < len(self.values) else None) * ((0.01 / qadj)))
        while (len(self.values) > 2):
            last = python_internal_ArrayImpl._get(self.values, (len(self.values) - 1))
            if (last > minVal):
                break
            tot = (tot - ((last * 2)))
            _this = self.values
            if (len(_this) != 0):
                _this.pop()
        tot = (tot / self.gain)
        _g2 = 0
        _g3 = len(self.values)
        while (_g2 < _g3):
            i3 = _g2
            _g2 = (_g2 + 1)
            _hx_local_4 = self.values
            _hx_local_5 = i3
            _hx_local_6 = (_hx_local_4[_hx_local_5] if _hx_local_5 >= 0 and _hx_local_5 < len(_hx_local_4) else None)
            python_internal_ArrayImpl._set(_hx_local_4, _hx_local_5, (_hx_local_6 / tot))
            (_hx_local_4[_hx_local_5] if _hx_local_5 >= 0 and _hx_local_5 < len(_hx_local_4) else None)
        if (self.linear > 0):
            m = (self.gain / (((len(self.values) * 2) - 1)))
            _g4 = 0
            _g5 = len(self.values)
            while (_g4 < _g5):
                i4 = _g4
                _g4 = (_g4 + 1)
                a1 = (self.values[i4] if i4 >= 0 and i4 < len(self.values) else None)
                python_internal_ArrayImpl._set(self.values, i4, (a1 + ((self.linear * ((m - a1))))))
                a2 = (self.offsets[i4] if i4 >= 0 and i4 < len(self.offsets) else None)
                python_internal_ArrayImpl._set(self.offsets, i4, (a2 + ((self.linear * ((((0 if ((i4 == 0)) else ((((i4 * 2) - 0.5)) / ((i4 * qadj))))) - a2))))))

    def getKernelSize(self):
        if (self.values is None):
            self.calcValues()
        if (self.radius <= 0):
            return 0
        else:
            return ((len(self.values) * 2) - 1)

    def apply(self,ctx,src,output = None):
        if ((self.radius <= 0) and ((self.shader.fixedColor__ is None))):
            if (output is not None):
                h3d_pass_Copy.run(src,output)
            return
        if (output is None):
            output = src
        if (self.values is None):
            self.calcValues()
        isCube = (((src.flags & ((1 << h3d_mat_TextureFlags.Cube.index)))) != 0)
        faceCount = (6 if isCube else 1)
        tmp = ctx.textures.allocTarget((HxOverrides.stringOrNull(src.name) + "BlurTmp"),src.width,src.height,False,src.format,isCube)
        _this = self.shader
        _this.constModified = True
        _this.Quality__ = len(self.values)
        self.shader.values__ = self.values
        self.shader.offsets__ = self.offsets
        if isCube:
            self.shader.cubeTexture__ = src
            _this1 = self.shader
            _this1.constModified = True
            _this1.isCube__ = True
        else:
            self.shader.texture__ = src
            _this2 = self.shader
            _this2.constModified = True
            _this2.isCube__ = False
        _this3 = self.shader.pixel__
        x = (1 / src.width)
        y = 0
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this3.x = x
        _this3.y = y
        _this3.z = 0.
        _this3.w = 1.
        _g = 0
        _g1 = faceCount
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            self.get_engine().pushTarget(tmp,i)
            if isCube:
                self.shader.cubeDir__ = (self.cubeDir[i] if i >= 0 and i < len(self.cubeDir) else None)
            self.render()
            self.get_engine().popTarget()
        if isCube:
            self.shader.cubeTexture__ = tmp
        else:
            self.shader.texture__ = tmp
        _this4 = self.shader.pixel__
        x1 = 0
        y1 = (1 / src.height)
        if (y1 is None):
            y1 = 0.
        if (x1 is None):
            x1 = 0.
        _this4.x = x1
        _this4.y = y1
        _this4.z = 0.
        _this4.w = 1.
        outDepth = output.depthBuffer
        output.depthBuffer = None
        _g2 = 0
        _g3 = faceCount
        while (_g2 < _g3):
            i1 = _g2
            _g2 = (_g2 + 1)
            self.get_engine().pushTarget(output,i1)
            if isCube:
                self.shader.cubeDir__ = (self.cubeDir[i1] if i1 >= 0 and i1 < len(self.cubeDir) else None)
            self.render()
            self.get_engine().popTarget()
        output.depthBuffer = outDepth

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.cubeDir = None
        _hx_o.radius = None
        _hx_o.gain = None
        _hx_o.linear = None
        _hx_o.quality = None
        _hx_o.values = None
        _hx_o.offsets = None
h3d_pass_Blur._hx_class = h3d_pass_Blur
_hx_classes["h3d.pass.Blur"] = h3d_pass_Blur


class hxsl_Shader:
    _hx_class_name = "hxsl.Shader"
    _hx_is_interface = "False"
    __slots__ = ("priority", "shader", "instance", "constBits", "constModified")
    _hx_fields = ["priority", "shader", "instance", "constBits", "constModified"]
    _hx_methods = ["initialize", "setPriority", "getParamValue", "getParamFloatValue", "updateConstants", "updateConstantsFinal", "clone", "toString"]

    def __init__(self):
        self.constModified = None
        self.constBits = None
        self.instance = None
        self.shader = None
        self.priority = 0
        self.initialize()

    def initialize(self):
        self.constModified = True
        if (self.shader is not None):
            return
        cl = Type.getClass(self)
        self.shader = Reflect.field(cl,"_SHADER")
        if (self.shader is None):
            curClass = cl
            while ((curClass is not None) and ((Reflect.field(curClass,"SRC") is None))):
                curClass = Type.getSuperClass(curClass)
            if (curClass is None):
                raise _HxException((HxOverrides.stringOrNull(Type.getClassName(cl)) + " has no shader source"))
            self.shader = Reflect.field(curClass,"_SHADER")
            if (self.shader is None):
                self.shader = hxsl_SharedShader(Reflect.field(curClass,"SRC"))
                Reflect.setField(curClass,"_SHADER",self.shader)

    def setPriority(self,v):
        self.priority = v

    def getParamValue(self,index):
        raise _HxException("assert")

    def getParamFloatValue(self,index):
        raise _HxException("assert")

    def updateConstants(self,globals):
        raise _HxException("assert")

    def updateConstantsFinal(self,globals):
        c = self.shader.consts
        while (c is not None):
            if (c.globalId == 0):
                c = c.next
                continue
            v = globals.map.h.get(c.globalId,None)
            _g = c.v.type
            tmp = _g.index
            if (tmp == 1):
                v1 = v
                if (HxOverrides.rshift(v1, c.bits) != 0):
                    raise _HxException((((((("Constant " + HxOverrides.stringOrNull(c.v.name)) + " is outside range (") + Std.string(v1)) + " > ") + Std.string(((((1 << c.bits)) - 1)))) + ")"))
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.constBits
                _hx_local_0.constBits = (_hx_local_1 | ((v1 << c.pos)))
                _hx_local_0.constBits
            elif (tmp == 2):
                v2 = v
                if v2:
                    _hx_local_2 = self
                    _hx_local_3 = _hx_local_2.constBits
                    _hx_local_2.constBits = (_hx_local_3 | ((1 << c.pos)))
                    _hx_local_2.constBits
            elif (tmp == 17):
                count = _g.params[0]
                if (v is None):
                    c = c.next
                    continue
                v3 = v
                sel = v3.channel
                if (v3.texture is None):
                    sel = hxsl_Channel.Unknown
                elif ((sel is None) or ((sel == hxsl_Channel.Unknown))):
                    count1 = count
                    if (count1 == 1):
                        if (v3.texture.format == h3d_mat_Texture.nativeFormat):
                            sel = hxsl_Channel.PackedFloat
                        else:
                            raise _HxException((("Constant " + HxOverrides.stringOrNull(c.v.name)) + " does not define channel select value"))
                    elif (count1 == 3):
                        if (v3.texture.format == h3d_mat_Texture.nativeFormat):
                            sel = hxsl_Channel.PackedNormal
                        else:
                            raise _HxException((("Constant " + HxOverrides.stringOrNull(c.v.name)) + " does not define channel select value"))
                    else:
                        raise _HxException((("Constant " + HxOverrides.stringOrNull(c.v.name)) + " does not define channel select value"))
                _hx_local_4 = self
                _hx_local_5 = _hx_local_4.constBits
                _hx_local_4.constBits = (_hx_local_5 | (((((globals.allocChannelID(v3.texture) << 3) | sel.index)) << c.pos)))
                _hx_local_4.constBits
            else:
                raise _HxException("assert")
            c = c.next
        _this = self.shader
        constBits = self.constBits
        i = _this.instanceCache.h.get(constBits,None)
        self.instance = (_this.makeInstance(constBits) if ((i is None)) else i)

    def clone(self):
        return self

    def toString(self):
        return Type.getClassName(Type.getClass(self))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.priority = None
        _hx_o.shader = None
        _hx_o.instance = None
        _hx_o.constBits = None
        _hx_o.constModified = None
hxsl_Shader._hx_class = hxsl_Shader
_hx_classes["hxsl.Shader"] = hxsl_Shader


class h3d_shader_ScreenShader(hxsl_Shader):
    _hx_class_name = "h3d.shader.ScreenShader"
    _hx_is_interface = "False"
    __slots__ = ("flipY__",)
    _hx_fields = ["flipY__"]
    _hx_methods = ["get_flipY", "set_flipY", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader


    def __init__(self):
        self.flipY__ = 0
        super().__init__()

    def get_flipY(self):
        return self.flipY__

    def set_flipY(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.flipY__ = _v
                return self.flipY__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        if (index == 0):
            return self.flipY__
        return None

    def getParamFloatValue(self,index):
        if (index == 0):
            return self.flipY__
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_ScreenShader)
        s.shader = self.shader
        s.flipY__ = self.flipY__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.flipY__ = None
h3d_shader_ScreenShader._hx_class = h3d_shader_ScreenShader
_hx_classes["h3d.shader.ScreenShader"] = h3d_shader_ScreenShader


class h3d_pass__Border_BorderShader(h3d_shader_ScreenShader):
    _hx_class_name = "h3d.pass._Border.BorderShader"
    _hx_is_interface = "False"
    __slots__ = ("color__",)
    _hx_fields = ["color__"]
    _hx_methods = ["get_color", "set_color", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = h3d_shader_ScreenShader


    def __init__(self):
        self.color__ = h3d_Vector()
        super().__init__()

    def get_color(self):
        return self.color__

    def set_color(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.color__ = _v
                return self.color__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.flipY__
        elif (index1 == 1):
            return self.color__
        else:
            pass
        return None

    def getParamFloatValue(self,index):
        if (index == 0):
            return self.flipY__
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_pass__Border_BorderShader)
        s.shader = self.shader
        s.flipY__ = self.flipY__
        s.color__ = self.color__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.color__ = None
h3d_pass__Border_BorderShader._hx_class = h3d_pass__Border_BorderShader
_hx_classes["h3d.pass._Border.BorderShader"] = h3d_pass__Border_BorderShader


class h3d_pass_Border(h3d_pass_ScreenFx):
    _hx_class_name = "h3d.pass.Border"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["dispose"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_pass_ScreenFx


    def __init__(self,width,height,size = None):
        if (size is None):
            size = 1
        super().__init__(h3d_pass__Border_BorderShader())
        this1 = list()
        bbuf = this1
        bbuf.append((((0 / width) * 2) - 1))
        bbuf.append((1 - (((0 / height) * 2))))
        bbuf.append((((width / width) * 2) - 1))
        bbuf.append((1 - (((0 / height) * 2))))
        bbuf.append((((0 / width) * 2) - 1))
        bbuf.append((1 - (((size / height) * 2))))
        bbuf.append((((width / width) * 2) - 1))
        bbuf.append((1 - (((size / height) * 2))))
        bbuf.append((((0 / width) * 2) - 1))
        bbuf.append((1 - (((0 / height) * 2))))
        bbuf.append((((size / width) * 2) - 1))
        bbuf.append((1 - (((0 / height) * 2))))
        bbuf.append((((0 / width) * 2) - 1))
        bbuf.append((1 - (((height / height) * 2))))
        bbuf.append((((size / width) * 2) - 1))
        bbuf.append((1 - (((height / height) * 2))))
        bbuf.append((((0 / width) * 2) - 1))
        bbuf.append((1 - (((((height - size)) / height) * 2))))
        bbuf.append((((width / width) * 2) - 1))
        bbuf.append((1 - (((((height - size)) / height) * 2))))
        bbuf.append((((0 / width) * 2) - 1))
        bbuf.append((1 - (((height / height) * 2))))
        bbuf.append((((width / width) * 2) - 1))
        bbuf.append((1 - (((height / height) * 2))))
        bbuf.append((((((width - size)) / width) * 2) - 1))
        bbuf.append((1 - (((0 / height) * 2))))
        bbuf.append((((width / width) * 2) - 1))
        bbuf.append((1 - (((0 / height) * 2))))
        bbuf.append((((((width - size)) / width) * 2) - 1))
        bbuf.append((1 - (((height / height) * 2))))
        bbuf.append((((width / width) * 2) - 1))
        bbuf.append((1 - (((height / height) * 2))))
        self.primitive = h3d_prim_RawPrimitive(_hx_AnonObject({'vbuf': bbuf, 'stride': 2, 'quads': True}),True)
        _this = self.shader.color__
        x = 1
        y = 1
        z = 1
        w = 1
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = w

    def dispose(self):
        super().dispose()
        self.primitive.dispose()

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
h3d_pass_Border._hx_class = h3d_pass_Border
_hx_classes["h3d.pass.Border"] = h3d_pass_Border


class h3d_pass__Copy_ArrayCopyShader(h3d_shader_ScreenShader):
    _hx_class_name = "h3d.pass._Copy.ArrayCopyShader"
    _hx_is_interface = "False"
    __slots__ = ("texture__", "layer__")
    _hx_fields = ["texture__", "layer__"]
    _hx_methods = ["get_texture", "set_texture", "get_layer", "set_layer", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = h3d_shader_ScreenShader


    def __init__(self):
        self.texture__ = None
        self.layer__ = 0
        super().__init__()

    def get_texture(self):
        return self.texture__

    def set_texture(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.texture__ = _v
                return self.texture__
            return _hx_local_0()
        return _hx_local_1()

    def get_layer(self):
        return self.layer__

    def set_layer(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.layer__ = _v
                return self.layer__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.flipY__
        elif (index1 == 1):
            return self.texture__
        elif (index1 == 2):
            return self.layer__
        else:
            pass
        return None

    def getParamFloatValue(self,index):
        if (index == 0):
            return self.flipY__
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_pass__Copy_ArrayCopyShader)
        s.shader = self.shader
        s.flipY__ = self.flipY__
        s.texture__ = self.texture__
        s.layer__ = self.layer__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.texture__ = None
        _hx_o.layer__ = None
h3d_pass__Copy_ArrayCopyShader._hx_class = h3d_pass__Copy_ArrayCopyShader
_hx_classes["h3d.pass._Copy.ArrayCopyShader"] = h3d_pass__Copy_ArrayCopyShader


class h3d_pass_ArrayCopy(h3d_pass_ScreenFx):
    _hx_class_name = "h3d.pass.ArrayCopy"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["apply"]
    _hx_statics = ["run"]
    _hx_interfaces = []
    _hx_super = h3d_pass_ScreenFx


    def __init__(self):
        super().__init__(h3d_pass__Copy_ArrayCopyShader())

    def apply(self,_hx_from,fromLayer,to,blend = None,customPass = None,layer = None):
        if (to is not None):
            self.get_engine().pushTarget(to,(layer if ((layer is not None)) else 0))
        self.shader.texture__ = _hx_from
        self.shader.layer__ = fromLayer
        if (customPass is not None):
            old = self._hx_pass
            self._hx_pass = customPass
            if (blend is not None):
                self._hx_pass.setBlendMode(blend)
            h = self.shaders
            while (h.next is not None):
                h = h.next
            h.next = self._hx_pass.shaders
            self.render()
            self._hx_pass = old
            h.next = None
        else:
            self._hx_pass.setBlendMode((h2d_BlendMode._hx_None if ((blend is None)) else blend))
            self.render()
        self.shader.texture__ = None
        self.shader.layer__ = 0
        if (to is not None):
            self.get_engine().popTarget()

    @staticmethod
    def run(_hx_from,fromLayer,to,blend = None,_hx_pass = None,layer = None):
        engine = h3d_Engine.CURRENT
        if (((((to is not None) and ((_hx_from is not None))) and (((blend is None) or ((blend == h2d_BlendMode._hx_None))))) and ((_hx_pass is None))) and engine.driver.copyTexture(_hx_from,to)):
            return
        inst = engine.resCache.h.get(h3d_pass_ArrayCopy,None)
        if (inst is None):
            inst = h3d_pass_ArrayCopy()
            engine.resCache.set(h3d_pass_ArrayCopy,inst)
        inst.apply(_hx_from,fromLayer,to,blend,_hx_pass,layer)
        return

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
h3d_pass_ArrayCopy._hx_class = h3d_pass_ArrayCopy
_hx_classes["h3d.pass.ArrayCopy"] = h3d_pass_ArrayCopy


class h3d_pass__Copy_CopyShader(h3d_shader_ScreenShader):
    _hx_class_name = "h3d.pass._Copy.CopyShader"
    _hx_is_interface = "False"
    __slots__ = ("texture__",)
    _hx_fields = ["texture__"]
    _hx_methods = ["get_texture", "set_texture", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = h3d_shader_ScreenShader


    def __init__(self):
        self.texture__ = None
        super().__init__()

    def get_texture(self):
        return self.texture__

    def set_texture(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.texture__ = _v
                return self.texture__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.flipY__
        elif (index1 == 1):
            return self.texture__
        else:
            pass
        return None

    def getParamFloatValue(self,index):
        if (index == 0):
            return self.flipY__
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_pass__Copy_CopyShader)
        s.shader = self.shader
        s.flipY__ = self.flipY__
        s.texture__ = self.texture__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.texture__ = None
h3d_pass__Copy_CopyShader._hx_class = h3d_pass__Copy_CopyShader
_hx_classes["h3d.pass._Copy.CopyShader"] = h3d_pass__Copy_CopyShader


class h3d_pass_Copy(h3d_pass_ScreenFx):
    _hx_class_name = "h3d.pass.Copy"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["apply"]
    _hx_statics = ["run"]
    _hx_interfaces = []
    _hx_super = h3d_pass_ScreenFx


    def __init__(self):
        super().__init__(h3d_pass__Copy_CopyShader())

    def apply(self,_hx_from,to,blend = None,customPass = None,layer = None):
        if (to is not None):
            self.get_engine().pushTarget(to,(layer if ((layer is not None)) else 0))
        self.shader.texture__ = _hx_from
        if (customPass is not None):
            old = self._hx_pass
            self._hx_pass = customPass
            if (blend is not None):
                self._hx_pass.setBlendMode(blend)
            h = self.shaders
            while (h.next is not None):
                h = h.next
            h.next = self._hx_pass.shaders
            self.render()
            self._hx_pass = old
            h.next = None
        else:
            self._hx_pass.setBlendMode((h2d_BlendMode._hx_None if ((blend is None)) else blend))
            self.render()
        self.shader.texture__ = None
        if (to is not None):
            self.get_engine().popTarget()

    @staticmethod
    def run(_hx_from,to,blend = None,_hx_pass = None,layer = None):
        engine = h3d_Engine.CURRENT
        if (((((to is not None) and ((_hx_from is not None))) and (((blend is None) or ((blend == h2d_BlendMode._hx_None))))) and ((_hx_pass is None))) and engine.driver.copyTexture(_hx_from,to)):
            return
        inst = engine.resCache.h.get(h3d_pass_Copy,None)
        if (inst is None):
            inst = h3d_pass_Copy()
            engine.resCache.set(h3d_pass_Copy,inst)
        inst.apply(_hx_from,to,blend,_hx_pass,layer)
        return

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
h3d_pass_Copy._hx_class = h3d_pass_Copy
_hx_classes["h3d.pass.Copy"] = h3d_pass_Copy


class h3d_pass__CubeCopy_CubeCopyShader(h3d_shader_ScreenShader):
    _hx_class_name = "h3d.pass._CubeCopy.CubeCopyShader"
    _hx_is_interface = "False"
    __slots__ = ("texture__", "mat__")
    _hx_fields = ["texture__", "mat__"]
    _hx_methods = ["get_texture", "set_texture", "get_mat", "set_mat", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = h3d_shader_ScreenShader


    def __init__(self):
        self.texture__ = None
        self.mat__ = h3d_Matrix()
        super().__init__()

    def get_texture(self):
        return self.texture__

    def set_texture(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.texture__ = _v
                return self.texture__
            return _hx_local_0()
        return _hx_local_1()

    def get_mat(self):
        return self.mat__

    def set_mat(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.mat__ = _v
                return self.mat__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.flipY__
        elif (index1 == 1):
            return self.texture__
        elif (index1 == 2):
            return self.mat__
        else:
            pass
        return None

    def getParamFloatValue(self,index):
        if (index == 0):
            return self.flipY__
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_pass__CubeCopy_CubeCopyShader)
        s.shader = self.shader
        s.flipY__ = self.flipY__
        s.texture__ = self.texture__
        s.mat__ = self.mat__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.texture__ = None
        _hx_o.mat__ = None
h3d_pass__CubeCopy_CubeCopyShader._hx_class = h3d_pass__CubeCopy_CubeCopyShader
_hx_classes["h3d.pass._CubeCopy.CubeCopyShader"] = h3d_pass__CubeCopy_CubeCopyShader


class h3d_pass_CubeCopy(h3d_pass_ScreenFx):
    _hx_class_name = "h3d.pass.CubeCopy"
    _hx_is_interface = "False"
    __slots__ = ("cubeDir",)
    _hx_fields = ["cubeDir"]
    _hx_methods = ["apply"]
    _hx_statics = ["run"]
    _hx_interfaces = []
    _hx_super = h3d_pass_ScreenFx


    def __init__(self):
        self.cubeDir = [h3d_Matrix.L([0, 0, -1, 0, 0, -1, 0, 0, 1, 0, 0, 0]), h3d_Matrix.L([0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, 0]), h3d_Matrix.L([1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0]), h3d_Matrix.L([1, 0, 0, 0, 0, 0, -1, 0, 0, -1, 0, 0]), h3d_Matrix.L([1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1, 0]), h3d_Matrix.L([-1, 0, 0, 0, 0, -1, 0, 0, 0, 0, -1, 0])]
        super().__init__(h3d_pass__CubeCopy_CubeCopyShader())

    def apply(self,_hx_from,to,blend = None,customPass = None):
        self.shader.texture__ = _hx_from
        _g = 0
        while (_g < 6):
            i = _g
            _g = (_g + 1)
            if (to is not None):
                self.get_engine().pushTarget(to,i)
            self.shader.mat__ = (self.cubeDir[i] if i >= 0 and i < len(self.cubeDir) else None)
            if (customPass is not None):
                old = self._hx_pass
                self._hx_pass = customPass
                if (blend is not None):
                    self._hx_pass.setBlendMode(blend)
                h = self.shaders
                while (h.next is not None):
                    h = h.next
                h.next = self._hx_pass.shaders
                self.render()
                self._hx_pass = old
                h.next = None
            else:
                self._hx_pass.setBlendMode((h2d_BlendMode._hx_None if ((blend is None)) else blend))
                self.render()
            if (to is not None):
                self.get_engine().popTarget()
        self.shader.texture__ = None

    @staticmethod
    def run(_hx_from,to,blend = None,_hx_pass = None):
        engine = h3d_Engine.CURRENT
        if (((((to is not None) and ((_hx_from is not None))) and (((blend is None) or ((blend == h2d_BlendMode._hx_None))))) and ((_hx_pass is None))) and engine.driver.copyTexture(_hx_from,to)):
            return
        inst = engine.resCache.h.get(h3d_pass_CubeCopy,None)
        if (inst is None):
            inst = h3d_pass_CubeCopy()
            engine.resCache.set(h3d_pass_CubeCopy,inst)
        inst.apply(_hx_from,to,blend,_hx_pass)
        return

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.cubeDir = None
h3d_pass_CubeCopy._hx_class = h3d_pass_CubeCopy
_hx_classes["h3d.pass.CubeCopy"] = h3d_pass_CubeCopy


class h3d_pass_Default(h3d_pass_Base):
    _hx_class_name = "h3d.pass.Default"
    _hx_is_interface = "False"
    __slots__ = ("manager", "defaultSort", "cameraView_id", "cameraNear_id", "cameraFar_id", "cameraProj_id", "cameraPos_id", "cameraProjDiag_id", "cameraProjFlip_id", "cameraViewProj_id", "cameraInverseViewProj_id", "globalTime_id", "pixelSize_id", "globalModelView_id", "globalModelViewInverse_id")
    _hx_fields = ["manager", "defaultSort", "cameraView_id", "cameraNear_id", "cameraFar_id", "cameraProj_id", "cameraPos_id", "cameraProjDiag_id", "cameraProjFlip_id", "cameraViewProj_id", "cameraInverseViewProj_id", "globalTime_id", "pixelSize_id", "globalModelView_id", "globalModelViewInverse_id"]
    _hx_methods = ["get_globals", "getOutputs", "compileShader", "processShaders", "setupShaders", "log", "drawObject", "draw", "get_cameraView", "set_cameraView", "get_cameraNear", "set_cameraNear", "get_cameraFar", "set_cameraFar", "get_cameraProj", "set_cameraProj", "get_cameraPos", "set_cameraPos", "get_cameraProjDiag", "set_cameraProjDiag", "get_cameraProjFlip", "set_cameraProjFlip", "get_cameraViewProj", "set_cameraViewProj", "get_cameraInverseViewProj", "set_cameraInverseViewProj", "get_globalTime", "set_globalTime", "get_pixelSize", "set_pixelSize", "get_globalModelView", "set_globalModelView", "get_globalModelViewInverse", "set_globalModelViewInverse", "initGlobals", "setGlobals"]
    _hx_statics = ["__meta__"]
    _hx_interfaces = []
    _hx_super = h3d_pass_Base


    def __init__(self,name):
        self.globalModelViewInverse_id = None
        self.globalModelView_id = None
        self.pixelSize_id = None
        self.globalTime_id = None
        self.cameraInverseViewProj_id = None
        self.cameraViewProj_id = None
        self.cameraProjFlip_id = None
        self.cameraProjDiag_id = None
        self.cameraPos_id = None
        self.cameraProj_id = None
        self.cameraFar_id = None
        self.cameraNear_id = None
        self.cameraView_id = None
        self.manager = None
        self.defaultSort = h3d_pass_SortByMaterial().sort
        super().__init__(name)
        self.manager = h3d_pass_ShaderManager(self.getOutputs())
        self.initGlobals()

    def get_globals(self):
        return self.manager.globals

    def getOutputs(self):
        return [hxsl_Output.Value("output.color")]

    def compileShader(self,p):
        o = h3d_pass_PassObject()
        o._hx_pass = p
        self.setupShaders(h3d_pass_PassList(o))
        return self.manager.compileShaders(o.shaders,p.batchMode)

    def processShaders(self,p,shaders):
        p1 = self.ctx.extraShaders
        while (p1 is not None):
            shaders = self.ctx.allocShaderList(p1.s,shaders)
            p1 = p1.next
        return shaders

    def setupShaders(self,passes):
        lightInit = False
        _g_o = passes.current
        while (_g_o is not None):
            tmp = _g_o
            _g_o = _g_o.next
            p = tmp
            shaders = p._hx_pass.getShadersRec()
            shaders = self.processShaders(p,shaders)
            if (p._hx_pass.enableLights and ((self.ctx.lightSystem is not None))):
                if (not lightInit):
                    self.ctx.lightSystem.initGlobals(self.manager.globals)
                    lightInit = True
                shaders = self.ctx.lightSystem.computeLight(p.obj,shaders)
            p.shader = self.manager.compileShaders(shaders,p._hx_pass.batchMode)
            p.shaders = shaders
            t = p.shader.fragment.textures
            if (t is None):
                p.texture = 0
            else:
                _this = self.manager
                opt = True
                if (opt is None):
                    opt = False
                t1 = None
                if (t.perObjectGlobal is not None):
                    v = _this.globals.map.h.get(t.perObjectGlobal.gid,None)
                    if (v is None):
                        raise _HxException(((("Missing global value " + HxOverrides.stringOrNull(t.perObjectGlobal.path)) + " for shader ") + HxOverrides.stringOrNull(_this.shaderInfo(shaders,t.perObjectGlobal.path))))
                    _g = t.type
                    t2 = None
                    if (_g.index == 17):
                        _g1 = _g.params[0]
                        t2 = True
                    else:
                        t2 = False
                    t1 = (Reflect.field(v,"texture") if t2 else v)
                else:
                    si = shaders
                    n = t.instance
                    while True:
                        n = (n - 1)
                        t3 = n
                        if (not ((t3 > 0))):
                            break
                        si = si.next
                    v1 = si.s.getParamValue(t.index)
                    if ((v1 is None) and (not opt)):
                        raise _HxException(((("Missing param value " + Std.string(si.s)) + ".") + HxOverrides.stringOrNull(t.name)))
                    t1 = v1
                p.texture = (0 if ((t1 is None)) else t1.id)

    def log(self,_hx_str):
        pass

    def drawObject(self,p):
        self.ctx.drawPass = p
        self.ctx.engine.selectMaterial(p._hx_pass)
        p.obj.draw(self.ctx)

    def draw(self,passes,sort = None):
        if (passes.current is None):
            return
        _g = 0
        _g1 = self.ctx.sharedGlobals
        while (_g < len(_g1)):
            g = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            self.manager.globals.map.set(g.gid,g.value)
        self.setGlobals()
        self.setupShaders(passes)
        if (sort is None):
            self.defaultSort(passes)
        else:
            sort(passes)
        self.ctx.currentManager = self.manager
        buf = self.ctx.shaderBuffers
        prevShader = None
        _g2_o = passes.current
        while (_g2_o is not None):
            tmp = _g2_o
            _g2_o = _g2_o.next
            p = tmp
            v = p.obj.absPos
            self.manager.globals.map.set(self.globalModelView_id,v)
            if (self.globalModelViewInverse_id in p.shader.globals.h):
                v1 = p.obj.getInvPos()
                self.manager.globals.map.set(self.globalModelViewInverse_id,v1)
            if (prevShader != p.shader):
                prevShader = p.shader
                self.ctx.engine.selectShader(p.shader)
                if (buf is None):
                    def _hx_local_1():
                        self.ctx.shaderBuffers = h3d_shader_Buffers(p.shader)
                        return self.ctx.shaderBuffers
                    buf = _hx_local_1()
                else:
                    s = p.shader
                    buf.vertex.grow(s.vertex)
                    buf.fragment.grow(s.fragment)
                self.manager.fillGlobals(buf,p.shader)
                self.ctx.engine.uploadShaderBuffers(buf,0)
            if (not p._hx_pass.dynamicParameters):
                self.manager.fillParams(buf,p.shader,p.shaders)
                self.ctx.engine.uploadShaderBuffers(buf,1)
                self.ctx.engine.uploadShaderBuffers(buf,2)
                self.ctx.engine.uploadShaderBuffers(buf,3)
            self.drawObject(p)
        _this = self.ctx
        _this.cachedPos = 0
        _this.drawPass = None

    def get_cameraView(self):
        return self.manager.globals.map.h.get(self.cameraView_id,None)

    def set_cameraView(self,v):
        self.manager.globals.map.set(self.cameraView_id,v)
        return v

    def get_cameraNear(self):
        return self.manager.globals.map.h.get(self.cameraNear_id,None)

    def set_cameraNear(self,v):
        self.manager.globals.map.set(self.cameraNear_id,v)
        return v

    def get_cameraFar(self):
        return self.manager.globals.map.h.get(self.cameraFar_id,None)

    def set_cameraFar(self,v):
        self.manager.globals.map.set(self.cameraFar_id,v)
        return v

    def get_cameraProj(self):
        return self.manager.globals.map.h.get(self.cameraProj_id,None)

    def set_cameraProj(self,v):
        self.manager.globals.map.set(self.cameraProj_id,v)
        return v

    def get_cameraPos(self):
        return self.manager.globals.map.h.get(self.cameraPos_id,None)

    def set_cameraPos(self,v):
        self.manager.globals.map.set(self.cameraPos_id,v)
        return v

    def get_cameraProjDiag(self):
        return self.manager.globals.map.h.get(self.cameraProjDiag_id,None)

    def set_cameraProjDiag(self,v):
        self.manager.globals.map.set(self.cameraProjDiag_id,v)
        return v

    def get_cameraProjFlip(self):
        return self.manager.globals.map.h.get(self.cameraProjFlip_id,None)

    def set_cameraProjFlip(self,v):
        self.manager.globals.map.set(self.cameraProjFlip_id,v)
        return v

    def get_cameraViewProj(self):
        return self.manager.globals.map.h.get(self.cameraViewProj_id,None)

    def set_cameraViewProj(self,v):
        self.manager.globals.map.set(self.cameraViewProj_id,v)
        return v

    def get_cameraInverseViewProj(self):
        return self.manager.globals.map.h.get(self.cameraInverseViewProj_id,None)

    def set_cameraInverseViewProj(self,v):
        self.manager.globals.map.set(self.cameraInverseViewProj_id,v)
        return v

    def get_globalTime(self):
        return self.manager.globals.map.h.get(self.globalTime_id,None)

    def set_globalTime(self,v):
        self.manager.globals.map.set(self.globalTime_id,v)
        return v

    def get_pixelSize(self):
        return self.manager.globals.map.h.get(self.pixelSize_id,None)

    def set_pixelSize(self,v):
        self.manager.globals.map.set(self.pixelSize_id,v)
        return v

    def get_globalModelView(self):
        return self.manager.globals.map.h.get(self.globalModelView_id,None)

    def set_globalModelView(self,v):
        self.manager.globals.map.set(self.globalModelView_id,v)
        return v

    def get_globalModelViewInverse(self):
        return self.manager.globals.map.h.get(self.globalModelViewInverse_id,None)

    def set_globalModelViewInverse(self,v):
        self.manager.globals.map.set(self.globalModelViewInverse_id,v)
        return v

    def initGlobals(self):
        this1 = hxsl_Globals.allocID("camera.view")
        self.cameraView_id = this1
        this2 = hxsl_Globals.allocID("camera.zNear")
        self.cameraNear_id = this2
        this3 = hxsl_Globals.allocID("camera.zFar")
        self.cameraFar_id = this3
        this4 = hxsl_Globals.allocID("camera.proj")
        self.cameraProj_id = this4
        this5 = hxsl_Globals.allocID("camera.position")
        self.cameraPos_id = this5
        this6 = hxsl_Globals.allocID("camera.projDiag")
        self.cameraProjDiag_id = this6
        this7 = hxsl_Globals.allocID("camera.projFlip")
        self.cameraProjFlip_id = this7
        this8 = hxsl_Globals.allocID("camera.viewProj")
        self.cameraViewProj_id = this8
        this9 = hxsl_Globals.allocID("camera.inverseViewProj")
        self.cameraInverseViewProj_id = this9
        this10 = hxsl_Globals.allocID("global.time")
        self.globalTime_id = this10
        this11 = hxsl_Globals.allocID("global.pixelSize")
        self.pixelSize_id = this11
        this12 = hxsl_Globals.allocID("global.modelView")
        self.globalModelView_id = this12
        this13 = hxsl_Globals.allocID("global.modelViewInverse")
        self.globalModelViewInverse_id = this13

    def setGlobals(self):
        v = self.ctx.camera.mcam
        self.manager.globals.map.set(self.cameraView_id,v)
        v1 = self.ctx.camera.zNear
        self.manager.globals.map.set(self.cameraNear_id,v1)
        v2 = self.ctx.camera.zFar
        self.manager.globals.map.set(self.cameraFar_id,v2)
        v3 = self.ctx.camera.mproj
        self.manager.globals.map.set(self.cameraProj_id,v3)
        v4 = self.ctx.camera.pos
        self.manager.globals.map.set(self.cameraPos_id,v4)
        v5 = h3d_Vector(self.ctx.camera.mproj._11,self.ctx.camera.mproj._22,self.ctx.camera.mproj._33,self.ctx.camera.mproj._44)
        self.manager.globals.map.set(self.cameraProjDiag_id,v5)
        v6 = (-1 if ((self.ctx.engine.driver.hasFeature(h3d_impl_Feature.BottomLeftCoords) and ((self.ctx.engine.getCurrentTarget() is not None)))) else 1)
        self.manager.globals.map.set(self.cameraProjFlip_id,v6)
        v7 = self.ctx.camera.m
        self.manager.globals.map.set(self.cameraViewProj_id,v7)
        v8 = self.ctx.camera.getInverseViewProj()
        self.manager.globals.map.set(self.cameraInverseViewProj_id,v8)
        v9 = self.ctx.time
        self.manager.globals.map.set(self.globalTime_id,v9)
        v10 = h3d_Vector((2 / self.ctx.engine.width),(2 / self.ctx.engine.height))
        self.manager.globals.map.set(self.pixelSize_id,v10)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.manager = None
        _hx_o.defaultSort = None
        _hx_o.cameraView_id = None
        _hx_o.cameraNear_id = None
        _hx_o.cameraFar_id = None
        _hx_o.cameraProj_id = None
        _hx_o.cameraPos_id = None
        _hx_o.cameraProjDiag_id = None
        _hx_o.cameraProjFlip_id = None
        _hx_o.cameraViewProj_id = None
        _hx_o.cameraInverseViewProj_id = None
        _hx_o.globalTime_id = None
        _hx_o.pixelSize_id = None
        _hx_o.globalModelView_id = None
        _hx_o.globalModelViewInverse_id = None
h3d_pass_Default._hx_class = h3d_pass_Default
_hx_classes["h3d.pass.Default"] = h3d_pass_Default


class h3d_pass_Shadows(h3d_pass_Default):
    _hx_class_name = "h3d.pass.Shadows"
    _hx_is_interface = "False"
    __slots__ = ("lightCamera", "format", "staticTexture", "light", "enabled", "mode", "size", "shader", "blur", "samplingKind", "power", "bias", "pcfQuality", "pcfScale")
    _hx_fields = ["lightCamera", "format", "staticTexture", "light", "enabled", "mode", "size", "shader", "blur", "samplingKind", "power", "bias", "pcfQuality", "pcfScale"]
    _hx_methods = ["set_mode", "set_enabled", "set_size", "dispose", "getShadowProj", "getShadowTex", "isUsingWorldDist", "getOutputs", "loadStaticData", "saveStaticData", "computeStatic", "createDefaultShadowMap", "syncShader", "filterPasses", "cullPasses"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_pass_Default


    def __init__(self,light):
        self.blur = None
        self.shader = None
        self.light = None
        self.staticTexture = None
        self.format = None
        self.lightCamera = None
        self.pcfScale = 1.0
        self.pcfQuality = 1
        self.bias = 0.01
        self.power = 30.0
        self.samplingKind = h3d_pass_ShadowSamplingKind._hx_None
        self.size = 1024
        self.mode = h3d_pass_RenderMode._hx_None
        self.enabled = True
        if (self.format is None):
            self.format = hxd_PixelFormat.R16F
        if (not h3d_Engine.CURRENT.driver.isSupportedFormat(self.format)):
            self.format = h3d_mat_Texture.nativeFormat
        super().__init__("shadow")
        self.light = light
        self.blur = h3d_pass_Blur(5)
        self.blur.set_quality(0.5)
        _this = self.blur.shader
        _this.constModified = True
        _this.isDepth__ = (self.format == h3d_mat_Texture.nativeFormat)

    def set_mode(self,m):
        if (m != h3d_pass_RenderMode._hx_None):
            raise _HxException(((("Shadow mode " + Std.string(m)) + " not supported for ") + Std.string(self.light)))
        def _hx_local_1():
            def _hx_local_0():
                self.mode = m
                return self.mode
            return _hx_local_0()
        return _hx_local_1()

    def set_enabled(self,b):
        def _hx_local_1():
            def _hx_local_0():
                self.enabled = b
                return self.enabled
            return _hx_local_0()
        return _hx_local_1()

    def set_size(self,s):
        if ((s != self.size) and ((self.staticTexture is not None))):
            self.staticTexture.dispose()
            self.staticTexture = None
        def _hx_local_1():
            def _hx_local_0():
                self.size = s
                return self.size
            return _hx_local_0()
        return _hx_local_1()

    def dispose(self):
        super().dispose()
        self.blur.dispose()
        if (self.staticTexture is not None):
            self.staticTexture.dispose()

    def getShadowProj(self):
        return self.lightCamera.m

    def getShadowTex(self):
        return None

    def isUsingWorldDist(self):
        return False

    def getOutputs(self):
        if self.isUsingWorldDist():
            return [hxsl_Output.Swiz(hxsl_Output.Value("output.worldDist",1),[hxsl_Component.X, hxsl_Component.X, hxsl_Component.X, hxsl_Component.X])]
        if (self.format == h3d_mat_Texture.nativeFormat):
            return [hxsl_Output.PackFloat(hxsl_Output.Value("output.depth"))]
        return [hxsl_Output.Swiz(hxsl_Output.Value("output.depth",1),[hxsl_Component.X, hxsl_Component.X, hxsl_Component.X, hxsl_Component.X])]

    def loadStaticData(self,_hx_bytes):
        return False

    def saveStaticData(self):
        return None

    def computeStatic(self,passes):
        raise _HxException("Not implemented")

    def createDefaultShadowMap(self):
        tex = h3d_mat_Texture.fromColor(16777215)
        tex.name = "defaultShadowMap"
        return tex

    def syncShader(self,texture):
        pass

    def filterPasses(self,passes):
        if (not self.ctx.computingStatic):
            tmp = self.mode.index
            if (tmp == 0):
                return False
            elif (tmp == 1):
                tmp1 = None
                if (self.staticTexture is not None):
                    _this = self.staticTexture
                    tmp1 = ((_this.t is None) and ((_this.realloc is None)))
                else:
                    tmp1 = True
                if tmp1:
                    self.staticTexture = self.createDefaultShadowMap()
                self.syncShader(self.staticTexture)
                return False
            elif (tmp == 2):
                return True
            elif (tmp == 3):
                tmp2 = None
                if (self.staticTexture is not None):
                    _this1 = self.staticTexture
                    tmp2 = ((_this1.t is None) and ((_this1.realloc is None)))
                else:
                    tmp2 = True
                if tmp2:
                    self.staticTexture = self.createDefaultShadowMap()
                return True
            else:
                pass
        else:
            tmp3 = self.mode.index
            if (tmp3 == 0):
                return False
            elif (tmp3 == 1):
                head = None
                prev = None
                disc = passes.discarded
                discQueue = passes.lastDisc
                cur = passes.current
                while (cur is not None):
                    if (cur._hx_pass.isStatic == True):
                        if (head is None):
                            prev = cur
                            head = prev
                        else:
                            prev.next = cur
                            prev = cur
                    elif (disc is None):
                        discQueue = cur
                        disc = discQueue
                    else:
                        discQueue.next = cur
                        discQueue = cur
                    cur = cur.next
                if (prev is not None):
                    prev.next = None
                if (discQueue is not None):
                    discQueue.next = None
                passes.current = head
                passes.discarded = disc
                passes.lastDisc = discQueue
                return True
            elif (tmp3 == 2):
                return False
            elif (tmp3 == 3):
                head1 = None
                prev1 = None
                disc1 = passes.discarded
                discQueue1 = passes.lastDisc
                cur1 = passes.current
                while (cur1 is not None):
                    if (cur1._hx_pass.isStatic == True):
                        if (head1 is None):
                            prev1 = cur1
                            head1 = prev1
                        else:
                            prev1.next = cur1
                            prev1 = cur1
                    elif (disc1 is None):
                        discQueue1 = cur1
                        disc1 = discQueue1
                    else:
                        discQueue1.next = cur1
                        discQueue1 = cur1
                    cur1 = cur1.next
                if (prev1 is not None):
                    prev1.next = None
                if (discQueue1 is not None):
                    discQueue1.next = None
                passes.current = head1
                passes.discarded = disc1
                passes.lastDisc = discQueue1
                return True
            else:
                pass

    def cullPasses(self,passes,f):
        prevCollider = None
        prevResult = True
        head = None
        prev = None
        disc = passes.discarded
        discQueue = passes.lastDisc
        cur = passes.current
        while (cur is not None):
            col = cur.obj.cullingCollider
            tmp = None
            if (col is None):
                tmp = True
            else:
                if (col != prevCollider):
                    prevCollider = col
                    prevResult = f(col)
                tmp = prevResult
            if tmp:
                if (head is None):
                    prev = cur
                    head = prev
                else:
                    prev.next = cur
                    prev = cur
            elif (disc is None):
                discQueue = cur
                disc = discQueue
            else:
                discQueue.next = cur
                discQueue = cur
            cur = cur.next
        if (prev is not None):
            prev.next = None
        if (discQueue is not None):
            discQueue.next = None
        passes.current = head
        passes.discarded = disc
        passes.lastDisc = discQueue

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.lightCamera = None
        _hx_o.format = None
        _hx_o.staticTexture = None
        _hx_o.light = None
        _hx_o.enabled = None
        _hx_o.mode = None
        _hx_o.size = None
        _hx_o.shader = None
        _hx_o.blur = None
        _hx_o.samplingKind = None
        _hx_o.power = None
        _hx_o.bias = None
        _hx_o.pcfQuality = None
        _hx_o.pcfScale = None
h3d_pass_Shadows._hx_class = h3d_pass_Shadows
_hx_classes["h3d.pass.Shadows"] = h3d_pass_Shadows


class h3d_pass_DirShadowMap(h3d_pass_Shadows):
    _hx_class_name = "h3d.pass.DirShadowMap"
    _hx_is_interface = "False"
    _hx_fields = ["customDepth", "depth", "dshader", "border", "mergePass"]
    _hx_methods = ["set_mode", "set_enabled", "set_size", "dispose", "getShadowTex", "calcShadowBounds", "setGlobals", "syncShader", "saveStaticData", "loadStaticData", "draw", "computeStatic"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_pass_Shadows


    def __init__(self,light):
        self.border = None
        self.dshader = None
        self.depth = None
        self.customDepth = None
        self.mergePass = h3d_pass_ScreenFx(h3d_shader_MinMaxShader())
        super().__init__(light)
        self.lightCamera = h3d_Camera()
        self.lightCamera.orthoBounds = h3d_col_Bounds()
        def _hx_local_0():
            self.dshader = h3d_shader_DirShadow()
            return self.dshader
        self.shader = _hx_local_0()
        self.border = h3d_pass_Border(self.size,self.size)
        self.customDepth = h3d_Engine.CURRENT.driver.hasFeature(h3d_impl_Feature.AllocDepthBuffer)
        if (not self.customDepth):
            self.depth = h3d_mat_DepthBuffer.getDefault()

    def set_mode(self,m):
        _this = self.dshader
        _this.constModified = True
        _this.enable__ = (m != h3d_pass_RenderMode._hx_None)
        def _hx_local_1():
            def _hx_local_0():
                self.mode = m
                return self.mode
            return _hx_local_0()
        return _hx_local_1()

    def set_enabled(self,b):
        _this = self.dshader
        _this.constModified = True
        _this.enable__ = (b and ((self.mode != h3d_pass_RenderMode._hx_None)))
        def _hx_local_1():
            def _hx_local_0():
                self.enabled = b
                return self.enabled
            return _hx_local_0()
        return _hx_local_1()

    def set_size(self,s):
        if ((self.border is not None) and ((self.size != s))):
            self.border.dispose()
            self.border = h3d_pass_Border(s,s)
        return super().set_size(s)

    def dispose(self):
        super().dispose()
        if (self.customDepth and ((self.depth is not None))):
            self.depth.dispose()
        self.border.dispose()

    def getShadowTex(self):
        return self.dshader.shadowMap__

    def calcShadowBounds(self,camera):
        bounds = camera.orthoBounds
        mtmp = h3d_Matrix()
        def _hx_local_0(m):
            if ((m.primitive is None) or (not m.material.castShadows)):
                return
            b = m.primitive.getBounds()
            if (b.xMin > b.xMax):
                return
            tmp = m.getAbsPos()
            mtmp.multiply3x4(tmp,camera.mcam)
            x = b.xMin
            y = b.yMin
            z = b.zMin
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            p_x = x
            p_y = y
            p_z = z
            px = ((((p_x * mtmp._11) + ((p_y * mtmp._21))) + ((p_z * mtmp._31))) + mtmp._41)
            py = ((((p_x * mtmp._12) + ((p_y * mtmp._22))) + ((p_z * mtmp._32))) + mtmp._42)
            pz = ((((p_x * mtmp._13) + ((p_y * mtmp._23))) + ((p_z * mtmp._33))) + mtmp._43)
            p_x = px
            p_y = py
            p_z = pz
            if (p_x < bounds.xMin):
                bounds.xMin = p_x
            if (p_x > bounds.xMax):
                bounds.xMax = p_x
            if (p_y < bounds.yMin):
                bounds.yMin = p_y
            if (p_y > bounds.yMax):
                bounds.yMax = p_y
            if (p_z < bounds.zMin):
                bounds.zMin = p_z
            if (p_z > bounds.zMax):
                bounds.zMax = p_z
            x1 = b.xMin
            y1 = b.yMin
            z1 = b.zMax
            if (z1 is None):
                z1 = 0.
            if (y1 is None):
                y1 = 0.
            if (x1 is None):
                x1 = 0.
            p_x1 = x1
            p_y1 = y1
            p_z1 = z1
            px1 = ((((p_x1 * mtmp._11) + ((p_y1 * mtmp._21))) + ((p_z1 * mtmp._31))) + mtmp._41)
            py1 = ((((p_x1 * mtmp._12) + ((p_y1 * mtmp._22))) + ((p_z1 * mtmp._32))) + mtmp._42)
            pz1 = ((((p_x1 * mtmp._13) + ((p_y1 * mtmp._23))) + ((p_z1 * mtmp._33))) + mtmp._43)
            p_x1 = px1
            p_y1 = py1
            p_z1 = pz1
            if (p_x1 < bounds.xMin):
                bounds.xMin = p_x1
            if (p_x1 > bounds.xMax):
                bounds.xMax = p_x1
            if (p_y1 < bounds.yMin):
                bounds.yMin = p_y1
            if (p_y1 > bounds.yMax):
                bounds.yMax = p_y1
            if (p_z1 < bounds.zMin):
                bounds.zMin = p_z1
            if (p_z1 > bounds.zMax):
                bounds.zMax = p_z1
            x2 = b.xMin
            y2 = b.yMax
            z2 = b.zMin
            if (z2 is None):
                z2 = 0.
            if (y2 is None):
                y2 = 0.
            if (x2 is None):
                x2 = 0.
            p_x2 = x2
            p_y2 = y2
            p_z2 = z2
            px2 = ((((p_x2 * mtmp._11) + ((p_y2 * mtmp._21))) + ((p_z2 * mtmp._31))) + mtmp._41)
            py2 = ((((p_x2 * mtmp._12) + ((p_y2 * mtmp._22))) + ((p_z2 * mtmp._32))) + mtmp._42)
            pz2 = ((((p_x2 * mtmp._13) + ((p_y2 * mtmp._23))) + ((p_z2 * mtmp._33))) + mtmp._43)
            p_x2 = px2
            p_y2 = py2
            p_z2 = pz2
            if (p_x2 < bounds.xMin):
                bounds.xMin = p_x2
            if (p_x2 > bounds.xMax):
                bounds.xMax = p_x2
            if (p_y2 < bounds.yMin):
                bounds.yMin = p_y2
            if (p_y2 > bounds.yMax):
                bounds.yMax = p_y2
            if (p_z2 < bounds.zMin):
                bounds.zMin = p_z2
            if (p_z2 > bounds.zMax):
                bounds.zMax = p_z2
            x3 = b.xMin
            y3 = b.yMax
            z3 = b.zMax
            if (z3 is None):
                z3 = 0.
            if (y3 is None):
                y3 = 0.
            if (x3 is None):
                x3 = 0.
            p_x3 = x3
            p_y3 = y3
            p_z3 = z3
            px3 = ((((p_x3 * mtmp._11) + ((p_y3 * mtmp._21))) + ((p_z3 * mtmp._31))) + mtmp._41)
            py3 = ((((p_x3 * mtmp._12) + ((p_y3 * mtmp._22))) + ((p_z3 * mtmp._32))) + mtmp._42)
            pz3 = ((((p_x3 * mtmp._13) + ((p_y3 * mtmp._23))) + ((p_z3 * mtmp._33))) + mtmp._43)
            p_x3 = px3
            p_y3 = py3
            p_z3 = pz3
            if (p_x3 < bounds.xMin):
                bounds.xMin = p_x3
            if (p_x3 > bounds.xMax):
                bounds.xMax = p_x3
            if (p_y3 < bounds.yMin):
                bounds.yMin = p_y3
            if (p_y3 > bounds.yMax):
                bounds.yMax = p_y3
            if (p_z3 < bounds.zMin):
                bounds.zMin = p_z3
            if (p_z3 > bounds.zMax):
                bounds.zMax = p_z3
            x4 = b.xMax
            y4 = b.yMin
            z4 = b.zMin
            if (z4 is None):
                z4 = 0.
            if (y4 is None):
                y4 = 0.
            if (x4 is None):
                x4 = 0.
            p_x4 = x4
            p_y4 = y4
            p_z4 = z4
            px4 = ((((p_x4 * mtmp._11) + ((p_y4 * mtmp._21))) + ((p_z4 * mtmp._31))) + mtmp._41)
            py4 = ((((p_x4 * mtmp._12) + ((p_y4 * mtmp._22))) + ((p_z4 * mtmp._32))) + mtmp._42)
            pz4 = ((((p_x4 * mtmp._13) + ((p_y4 * mtmp._23))) + ((p_z4 * mtmp._33))) + mtmp._43)
            p_x4 = px4
            p_y4 = py4
            p_z4 = pz4
            if (p_x4 < bounds.xMin):
                bounds.xMin = p_x4
            if (p_x4 > bounds.xMax):
                bounds.xMax = p_x4
            if (p_y4 < bounds.yMin):
                bounds.yMin = p_y4
            if (p_y4 > bounds.yMax):
                bounds.yMax = p_y4
            if (p_z4 < bounds.zMin):
                bounds.zMin = p_z4
            if (p_z4 > bounds.zMax):
                bounds.zMax = p_z4
            x5 = b.xMax
            y5 = b.yMin
            z5 = b.zMax
            if (z5 is None):
                z5 = 0.
            if (y5 is None):
                y5 = 0.
            if (x5 is None):
                x5 = 0.
            p_x5 = x5
            p_y5 = y5
            p_z5 = z5
            px5 = ((((p_x5 * mtmp._11) + ((p_y5 * mtmp._21))) + ((p_z5 * mtmp._31))) + mtmp._41)
            py5 = ((((p_x5 * mtmp._12) + ((p_y5 * mtmp._22))) + ((p_z5 * mtmp._32))) + mtmp._42)
            pz5 = ((((p_x5 * mtmp._13) + ((p_y5 * mtmp._23))) + ((p_z5 * mtmp._33))) + mtmp._43)
            p_x5 = px5
            p_y5 = py5
            p_z5 = pz5
            if (p_x5 < bounds.xMin):
                bounds.xMin = p_x5
            if (p_x5 > bounds.xMax):
                bounds.xMax = p_x5
            if (p_y5 < bounds.yMin):
                bounds.yMin = p_y5
            if (p_y5 > bounds.yMax):
                bounds.yMax = p_y5
            if (p_z5 < bounds.zMin):
                bounds.zMin = p_z5
            if (p_z5 > bounds.zMax):
                bounds.zMax = p_z5
            x6 = b.xMax
            y6 = b.yMax
            z6 = b.zMin
            if (z6 is None):
                z6 = 0.
            if (y6 is None):
                y6 = 0.
            if (x6 is None):
                x6 = 0.
            p_x6 = x6
            p_y6 = y6
            p_z6 = z6
            px6 = ((((p_x6 * mtmp._11) + ((p_y6 * mtmp._21))) + ((p_z6 * mtmp._31))) + mtmp._41)
            py6 = ((((p_x6 * mtmp._12) + ((p_y6 * mtmp._22))) + ((p_z6 * mtmp._32))) + mtmp._42)
            pz6 = ((((p_x6 * mtmp._13) + ((p_y6 * mtmp._23))) + ((p_z6 * mtmp._33))) + mtmp._43)
            p_x6 = px6
            p_y6 = py6
            p_z6 = pz6
            if (p_x6 < bounds.xMin):
                bounds.xMin = p_x6
            if (p_x6 > bounds.xMax):
                bounds.xMax = p_x6
            if (p_y6 < bounds.yMin):
                bounds.yMin = p_y6
            if (p_y6 > bounds.yMax):
                bounds.yMax = p_y6
            if (p_z6 < bounds.zMin):
                bounds.zMin = p_z6
            if (p_z6 > bounds.zMax):
                bounds.zMax = p_z6
            x7 = b.xMax
            y7 = b.yMax
            z7 = b.zMax
            if (z7 is None):
                z7 = 0.
            if (y7 is None):
                y7 = 0.
            if (x7 is None):
                x7 = 0.
            p_x7 = x7
            p_y7 = y7
            p_z7 = z7
            px7 = ((((p_x7 * mtmp._11) + ((p_y7 * mtmp._21))) + ((p_z7 * mtmp._31))) + mtmp._41)
            py7 = ((((p_x7 * mtmp._12) + ((p_y7 * mtmp._22))) + ((p_z7 * mtmp._32))) + mtmp._42)
            pz7 = ((((p_x7 * mtmp._13) + ((p_y7 * mtmp._23))) + ((p_z7 * mtmp._33))) + mtmp._43)
            p_x7 = px7
            p_y7 = py7
            p_z7 = pz7
            if (p_x7 < bounds.xMin):
                bounds.xMin = p_x7
            if (p_x7 > bounds.xMax):
                bounds.xMax = p_x7
            if (p_y7 < bounds.yMin):
                bounds.yMin = p_y7
            if (p_y7 > bounds.yMax):
                bounds.yMax = p_y7
            if (p_z7 < bounds.zMin):
                bounds.zMin = p_z7
            if (p_z7 > bounds.zMax):
                bounds.zMax = p_z7
        self.ctx.scene.iterVisibleMeshes(_hx_local_0)
        if (self.mode == h3d_pass_RenderMode.Dynamic):
            cameraBounds = h3d_col_Bounds()
            _g = 0
            _g1 = self.ctx.camera.getFrustumCorners()
            while (_g < len(_g1)):
                pt = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                m1 = camera.mcam
                px8 = ((((pt.x * m1._11) + ((pt.y * m1._21))) + ((pt.z * m1._31))) + ((pt.w * m1._41)))
                py8 = ((((pt.x * m1._12) + ((pt.y * m1._22))) + ((pt.z * m1._32))) + ((pt.w * m1._42)))
                pz8 = ((((pt.x * m1._13) + ((pt.y * m1._23))) + ((pt.z * m1._33))) + ((pt.w * m1._43)))
                pw = ((((pt.x * m1._14) + ((pt.y * m1._24))) + ((pt.z * m1._34))) + ((pt.w * m1._44)))
                pt.x = px8
                pt.y = py8
                pt.z = pz8
                pt.w = pw
                x8 = pt.x
                y8 = pt.y
                z8 = pt.z
                if (x8 < cameraBounds.xMin):
                    cameraBounds.xMin = x8
                if (x8 > cameraBounds.xMax):
                    cameraBounds.xMax = x8
                if (y8 < cameraBounds.yMin):
                    cameraBounds.yMin = y8
                if (y8 > cameraBounds.yMax):
                    cameraBounds.yMax = y8
                if (z8 < cameraBounds.zMin):
                    cameraBounds.zMin = z8
                if (z8 > cameraBounds.zMax):
                    cameraBounds.zMax = z8
            cameraBounds.zMin = bounds.zMin
            bounds.intersection(bounds,cameraBounds)
        bounds.scaleCenter(1.01)

    def setGlobals(self):
        super().setGlobals()
        if ((self.mode != h3d_pass_RenderMode.Mixed) or self.ctx.computingStatic):
            _this = self.lightCamera.orthoBounds
            _this.xMin = 1e20
            _this.xMax = -1e20
            _this.yMin = 1e20
            _this.yMax = -1e20
            _this.zMin = 1e20
            _this.zMax = -1e20
            self.calcShadowBounds(self.lightCamera)
            self.lightCamera.update()
        v = self.getShadowProj()
        self.manager.globals.map.set(self.cameraViewProj_id,v)

    def syncShader(self,texture):
        _this = self.dshader
        _this.constModified = True
        _this.shadowMap__ = texture
        _this1 = self.dshader
        _this1.constModified = True
        _this1.shadowMapChannel__ = (hxsl_Channel.PackedFloat if ((self.format == h3d_mat_Texture.nativeFormat)) else hxsl_Channel.R)
        self.dshader.shadowBias__ = self.bias
        self.dshader.shadowPower__ = self.power
        self.dshader.shadowProj__ = self.getShadowProj()
        _this2 = self.dshader
        _this2.constModified = True
        _this2.USE_ESM__ = (self.samplingKind == h3d_pass_ShadowSamplingKind.ESM)
        self.dshader.shadowPower__ = self.power
        _this3 = self.dshader
        _this3.constModified = True
        _this3.USE_PCF__ = (self.samplingKind == h3d_pass_ShadowSamplingKind.PCF)
        _this4 = self.dshader.shadowRes__
        x = texture.width
        y = texture.height
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this4.x = x
        _this4.y = y
        _this4.z = 0.
        _this4.w = 1.
        self.dshader.pcfScale__ = self.pcfScale
        _this5 = self.dshader
        _this5.constModified = True
        _this5.pcfQuality__ = self.pcfQuality

    def saveStaticData(self):
        if ((self.mode != h3d_pass_RenderMode.Mixed) and ((self.mode != h3d_pass_RenderMode.Static))):
            return None
        if (self.staticTexture is None):
            raise _HxException("Data not computed")
        _hx_bytes = haxe_zip_Compress.run(self.staticTexture.capturePixels().bytes,9)
        buffer = haxe_io_BytesBuffer()
        buffer.addInt32(self.staticTexture.width)
        buffer.addInt32(haxe_io_FPHelper.floatToI32(self.lightCamera.pos.x))
        buffer.addInt32(haxe_io_FPHelper.floatToI32(self.lightCamera.pos.y))
        buffer.addInt32(haxe_io_FPHelper.floatToI32(self.lightCamera.pos.z))
        buffer.addInt32(haxe_io_FPHelper.floatToI32(self.lightCamera.target.x))
        buffer.addInt32(haxe_io_FPHelper.floatToI32(self.lightCamera.target.y))
        buffer.addInt32(haxe_io_FPHelper.floatToI32(self.lightCamera.target.z))
        buffer.addInt32(haxe_io_FPHelper.floatToI32(self.lightCamera.orthoBounds.xMin))
        buffer.addInt32(haxe_io_FPHelper.floatToI32(self.lightCamera.orthoBounds.yMin))
        buffer.addInt32(haxe_io_FPHelper.floatToI32(self.lightCamera.orthoBounds.zMin))
        buffer.addInt32(haxe_io_FPHelper.floatToI32(self.lightCamera.orthoBounds.xMax))
        buffer.addInt32(haxe_io_FPHelper.floatToI32(self.lightCamera.orthoBounds.yMax))
        buffer.addInt32(haxe_io_FPHelper.floatToI32(self.lightCamera.orthoBounds.zMax))
        buffer.addInt32(_hx_bytes.length)
        buffer.b.extend(_hx_bytes.b)
        return buffer.getBytes()

    def loadStaticData(self,_hx_bytes):
        if (((self.mode != h3d_pass_RenderMode.Mixed) and ((self.mode != h3d_pass_RenderMode.Static))) or ((_hx_bytes is None))):
            return False
        buffer = haxe_io_BytesInput(_hx_bytes)
        size = buffer.readInt32()
        if (size != self.size):
            return False
        self.lightCamera.pos.x = buffer.readFloat()
        self.lightCamera.pos.y = buffer.readFloat()
        self.lightCamera.pos.z = buffer.readFloat()
        self.lightCamera.target.x = buffer.readFloat()
        self.lightCamera.target.y = buffer.readFloat()
        self.lightCamera.target.z = buffer.readFloat()
        self.lightCamera.orthoBounds.xMin = buffer.readFloat()
        self.lightCamera.orthoBounds.yMin = buffer.readFloat()
        self.lightCamera.orthoBounds.zMin = buffer.readFloat()
        self.lightCamera.orthoBounds.xMax = buffer.readFloat()
        self.lightCamera.orthoBounds.yMax = buffer.readFloat()
        self.lightCamera.orthoBounds.zMax = buffer.readFloat()
        self.lightCamera.update()
        _hx_len = buffer.readInt32()
        pixels = hxd_Pixels(size,size,haxe_zip_Uncompress.run(buffer.read(_hx_len)),self.format)
        if (self.staticTexture is not None):
            self.staticTexture.dispose()
        self.staticTexture = h3d_mat_Texture(size,size,[h3d_mat_TextureFlags.Target],self.format)
        self.staticTexture.uploadPixels(pixels)
        self.staticTexture.name = "staticTexture"
        self.staticTexture.preventAutoDispose()
        self.syncShader(self.staticTexture)
        return True

    def draw(self,passes,sort = None):
        _gthis = self
        if (not self.enabled):
            return
        if (not self.filterPasses(passes)):
            return
        def _hx_local_0(col):
            return col.inFrustum(_gthis.lightCamera.frustum)
        f = _hx_local_0
        prevCollider = None
        prevResult = True
        head = None
        prev = None
        disc = passes.discarded
        discQueue = passes.lastDisc
        cur = passes.current
        while (cur is not None):
            col1 = cur.obj.cullingCollider
            tmp = None
            if (col1 is None):
                tmp = True
            else:
                if (col1 != prevCollider):
                    prevCollider = col1
                    prevResult = f(col1)
                tmp = prevResult
            if tmp:
                if (head is None):
                    prev = cur
                    head = prev
                else:
                    prev.next = cur
                    prev = cur
            elif (disc is None):
                discQueue = cur
                disc = discQueue
            else:
                discQueue.next = cur
                discQueue = cur
            cur = cur.next
        if (prev is not None):
            prev.next = None
        if (discQueue is not None):
            discQueue.next = None
        passes.current = head
        passes.discarded = disc
        passes.lastDisc = discQueue
        texture = self.ctx.textures.allocTarget("dirShadowMap",self.size,self.size,False,self.format)
        if (self.customDepth and (((((self.depth is None) or ((self.depth.width != self.size))) or ((self.depth.height != self.size))) or self.depth.isDisposed()))):
            if (self.depth is not None):
                self.depth.dispose()
            self.depth = h3d_mat_DepthBuffer(self.size,self.size)
        texture.depthBuffer = self.depth
        if ((self.mode != h3d_pass_RenderMode.Mixed) or self.ctx.computingStatic):
            ct = self.ctx.camera.target
            slight = (self.ctx.lightSystem.shadowLight if ((self.light is None)) else self.light)
            ldir = (None if ((slight is None)) else slight.getShadowDirection())
            if (ldir is None):
                _this = self.lightCamera.target
                x = 0
                y = 0
                z = -1
                if (z is None):
                    z = 0.
                if (y is None):
                    y = 0.
                if (x is None):
                    x = 0.
                _this.x = x
                _this.y = y
                _this.z = z
                _this.w = 1.
            else:
                _this1 = self.lightCamera.target
                x1 = ldir.x
                y1 = ldir.y
                z1 = ldir.z
                if (z1 is None):
                    z1 = 0.
                if (y1 is None):
                    y1 = 0.
                if (x1 is None):
                    x1 = 0.
                _this1.x = x1
                _this1.y = y1
                _this1.z = z1
                _this1.w = 1.
                self.lightCamera.target.normalize()
            _hx_local_1 = self.lightCamera.target
            _hx_local_2 = _hx_local_1.x
            _hx_local_1.x = (_hx_local_2 + ct.x)
            _hx_local_1.x
            _hx_local_3 = self.lightCamera.target
            _hx_local_4 = _hx_local_3.y
            _hx_local_3.y = (_hx_local_4 + ct.y)
            _hx_local_3.y
            _hx_local_5 = self.lightCamera.target
            _hx_local_6 = _hx_local_5.z
            _hx_local_5.z = (_hx_local_6 + ct.z)
            _hx_local_5.z
            _this2 = self.lightCamera.pos
            _this2.x = ct.x
            _this2.y = ct.y
            _this2.z = ct.z
            _this2.w = ct.w
            self.lightCamera.update()
        self.ctx.engine.pushTarget(texture)
        self.ctx.engine.clear(16777215,1)
        super().draw(passes,sort)
        if (self.border is not None):
            self.border.render()
        self.ctx.engine.popTarget()
        if ((self.mode == h3d_pass_RenderMode.Mixed) and (not self.ctx.computingStatic)):
            merge = self.ctx.textures.allocTarget("mergedDirShadowMap",self.size,self.size,False,self.format)
            self.mergePass.shader.texA__ = texture
            self.mergePass.shader.texB__ = self.staticTexture
            self.ctx.engine.pushTarget(merge)
            self.mergePass.render()
            self.ctx.engine.popTarget()
            texture = merge
        if ((self.blur.radius > 0) and (((self.mode != h3d_pass_RenderMode.Mixed) or (not self.ctx.computingStatic)))):
            self.blur.apply(self.ctx,texture)
        self.syncShader(texture)

    def computeStatic(self,passes):
        if ((self.mode != h3d_pass_RenderMode.Static) and ((self.mode != h3d_pass_RenderMode.Mixed))):
            return
        self.draw(passes)
        texture = self.dshader.shadowMap__
        old = self.staticTexture
        self.staticTexture = texture.clone()
        self.staticTexture.name = "StaticDirShadowMap"
        self.staticTexture.preventAutoDispose()
        _this = self.dshader
        _this.constModified = True
        _this.shadowMap__ = self.staticTexture
        if (old is not None):
            old.dispose()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.customDepth = None
        _hx_o.depth = None
        _hx_o.dshader = None
        _hx_o.border = None
        _hx_o.mergePass = None
h3d_pass_DirShadowMap._hx_class = h3d_pass_DirShadowMap
_hx_classes["h3d.pass.DirShadowMap"] = h3d_pass_DirShadowMap


class h3d_pass_DefaultShadowMap(h3d_pass_DirShadowMap):
    _hx_class_name = "h3d.pass.DefaultShadowMap"
    _hx_is_interface = "False"
    __slots__ = ("shadowMapId", "shadowProjId", "shadowColorId", "shadowPowerId", "shadowBiasId", "color")
    _hx_fields = ["shadowMapId", "shadowProjId", "shadowColorId", "shadowPowerId", "shadowBiasId", "color"]
    _hx_methods = ["draw"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_pass_DirShadowMap


    def __init__(self,size = None,format = None):
        if (size is None):
            size = 1024
        self.color = None
        self.shadowBiasId = None
        self.shadowPowerId = None
        self.shadowColorId = None
        self.shadowProjId = None
        self.shadowMapId = None
        if (format is not None):
            self.format = format
        super().__init__(None)
        self.set_size(size)
        self.color = h3d_Vector()
        self.set_mode(h3d_pass_RenderMode.Dynamic)
        self.shadowMapId = hxsl_Globals.allocID("shadow.map")
        self.shadowProjId = hxsl_Globals.allocID("shadow.proj")
        self.shadowColorId = hxsl_Globals.allocID("shadow.color")
        self.shadowPowerId = hxsl_Globals.allocID("shadow.power")
        self.shadowBiasId = hxsl_Globals.allocID("shadow.bias")

    def draw(self,passes,sort = None):
        super().draw(passes,sort)
        self.ctx.setGlobalID(self.shadowMapId,_hx_AnonObject({'texture': self.dshader.shadowMap__, 'channel': (hxsl_Channel.PackedFloat if ((self.format == h3d_mat_Texture.nativeFormat)) else hxsl_Channel.R)}))
        self.ctx.setGlobalID(self.shadowProjId,self.getShadowProj())
        self.ctx.setGlobalID(self.shadowColorId,self.color)
        self.ctx.setGlobalID(self.shadowPowerId,self.power)
        self.ctx.setGlobalID(self.shadowBiasId,self.bias)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.shadowMapId = None
        _hx_o.shadowProjId = None
        _hx_o.shadowColorId = None
        _hx_o.shadowPowerId = None
        _hx_o.shadowBiasId = None
        _hx_o.color = None
h3d_pass_DefaultShadowMap._hx_class = h3d_pass_DefaultShadowMap
_hx_classes["h3d.pass.DefaultShadowMap"] = h3d_pass_DefaultShadowMap


class h3d_pass__HardwarePick_FixedColor(hxsl_Shader):
    _hx_class_name = "h3d.pass._HardwarePick.FixedColor"
    _hx_is_interface = "False"
    __slots__ = ("colorID__", "viewport__")
    _hx_fields = ["colorID__", "viewport__"]
    _hx_methods = ["get_colorID", "set_colorID", "get_viewport", "set_viewport", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader


    def __init__(self):
        self.viewport__ = h3d_Vector()
        self.colorID__ = h3d_Vector()
        super().__init__()

    def get_colorID(self):
        return self.colorID__

    def set_colorID(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.colorID__ = _v
                return self.colorID__
            return _hx_local_0()
        return _hx_local_1()

    def get_viewport(self):
        return self.viewport__

    def set_viewport(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.viewport__ = _v
                return self.viewport__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.colorID__
        elif (index1 == 1):
            return self.viewport__
        else:
            pass
        return None

    def getParamFloatValue(self,index):
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_pass__HardwarePick_FixedColor)
        s.shader = self.shader
        s.colorID__ = self.colorID__
        s.viewport__ = self.viewport__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.colorID__ = None
        _hx_o.viewport__ = None
h3d_pass__HardwarePick_FixedColor._hx_class = h3d_pass__HardwarePick_FixedColor
_hx_classes["h3d.pass._HardwarePick.FixedColor"] = h3d_pass__HardwarePick_FixedColor


class h3d_pass_HardwarePick(h3d_pass_Default):
    _hx_class_name = "h3d.pass.HardwarePick"
    _hx_is_interface = "False"
    __slots__ = ("pickX", "pickY", "fixedColor", "colorID", "texOut", "material", "pickedIndex")
    _hx_fields = ["pickX", "pickY", "fixedColor", "colorID", "texOut", "material", "pickedIndex"]
    _hx_methods = ["dispose", "getOutputs", "drawObject", "nextID", "draw"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_pass_Default


    def __init__(self):
        self.material = None
        self.texOut = None
        self.colorID = None
        self.pickY = None
        self.pickX = None
        self.pickedIndex = -1
        self.fixedColor = h3d_pass__HardwarePick_FixedColor()
        super().__init__("hwpick")
        self.material = h3d_mat_Pass("")
        _this = self.material
        src = h3d_mat_Blend.One
        dst = h3d_mat_Blend.Zero
        _this.set_blendSrc(src)
        _this.set_blendAlphaSrc(src)
        _this.set_blendDst(dst)
        _this.set_blendAlphaDst(dst)
        self.texOut = h3d_mat_Texture(3,3,[h3d_mat_TextureFlags.Target])
        self.texOut.depthBuffer = h3d_mat_DepthBuffer(3,3)

    def dispose(self):
        super().dispose()
        self.texOut.dispose()
        self.texOut.depthBuffer.dispose()

    def getOutputs(self):
        return [hxsl_Output.Value("output.colorID")]

    def drawObject(self,p):
        super().drawObject(p)
        _this = self.fixedColor.colorID__
        def _hx_local_2():
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.colorID
            _hx_local_0.colorID = (_hx_local_1 + 1)
            return _hx_local_0.colorID
        c = (-16777216 | _hx_local_2())
        _this.x = ((((c >> 16) & 255)) / 255)
        _this.y = ((((c >> 8) & 255)) / 255)
        _this.z = (((c & 255)) / 255)
        _this.w = ((HxOverrides.rshift(c, 24)) / 255)

    def nextID(self):
        _this = self.fixedColor.colorID__
        def _hx_local_2():
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.colorID
            _hx_local_0.colorID = (_hx_local_1 + 1)
            return _hx_local_0.colorID
        c = (-16777216 | _hx_local_2())
        _this.x = ((((c >> 16) & 255)) / 255)
        _this.y = ((((c >> 8) & 255)) / 255)
        _this.z = (((c & 255)) / 255)
        _this.w = ((HxOverrides.rshift(c, 24)) / 255)

    def draw(self,passes,sort = None):
        _g_o = passes.current
        while (_g_o is not None):
            tmp = _g_o
            _g_o = _g_o.next
            cur = tmp
            mask = 268435392
            _hx_local_0 = cur._hx_pass
            _hx_local_1 = _hx_local_0.bits
            _hx_local_0.bits = (_hx_local_1 & ~mask)
            _hx_local_0.bits
            _hx_local_2 = cur._hx_pass
            _hx_local_3 = _hx_local_2.bits
            _hx_local_2.bits = (_hx_local_3 | ((self.material.bits & mask)))
            _hx_local_2.bits
        self.colorID = 0
        _this = self.fixedColor.colorID__
        def _hx_local_6():
            _hx_local_4 = self
            _hx_local_5 = _hx_local_4.colorID
            _hx_local_4.colorID = (_hx_local_5 + 1)
            return _hx_local_4.colorID
        c = (-16777216 | _hx_local_6())
        _this.x = ((((c >> 16) & 255)) / 255)
        _this.y = ((((c >> 8) & 255)) / 255)
        _this.z = (((c & 255)) / 255)
        _this.w = ((HxOverrides.rshift(c, 24)) / 255)
        _this1 = self.fixedColor.viewport__
        x = -((((self.pickX * 2) / self.ctx.engine.width) - 1))
        y = (((self.pickY * 2) / self.ctx.engine.height) - 1)
        z = (self.ctx.engine.width / self.texOut.width)
        w = (self.ctx.engine.height / self.texOut.height)
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this1.x = x
        _this1.y = y
        _this1.z = z
        _this1.w = w
        self.ctx.engine.pushTarget(self.texOut)
        self.ctx.engine.clear(-16777216,1)
        self.ctx.extraShaders = self.ctx.allocShaderList(self.fixedColor)
        super().draw(passes,sort)
        self.ctx.extraShaders = None
        self.ctx.engine.popTarget()
        _g1_o = passes.current
        while (_g1_o is not None):
            tmp1 = _g1_o
            _g1_o = _g1_o.next
            cur1 = tmp1
            cur1._hx_pass.set_blendSrc(cur1._hx_pass.blendSrc)
            cur1._hx_pass.set_blendDst(cur1._hx_pass.blendDst)
            cur1._hx_pass.set_blendOp(cur1._hx_pass.blendOp)
            cur1._hx_pass.set_blendAlphaSrc(cur1._hx_pass.blendAlphaSrc)
            cur1._hx_pass.set_blendAlphaDst(cur1._hx_pass.blendAlphaDst)
            cur1._hx_pass.set_blendAlphaOp(cur1._hx_pass.blendAlphaOp)
            cur1._hx_pass.colorMask = cur1._hx_pass.colorMask
        self.ctx.engine.clear(None,None,0)
        pix = self.texOut.capturePixels()
        self.pickedIndex = (((pix.getPixel((pix.width >> 1),(pix.height >> 1)) & 16777215)) - 1)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.pickX = None
        _hx_o.pickY = None
        _hx_o.fixedColor = None
        _hx_o.colorID = None
        _hx_o.texOut = None
        _hx_o.material = None
        _hx_o.pickedIndex = None
h3d_pass_HardwarePick._hx_class = h3d_pass_HardwarePick
_hx_classes["h3d.pass.HardwarePick"] = h3d_pass_HardwarePick


class h3d_pass_PassListIterator:
    _hx_class_name = "h3d.pass.PassListIterator"
    _hx_is_interface = "False"
    __slots__ = ("o",)
    _hx_fields = ["o"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,o):
        self.o = o

    def hasNext(self):
        return (self.o is not None)

    def next(self):
        tmp = self.o
        self.o = self.o.next
        return tmp

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.o = None
h3d_pass_PassListIterator._hx_class = h3d_pass_PassListIterator
_hx_classes["h3d.pass.PassListIterator"] = h3d_pass_PassListIterator


class h3d_pass_PassList:
    _hx_class_name = "h3d.pass.PassList"
    _hx_is_interface = "False"
    __slots__ = ("current", "discarded", "lastDisc")
    _hx_fields = ["current", "discarded", "lastDisc"]
    _hx_methods = ["init", "reset", "save", "load", "isEmpty", "clear", "sort", "filter", "iterator", "getFiltered"]

    def __init__(self,current = None):
        self.current = current
        def _hx_local_0():
            self.lastDisc = None
            return self.lastDisc
        self.discarded = _hx_local_0()

    def init(self,_hx_pass):
        self.current = _hx_pass
        def _hx_local_0():
            self.lastDisc = None
            return self.lastDisc
        self.discarded = _hx_local_0()

    def reset(self):
        if (self.discarded is not None):
            self.lastDisc.next = self.current
            self.current = self.discarded
            def _hx_local_0():
                self.lastDisc = None
                return self.lastDisc
            self.discarded = _hx_local_0()

    def save(self):
        return self.lastDisc

    def load(self,p):
        if (self.lastDisc != p):
            self.lastDisc.next = self.current
            if (p is None):
                self.current = self.discarded
                self.discarded = None
            else:
                self.current = p.next
                p.next = None
            self.lastDisc = p

    def isEmpty(self):
        return (self.current is None)

    def clear(self):
        if (self.current is None):
            return
        if (self.discarded is None):
            self.discarded = self.current
        else:
            self.lastDisc.next = self.current
        p = self.current
        while (p.next is not None):
            p = p.next
        self.lastDisc = p
        self.current = None

    def sort(self,f):
        _hx_list = self.current
        tmp = None
        if (_hx_list is None):
            tmp = None
        else:
            insize = 1
            nmerges = None
            psize = 0
            qsize = 0
            p = None
            q = None
            e = None
            tail = None
            while True:
                p = _hx_list
                _hx_list = None
                tail = None
                nmerges = 0
                while (p is not None):
                    nmerges = (nmerges + 1)
                    q = p
                    psize = 0
                    _g = 0
                    _g1 = insize
                    while (_g < _g1):
                        i = _g
                        _g = (_g + 1)
                        psize = (psize + 1)
                        q = q.next
                        if (q is None):
                            break
                    qsize = insize
                    while ((psize > 0) or (((qsize > 0) and ((q is not None))))):
                        if (psize == 0):
                            e = q
                            q = q.next
                            qsize = (qsize - 1)
                        elif (((qsize == 0) or ((q is None))) or ((f(p,q) <= 0))):
                            e = p
                            p = p.next
                            psize = (psize - 1)
                        else:
                            e = q
                            q = q.next
                            qsize = (qsize - 1)
                        if (tail is not None):
                            tail.next = e
                        else:
                            _hx_list = e
                        tail = e
                    p = q
                tail.next = None
                if (nmerges <= 1):
                    break
                insize = (insize * 2)
            tmp = _hx_list
        self.current = tmp

    def filter(self,f):
        head = None
        prev = None
        disc = self.discarded
        discQueue = self.lastDisc
        cur = self.current
        while (cur is not None):
            if f(cur):
                if (head is None):
                    prev = cur
                    head = prev
                else:
                    prev.next = cur
                    prev = cur
            elif (disc is None):
                discQueue = cur
                disc = discQueue
            else:
                discQueue.next = cur
                discQueue = cur
            cur = cur.next
        if (prev is not None):
            prev.next = None
        if (discQueue is not None):
            discQueue.next = None
        self.current = head
        self.discarded = disc
        self.lastDisc = discQueue

    def iterator(self):
        return h3d_pass_PassListIterator(self.current)

    def getFiltered(self):
        return h3d_pass_PassListIterator(self.discarded)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.current = None
        _hx_o.discarded = None
        _hx_o.lastDisc = None
h3d_pass_PassList._hx_class = h3d_pass_PassList
_hx_classes["h3d.pass.PassList"] = h3d_pass_PassList


class h3d_pass_PassObject:
    _hx_class_name = "h3d.pass.PassObject"
    _hx_is_interface = "False"
    __slots__ = ("next", "nextAlloc", "_hx_pass", "obj", "index", "shaders", "shader", "depth", "texture")
    _hx_fields = ["next", "nextAlloc", "pass", "obj", "index", "shaders", "shader", "depth", "texture"]

    def __init__(self):
        self.depth = None
        self.shader = None
        self.shaders = None
        self.index = None
        self.obj = None
        self._hx_pass = None
        self.nextAlloc = None
        self.next = None
        self.texture = 0

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.next = None
        _hx_o.nextAlloc = None
        _hx_o._hx_pass = None
        _hx_o.obj = None
        _hx_o.index = None
        _hx_o.shaders = None
        _hx_o.shader = None
        _hx_o.depth = None
        _hx_o.texture = None
h3d_pass_PassObject._hx_class = h3d_pass_PassObject
_hx_classes["h3d.pass.PassObject"] = h3d_pass_PassObject


class h3d_pass_ShaderManager:
    _hx_class_name = "h3d.pass.ShaderManager"
    _hx_is_interface = "False"
    __slots__ = ("globals", "shaderCache", "currentOutput")
    _hx_fields = ["globals", "shaderCache", "currentOutput"]
    _hx_methods = ["setOutput", "fillRec", "shaderInfo", "getPtr", "getParamValue", "fillGlobals", "fillParams", "compileShaders"]
    _hx_statics = ["STRICT"]

    def __init__(self,output = None):
        self.shaderCache = hxsl_Cache.get()
        self.globals = hxsl_Globals()
        self.currentOutput = hxsl_ShaderList(None)
        self.setOutput(output)

    def setOutput(self,output = None):
        if (output is None):
            output = [hxsl_Output.Value("output.color")]
        self.currentOutput.s = self.shaderCache.getLinkShader(output)

    def fillRec(self,v,_hx_type,out,pos):
        tmp = _hx_type.index
        if (tmp == 1):
            val = v
            out[pos] = val
            return 1
        elif (tmp == 3):
            val1 = v
            out[pos] = val1
            return 1
        elif (tmp == 5):
            _g1 = _hx_type.params[1]
            n = _hx_type.params[0]
            v1 = v
            index = pos
            pos = (pos + 1)
            val2 = v1.x
            out[index] = val2
            index1 = pos
            pos = (pos + 1)
            val3 = v1.y
            out[index1] = val3
            n1 = n
            if (n1 == 3):
                index2 = pos
                pos = (pos + 1)
                val4 = v1.z
                out[index2] = val4
            elif (n1 == 4):
                index3 = pos
                pos = (pos + 1)
                val5 = v1.z
                out[index3] = val5
                index4 = pos
                pos = (pos + 1)
                val6 = v1.w
                out[index4] = val6
            else:
                pass
            return n
        elif (tmp == 6):
            m = v
            index5 = pos
            pos = (pos + 1)
            val7 = m._11
            out[index5] = val7
            index6 = pos
            pos = (pos + 1)
            val8 = m._21
            out[index6] = val8
            index7 = pos
            pos = (pos + 1)
            val9 = m._31
            out[index7] = val9
            index8 = pos
            pos = (pos + 1)
            out[index8] = 0
            index9 = pos
            pos = (pos + 1)
            val10 = m._12
            out[index9] = val10
            index10 = pos
            pos = (pos + 1)
            val11 = m._22
            out[index10] = val11
            index11 = pos
            pos = (pos + 1)
            val12 = m._32
            out[index11] = val12
            index12 = pos
            pos = (pos + 1)
            out[index12] = 0
            index13 = pos
            pos = (pos + 1)
            val13 = m._13
            out[index13] = val13
            index14 = pos
            pos = (pos + 1)
            val14 = m._23
            out[index14] = val14
            index15 = pos
            pos = (pos + 1)
            val15 = m._33
            out[index15] = val15
            index16 = pos
            pos = (pos + 1)
            out[index16] = 0
            return 12
        elif (tmp == 7):
            m1 = v
            index17 = pos
            pos = (pos + 1)
            val16 = m1._11
            out[index17] = val16
            index18 = pos
            pos = (pos + 1)
            val17 = m1._21
            out[index18] = val17
            index19 = pos
            pos = (pos + 1)
            val18 = m1._31
            out[index19] = val18
            index20 = pos
            pos = (pos + 1)
            val19 = m1._41
            out[index20] = val19
            index21 = pos
            pos = (pos + 1)
            val20 = m1._12
            out[index21] = val20
            index22 = pos
            pos = (pos + 1)
            val21 = m1._22
            out[index22] = val21
            index23 = pos
            pos = (pos + 1)
            val22 = m1._32
            out[index23] = val22
            index24 = pos
            pos = (pos + 1)
            val23 = m1._42
            out[index24] = val23
            index25 = pos
            pos = (pos + 1)
            val24 = m1._13
            out[index25] = val24
            index26 = pos
            pos = (pos + 1)
            val25 = m1._23
            out[index26] = val25
            index27 = pos
            pos = (pos + 1)
            val26 = m1._33
            out[index27] = val26
            index28 = pos
            pos = (pos + 1)
            val27 = m1._43
            out[index28] = val27
            index29 = pos
            pos = (pos + 1)
            val28 = m1._14
            out[index29] = val28
            index30 = pos
            pos = (pos + 1)
            val29 = m1._24
            out[index30] = val29
            index31 = pos
            pos = (pos + 1)
            val30 = m1._34
            out[index31] = val30
            index32 = pos
            pos = (pos + 1)
            val31 = m1._44
            out[index32] = val31
            return 16
        elif (tmp == 8):
            m2 = v
            index33 = pos
            pos = (pos + 1)
            val32 = m2._11
            out[index33] = val32
            index34 = pos
            pos = (pos + 1)
            val33 = m2._21
            out[index34] = val33
            index35 = pos
            pos = (pos + 1)
            val34 = m2._31
            out[index35] = val34
            index36 = pos
            pos = (pos + 1)
            val35 = m2._41
            out[index36] = val35
            index37 = pos
            pos = (pos + 1)
            val36 = m2._12
            out[index37] = val36
            index38 = pos
            pos = (pos + 1)
            val37 = m2._22
            out[index38] = val37
            index39 = pos
            pos = (pos + 1)
            val38 = m2._32
            out[index39] = val38
            index40 = pos
            pos = (pos + 1)
            val39 = m2._42
            out[index40] = val39
            index41 = pos
            pos = (pos + 1)
            val40 = m2._13
            out[index41] = val40
            index42 = pos
            pos = (pos + 1)
            val41 = m2._23
            out[index42] = val41
            index43 = pos
            pos = (pos + 1)
            val42 = m2._33
            out[index43] = val42
            index44 = pos
            pos = (pos + 1)
            val43 = m2._43
            out[index44] = val43
            return 12
        elif (tmp == 13):
            vl = _hx_type.params[0]
            tot = 0
            _g = 0
            while (_g < len(vl)):
                vv = (vl[_g] if _g >= 0 and _g < len(vl) else None)
                _g = (_g + 1)
                tot = (tot + self.fillRec(Reflect.field(v,vv.name),vv.type,out,(pos + tot)))
            return tot
        elif (tmp == 15):
            _g4 = _hx_type.params[1]
            _g3 = _hx_type.params[0]
            tmp1 = _g3.index
            if (tmp1 == 3):
                if (_g4.index == 0):
                    _hx_len = _g4.params[0]
                    v2 = v
                    size = 0
                    count = (len(v2) if ((len(v2) < _hx_len)) else _hx_len)
                    _g2 = 0
                    _g11 = count
                    while (_g2 < _g11):
                        i = _g2
                        _g2 = (_g2 + 1)
                        index45 = pos
                        pos = (pos + 1)
                        val44 = (v2[i] if i >= 0 and i < len(v2) else None)
                        out[index45] = val44
                    return _hx_len
                else:
                    raise _HxException(("assert " + Std.string(_hx_type)))
            elif (tmp1 == 5):
                if (_g3.params[0] == 4):
                    if (_g3.params[1].index == 1):
                        if (_g4.index == 0):
                            len1 = _g4.params[0]
                            v3 = v
                            _g5 = 0
                            _g12 = len1
                            while (_g5 < _g12):
                                i1 = _g5
                                _g5 = (_g5 + 1)
                                n2 = (v3[i1] if i1 >= 0 and i1 < len(v3) else None)
                                if (n2 is None):
                                    break
                                index46 = pos
                                pos = (pos + 1)
                                val45 = n2.x
                                out[index46] = val45
                                index47 = pos
                                pos = (pos + 1)
                                val46 = n2.y
                                out[index47] = val46
                                index48 = pos
                                pos = (pos + 1)
                                val47 = n2.z
                                out[index48] = val47
                                index49 = pos
                                pos = (pos + 1)
                                val48 = n2.w
                                out[index49] = val48
                            return (len1 * 4)
                        else:
                            raise _HxException(("assert " + Std.string(_hx_type)))
                    elif (_g4.index == 0):
                        len2 = _g4.params[0]
                        t = _g3
                        v4 = v
                        size1 = 0
                        _g6 = 0
                        _g13 = len2
                        while (_g6 < _g13):
                            i2 = _g6
                            _g6 = (_g6 + 1)
                            n3 = (v4[i2] if i2 >= 0 and i2 < len(v4) else None)
                            if (n3 is None):
                                break
                            size1 = self.fillRec(n3,t,out,pos)
                            pos = (pos + size1)
                        return (len2 * size1)
                    else:
                        raise _HxException(("assert " + Std.string(_hx_type)))
                elif (_g4.index == 0):
                    len3 = _g4.params[0]
                    t1 = _g3
                    v5 = v
                    size2 = 0
                    _g7 = 0
                    _g14 = len3
                    while (_g7 < _g14):
                        i3 = _g7
                        _g7 = (_g7 + 1)
                        n4 = (v5[i3] if i3 >= 0 and i3 < len(v5) else None)
                        if (n4 is None):
                            break
                        size2 = self.fillRec(n4,t1,out,pos)
                        pos = (pos + size2)
                    return (len3 * size2)
                else:
                    raise _HxException(("assert " + Std.string(_hx_type)))
            elif (tmp1 == 8):
                if (_g4.index == 0):
                    len4 = _g4.params[0]
                    v6 = v
                    _g8 = 0
                    _g15 = len4
                    while (_g8 < _g15):
                        i4 = _g8
                        _g8 = (_g8 + 1)
                        m3 = (v6[i4] if i4 >= 0 and i4 < len(v6) else None)
                        if (m3 is None):
                            break
                        index50 = pos
                        pos = (pos + 1)
                        val49 = m3._11
                        out[index50] = val49
                        index51 = pos
                        pos = (pos + 1)
                        val50 = m3._21
                        out[index51] = val50
                        index52 = pos
                        pos = (pos + 1)
                        val51 = m3._31
                        out[index52] = val51
                        index53 = pos
                        pos = (pos + 1)
                        val52 = m3._41
                        out[index53] = val52
                        index54 = pos
                        pos = (pos + 1)
                        val53 = m3._12
                        out[index54] = val53
                        index55 = pos
                        pos = (pos + 1)
                        val54 = m3._22
                        out[index55] = val54
                        index56 = pos
                        pos = (pos + 1)
                        val55 = m3._32
                        out[index56] = val55
                        index57 = pos
                        pos = (pos + 1)
                        val56 = m3._42
                        out[index57] = val56
                        index58 = pos
                        pos = (pos + 1)
                        val57 = m3._13
                        out[index58] = val57
                        index59 = pos
                        pos = (pos + 1)
                        val58 = m3._23
                        out[index59] = val58
                        index60 = pos
                        pos = (pos + 1)
                        val59 = m3._33
                        out[index60] = val59
                        index61 = pos
                        pos = (pos + 1)
                        val60 = m3._43
                        out[index61] = val60
                    return (len4 * 12)
                else:
                    raise _HxException(("assert " + Std.string(_hx_type)))
            elif (_g4.index == 0):
                len5 = _g4.params[0]
                t2 = _g3
                v7 = v
                size3 = 0
                _g9 = 0
                _g16 = len5
                while (_g9 < _g16):
                    i5 = _g9
                    _g9 = (_g9 + 1)
                    n5 = (v7[i5] if i5 >= 0 and i5 < len(v7) else None)
                    if (n5 is None):
                        break
                    size3 = self.fillRec(n5,t2,out,pos)
                    pos = (pos + size3)
                return (len5 * size3)
            else:
                raise _HxException(("assert " + Std.string(_hx_type)))
        else:
            raise _HxException(("assert " + Std.string(_hx_type)))

    def shaderInfo(self,shaders,path):
        _this = path.split(".")
        name = (None if ((len(_this) == 0)) else _this.pop())
        while (shaders is not None):
            inst = shaders.s.instance
            _g = 0
            _g1 = inst.shader.vars
            while (_g < len(_g1)):
                v = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (v.name == name):
                    return shaders.s.toString()
            shaders = shaders.next
        return "(not found)"

    def getPtr(self,data):
        return data

    def getParamValue(self,p,shaders,opt = None):
        if (opt is None):
            opt = False
        if (p.perObjectGlobal is not None):
            v = self.globals.map.h.get(p.perObjectGlobal.gid,None)
            if (v is None):
                raise _HxException(((("Missing global value " + HxOverrides.stringOrNull(p.perObjectGlobal.path)) + " for shader ") + HxOverrides.stringOrNull(self.shaderInfo(shaders,p.perObjectGlobal.path))))
            _g = p.type
            tmp = None
            if (_g.index == 17):
                _g1 = _g.params[0]
                tmp = True
            else:
                tmp = False
            if tmp:
                return Reflect.field(v,"texture")
            return v
        si = shaders
        n = p.instance
        while True:
            n = (n - 1)
            tmp1 = n
            if (not ((tmp1 > 0))):
                break
            si = si.next
        v1 = si.s.getParamValue(p.index)
        if ((v1 is None) and (not opt)):
            raise _HxException(((("Missing param value " + Std.string(si.s)) + ".") + HxOverrides.stringOrNull(p.name)))
        return v1

    def fillGlobals(self,buf,s):
        _gthis = self
        s1 = s.vertex
        g = s1.globals
        ptr = buf.vertex.globals
        while (g is not None):
            v = _gthis.globals.map.h.get(g.gid,None)
            if (v is None):
                if (g.path == "__consts__"):
                    _gthis.fillRec(s1.consts,g.type,ptr,g.pos)
                    g = g.next
                    continue
                raise _HxException(("Missing global value " + HxOverrides.stringOrNull(g.path)))
            _gthis.fillRec(v,g.type,ptr,g.pos)
            g = g.next
        s2 = s.fragment
        g1 = s2.globals
        ptr1 = buf.fragment.globals
        while (g1 is not None):
            v1 = _gthis.globals.map.h.get(g1.gid,None)
            if (v1 is None):
                if (g1.path == "__consts__"):
                    _gthis.fillRec(s2.consts,g1.type,ptr1,g1.pos)
                    g1 = g1.next
                    continue
                raise _HxException(("Missing global value " + HxOverrides.stringOrNull(g1.path)))
            _gthis.fillRec(v1,g1.type,ptr1,g1.pos)
            g1 = g1.next

    def fillParams(self,buf,s,shaders):
        _gthis = self
        curInstance = -1
        curInstanceValue = None
        buf1 = buf.vertex
        s1 = s.vertex
        p = s1.params
        ptr = buf1.params
        while (p is not None):
            v = None
            if (p.perObjectGlobal is None):
                if (p.type == hxsl_Type.TFloat):
                    index = p.instance
                    i = None
                    if (curInstance == index):
                        i = curInstanceValue
                    else:
                        si = shaders
                        curInstance = index
                        while True:
                            index = (index - 1)
                            i1 = index
                            if (not ((i1 > 0))):
                                break
                            si = si.next
                        curInstanceValue = si.s
                        i = curInstanceValue
                    index1 = p.pos
                    val = i.getParamFloatValue(p.index)
                    ptr[index1] = val
                    p = p.next
                    continue
                index2 = p.instance
                v1 = None
                if (curInstance == index2):
                    v1 = curInstanceValue
                else:
                    si1 = shaders
                    curInstance = index2
                    while True:
                        index2 = (index2 - 1)
                        v2 = index2
                        if (not ((v2 > 0))):
                            break
                        si1 = si1.next
                    curInstanceValue = si1.s
                    v1 = curInstanceValue
                v = v1.getParamValue(p.index)
                if (v is None):
                    raise _HxException(((("Missing param value " + Std.string(curInstanceValue)) + ".") + HxOverrides.stringOrNull(p.name)))
            elif (p.perObjectGlobal is not None):
                v3 = _gthis.globals.map.h.get(p.perObjectGlobal.gid,None)
                if (v3 is None):
                    raise _HxException(((("Missing global value " + HxOverrides.stringOrNull(p.perObjectGlobal.path)) + " for shader ") + HxOverrides.stringOrNull(_gthis.shaderInfo(shaders,p.perObjectGlobal.path))))
                _g = p.type
                v4 = None
                if (_g.index == 17):
                    _g1 = _g.params[0]
                    v4 = True
                else:
                    v4 = False
                v = (Reflect.field(v3,"texture") if v4 else v3)
            else:
                si2 = shaders
                n = p.instance
                while True:
                    n = (n - 1)
                    v5 = n
                    if (not ((v5 > 0))):
                        break
                    si2 = si2.next
                v6 = si2.s.getParamValue(p.index)
                if (v6 is None):
                    raise _HxException(((("Missing param value " + Std.string(si2.s)) + ".") + HxOverrides.stringOrNull(p.name)))
                v = v6
            _gthis.fillRec(v,p.type,ptr,p.pos)
            p = p.next
        tid = 0
        p1 = s1.textures
        while (p1 is not None):
            this1 = buf1.tex
            index3 = tid
            tid = (tid + 1)
            opt = (not h3d_pass_ShaderManager.STRICT)
            if (opt is None):
                opt = False
            val1 = None
            if (p1.perObjectGlobal is not None):
                v7 = _gthis.globals.map.h.get(p1.perObjectGlobal.gid,None)
                if (v7 is None):
                    raise _HxException(((("Missing global value " + HxOverrides.stringOrNull(p1.perObjectGlobal.path)) + " for shader ") + HxOverrides.stringOrNull(_gthis.shaderInfo(shaders,p1.perObjectGlobal.path))))
                _g2 = p1.type
                val2 = None
                if (_g2.index == 17):
                    _g11 = _g2.params[0]
                    val2 = True
                else:
                    val2 = False
                val1 = (Reflect.field(v7,"texture") if val2 else v7)
            else:
                si3 = shaders
                n1 = p1.instance
                while True:
                    n1 = (n1 - 1)
                    val3 = n1
                    if (not ((val3 > 0))):
                        break
                    si3 = si3.next
                v8 = si3.s.getParamValue(p1.index)
                if ((v8 is None) and (not opt)):
                    raise _HxException(((("Missing param value " + Std.string(si3.s)) + ".") + HxOverrides.stringOrNull(p1.name)))
                val1 = v8
            val4 = val1
            this1[index3] = val4
            p1 = p1.next
        p2 = s1.buffers
        bid = 0
        while (p2 is not None):
            opt1 = (not h3d_pass_ShaderManager.STRICT)
            if (opt1 is None):
                opt1 = False
            b = None
            if (p2.perObjectGlobal is not None):
                v9 = _gthis.globals.map.h.get(p2.perObjectGlobal.gid,None)
                if (v9 is None):
                    raise _HxException(((("Missing global value " + HxOverrides.stringOrNull(p2.perObjectGlobal.path)) + " for shader ") + HxOverrides.stringOrNull(_gthis.shaderInfo(shaders,p2.perObjectGlobal.path))))
                _g3 = p2.type
                b1 = None
                if (_g3.index == 17):
                    _g12 = _g3.params[0]
                    b1 = True
                else:
                    b1 = False
                b = (Reflect.field(v9,"texture") if b1 else v9)
            else:
                si4 = shaders
                n2 = p2.instance
                while True:
                    n2 = (n2 - 1)
                    b2 = n2
                    if (not ((b2 > 0))):
                        break
                    si4 = si4.next
                v10 = si4.s.getParamValue(p2.index)
                if ((v10 is None) and (not opt1)):
                    raise _HxException(((("Missing param value " + Std.string(si4.s)) + ".") + HxOverrides.stringOrNull(p2.name)))
                b = v10
            index4 = bid
            bid = (bid + 1)
            buf1.buffers[index4] = b
            p2 = p2.next
        buf2 = buf.fragment
        s2 = s.fragment
        p3 = s2.params
        ptr1 = buf2.params
        while (p3 is not None):
            v11 = None
            if (p3.perObjectGlobal is None):
                if (p3.type == hxsl_Type.TFloat):
                    index5 = p3.instance
                    i2 = None
                    if (curInstance == index5):
                        i2 = curInstanceValue
                    else:
                        si5 = shaders
                        curInstance = index5
                        while True:
                            index5 = (index5 - 1)
                            i3 = index5
                            if (not ((i3 > 0))):
                                break
                            si5 = si5.next
                        curInstanceValue = si5.s
                        i2 = curInstanceValue
                    index6 = p3.pos
                    val5 = i2.getParamFloatValue(p3.index)
                    ptr1[index6] = val5
                    p3 = p3.next
                    continue
                index7 = p3.instance
                v12 = None
                if (curInstance == index7):
                    v12 = curInstanceValue
                else:
                    si6 = shaders
                    curInstance = index7
                    while True:
                        index7 = (index7 - 1)
                        v13 = index7
                        if (not ((v13 > 0))):
                            break
                        si6 = si6.next
                    curInstanceValue = si6.s
                    v12 = curInstanceValue
                v11 = v12.getParamValue(p3.index)
                if (v11 is None):
                    raise _HxException(((("Missing param value " + Std.string(curInstanceValue)) + ".") + HxOverrides.stringOrNull(p3.name)))
            elif (p3.perObjectGlobal is not None):
                v14 = _gthis.globals.map.h.get(p3.perObjectGlobal.gid,None)
                if (v14 is None):
                    raise _HxException(((("Missing global value " + HxOverrides.stringOrNull(p3.perObjectGlobal.path)) + " for shader ") + HxOverrides.stringOrNull(_gthis.shaderInfo(shaders,p3.perObjectGlobal.path))))
                _g4 = p3.type
                v15 = None
                if (_g4.index == 17):
                    _g13 = _g4.params[0]
                    v15 = True
                else:
                    v15 = False
                v11 = (Reflect.field(v14,"texture") if v15 else v14)
            else:
                si7 = shaders
                n3 = p3.instance
                while True:
                    n3 = (n3 - 1)
                    v16 = n3
                    if (not ((v16 > 0))):
                        break
                    si7 = si7.next
                v17 = si7.s.getParamValue(p3.index)
                if (v17 is None):
                    raise _HxException(((("Missing param value " + Std.string(si7.s)) + ".") + HxOverrides.stringOrNull(p3.name)))
                v11 = v17
            _gthis.fillRec(v11,p3.type,ptr1,p3.pos)
            p3 = p3.next
        tid1 = 0
        p4 = s2.textures
        while (p4 is not None):
            this2 = buf2.tex
            index8 = tid1
            tid1 = (tid1 + 1)
            opt2 = (not h3d_pass_ShaderManager.STRICT)
            if (opt2 is None):
                opt2 = False
            val6 = None
            if (p4.perObjectGlobal is not None):
                v18 = _gthis.globals.map.h.get(p4.perObjectGlobal.gid,None)
                if (v18 is None):
                    raise _HxException(((("Missing global value " + HxOverrides.stringOrNull(p4.perObjectGlobal.path)) + " for shader ") + HxOverrides.stringOrNull(_gthis.shaderInfo(shaders,p4.perObjectGlobal.path))))
                _g5 = p4.type
                val7 = None
                if (_g5.index == 17):
                    _g14 = _g5.params[0]
                    val7 = True
                else:
                    val7 = False
                val6 = (Reflect.field(v18,"texture") if val7 else v18)
            else:
                si8 = shaders
                n4 = p4.instance
                while True:
                    n4 = (n4 - 1)
                    val8 = n4
                    if (not ((val8 > 0))):
                        break
                    si8 = si8.next
                v19 = si8.s.getParamValue(p4.index)
                if ((v19 is None) and (not opt2)):
                    raise _HxException(((("Missing param value " + Std.string(si8.s)) + ".") + HxOverrides.stringOrNull(p4.name)))
                val6 = v19
            val9 = val6
            this2[index8] = val9
            p4 = p4.next
        p5 = s2.buffers
        bid1 = 0
        while (p5 is not None):
            opt3 = (not h3d_pass_ShaderManager.STRICT)
            if (opt3 is None):
                opt3 = False
            b3 = None
            if (p5.perObjectGlobal is not None):
                v20 = _gthis.globals.map.h.get(p5.perObjectGlobal.gid,None)
                if (v20 is None):
                    raise _HxException(((("Missing global value " + HxOverrides.stringOrNull(p5.perObjectGlobal.path)) + " for shader ") + HxOverrides.stringOrNull(_gthis.shaderInfo(shaders,p5.perObjectGlobal.path))))
                _g6 = p5.type
                b4 = None
                if (_g6.index == 17):
                    _g15 = _g6.params[0]
                    b4 = True
                else:
                    b4 = False
                b3 = (Reflect.field(v20,"texture") if b4 else v20)
            else:
                si9 = shaders
                n5 = p5.instance
                while True:
                    n5 = (n5 - 1)
                    b5 = n5
                    if (not ((b5 > 0))):
                        break
                    si9 = si9.next
                v21 = si9.s.getParamValue(p5.index)
                if ((v21 is None) and (not opt3)):
                    raise _HxException(((("Missing param value " + Std.string(si9.s)) + ".") + HxOverrides.stringOrNull(p5.name)))
                b3 = v21
            index9 = bid1
            bid1 = (bid1 + 1)
            buf2.buffers[index9] = b3
            p5 = p5.next

    def compileShaders(self,shaders,batchMode = None):
        if (batchMode is None):
            batchMode = False
        self.globals.maxChannels = 0
        _g_l = shaders
        _g_last = None
        while (_g_l != _g_last):
            s = _g_l.s
            _g_l = _g_l.next
            s1 = s
            s1.updateConstants(self.globals)
        self.currentOutput.next = shaders
        s2 = self.shaderCache.link(self.currentOutput,batchMode)
        self.currentOutput.next = None
        return s2

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.globals = None
        _hx_o.shaderCache = None
        _hx_o.currentOutput = None
h3d_pass_ShaderManager._hx_class = h3d_pass_ShaderManager
_hx_classes["h3d.pass.ShaderManager"] = h3d_pass_ShaderManager

class h3d_pass_RenderMode(Enum):
    __slots__ = ()
    _hx_class_name = "h3d.pass.RenderMode"
    _hx_constructs = ["None", "Static", "Dynamic", "Mixed"]
h3d_pass_RenderMode._hx_None = h3d_pass_RenderMode("None", 0, ())
h3d_pass_RenderMode.Static = h3d_pass_RenderMode("Static", 1, ())
h3d_pass_RenderMode.Dynamic = h3d_pass_RenderMode("Dynamic", 2, ())
h3d_pass_RenderMode.Mixed = h3d_pass_RenderMode("Mixed", 3, ())
h3d_pass_RenderMode._hx_class = h3d_pass_RenderMode
_hx_classes["h3d.pass.RenderMode"] = h3d_pass_RenderMode

class h3d_pass_ShadowSamplingKind(Enum):
    __slots__ = ()
    _hx_class_name = "h3d.pass.ShadowSamplingKind"
    _hx_constructs = ["None", "PCF", "ESM"]
h3d_pass_ShadowSamplingKind._hx_None = h3d_pass_ShadowSamplingKind("None", 0, ())
h3d_pass_ShadowSamplingKind.PCF = h3d_pass_ShadowSamplingKind("PCF", 1, ())
h3d_pass_ShadowSamplingKind.ESM = h3d_pass_ShadowSamplingKind("ESM", 2, ())
h3d_pass_ShadowSamplingKind._hx_class = h3d_pass_ShadowSamplingKind
_hx_classes["h3d.pass.ShadowSamplingKind"] = h3d_pass_ShadowSamplingKind


class h3d_pass_SortByMaterial:
    _hx_class_name = "h3d.pass.SortByMaterial"
    _hx_is_interface = "False"
    __slots__ = ("shaderCount", "textureCount", "shaderIdMap", "textureIdMap")
    _hx_fields = ["shaderCount", "textureCount", "shaderIdMap", "textureIdMap"]
    _hx_methods = ["sort"]

    def __init__(self):
        self.textureCount = 1
        self.shaderCount = 1
        self.shaderIdMap = []
        self.textureIdMap = []

    def sort(self,passes):
        _gthis = self
        shaderStart = self.shaderCount
        textureStart = self.textureCount
        _g_o = passes.current
        while (_g_o is not None):
            tmp = _g_o
            _g_o = _g_o.next
            p = tmp
            if (python_internal_ArrayImpl._get(self.shaderIdMap, p.shader.id) < shaderStart):
                def _hx_local_2():
                    _hx_local_0 = self
                    _hx_local_1 = _hx_local_0.shaderCount
                    _hx_local_0.shaderCount = (_hx_local_1 + 1)
                    return _hx_local_1
                python_internal_ArrayImpl._set(self.shaderIdMap, p.shader.id, _hx_local_2())
            if (python_internal_ArrayImpl._get(self.textureIdMap, p.texture) < textureStart):
                def _hx_local_5():
                    _hx_local_3 = self
                    _hx_local_4 = _hx_local_3.textureCount
                    _hx_local_3.textureCount = (_hx_local_4 + 1)
                    return _hx_local_4
                python_internal_ArrayImpl._set(self.textureIdMap, p.texture, _hx_local_5())
        _hx_list = passes.current
        tmp1 = None
        if (_hx_list is None):
            tmp1 = None
        else:
            insize = 1
            nmerges = None
            psize = 0
            qsize = 0
            p1 = None
            q = None
            e = None
            tail = None
            while True:
                p1 = _hx_list
                _hx_list = None
                tail = None
                nmerges = 0
                while (p1 is not None):
                    nmerges = (nmerges + 1)
                    q = p1
                    psize = 0
                    _g = 0
                    _g1 = insize
                    while (_g < _g1):
                        i = _g
                        _g = (_g + 1)
                        psize = (psize + 1)
                        q = q.next
                        if (q is None):
                            break
                    qsize = insize
                    while ((psize > 0) or (((qsize > 0) and ((q is not None))))):
                        if (psize == 0):
                            e = q
                            q = q.next
                            qsize = (qsize - 1)
                        else:
                            tmp2 = None
                            if (not (((qsize == 0) or ((q is None))))):
                                d = (python_internal_ArrayImpl._get(_gthis.shaderIdMap, p1.shader.id) - python_internal_ArrayImpl._get(_gthis.shaderIdMap, q.shader.id))
                                tmp2 = (((d if ((d != 0)) else (python_internal_ArrayImpl._get(_gthis.textureIdMap, p1.texture) - python_internal_ArrayImpl._get(_gthis.textureIdMap, q.texture)))) <= 0)
                            else:
                                tmp2 = True
                            if tmp2:
                                e = p1
                                p1 = p1.next
                                psize = (psize - 1)
                            else:
                                e = q
                                q = q.next
                                qsize = (qsize - 1)
                        if (tail is not None):
                            tail.next = e
                        else:
                            _hx_list = e
                        tail = e
                    p1 = q
                tail.next = None
                if (nmerges <= 1):
                    break
                insize = (insize * 2)
            tmp1 = _hx_list
        passes.current = tmp1

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.shaderCount = None
        _hx_o.textureCount = None
        _hx_o.shaderIdMap = None
        _hx_o.textureIdMap = None
h3d_pass_SortByMaterial._hx_class = h3d_pass_SortByMaterial
_hx_classes["h3d.pass.SortByMaterial"] = h3d_pass_SortByMaterial


class h3d_prim_Primitive:
    _hx_class_name = "h3d.prim.Primitive"
    _hx_is_interface = "False"
    __slots__ = ("buffer", "indexes", "refCount")
    _hx_fields = ["buffer", "indexes", "refCount"]
    _hx_methods = ["triCount", "vertexCount", "getCollider", "getBounds", "incref", "decref", "alloc", "selectMaterial", "buildNormalsDisplay", "render", "dispose", "toString"]
    _hx_interfaces = [hxd_impl__Serializable_NoSerializeSupport]

    def __init__(self):
        self.indexes = None
        self.buffer = None
        self.refCount = 0

    def triCount(self):
        if (self.indexes is not None):
            x = (self.indexes.count / 3)
            try:
                return int(x)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                return None
        elif (self.buffer is None):
            return 0
        else:
            x1 = (self.buffer.totalVertices() / 3)
            try:
                return int(x1)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e1 = _hx_e1
                return None

    def vertexCount(self):
        return 0

    def getCollider(self):
        raise _HxException(("not implemented for " + Std.string(self)))

    def getBounds(self):
        raise _HxException(("not implemented for " + Std.string(self)))

    def incref(self):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.refCount
        _hx_local_0.refCount = (_hx_local_1 + 1)
        _hx_local_1

    def decref(self):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.refCount
        _hx_local_0.refCount = (_hx_local_1 - 1)
        _hx_local_1
        if (self.refCount <= 0):
            self.refCount = 0
            self.dispose()

    def alloc(self,engine):
        raise _HxException("not implemented")

    def selectMaterial(self,material):
        pass

    def buildNormalsDisplay(self):
        raise _HxException(("not implemented for " + Std.string(self)))

    def render(self,engine):
        if ((self.buffer is None) or self.buffer.isDisposed()):
            self.alloc(engine)
        if (self.indexes is None):
            if (((self.buffer.flags & ((1 << h3d_BufferFlag.Quads.index)))) != 0):
                engine.renderBuffer(self.buffer,engine.mem.quadIndexes,2,0,-1)
            else:
                engine.renderBuffer(self.buffer,engine.mem.triIndexes,3,0,-1)
        else:
            engine.renderIndexed(self.buffer,self.indexes)

    def dispose(self):
        if (self.buffer is not None):
            self.buffer.dispose()
            self.buffer = None
        if (self.indexes is not None):
            self.indexes.dispose()
            self.indexes = None

    def toString(self):
        _this = Type.getClassName(Type.getClass(self))
        _this1 = _this.split(".")
        return (None if ((len(_this1) == 0)) else _this1.pop())

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.buffer = None
        _hx_o.indexes = None
        _hx_o.refCount = None
h3d_prim_Primitive._hx_class = h3d_prim_Primitive
_hx_classes["h3d.prim.Primitive"] = h3d_prim_Primitive


class h3d_prim_BigPrimitive(h3d_prim_Primitive):
    _hx_class_name = "h3d.prim.BigPrimitive"
    _hx_is_interface = "False"
    __slots__ = ("isRaw", "stride", "buffers", "allIndexes", "tmpBuf", "tmpIdx", "bounds", "bufPos", "idxPos", "startIndex", "flushing", "hasTangents", "isStatic")
    _hx_fields = ["isRaw", "stride", "buffers", "allIndexes", "tmpBuf", "tmpIdx", "bounds", "bufPos", "idxPos", "startIndex", "flushing", "hasTangents", "isStatic"]
    _hx_methods = ["begin", "addPoint", "addBounds", "addVertexValue", "addIndex", "triCount", "vertexCount", "flush", "render", "getBounds", "dispose", "clear", "add", "addSub"]
    _hx_statics = ["PREV_BUFFER", "PREV_INDEX"]
    _hx_interfaces = []
    _hx_super = h3d_prim_Primitive


    def __init__(self,stride,isRaw = None):
        if (isRaw is None):
            isRaw = False
        self.flushing = None
        self.bounds = None
        self.tmpIdx = None
        self.tmpBuf = None
        self.allIndexes = None
        self.buffers = None
        self.stride = None
        self.isRaw = None
        self.isStatic = True
        self.hasTangents = False
        self.startIndex = 0
        self.idxPos = 0
        self.bufPos = 0
        super().__init__()
        self.isRaw = isRaw
        self.buffers = []
        self.allIndexes = []
        self.bounds = h3d_col_Bounds()
        self.stride = stride
        if (stride < 3):
            raise _HxException("Minimum stride = 3")

    def begin(self,vcount,icount):
        x = (self.bufPos / self.stride)
        tmp = None
        try:
            tmp = int(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            tmp = None
        self.startIndex = tmp
        if ((self.startIndex + vcount) >= 65535):
            if (vcount >= 65535):
                raise _HxException("Too many vertices in begin()")
            self.flush()
        if (self.tmpBuf is None):
            self.tmpBuf = h3d_prim_BigPrimitive.PREV_BUFFER
            if (self.tmpBuf is None):
                this1 = list()
                self.tmpBuf = this1
            else:
                h3d_prim_BigPrimitive.PREV_BUFFER = None
            if self.isStatic:
                this2 = self.tmpBuf
                v = (65535 * self.stride)
                if (v > len(this2)):
                    python_internal_ArrayImpl._set(this2, (v - 1), 0.)
        if (not self.isStatic):
            this3 = self.tmpBuf
            v1 = ((vcount * self.stride) + self.bufPos)
            if (v1 > len(this3)):
                python_internal_ArrayImpl._set(this3, (v1 - 1), 0.)
        if (self.tmpIdx is None):
            self.tmpIdx = h3d_prim_BigPrimitive.PREV_INDEX
            if (self.tmpIdx is None):
                this4 = list()
                self.tmpIdx = this4
            else:
                h3d_prim_BigPrimitive.PREV_INDEX = None
        if ((self.idxPos + icount) > len(self.tmpIdx)):
            size = (1024 if ((len(self.tmpIdx) == 0)) else len(self.tmpIdx))
            req = (self.idxPos + icount)
            while (size < req):
                size = (size << 1)
            this5 = self.tmpIdx
            if (size > len(this5)):
                python_internal_ArrayImpl._set(this5, (size - 1), 0)

    def addPoint(self,x,y,z):
        key = self.bufPos
        self.bufPos = (self.bufPos + 1)
        python_internal_ArrayImpl._set(self.tmpBuf, key, x)
        key1 = self.bufPos
        self.bufPos = (self.bufPos + 1)
        python_internal_ArrayImpl._set(self.tmpBuf, key1, y)
        key2 = self.bufPos
        self.bufPos = (self.bufPos + 1)
        python_internal_ArrayImpl._set(self.tmpBuf, key2, z)
        _this = self.bounds
        if (x < _this.xMin):
            _this.xMin = x
        if (x > _this.xMax):
            _this.xMax = x
        if (y < _this.yMin):
            _this.yMin = y
        if (y > _this.yMax):
            _this.yMax = y
        if (z < _this.zMin):
            _this.zMin = z
        if (z > _this.zMax):
            _this.zMax = z

    def addBounds(self,x,y,z):
        _this = self.bounds
        if (x < _this.xMin):
            _this.xMin = x
        if (x > _this.xMax):
            _this.xMax = x
        if (y < _this.yMin):
            _this.yMin = y
        if (y > _this.yMax):
            _this.yMax = y
        if (z < _this.zMin):
            _this.zMin = z
        if (z > _this.zMax):
            _this.zMax = z

    def addVertexValue(self,v):
        key = self.bufPos
        self.bufPos = (self.bufPos + 1)
        python_internal_ArrayImpl._set(self.tmpBuf, key, v)

    def addIndex(self,i):
        key = self.idxPos
        self.idxPos = (self.idxPos + 1)
        python_internal_ArrayImpl._set(self.tmpIdx, key, (i + self.startIndex))

    def triCount(self):
        count = 0
        _g = 0
        _g1 = self.allIndexes
        while (_g < len(_g1)):
            i = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            count = (count + i.count)
        count = (count + self.idxPos)
        tmp = None
        try:
            tmp = int((count / 3))
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            tmp = None
        return tmp

    def vertexCount(self):
        count = 0
        _g = 0
        _g1 = self.buffers
        while (_g < len(_g1)):
            b = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            count = (count + b.vertices)
        x = (self.bufPos / self.stride)
        count1 = None
        try:
            count1 = int(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            count1 = None
        count = (count + count1)
        return count

    def flush(self):
        if (self.tmpBuf is not None):
            if ((self.bufPos > 0) and ((self.idxPos > 0))):
                self.flushing = True
                b = self.tmpBuf
                b1 = self.stride
                x = (self.bufPos / self.stride)
                b2 = None
                try:
                    b2 = int(x)
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e = _hx_e1
                    b2 = None
                b3 = h3d_Buffer.ofSubFloats(b,b1,b2)
                if self.isRaw:
                    b3.flags = (b3.flags | ((1 << h3d_BufferFlag.RawFormat.index)))
                _this = self.buffers
                _this.append(b3)
                idx = h3d_Indexes.alloc(self.tmpIdx,0,self.idxPos)
                _this1 = self.allIndexes
                _this1.append(idx)
                self.flushing = False
            if ((h3d_prim_BigPrimitive.PREV_BUFFER is None) or ((len(h3d_prim_BigPrimitive.PREV_BUFFER) < len(self.tmpBuf)))):
                h3d_prim_BigPrimitive.PREV_BUFFER = self.tmpBuf
            if ((h3d_prim_BigPrimitive.PREV_INDEX is None) or ((len(h3d_prim_BigPrimitive.PREV_INDEX) < len(self.tmpIdx)))):
                h3d_prim_BigPrimitive.PREV_INDEX = self.tmpIdx
            self.tmpBuf = None
            self.tmpIdx = None
            self.bufPos = 0
            self.idxPos = 0
            self.startIndex = 0

    def render(self,engine):
        if (self.tmpBuf is not None):
            self.flush()
        _g = 0
        _g1 = len(self.buffers)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            engine.renderIndexed((self.buffers[i] if i >= 0 and i < len(self.buffers) else None),(self.allIndexes[i] if i >= 0 and i < len(self.allIndexes) else None))

    def getBounds(self):
        return self.bounds

    def dispose(self):
        self.clear()

    def clear(self):
        if self.flushing:
            raise _HxException("Cannot clear() BigPrimitive while it's flushing")
        _this = self.bounds
        _this.xMin = 1e20
        _this.xMax = -1e20
        _this.yMin = 1e20
        _this.yMax = -1e20
        _this.zMin = 1e20
        _this.zMax = -1e20
        _g = 0
        _g1 = self.buffers
        while (_g < len(_g1)):
            b = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            b.dispose()
        _g2 = 0
        _g3 = self.allIndexes
        while (_g2 < len(_g3)):
            i = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
            _g2 = (_g2 + 1)
            i.dispose()
        self.buffers = []
        self.allIndexes = []
        self.bufPos = 0
        self.idxPos = 0
        self.tmpBuf = None
        self.tmpIdx = None

    def add(self,buf,idx,dx = None,dy = None,dz = None,rotation = None,scale = None,stride = None):
        if (dx is None):
            dx = 0.
        if (dy is None):
            dy = 0.
        if (dz is None):
            dz = 0.
        if (rotation is None):
            rotation = 0.
        if (scale is None):
            scale = 1.
        if (stride is None):
            stride = -1
        x = (len(buf) / ((self.stride if ((stride < 0)) else stride)))
        tmp = None
        try:
            tmp = int(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            tmp = None
        x1 = (len(idx) / 3)
        tmp1 = None
        try:
            tmp1 = int(x1)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e1 = _hx_e1
            tmp1 = None
        self.addSub(buf,idx,0,0,tmp,tmp1,dx,dy,dz,rotation,scale,stride)
        return

    def addSub(self,buf,idx,startVert,startTri,nvert,triCount,dx = None,dy = None,dz = None,rotation = None,scale = None,stride = None,deltaU = None,deltaV = None,color = None,mat = None):
        if (dx is None):
            dx = 0.
        if (dy is None):
            dy = 0.
        if (dz is None):
            dz = 0.
        if (rotation is None):
            rotation = 0.
        if (scale is None):
            scale = 1.
        if (stride is None):
            stride = -1
        if (deltaU is None):
            deltaU = 0.
        if (deltaV is None):
            deltaV = 0.
        if (color is None):
            color = 1.
        if (stride < 0):
            stride = self.stride
        if (stride < self.stride):
            raise _HxException((("only stride >= " + Std.string(self.stride)) + " allowed"))
        self.begin(nvert,(triCount * 3))
        start = self.startIndex
        cr = (Math.NaN if (((rotation == Math.POSITIVE_INFINITY) or ((rotation == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(rotation))
        sr = (Math.NaN if (((rotation == Math.POSITIVE_INFINITY) or ((rotation == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(rotation))
        pos = self.bufPos
        tmpBuf = self.tmpBuf
        _g = 0
        _g1 = nvert
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            p = (((i + startVert)) * stride)
            key = p
            p = (p + 1)
            x = python_internal_ArrayImpl._get(buf, key)
            key1 = p
            p = (p + 1)
            y = python_internal_ArrayImpl._get(buf, key1)
            key2 = p
            p = (p + 1)
            z = python_internal_ArrayImpl._get(buf, key2)
            if (mat is not None):
                x1 = x
                y1 = y
                z1 = z
                if (z1 is None):
                    z1 = 0.
                if (y1 is None):
                    y1 = 0.
                if (x1 is None):
                    x1 = 0.
                pt_x = x1
                pt_y = y1
                pt_z = z1
                px = ((((pt_x * mat._11) + ((pt_y * mat._21))) + ((pt_z * mat._31))) + mat._41)
                py = ((((pt_x * mat._12) + ((pt_y * mat._22))) + ((pt_z * mat._32))) + mat._42)
                pz = ((((pt_x * mat._13) + ((pt_y * mat._23))) + ((pt_z * mat._33))) + mat._43)
                pt_x = px
                pt_y = py
                pt_z = pz
                key3 = pos
                pos = (pos + 1)
                python_internal_ArrayImpl._set(tmpBuf, key3, pt_x)
                key4 = pos
                pos = (pos + 1)
                python_internal_ArrayImpl._set(tmpBuf, key4, pt_y)
                key5 = pos
                pos = (pos + 1)
                python_internal_ArrayImpl._set(tmpBuf, key5, pt_z)
                _this = self.bounds
                if (pt_x < _this.xMin):
                    _this.xMin = pt_x
                if (pt_x > _this.xMax):
                    _this.xMax = pt_x
                if (pt_y < _this.yMin):
                    _this.yMin = pt_y
                if (pt_y > _this.yMax):
                    _this.yMax = pt_y
                if (pt_z < _this.zMin):
                    _this.zMin = pt_z
                if (pt_z > _this.zMax):
                    _this.zMax = pt_z
            else:
                tx = ((((x * cr) - ((y * sr)))) * scale)
                ty = ((((x * sr) + ((y * cr)))) * scale)
                vx = (dx + tx)
                vy = (dy + ty)
                vz = (dz + ((z * scale)))
                key6 = pos
                pos = (pos + 1)
                python_internal_ArrayImpl._set(tmpBuf, key6, vx)
                key7 = pos
                pos = (pos + 1)
                python_internal_ArrayImpl._set(tmpBuf, key7, vy)
                key8 = pos
                pos = (pos + 1)
                python_internal_ArrayImpl._set(tmpBuf, key8, vz)
                _this1 = self.bounds
                if (vx < _this1.xMin):
                    _this1.xMin = vx
                if (vx > _this1.xMax):
                    _this1.xMax = vx
                if (vy < _this1.yMin):
                    _this1.yMin = vy
                if (vy > _this1.yMax):
                    _this1.yMax = vy
                if (vz < _this1.zMin):
                    _this1.zMin = vz
                if (vz > _this1.zMax):
                    _this1.zMax = vz
            if (self.stride >= 6):
                key9 = p
                p = (p + 1)
                nx = python_internal_ArrayImpl._get(buf, key9)
                key10 = p
                p = (p + 1)
                ny = python_internal_ArrayImpl._get(buf, key10)
                key11 = p
                p = (p + 1)
                nz = python_internal_ArrayImpl._get(buf, key11)
                if (mat is not None):
                    x2 = nx
                    y2 = ny
                    z2 = nz
                    if (z2 is None):
                        z2 = 0.
                    if (y2 is None):
                        y2 = 0.
                    if (x2 is None):
                        x2 = 0.
                    pt_x1 = x2
                    pt_y1 = y2
                    pt_z1 = z2
                    px1 = (((pt_x1 * mat._11) + ((pt_y1 * mat._21))) + ((pt_z1 * mat._31)))
                    py1 = (((pt_x1 * mat._12) + ((pt_y1 * mat._22))) + ((pt_z1 * mat._32)))
                    pz1 = (((pt_x1 * mat._13) + ((pt_y1 * mat._23))) + ((pt_z1 * mat._33)))
                    pt_x1 = px1
                    pt_y1 = py1
                    pt_z1 = pz1
                    k = (((pt_x1 * pt_x1) + ((pt_y1 * pt_y1))) + ((pt_z1 * pt_z1)))
                    k = (1. / ((Math.NaN if ((k < 0)) else python_lib_Math.sqrt(k))))
                    pt_x1 = (pt_x1 * k)
                    pt_y1 = (pt_y1 * k)
                    pt_z1 = (pt_z1 * k)
                    key12 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(tmpBuf, key12, pt_x1)
                    key13 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(tmpBuf, key13, pt_y1)
                    key14 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(tmpBuf, key14, pt_z1)
                else:
                    tnx = ((nx * cr) - ((ny * sr)))
                    tny = ((nx * sr) + ((ny * cr)))
                    key15 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(tmpBuf, key15, tnx)
                    key16 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(tmpBuf, key16, tny)
                    key17 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(tmpBuf, key17, nz)
            stride1 = self.stride
            if self.hasTangents:
                key18 = p
                p = (p + 1)
                tx1 = python_internal_ArrayImpl._get(buf, key18)
                key19 = p
                p = (p + 1)
                ty1 = python_internal_ArrayImpl._get(buf, key19)
                key20 = p
                p = (p + 1)
                tz = python_internal_ArrayImpl._get(buf, key20)
                if (mat is not None):
                    x3 = tx1
                    y3 = ty1
                    z3 = tz
                    if (z3 is None):
                        z3 = 0.
                    if (y3 is None):
                        y3 = 0.
                    if (x3 is None):
                        x3 = 0.
                    pt_x2 = x3
                    pt_y2 = y3
                    pt_z2 = z3
                    _hx_len = (((pt_x2 * pt_x2) + ((pt_y2 * pt_y2))) + ((pt_z2 * pt_z2)))
                    px2 = (((pt_x2 * mat._11) + ((pt_y2 * mat._21))) + ((pt_z2 * mat._31)))
                    py2 = (((pt_x2 * mat._12) + ((pt_y2 * mat._22))) + ((pt_z2 * mat._32)))
                    pz2 = (((pt_x2 * mat._13) + ((pt_y2 * mat._23))) + ((pt_z2 * mat._33)))
                    pt_x2 = px2
                    pt_y2 = py2
                    pt_z2 = pz2
                    k1 = (((pt_x2 * pt_x2) + ((pt_y2 * pt_y2))) + ((pt_z2 * pt_z2)))
                    k1 = (1. / ((Math.NaN if ((k1 < 0)) else python_lib_Math.sqrt(k1))))
                    pt_x2 = (pt_x2 * k1)
                    pt_y2 = (pt_y2 * k1)
                    pt_z2 = (pt_z2 * k1)
                    if (_hx_len < 0.5):
                        pt_x2 = (pt_x2 * 0.5)
                        pt_y2 = (pt_y2 * 0.5)
                        pt_z2 = (pt_z2 * 0.5)
                    key21 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(tmpBuf, key21, pt_x2)
                    key22 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(tmpBuf, key22, pt_y2)
                    key23 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(tmpBuf, key23, pt_z2)
                else:
                    tnx1 = ((tx1 * cr) - ((ty1 * sr)))
                    tny1 = ((tx1 * sr) + ((ty1 * cr)))
                    key24 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(tmpBuf, key24, tnx1)
                    key25 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(tmpBuf, key25, tny1)
                    key26 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(tmpBuf, key26, tz)
                stride1 = (stride1 - 3)
            stride2 = stride1
            if ((stride2 == 6) or ((stride2 == 3))):
                continue
            elif ((stride2 == 7) or ((stride2 == 4))):
                key27 = p
                p = (p + 1)
                key28 = pos
                pos = (pos + 1)
                python_internal_ArrayImpl._set(tmpBuf, key28, (python_internal_ArrayImpl._get(buf, key27) + deltaU))
            elif ((((stride2 == 10) or ((stride2 == 9))) or ((stride2 == 8))) or ((stride2 == 5))):
                key29 = p
                p = (p + 1)
                key30 = pos
                pos = (pos + 1)
                python_internal_ArrayImpl._set(tmpBuf, key30, (python_internal_ArrayImpl._get(buf, key29) + deltaU))
                key31 = p
                p = (p + 1)
                key32 = pos
                pos = (pos + 1)
                python_internal_ArrayImpl._set(tmpBuf, key32, (python_internal_ArrayImpl._get(buf, key31) + deltaV))
                _g2 = 8
                _g11 = stride1
                while (_g2 < _g11):
                    i1 = _g2
                    _g2 = (_g2 + 1)
                    key33 = p
                    p = (p + 1)
                    key34 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(tmpBuf, key34, python_internal_ArrayImpl._get(buf, key33))
            else:
                key35 = p
                p = (p + 1)
                key36 = pos
                pos = (pos + 1)
                python_internal_ArrayImpl._set(tmpBuf, key36, (python_internal_ArrayImpl._get(buf, key35) + deltaU))
                key37 = p
                p = (p + 1)
                key38 = pos
                pos = (pos + 1)
                python_internal_ArrayImpl._set(tmpBuf, key38, (python_internal_ArrayImpl._get(buf, key37) + deltaV))
                key39 = p
                p = (p + 1)
                key40 = pos
                pos = (pos + 1)
                python_internal_ArrayImpl._set(tmpBuf, key40, (python_internal_ArrayImpl._get(buf, key39) * color))
                key41 = p
                p = (p + 1)
                key42 = pos
                pos = (pos + 1)
                python_internal_ArrayImpl._set(tmpBuf, key42, (python_internal_ArrayImpl._get(buf, key41) * color))
                key43 = p
                p = (p + 1)
                key44 = pos
                pos = (pos + 1)
                python_internal_ArrayImpl._set(tmpBuf, key44, (python_internal_ArrayImpl._get(buf, key43) * color))
                _g3 = 11
                _g12 = stride1
                while (_g3 < _g12):
                    i2 = _g3
                    _g3 = (_g3 + 1)
                    key45 = p
                    p = (p + 1)
                    key46 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(tmpBuf, key46, python_internal_ArrayImpl._get(buf, key45))
        self.bufPos = pos
        start = (start - startVert)
        _g21 = 0
        _g31 = (triCount * 3)
        while (_g21 < _g31):
            i3 = _g21
            _g21 = (_g21 + 1)
            key47 = self.idxPos
            self.idxPos = (self.idxPos + 1)
            python_internal_ArrayImpl._set(self.tmpIdx, key47, (python_internal_ArrayImpl._get(idx, (i3 + ((startTri * 3)))) + start))
    PREV_BUFFER = None
    PREV_INDEX = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.isRaw = None
        _hx_o.stride = None
        _hx_o.buffers = None
        _hx_o.allIndexes = None
        _hx_o.tmpBuf = None
        _hx_o.tmpIdx = None
        _hx_o.bounds = None
        _hx_o.bufPos = None
        _hx_o.idxPos = None
        _hx_o.startIndex = None
        _hx_o.flushing = None
        _hx_o.hasTangents = None
        _hx_o.isStatic = None
h3d_prim_BigPrimitive._hx_class = h3d_prim_BigPrimitive
_hx_classes["h3d.prim.BigPrimitive"] = h3d_prim_BigPrimitive


class h3d_prim_MeshPrimitive(h3d_prim_Primitive):
    _hx_class_name = "h3d.prim.MeshPrimitive"
    _hx_is_interface = "False"
    __slots__ = ("bufferCache", "layouts")
    _hx_fields = ["bufferCache", "layouts"]
    _hx_methods = ["allocBuffer", "hasBuffer", "addBuffer", "dispose", "getBuffers", "render"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_prim_Primitive


    def __init__(self):
        self.layouts = None
        self.bufferCache = None
        super().__init__()

    def allocBuffer(self,engine,name):
        return None

    def hasBuffer(self,name):
        if (self.bufferCache is None):
            return False
        this1 = self.bufferCache
        return (hxsl_Globals.allocID(name) in this1.h)

    def addBuffer(self,name,buf,offset = None):
        if (offset is None):
            offset = 0
        if (self.bufferCache is None):
            self.bufferCache = haxe_ds_IntMap()
        id = hxsl_Globals.allocID(name)
        old = self.bufferCache.h.get(id,None)
        if (old is not None):
            old.dispose()
        self.bufferCache.set(id,h3d_BufferOffset(buf,offset))
        self.layouts = None

    def dispose(self):
        super().dispose()
        if (self.bufferCache is not None):
            b = self.bufferCache.iterator()
            while b.hasNext():
                b1 = b.next()
                b1.dispose()
        self.bufferCache = None
        self.layouts = None

    def getBuffers(self,engine):
        if (self.bufferCache is None):
            self.bufferCache = haxe_ds_IntMap()
        if (self.layouts is None):
            self.layouts = haxe_ds_IntMap()
        inputs = engine.driver.getShaderInputNames()
        buffers = self.layouts.h.get(inputs.id,None)
        if (buffers is not None):
            return buffers
        prev = None
        _g = 0
        _g1 = inputs.names
        while (_g < len(_g1)):
            name = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            id = hxsl_Globals.allocID(name)
            b = self.bufferCache.h.get(id,None)
            if (b is None):
                b = self.allocBuffer(engine,name)
                if (b is None):
                    raise _HxException((("Buffer " + ("null" if name is None else name)) + " is not available"))
                self.bufferCache.set(id,b)
            b1 = h3d_BufferOffset(b.buffer,b.offset)
            b = b1
            if (prev is None):
                prev = b
                buffers = prev
            else:
                prev.next = b
                prev = b
        self.layouts.set(inputs.id,buffers)
        return buffers

    def render(self,engine):
        if ((self.indexes is None) or self.indexes.isDisposed()):
            self.alloc(engine)
        engine.renderMultiBuffers(self.getBuffers(engine),self.indexes)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.bufferCache = None
        _hx_o.layouts = None
h3d_prim_MeshPrimitive._hx_class = h3d_prim_MeshPrimitive
_hx_classes["h3d.prim.MeshPrimitive"] = h3d_prim_MeshPrimitive


class h3d_prim_Polygon(h3d_prim_MeshPrimitive):
    _hx_class_name = "h3d.prim.Polygon"
    _hx_is_interface = "False"
    __slots__ = ("points", "normals", "tangents", "uvs", "idx", "colors", "scaled", "translatedX", "translatedY", "translatedZ")
    _hx_fields = ["points", "normals", "tangents", "uvs", "idx", "colors", "scaled", "translatedX", "translatedY", "translatedZ"]
    _hx_methods = ["getBounds", "alloc", "unindex", "translate", "scale", "addNormals", "addTangents", "addUVs", "uvScale", "triCount", "vertexCount", "getCollider", "render"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_prim_MeshPrimitive


    def __init__(self,points,idx = None):
        self.colors = None
        self.idx = None
        self.uvs = None
        self.tangents = None
        self.normals = None
        self.points = None
        self.translatedZ = 0.
        self.translatedY = 0.
        self.translatedX = 0.
        self.scaled = 1.
        super().__init__()
        self.points = points
        self.idx = idx

    def getBounds(self):
        b = h3d_col_Bounds()
        _g = 0
        _g1 = self.points
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (p.x < b.xMin):
                b.xMin = p.x
            if (p.x > b.xMax):
                b.xMax = p.x
            if (p.y < b.yMin):
                b.yMin = p.y
            if (p.y > b.yMax):
                b.yMax = p.y
            if (p.z < b.zMin):
                b.zMin = p.z
            if (p.z > b.zMax):
                b.zMax = p.z
        return b

    def alloc(self,engine):
        self.dispose()
        size = 3
        names = ["position"]
        positions = [0]
        if (self.normals is not None):
            names.append("normal")
            positions.append(size)
            size = (size + 3)
        if (self.tangents is not None):
            names.append("tangent")
            positions.append(size)
            size = (size + 3)
        if (self.uvs is not None):
            names.append("uv")
            positions.append(size)
            size = (size + 2)
        if (self.colors is not None):
            names.append("color")
            positions.append(size)
            size = (size + 3)
        this1 = list()
        buf = this1
        _g = 0
        _g1 = len(self.points)
        while (_g < _g1):
            k = _g
            _g = (_g + 1)
            p = (self.points[k] if k >= 0 and k < len(self.points) else None)
            v = p.x
            buf.append(v)
            v1 = p.y
            buf.append(v1)
            v2 = p.z
            buf.append(v2)
            if (self.normals is not None):
                n = (self.normals[k] if k >= 0 and k < len(self.normals) else None)
                v3 = n.x
                buf.append(v3)
                v4 = n.y
                buf.append(v4)
                v5 = n.z
                buf.append(v5)
            if (self.tangents is not None):
                t = (self.tangents[k] if k >= 0 and k < len(self.tangents) else None)
                v6 = t.x
                buf.append(v6)
                v7 = t.y
                buf.append(v7)
                v8 = t.z
                buf.append(v8)
            if (self.uvs is not None):
                t1 = (self.uvs[k] if k >= 0 and k < len(self.uvs) else None)
                v9 = t1.u
                buf.append(v9)
                v10 = t1.v
                buf.append(v10)
            if (self.colors is not None):
                c = (self.colors[k] if k >= 0 and k < len(self.colors) else None)
                v11 = c.x
                buf.append(v11)
                v12 = c.y
                buf.append(v12)
                v13 = c.z
                buf.append(v13)
        flags = []
        if (self.idx is None):
            flags.append(h3d_BufferFlag.Triangles)
        if ((self.normals is None) or ((self.tangents is not None))):
            flags.append(h3d_BufferFlag.RawFormat)
        self.buffer = h3d_Buffer.ofFloats(buf,size,flags)
        _g2 = 0
        _g3 = len(names)
        while (_g2 < _g3):
            i = _g2
            _g2 = (_g2 + 1)
            self.addBuffer((names[i] if i >= 0 and i < len(names) else None),self.buffer,(positions[i] if i >= 0 and i < len(positions) else None))
        if (self.idx is not None):
            self.indexes = h3d_Indexes.alloc(self.idx)

    def unindex(self):
        if ((self.idx is not None) and ((len(self.points) != len(self.idx)))):
            p = []
            _g = 0
            _g1 = len(self.idx)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                _this = python_internal_ArrayImpl._get(self.points, python_internal_ArrayImpl._get(self.idx, i))
                x = h3d_col_Point(_this.x,_this.y,_this.z)
                p.append(x)
            if (self.normals is not None):
                n = []
                _g2 = 0
                _g3 = len(self.idx)
                while (_g2 < _g3):
                    i1 = _g2
                    _g2 = (_g2 + 1)
                    _this1 = python_internal_ArrayImpl._get(self.normals, python_internal_ArrayImpl._get(self.idx, i1))
                    x1 = h3d_col_Point(_this1.x,_this1.y,_this1.z)
                    n.append(x1)
                self.normals = n
            if (self.tangents is not None):
                t = []
                _g21 = 0
                _g31 = len(self.idx)
                while (_g21 < _g31):
                    i2 = _g21
                    _g21 = (_g21 + 1)
                    _this2 = python_internal_ArrayImpl._get(self.tangents, python_internal_ArrayImpl._get(self.idx, i2))
                    x2 = h3d_col_Point(_this2.x,_this2.y,_this2.z)
                    t.append(x2)
                self.tangents = t
            if (self.colors is not None):
                n1 = []
                _g22 = 0
                _g32 = len(self.idx)
                while (_g22 < _g32):
                    i3 = _g22
                    _g22 = (_g22 + 1)
                    _this3 = python_internal_ArrayImpl._get(self.colors, python_internal_ArrayImpl._get(self.idx, i3))
                    x3 = h3d_col_Point(_this3.x,_this3.y,_this3.z)
                    n1.append(x3)
                self.colors = n1
            if (self.uvs is not None):
                t1 = []
                _g23 = 0
                _g33 = len(self.idx)
                while (_g23 < _g33):
                    i4 = _g23
                    _g23 = (_g23 + 1)
                    x4 = python_internal_ArrayImpl._get(self.uvs, python_internal_ArrayImpl._get(self.idx, i4)).clone()
                    t1.append(x4)
                self.uvs = t1
            self.points = p
            self.idx = None

    def translate(self,dx,dy,dz):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.translatedX
        _hx_local_0.translatedX = (_hx_local_1 + dx)
        _hx_local_0.translatedX
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.translatedY
        _hx_local_2.translatedY = (_hx_local_3 + dy)
        _hx_local_2.translatedY
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.translatedZ
        _hx_local_4.translatedZ = (_hx_local_5 + dz)
        _hx_local_4.translatedZ
        _g = 0
        _g1 = self.points
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            p.x = (p.x + dx)
            p.y = (p.y + dy)
            p.z = (p.z + dz)

    def scale(self,s):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.scaled
        _hx_local_0.scaled = (_hx_local_1 * s)
        _hx_local_0.scaled
        _g = 0
        _g1 = self.points
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            p.x = (p.x * s)
            p.y = (p.y * s)
            p.z = (p.z * s)

    def addNormals(self):
        self.normals = list()
        _g = 0
        _g1 = len(self.points)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            python_internal_ArrayImpl._set(self.normals, i, h3d_col_Point())
        pos = 0
        _g2 = 0
        _g3 = self.triCount()
        while (_g2 < _g3):
            i1 = _g2
            _g2 = (_g2 + 1)
            i0 = None
            i11 = None
            i2 = None
            if (self.idx is None):
                pos = (pos + 1)
                i0 = (pos - 1)
                pos = (pos + 1)
                i11 = (pos - 1)
                pos = (pos + 1)
                i2 = (pos - 1)
            else:
                key = pos
                pos = (pos + 1)
                i0 = python_internal_ArrayImpl._get(self.idx, key)
                key1 = pos
                pos = (pos + 1)
                i11 = python_internal_ArrayImpl._get(self.idx, key1)
                key2 = pos
                pos = (pos + 1)
                i2 = python_internal_ArrayImpl._get(self.idx, key2)
            p0 = (self.points[i0] if i0 >= 0 and i0 < len(self.points) else None)
            p1 = (self.points[i11] if i11 >= 0 and i11 < len(self.points) else None)
            p2 = (self.points[i2] if i2 >= 0 and i2 < len(self.points) else None)
            x = (p1.x - p0.x)
            y = (p1.y - p0.y)
            z = (p1.z - p0.z)
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            _this_x = x
            _this_y = y
            _this_z = z
            x1 = (p2.x - p0.x)
            y1 = (p2.y - p0.y)
            z1 = (p2.z - p0.z)
            if (z1 is None):
                z1 = 0.
            if (y1 is None):
                y1 = 0.
            if (x1 is None):
                x1 = 0.
            p_x = x1
            p_y = y1
            p_z = z1
            x2 = ((_this_y * p_z) - ((_this_z * p_y)))
            y2 = ((_this_z * p_x) - ((_this_x * p_z)))
            z2 = ((_this_x * p_y) - ((_this_y * p_x)))
            if (z2 is None):
                z2 = 0.
            if (y2 is None):
                y2 = 0.
            if (x2 is None):
                x2 = 0.
            n_x = x2
            n_y = y2
            n_z = z2
            _hx_local_3 = (self.normals[i0] if i0 >= 0 and i0 < len(self.normals) else None)
            _hx_local_4 = _hx_local_3.x
            _hx_local_3.x = (_hx_local_4 + n_x)
            _hx_local_3.x
            _hx_local_5 = (self.normals[i0] if i0 >= 0 and i0 < len(self.normals) else None)
            _hx_local_6 = _hx_local_5.y
            _hx_local_5.y = (_hx_local_6 + n_y)
            _hx_local_5.y
            _hx_local_7 = (self.normals[i0] if i0 >= 0 and i0 < len(self.normals) else None)
            _hx_local_8 = _hx_local_7.z
            _hx_local_7.z = (_hx_local_8 + n_z)
            _hx_local_7.z
            _hx_local_9 = (self.normals[i11] if i11 >= 0 and i11 < len(self.normals) else None)
            _hx_local_10 = _hx_local_9.x
            _hx_local_9.x = (_hx_local_10 + n_x)
            _hx_local_9.x
            _hx_local_11 = (self.normals[i11] if i11 >= 0 and i11 < len(self.normals) else None)
            _hx_local_12 = _hx_local_11.y
            _hx_local_11.y = (_hx_local_12 + n_y)
            _hx_local_11.y
            _hx_local_13 = (self.normals[i11] if i11 >= 0 and i11 < len(self.normals) else None)
            _hx_local_14 = _hx_local_13.z
            _hx_local_13.z = (_hx_local_14 + n_z)
            _hx_local_13.z
            _hx_local_15 = (self.normals[i2] if i2 >= 0 and i2 < len(self.normals) else None)
            _hx_local_16 = _hx_local_15.x
            _hx_local_15.x = (_hx_local_16 + n_x)
            _hx_local_15.x
            _hx_local_17 = (self.normals[i2] if i2 >= 0 and i2 < len(self.normals) else None)
            _hx_local_18 = _hx_local_17.y
            _hx_local_17.y = (_hx_local_18 + n_y)
            _hx_local_17.y
            _hx_local_19 = (self.normals[i2] if i2 >= 0 and i2 < len(self.normals) else None)
            _hx_local_20 = _hx_local_19.z
            _hx_local_19.z = (_hx_local_20 + n_z)
            _hx_local_19.z
        _g4 = 0
        _g5 = self.normals
        while (_g4 < len(_g5)):
            n = (_g5[_g4] if _g4 >= 0 and _g4 < len(_g5) else None)
            _g4 = (_g4 + 1)
            n.normalize()

    def addTangents(self):
        if (self.normals is None):
            self.addNormals()
        if (self.uvs is None):
            self.addUVs()
        self.tangents = []
        _g = 0
        _g1 = len(self.points)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            python_internal_ArrayImpl._set(self.tangents, i, h3d_col_Point())
        pos = 0
        _g2 = 0
        _g3 = self.triCount()
        while (_g2 < _g3):
            i1 = _g2
            _g2 = (_g2 + 1)
            i0 = None
            i11 = None
            i2 = None
            if (self.idx is None):
                pos = (pos + 1)
                i0 = (pos - 1)
                pos = (pos + 1)
                i11 = (pos - 1)
                pos = (pos + 1)
                i2 = (pos - 1)
            else:
                key = pos
                pos = (pos + 1)
                i0 = python_internal_ArrayImpl._get(self.idx, key)
                key1 = pos
                pos = (pos + 1)
                i11 = python_internal_ArrayImpl._get(self.idx, key1)
                key2 = pos
                pos = (pos + 1)
                i2 = python_internal_ArrayImpl._get(self.idx, key2)
            p0 = (self.points[i0] if i0 >= 0 and i0 < len(self.points) else None)
            p1 = (self.points[i11] if i11 >= 0 and i11 < len(self.points) else None)
            p2 = (self.points[i2] if i2 >= 0 and i2 < len(self.points) else None)
            uv0 = (self.uvs[i0] if i0 >= 0 and i0 < len(self.uvs) else None)
            uv1 = (self.uvs[i11] if i11 >= 0 and i11 < len(self.uvs) else None)
            uv2 = (self.uvs[i2] if i2 >= 0 and i2 < len(self.uvs) else None)
            n = (self.normals[i0] if i0 >= 0 and i0 < len(self.normals) else None)
            x = (p1.x - p0.x)
            y = (p1.y - p0.y)
            z = (p1.z - p0.z)
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            k0_x = x
            k0_y = y
            k0_z = z
            x1 = (p2.x - p0.x)
            y1 = (p2.y - p0.y)
            z1 = (p2.z - p0.z)
            if (z1 is None):
                z1 = 0.
            if (y1 is None):
                y1 = 0.
            if (x1 is None):
                x1 = 0.
            k1_x = x1
            k1_y = y1
            k1_z = z1
            v = (uv2.v - uv0.v)
            k0_x = (k0_x * v)
            k0_y = (k0_y * v)
            k0_z = (k0_z * v)
            v1 = (uv1.v - uv0.v)
            k1_x = (k1_x * v1)
            k1_y = (k1_y * v1)
            k1_z = (k1_z * v1)
            t = h3d_col_Point((k0_x - k1_x),(k0_y - k1_y),(k0_z - k1_z))
            b = h3d_col_Point(((n.y * t.z) - ((n.z * t.y))),((n.z * t.x) - ((n.x * t.z))),((n.x * t.y) - ((n.y * t.x))))
            b.normalize()
            t = h3d_col_Point(((b.y * n.z) - ((b.z * n.y))),((b.z * n.x) - ((b.x * n.z))),((b.x * n.y) - ((b.y * n.x))))
            t.normalize()
            _hx_local_9 = (self.tangents[i0] if i0 >= 0 and i0 < len(self.tangents) else None)
            _hx_local_10 = _hx_local_9.x
            _hx_local_9.x = (_hx_local_10 + t.x)
            _hx_local_9.x
            _hx_local_11 = (self.tangents[i0] if i0 >= 0 and i0 < len(self.tangents) else None)
            _hx_local_12 = _hx_local_11.y
            _hx_local_11.y = (_hx_local_12 + t.y)
            _hx_local_11.y
            _hx_local_13 = (self.tangents[i0] if i0 >= 0 and i0 < len(self.tangents) else None)
            _hx_local_14 = _hx_local_13.z
            _hx_local_13.z = (_hx_local_14 + t.z)
            _hx_local_13.z
            _hx_local_15 = (self.tangents[i11] if i11 >= 0 and i11 < len(self.tangents) else None)
            _hx_local_16 = _hx_local_15.x
            _hx_local_15.x = (_hx_local_16 + t.x)
            _hx_local_15.x
            _hx_local_17 = (self.tangents[i11] if i11 >= 0 and i11 < len(self.tangents) else None)
            _hx_local_18 = _hx_local_17.y
            _hx_local_17.y = (_hx_local_18 + t.y)
            _hx_local_17.y
            _hx_local_19 = (self.tangents[i11] if i11 >= 0 and i11 < len(self.tangents) else None)
            _hx_local_20 = _hx_local_19.z
            _hx_local_19.z = (_hx_local_20 + t.z)
            _hx_local_19.z
            _hx_local_21 = (self.tangents[i2] if i2 >= 0 and i2 < len(self.tangents) else None)
            _hx_local_22 = _hx_local_21.x
            _hx_local_21.x = (_hx_local_22 + t.x)
            _hx_local_21.x
            _hx_local_23 = (self.tangents[i2] if i2 >= 0 and i2 < len(self.tangents) else None)
            _hx_local_24 = _hx_local_23.y
            _hx_local_23.y = (_hx_local_24 + t.y)
            _hx_local_23.y
            _hx_local_25 = (self.tangents[i2] if i2 >= 0 and i2 < len(self.tangents) else None)
            _hx_local_26 = _hx_local_25.z
            _hx_local_25.z = (_hx_local_26 + t.z)
            _hx_local_25.z
        _g4 = 0
        _g5 = self.tangents
        while (_g4 < len(_g5)):
            t1 = (_g5[_g4] if _g4 >= 0 and _g4 < len(_g5) else None)
            _g4 = (_g4 + 1)
            t1.normalize()

    def addUVs(self):
        self.uvs = []
        _g = 0
        _g1 = len(self.points)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            python_internal_ArrayImpl._set(self.uvs, i, h3d_prim_UV((self.points[i] if i >= 0 and i < len(self.points) else None).x,(self.points[i] if i >= 0 and i < len(self.points) else None).y))

    def uvScale(self,su,sv):
        if (self.uvs is None):
            raise _HxException("Missing UVs")
        m = haxe_ds_ObjectMap()
        _g = 0
        _g1 = self.uvs
        while (_g < len(_g1)):
            t = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (t in m.h):
                continue
            m.set(t,True)
            t.u = (t.u * su)
            t.v = (t.v * sv)

    def triCount(self):
        n = super().triCount()
        if (n != 0):
            return n
        x = (((len(self.points) if ((self.idx is None)) else len(self.idx))) / 3)
        try:
            return int(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            return None

    def vertexCount(self):
        return len(self.points)

    def getCollider(self):
        this1 = [None]*(len(self.points) * 3)
        vertexes = this1
        this2 = [None]*len(self.idx)
        indexes = this2
        vid = 0
        _g = 0
        _g1 = self.points
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            index = vid
            vid = (vid + 1)
            val = p.x
            vertexes[index] = val
            index1 = vid
            vid = (vid + 1)
            val1 = p.y
            vertexes[index1] = val1
            index2 = vid
            vid = (vid + 1)
            val2 = p.z
            vertexes[index2] = val2
        _g2 = 0
        _g3 = len(self.idx)
        while (_g2 < _g3):
            i = _g2
            _g2 = (_g2 + 1)
            val3 = python_internal_ArrayImpl._get(self.idx, i)
            indexes[i] = val3
        poly = h3d_col_Polygon()
        poly.addBuffers(vertexes,indexes)
        return poly

    def render(self,engine):
        if ((self.buffer is None) or self.buffer.isDisposed()):
            self.alloc(engine)
        bufs = self.getBuffers(engine)
        if (self.indexes is not None):
            engine.renderMultiBuffers(bufs,self.indexes)
        elif (((self.buffer.flags & ((1 << h3d_BufferFlag.Quads.index)))) != 0):
            engine.renderMultiBuffers(bufs,engine.mem.quadIndexes,0,self.triCount())
        else:
            engine.renderMultiBuffers(bufs,engine.mem.triIndexes,0,self.triCount())

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.points = None
        _hx_o.normals = None
        _hx_o.tangents = None
        _hx_o.uvs = None
        _hx_o.idx = None
        _hx_o.colors = None
        _hx_o.scaled = None
        _hx_o.translatedX = None
        _hx_o.translatedY = None
        _hx_o.translatedZ = None
h3d_prim_Polygon._hx_class = h3d_prim_Polygon
_hx_classes["h3d.prim.Polygon"] = h3d_prim_Polygon


class h3d_prim_Cube(h3d_prim_Polygon):
    _hx_class_name = "h3d.prim.Cube"
    _hx_is_interface = "False"
    __slots__ = ("sizeX", "sizeY", "sizeZ")
    _hx_fields = ["sizeX", "sizeY", "sizeZ"]
    _hx_methods = ["addUVs", "addUniformUVs", "getCollider"]
    _hx_statics = ["defaultUnitCube"]
    _hx_interfaces = []
    _hx_super = h3d_prim_Polygon


    def __init__(self,x = None,y = None,z = None,centered = None):
        if (x is None):
            x = 1.
        if (y is None):
            y = 1.
        if (z is None):
            z = 1.
        if (centered is None):
            centered = False
        self.sizeX = x
        self.sizeY = y
        self.sizeZ = z
        p = [h3d_col_Point(0,0,0), h3d_col_Point(x,0,0), h3d_col_Point(0,y,0), h3d_col_Point(0,0,z), h3d_col_Point(x,y,0), h3d_col_Point(x,0,z), h3d_col_Point(0,y,z), h3d_col_Point(x,y,z)]
        this1 = list()
        idx = this1
        idx.append(0)
        idx.append(1)
        idx.append(5)
        idx.append(0)
        idx.append(5)
        idx.append(3)
        idx.append(1)
        idx.append(4)
        idx.append(7)
        idx.append(1)
        idx.append(7)
        idx.append(5)
        idx.append(3)
        idx.append(5)
        idx.append(7)
        idx.append(3)
        idx.append(7)
        idx.append(6)
        idx.append(0)
        idx.append(6)
        idx.append(2)
        idx.append(0)
        idx.append(3)
        idx.append(6)
        idx.append(2)
        idx.append(7)
        idx.append(4)
        idx.append(2)
        idx.append(6)
        idx.append(7)
        idx.append(0)
        idx.append(4)
        idx.append(1)
        idx.append(0)
        idx.append(2)
        idx.append(4)
        super().__init__(p,idx)
        if centered:
            self.translate((-x * 0.5),(-y * 0.5),(-z * 0.5))

    def addUVs(self):
        self.unindex()
        z = h3d_prim_UV(0,1)
        x = h3d_prim_UV(1,1)
        y = h3d_prim_UV(0,0)
        o = h3d_prim_UV(1,0)
        self.uvs = [x, z, y, x, y, o, x, z, y, x, y, o, x, z, y, x, y, o, z, o, x, z, y, o, z, o, x, z, y, o, z, o, x, z, y, o]

    def addUniformUVs(self,scale = None):
        if (scale is None):
            scale = 1.
        self.unindex()
        v = scale
        self.uvs = [h3d_prim_UV((v * self.sizeX),(v * self.sizeZ)), h3d_prim_UV(0,(v * self.sizeZ)), h3d_prim_UV(0,0), h3d_prim_UV((v * self.sizeX),(v * self.sizeZ)), h3d_prim_UV(0,0), h3d_prim_UV((v * self.sizeX),0), h3d_prim_UV((v * self.sizeY),(v * self.sizeZ)), h3d_prim_UV(0,(v * self.sizeZ)), h3d_prim_UV(0,0), h3d_prim_UV((v * self.sizeY),(v * self.sizeZ)), h3d_prim_UV(0,0), h3d_prim_UV((v * self.sizeY),0), h3d_prim_UV((v * self.sizeX),(v * self.sizeY)), h3d_prim_UV(0,(v * self.sizeY)), h3d_prim_UV(0,0), h3d_prim_UV((v * self.sizeX),(v * self.sizeY)), h3d_prim_UV(0,0), h3d_prim_UV((v * self.sizeX),0), h3d_prim_UV(0,(v * self.sizeZ)), h3d_prim_UV((v * self.sizeY),0), h3d_prim_UV((v * self.sizeY),(v * self.sizeZ)), h3d_prim_UV(0,(v * self.sizeZ)), h3d_prim_UV(0,0), h3d_prim_UV((v * self.sizeY),0), h3d_prim_UV(0,(v * self.sizeZ)), h3d_prim_UV((v * self.sizeX),0), h3d_prim_UV((v * self.sizeX),(v * self.sizeZ)), h3d_prim_UV(0,(v * self.sizeZ)), h3d_prim_UV(0,0), h3d_prim_UV((v * self.sizeX),0), h3d_prim_UV(0,(v * self.sizeY)), h3d_prim_UV((v * self.sizeX),0), h3d_prim_UV((v * self.sizeX),(v * self.sizeY)), h3d_prim_UV(0,(v * self.sizeY)), h3d_prim_UV(0,0), h3d_prim_UV((v * self.sizeX),0)]

    def getCollider(self):
        x = self.translatedX
        y = self.translatedY
        z = self.translatedZ
        dx = (self.sizeX * self.scaled)
        dy = (self.sizeY * self.scaled)
        dz = (self.sizeZ * self.scaled)
        b = h3d_col_Bounds()
        b.xMin = x
        b.yMin = y
        b.zMin = z
        b.xMax = (x + dx)
        b.yMax = (y + dy)
        b.zMax = (z + dz)
        return b

    @staticmethod
    def defaultUnitCube():
        engine = h3d_Engine.CURRENT
        c = engine.resCache.h.get(h3d_prim_Cube,None)
        if (c is not None):
            return c
        c = h3d_prim_Cube(1,1,1)
        c.translate(-0.5,-0.5,-0.5)
        c.unindex()
        c.addNormals()
        c.addUniformUVs(1.0)
        c.addTangents()
        engine.resCache.set(h3d_prim_Cube,c)
        return c

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.sizeX = None
        _hx_o.sizeY = None
        _hx_o.sizeZ = None
h3d_prim_Cube._hx_class = h3d_prim_Cube
_hx_classes["h3d.prim.Cube"] = h3d_prim_Cube


class h3d_prim_HMDModel(h3d_prim_MeshPrimitive):
    _hx_class_name = "h3d.prim.HMDModel"
    _hx_is_interface = "False"
    __slots__ = ("data", "dataPosition", "indexCount", "indexesTriPos", "lib", "curMaterial", "collider", "normalsRecomputed", "bufferAliases")
    _hx_fields = ["data", "dataPosition", "indexCount", "indexesTriPos", "lib", "curMaterial", "collider", "normalsRecomputed", "bufferAliases"]
    _hx_methods = ["triCount", "vertexCount", "getBounds", "selectMaterial", "getDataBuffers", "loadSkin", "addAlias", "alloc", "recomputeNormals", "render", "initCollider", "getCollider"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_prim_MeshPrimitive


    def __init__(self,data,dataPos,lib):
        self.normalsRecomputed = None
        self.collider = None
        self.curMaterial = None
        self.lib = None
        self.indexesTriPos = None
        self.indexCount = None
        self.dataPosition = None
        self.data = None
        self.bufferAliases = haxe_ds_StringMap()
        super().__init__()
        self.data = data
        self.dataPosition = dataPos
        self.lib = lib

    def triCount(self):
        x = (self.data.get_indexCount() / 3)
        try:
            return int(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            return None

    def vertexCount(self):
        return self.data.vertexCount

    def getBounds(self):
        return self.data.bounds

    def selectMaterial(self,i):
        self.curMaterial = i

    def getDataBuffers(self,fmt,defaults = None,material = None):
        return self.lib.getBuffers(self.data,fmt,defaults,material)

    def loadSkin(self,skin):
        self.lib.loadSkin(self.data,skin)

    def addAlias(self,name,realName,offset = None):
        if (offset is None):
            offset = 0
        self.bufferAliases.h[name] = _hx_AnonObject({'realName': realName, 'offset': offset})

    def alloc(self,engine):
        self.dispose()
        self.buffer = h3d_Buffer(self.data.vertexCount,self.data.vertexStride)
        entry = self.lib.resource.entry
        entry.open()
        entry.skip((self.dataPosition + self.data.vertexPosition))
        size = ((self.data.vertexCount * self.data.vertexStride) * 4)
        _hx_bytes = haxe_io_Bytes.alloc(size)
        entry.read(_hx_bytes,0,size)
        self.buffer.uploadBytes(_hx_bytes,0,self.data.vertexCount)
        self.indexCount = 0
        self.indexesTriPos = []
        _g = 0
        _g1 = self.data.indexCounts
        while (_g < len(_g1)):
            n = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            _this = self.indexesTriPos
            x = (self.indexCount / 3)
            x1 = None
            try:
                x1 = int(x)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                x1 = None
            _this.append(x1)
            _hx_local_1 = self
            _hx_local_2 = _hx_local_1.indexCount
            _hx_local_1.indexCount = (_hx_local_2 + n)
            _hx_local_1.indexCount
        self.indexes = h3d_Indexes(self.indexCount)
        entry.skip((self.data.indexPosition - ((self.data.vertexPosition + size))))
        bytes1 = haxe_io_Bytes.alloc((self.indexCount * 2))
        entry.read(bytes1,0,(self.indexCount * 2))
        self.indexes.uploadBytes(bytes1,0,self.indexCount)
        entry.close()
        pos = 0
        _g2 = 0
        _g3 = self.data.vertexFormat
        while (_g2 < len(_g3)):
            f = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
            _g2 = (_g2 + 1)
            self.addBuffer(f.name,self.buffer,pos)
            pos = (pos + ((f.format & 7)))
        if (self.normalsRecomputed is not None):
            self.recomputeNormals(self.normalsRecomputed)
        name = self.bufferAliases.keys()
        while name.hasNext():
            name1 = name.next()
            alias = self.bufferAliases.h.get(name1,None)
            this1 = self.bufferCache
            key = hxsl_Globals.allocID(alias.realName)
            buffer = this1.h.get(key,None)
            if (buffer is None):
                raise _HxException(((("Buffer " + HxOverrides.stringOrNull(alias.realName)) + " not found for alias ") + ("null" if name1 is None else name1)))
            if ((buffer.offset + alias.offset) > buffer.buffer.buffer.stride):
                raise _HxException((((("Alias " + ("null" if name1 is None else name1)) + " for buffer ") + HxOverrides.stringOrNull(alias.realName)) + " outside stride"))
            self.addBuffer(name1,buffer.buffer,(buffer.offset + alias.offset))

    def recomputeNormals(self,name = None):
        if (name is None):
            name = "normal"
        pos = self.lib.getBuffers(self.data,[hxd_fmt_hmd_GeometryFormat("position",3)])
        ids = list()
        pts = []
        _g = 0
        _g1 = self.data.vertexCount
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            added = False
            px = pos.vertexes[(i * 3)]
            py = pos.vertexes[((i * 3) + 1)]
            pz = pos.vertexes[((i * 3) + 2)]
            _g2 = 0
            _g11 = len(pts)
            while (_g2 < _g11):
                i1 = _g2
                _g2 = (_g2 + 1)
                p = (pts[i1] if i1 >= 0 and i1 < len(pts) else None)
                if (((p.x == px) and ((p.y == py))) and ((p.z == pz))):
                    ids.append(i1)
                    added = True
                    break
            if (not added):
                x = len(pts)
                ids.append(x)
                x1 = h3d_col_Point(px,py,pz)
                pts.append(x1)
        this1 = list()
        idx = this1
        _g21 = 0
        _g3 = pos.indexes
        while (_g21 < len(_g3)):
            i2 = _g3[_g21]
            _g21 = (_g21 + 1)
            idx.append((ids[i2] if i2 >= 0 and i2 < len(ids) else None))
        pol = h3d_prim_Polygon(pts,idx)
        pol.addNormals()
        this2 = list()
        v = this2
        v1 = (self.data.vertexCount * 3)
        if (v1 > len(v)):
            python_internal_ArrayImpl._set(v, (v1 - 1), 0.)
        k = 0
        _g4 = 0
        _g5 = self.data.vertexCount
        while (_g4 < _g5):
            i3 = _g4
            _g4 = (_g4 + 1)
            n = python_internal_ArrayImpl._get(pol.normals, (ids[i3] if i3 >= 0 and i3 < len(ids) else None))
            key = k
            k = (k + 1)
            python_internal_ArrayImpl._set(v, key, n.x)
            key1 = k
            k = (k + 1)
            python_internal_ArrayImpl._set(v, key1, n.y)
            key2 = k
            k = (k + 1)
            python_internal_ArrayImpl._set(v, key2, n.z)
        buf = h3d_Buffer.ofFloats(v,3)
        self.addBuffer(name,buf,0)
        self.normalsRecomputed = name

    def render(self,engine):
        if (self.curMaterial < 0):
            super().render(engine)
            return
        if ((self.indexes is None) or self.indexes.isDisposed()):
            self.alloc(engine)
        tmp = self.getBuffers(engine)
        tmp1 = self.indexes
        tmp2 = python_internal_ArrayImpl._get(self.indexesTriPos, self.curMaterial)
        x = (python_internal_ArrayImpl._get(self.data.indexCounts, self.curMaterial) / 3)
        tmp3 = None
        try:
            tmp3 = int(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            tmp3 = None
        engine.renderMultiBuffers(tmp,tmp1,tmp2,tmp3)
        self.curMaterial = -1

    def initCollider(self,poly):
        buf = self.lib.getBuffers(self.data,[hxd_fmt_hmd_GeometryFormat("position",3)])
        poly.setData(buf.vertexes,buf.indexes)
        if (self.collider is None):
            _this = self.data.bounds
            dx = (_this.xMax - _this.xMin)
            dy = (_this.yMax - _this.yMin)
            dz = (_this.zMax - _this.zMin)
            f = (((dx * dx) + ((dy * dy))) + ((dz * dz)))
            sphere = h3d_col_Sphere((((_this.xMin + _this.xMax)) * 0.5),(((_this.yMin + _this.yMax)) * 0.5),(((_this.zMin + _this.zMax)) * 0.5),(((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))) * 0.5))
            self.collider = h3d_col_OptimizedCollider(sphere,poly)

    def getCollider(self):
        if (self.collider is not None):
            return self.collider
        poly = h3d_col_PolygonBuffer()
        poly.source = _hx_AnonObject({'entry': self.lib.resource.entry, 'geometryName': None})
        _g = 0
        _g1 = self.lib.header.models
        while (_g < len(_g1)):
            h = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (python_internal_ArrayImpl._get(self.lib.header.geometries, h.geometry) == self.data):
                poly.source.geometryName = h.name
                break
        self.initCollider(poly)
        return self.collider

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.data = None
        _hx_o.dataPosition = None
        _hx_o.indexCount = None
        _hx_o.indexesTriPos = None
        _hx_o.lib = None
        _hx_o.curMaterial = None
        _hx_o.collider = None
        _hx_o.normalsRecomputed = None
        _hx_o.bufferAliases = None
h3d_prim_HMDModel._hx_class = h3d_prim_HMDModel
_hx_classes["h3d.prim.HMDModel"] = h3d_prim_HMDModel


class h3d_prim_Instanced(h3d_prim_MeshPrimitive):
    _hx_class_name = "h3d.prim.Instanced"
    _hx_is_interface = "False"
    __slots__ = ("commands", "offset", "baseBounds", "tmpBounds", "primitive")
    _hx_fields = ["commands", "offset", "baseBounds", "tmpBounds", "primitive"]
    _hx_methods = ["setMesh", "dispose", "incref", "decref", "getBounds", "addBuffer", "render"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_prim_MeshPrimitive


    def __init__(self):
        self.primitive = None
        self.tmpBounds = None
        self.baseBounds = None
        self.offset = None
        self.commands = None
        super().__init__()
        self.offset = h3d_col_Sphere()
        self.tmpBounds = h3d_col_Bounds()

    def setMesh(self,m):
        if (self.refCount > 0):
            if (self.primitive is not None):
                self.primitive.decref()
            m.incref()
        self.primitive = m
        engine = h3d_Engine.CURRENT
        if ((m.buffer is None) or m.buffer.isDisposed()):
            m.alloc(engine)
        self.buffer = m.buffer
        self.indexes = m.indexes
        self.baseBounds = m.getBounds()
        if (self.indexes is None):
            self.indexes = engine.mem.triIndexes
        bid = m.bufferCache.keys()
        while bid.hasNext():
            bid1 = bid.next()
            b = m.bufferCache.h.get(bid1,None)
            self.addBuffer(hxsl_Globals.getIDName(bid1),b.buffer,b.offset)

    def dispose(self):
        pass

    def incref(self):
        if ((self.refCount == 0) and ((self.primitive is not None))):
            self.primitive.incref()
        super().incref()

    def decref(self):
        super().decref()
        if ((self.refCount == 0) and ((self.primitive is not None))):
            self.primitive.decref()

    def getBounds(self):
        self.tmpBounds.load(self.baseBounds)
        r = self.offset.r
        _this = self.tmpBounds
        dx = self.offset.x
        dy = self.offset.y
        dz = self.offset.z
        _this.xMin = (_this.xMin + dx)
        _this.xMax = (_this.xMax + dx)
        _this.yMin = (_this.yMin + dy)
        _this.yMax = (_this.yMax + dy)
        _this.zMin = (_this.zMin + dz)
        _this.zMax = (_this.zMax + dz)
        _hx_local_6 = self.tmpBounds
        _hx_local_7 = _hx_local_6.xMin
        _hx_local_6.xMin = (_hx_local_7 - r)
        _hx_local_6.xMin
        _hx_local_8 = self.tmpBounds
        _hx_local_9 = _hx_local_8.yMin
        _hx_local_8.yMin = (_hx_local_9 - r)
        _hx_local_8.yMin
        _hx_local_10 = self.tmpBounds
        _hx_local_11 = _hx_local_10.zMin
        _hx_local_10.zMin = (_hx_local_11 - r)
        _hx_local_10.zMin
        _hx_local_12 = self.tmpBounds
        _hx_local_13 = _hx_local_12.xMax
        _hx_local_12.xMax = (_hx_local_13 + r)
        _hx_local_12.xMax
        _hx_local_14 = self.tmpBounds
        _hx_local_15 = _hx_local_14.yMax
        _hx_local_14.yMax = (_hx_local_15 + r)
        _hx_local_14.yMax
        _hx_local_16 = self.tmpBounds
        _hx_local_17 = _hx_local_16.zMax
        _hx_local_16.zMax = (_hx_local_17 + r)
        _hx_local_16.zMax
        return self.tmpBounds

    def addBuffer(self,name,buffer,offset = None):
        if (offset is None):
            offset = 0
        super().addBuffer(name,buffer,offset)

    def render(self,engine):
        if self.buffer.isDisposed():
            self.setMesh(self.primitive)
        engine.renderInstanced(self.getBuffers(engine),self.indexes,self.commands)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.commands = None
        _hx_o.offset = None
        _hx_o.baseBounds = None
        _hx_o.tmpBounds = None
        _hx_o.primitive = None
h3d_prim_Instanced._hx_class = h3d_prim_Instanced
_hx_classes["h3d.prim.Instanced"] = h3d_prim_Instanced


class h3d_prim_Plane2D(h3d_prim_Primitive):
    _hx_class_name = "h3d.prim.Plane2D"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["triCount", "vertexCount", "alloc", "render"]
    _hx_statics = ["get"]
    _hx_interfaces = []
    _hx_super = h3d_prim_Primitive


    def __init__(self):
        super().__init__()

    def triCount(self):
        return 2

    def vertexCount(self):
        return 4

    def alloc(self,engine):
        this1 = list()
        v = this1
        v.append(-1)
        v.append(-1)
        v.append(0)
        v.append(1)
        v.append(-1)
        v.append(1)
        v.append(0)
        v.append(0)
        v.append(1)
        v.append(-1)
        v.append(1)
        v.append(1)
        v.append(1)
        v.append(1)
        v.append(1)
        v.append(0)
        self.buffer = h3d_Buffer.ofFloats(v,4,[h3d_BufferFlag.Quads, h3d_BufferFlag.RawFormat])

    def render(self,engine):
        if ((self.buffer is None) or self.buffer.isDisposed()):
            self.alloc(engine)
        engine.renderBuffer(self.buffer,engine.mem.quadIndexes,2,0,-1)

    @staticmethod
    def get():
        engine = h3d_Engine.CURRENT
        inst = engine.resCache.h.get(h3d_prim_Plane2D,None)
        if (inst is None):
            inst = h3d_prim_Plane2D()
            engine.resCache.set(h3d_prim_Plane2D,inst)
        return inst

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
h3d_prim_Plane2D._hx_class = h3d_prim_Plane2D
_hx_classes["h3d.prim.Plane2D"] = h3d_prim_Plane2D


class h3d_prim_RawPrimitive(h3d_prim_Primitive):
    _hx_class_name = "h3d.prim.RawPrimitive"
    _hx_is_interface = "False"
    __slots__ = ("vcount", "tcount", "bounds", "onContextLost")
    _hx_fields = ["vcount", "tcount", "bounds", "onContextLost"]
    _hx_methods = ["alloc", "getBounds", "triCount", "vertexCount"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_prim_Primitive


    def __init__(self,inf,persist = None):
        if (persist is None):
            persist = False
        self.onContextLost = None
        self.bounds = None
        self.tcount = None
        self.vcount = None
        super().__init__()
        def _hx_local_0():
            return inf
        self.onContextLost = _hx_local_0
        self.bounds = Reflect.field(inf,"bounds")
        self.alloc(None)
        if (not persist):
            self.onContextLost = None

    def alloc(self,engine):
        if (self.onContextLost is None):
            raise _HxException(("Cannot realloc " + Std.string(self)))
        inf = self.onContextLost()
        flags = []
        if (Reflect.field(inf,"ibuf") is None):
            x = (h3d_BufferFlag.Quads if (Reflect.field(inf,"quads")) else h3d_BufferFlag.Triangles)
            flags.append(x)
        if (inf.stride < 8):
            flags.append(h3d_BufferFlag.RawFormat)
        self.buffer = h3d_Buffer.ofFloats(inf.vbuf,inf.stride,flags)
        self.vcount = self.buffer.vertices
        tmp = None
        if (Reflect.field(inf,"ibuf") is not None):
            x1 = (len(Reflect.field(inf,"ibuf")) / 3)
            try:
                tmp = int(x1)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                tmp = None
        elif Reflect.field(inf,"quads"):
            tmp = (self.vcount >> 1)
        else:
            x2 = (self.vcount / 3)
            try:
                tmp = int(x2)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e1 = _hx_e1
                tmp = None
        self.tcount = tmp
        if (Reflect.field(inf,"ibuf") is not None):
            self.indexes = h3d_Indexes.alloc(Reflect.field(inf,"ibuf"))
        elif (self.indexes is not None):
            self.indexes.dispose()
            self.indexes = None

    def getBounds(self):
        if (self.bounds is None):
            raise _HxException(("Bounds not defined for " + Std.string(self)))
        return self.bounds

    def triCount(self):
        return self.tcount

    def vertexCount(self):
        return self.vcount

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.vcount = None
        _hx_o.tcount = None
        _hx_o.bounds = None
        _hx_o.onContextLost = None
h3d_prim_RawPrimitive._hx_class = h3d_prim_RawPrimitive
_hx_classes["h3d.prim.RawPrimitive"] = h3d_prim_RawPrimitive


class h3d_prim_UV:
    _hx_class_name = "h3d.prim.UV"
    _hx_is_interface = "False"
    __slots__ = ("u", "v")
    _hx_fields = ["u", "v"]
    _hx_methods = ["clone", "toString"]

    def __init__(self,u,v):
        self.u = u
        self.v = v

    def clone(self):
        return h3d_prim_UV(self.u,self.v)

    def toString(self):
        return (((("{" + Std.string(hxd_Math.fmt(self.u))) + ",") + Std.string(hxd_Math.fmt(self.v))) + "}")

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.u = None
        _hx_o.v = None
h3d_prim_UV._hx_class = h3d_prim_UV
_hx_classes["h3d.prim.UV"] = h3d_prim_UV


class h3d_scene_Object:
    _hx_class_name = "h3d.scene.Object"
    _hx_is_interface = "False"
    __slots__ = ("flags", "children", "parent", "name", "x", "y", "z", "scaleX", "scaleY", "scaleZ", "follow", "defaultTransform", "currentAnimation", "cullingCollider", "absPos", "invPos", "qRot", "lastFrame")
    _hx_fields = ["flags", "children", "parent", "name", "x", "y", "z", "scaleX", "scaleY", "scaleZ", "follow", "defaultTransform", "currentAnimation", "cullingCollider", "absPos", "invPos", "qRot", "lastFrame"]
    _hx_methods = ["set_cullingCollider", "get_visible", "get_allocated", "get_posChanged", "get_culled", "get_followPositionOnly", "get_lightCameraCenter", "get_alwaysSync", "get_inheritCulled", "get_ignoreBounds", "get_ignoreCollide", "get_allowSerialize", "get_ignoreParentTransform", "get_cullingColliderInherited", "set_posChanged", "set_culled", "set_visible", "set_allocated", "set_followPositionOnly", "set_lightCameraCenter", "set_alwaysSync", "set_ignoreBounds", "set_inheritCulled", "set_ignoreCollide", "set_allowSerialize", "set_ignoreParentTransform", "set_cullingColliderInherited", "playAnimation", "switchToAnimation", "stopAnimation", "applyAnimationTransform", "getObjectsCount", "getMaterialByName", "find", "findAll", "getMaterials", "localToGlobal", "globalToLocal", "getInvPos", "getBounds", "getBoundsRec", "getMeshes", "getMeshByName", "getObjectByName", "clone", "addChild", "addChildAt", "iterVisibleMeshes", "onParentChanged", "onAdd", "onRemove", "removeChild", "removeChildren", "remove", "getScene", "getAbsPos", "isMesh", "toMesh", "getCollider", "getGlobalCollider", "getLocalCollider", "draw", "set_follow", "calcAbsPos", "sync", "syncRec", "syncPos", "emit", "emitRec", "set_x", "set_y", "set_z", "set_scaleX", "set_scaleY", "set_scaleZ", "set_defaultTransform", "setPosition", "setTransform", "rotate", "setRotation", "setRotationAxis", "setDirection", "getDirection", "getRotationQuat", "setRotationQuat", "scale", "setScale", "toString", "getChildAt", "getChildIndex", "get_numChildren", "iterator"]
    _hx_statics = ["ROT2RAD", "tmpMat", "tmpVec"]
    _hx_interfaces = [hxd_impl__Serializable_NoSerializeSupport]

    def __init__(self,parent = None):
        self.lastFrame = None
        self.qRot = None
        self.invPos = None
        self.cullingCollider = None
        self.currentAnimation = None
        self.defaultTransform = None
        self.follow = None
        self.scaleZ = None
        self.scaleY = None
        self.scaleX = None
        self.z = None
        self.y = None
        self.x = None
        self.name = None
        self.parent = None
        self.children = None
        this1 = 0
        self.flags = this1
        self.absPos = h3d_Matrix()
        self.absPos.identity()
        self.x = 0
        f = 1
        b = True
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        self.y = 0
        f1 = 1
        b1 = True
        if b1:
            _hx_local_4 = self
            _hx_local_5 = _hx_local_4.flags
            _hx_local_4.flags = (_hx_local_5 | f1)
            _hx_local_4.flags
        else:
            _hx_local_6 = self
            _hx_local_7 = _hx_local_6.flags
            _hx_local_6.flags = (_hx_local_7 & ~f1)
            _hx_local_6.flags
        self.z = 0
        f2 = 1
        b2 = True
        if b2:
            _hx_local_8 = self
            _hx_local_9 = _hx_local_8.flags
            _hx_local_8.flags = (_hx_local_9 | f2)
            _hx_local_8.flags
        else:
            _hx_local_10 = self
            _hx_local_11 = _hx_local_10.flags
            _hx_local_10.flags = (_hx_local_11 & ~f2)
            _hx_local_10.flags
        self.scaleX = 1
        f3 = 1
        b3 = True
        if b3:
            _hx_local_12 = self
            _hx_local_13 = _hx_local_12.flags
            _hx_local_12.flags = (_hx_local_13 | f3)
            _hx_local_12.flags
        else:
            _hx_local_14 = self
            _hx_local_15 = _hx_local_14.flags
            _hx_local_14.flags = (_hx_local_15 & ~f3)
            _hx_local_14.flags
        self.scaleY = 1
        f4 = 1
        b4 = True
        if b4:
            _hx_local_16 = self
            _hx_local_17 = _hx_local_16.flags
            _hx_local_16.flags = (_hx_local_17 | f4)
            _hx_local_16.flags
        else:
            _hx_local_18 = self
            _hx_local_19 = _hx_local_18.flags
            _hx_local_18.flags = (_hx_local_19 & ~f4)
            _hx_local_18.flags
        self.scaleZ = 1
        f5 = 1
        b5 = True
        if b5:
            _hx_local_20 = self
            _hx_local_21 = _hx_local_20.flags
            _hx_local_20.flags = (_hx_local_21 | f5)
            _hx_local_20.flags
        else:
            _hx_local_22 = self
            _hx_local_23 = _hx_local_22.flags
            _hx_local_22.flags = (_hx_local_23 & ~f5)
            _hx_local_22.flags
        self.qRot = h3d_Quat()
        f6 = 1
        b6 = (self.follow is not None)
        if b6:
            _hx_local_24 = self
            _hx_local_25 = _hx_local_24.flags
            _hx_local_24.flags = (_hx_local_25 | f6)
            _hx_local_24.flags
        else:
            _hx_local_26 = self
            _hx_local_27 = _hx_local_26.flags
            _hx_local_26.flags = (_hx_local_27 & ~f6)
            _hx_local_26.flags
        f7 = 2
        _hx_local_28 = self
        _hx_local_29 = _hx_local_28.flags
        _hx_local_28.flags = (_hx_local_29 | f7)
        _hx_local_28.flags
        self.children = []
        if (parent is not None):
            parent.addChild(self)

    def set_cullingCollider(self,c):
        self.cullingCollider = c
        f = 4096
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.flags
        _hx_local_0.flags = (_hx_local_1 & ~f)
        _hx_local_0.flags
        return c

    def get_visible(self):
        return (((self.flags & 2)) != 0)

    def get_allocated(self):
        return (((self.flags & 32)) != 0)

    def get_posChanged(self):
        return (((self.flags & 1)) != 0)

    def get_culled(self):
        return (((self.flags & 4)) != 0)

    def get_followPositionOnly(self):
        return (((self.flags & 8)) != 0)

    def get_lightCameraCenter(self):
        return (((self.flags & 16)) != 0)

    def get_alwaysSync(self):
        return (((self.flags & 64)) != 0)

    def get_inheritCulled(self):
        return (((self.flags & 128)) != 0)

    def get_ignoreBounds(self):
        return (((self.flags & 512)) != 0)

    def get_ignoreCollide(self):
        return (((self.flags & 1024)) != 0)

    def get_allowSerialize(self):
        return (((self.flags & 256)) == 0)

    def get_ignoreParentTransform(self):
        return (((self.flags & 2048)) != 0)

    def get_cullingColliderInherited(self):
        return (((self.flags & 4096)) != 0)

    def set_posChanged(self,b):
        f = 1
        b1 = (b or ((self.follow is not None)))
        if b1:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        return b1

    def set_culled(self,b):
        f = 4
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        return b

    def set_visible(self,b):
        f = 2
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        return b

    def set_allocated(self,b):
        f = 32
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        return b

    def set_followPositionOnly(self,b):
        f = 8
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        return b

    def set_lightCameraCenter(self,b):
        f = 16
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        return b

    def set_alwaysSync(self,b):
        f = 64
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        return b

    def set_ignoreBounds(self,b):
        f = 512
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        return b

    def set_inheritCulled(self,b):
        f = 128
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        return b

    def set_ignoreCollide(self,b):
        f = 1024
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        return b

    def set_allowSerialize(self,b):
        f = 256
        b1 = (not b)
        if b1:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        return (not b1)

    def set_ignoreParentTransform(self,b):
        f = 2048
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        return b

    def set_cullingColliderInherited(self,b):
        f = 4096
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        return b

    def playAnimation(self,a):
        def _hx_local_1():
            def _hx_local_0():
                self.currentAnimation = a.createInstance(self)
                return self.currentAnimation
            return _hx_local_0()
        return _hx_local_1()

    def switchToAnimation(self,a):
        def _hx_local_1():
            def _hx_local_0():
                self.currentAnimation = a
                return self.currentAnimation
            return _hx_local_0()
        return _hx_local_1()

    def stopAnimation(self,recursive = None):
        if (recursive is None):
            recursive = False
        self.currentAnimation = None
        if recursive:
            _g = 0
            _g1 = self.children
            while (_g < len(_g1)):
                c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                c.stopAnimation(True)

    def applyAnimationTransform(self,recursive = None):
        if (recursive is None):
            recursive = True
        if (self.defaultTransform is not None):
            _this = self.defaultTransform
            v = None
            if (v is None):
                v = h3d_Vector()
            f = (((_this._11 * _this._11) + ((_this._12 * _this._12))) + ((_this._13 * _this._13)))
            v.x = (Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))
            f1 = (((_this._21 * _this._21) + ((_this._22 * _this._22))) + ((_this._23 * _this._23)))
            v.y = (Math.NaN if ((f1 < 0)) else python_lib_Math.sqrt(f1))
            f2 = (((_this._31 * _this._31) + ((_this._32 * _this._32))) + ((_this._33 * _this._33)))
            v.z = (Math.NaN if ((f2 < 0)) else python_lib_Math.sqrt(f2))
            if ((((_this._11 * (((_this._22 * _this._33) - ((_this._23 * _this._32))))) + ((_this._12 * (((_this._23 * _this._31) - ((_this._21 * _this._33))))))) + ((_this._13 * (((_this._21 * _this._32) - ((_this._22 * _this._31))))))) < 0):
                v.x = (v.x * -1)
                v.y = (v.y * -1)
                v.z = (v.z * -1)
            s = v
            v1 = s.x
            self.scaleX = v1
            f3 = 1
            b = True
            if b:
                _hx_local_3 = self
                _hx_local_4 = _hx_local_3.flags
                _hx_local_3.flags = (_hx_local_4 | f3)
                _hx_local_3.flags
            else:
                _hx_local_5 = self
                _hx_local_6 = _hx_local_5.flags
                _hx_local_5.flags = (_hx_local_6 & ~f3)
                _hx_local_5.flags
            v2 = s.y
            self.scaleY = v2
            f4 = 1
            b1 = True
            if b1:
                _hx_local_7 = self
                _hx_local_8 = _hx_local_7.flags
                _hx_local_7.flags = (_hx_local_8 | f4)
                _hx_local_7.flags
            else:
                _hx_local_9 = self
                _hx_local_10 = _hx_local_9.flags
                _hx_local_9.flags = (_hx_local_10 & ~f4)
                _hx_local_9.flags
            v3 = s.z
            self.scaleZ = v3
            f5 = 1
            b2 = True
            if b2:
                _hx_local_11 = self
                _hx_local_12 = _hx_local_11.flags
                _hx_local_11.flags = (_hx_local_12 | f5)
                _hx_local_11.flags
            else:
                _hx_local_13 = self
                _hx_local_14 = _hx_local_13.flags
                _hx_local_13.flags = (_hx_local_14 & ~f5)
                _hx_local_13.flags
            self.qRot.initRotateMatrix(self.defaultTransform)
            v4 = self.defaultTransform._41
            self.x = v4
            f6 = 1
            b3 = True
            if b3:
                _hx_local_15 = self
                _hx_local_16 = _hx_local_15.flags
                _hx_local_15.flags = (_hx_local_16 | f6)
                _hx_local_15.flags
            else:
                _hx_local_17 = self
                _hx_local_18 = _hx_local_17.flags
                _hx_local_17.flags = (_hx_local_18 & ~f6)
                _hx_local_17.flags
            v5 = self.defaultTransform._42
            self.y = v5
            f7 = 1
            b4 = True
            if b4:
                _hx_local_19 = self
                _hx_local_20 = _hx_local_19.flags
                _hx_local_19.flags = (_hx_local_20 | f7)
                _hx_local_19.flags
            else:
                _hx_local_21 = self
                _hx_local_22 = _hx_local_21.flags
                _hx_local_21.flags = (_hx_local_22 & ~f7)
                _hx_local_21.flags
            v6 = self.defaultTransform._43
            self.z = v6
            f8 = 1
            b5 = True
            if b5:
                _hx_local_23 = self
                _hx_local_24 = _hx_local_23.flags
                _hx_local_23.flags = (_hx_local_24 | f8)
                _hx_local_23.flags
            else:
                _hx_local_25 = self
                _hx_local_26 = _hx_local_25.flags
                _hx_local_25.flags = (_hx_local_26 & ~f8)
                _hx_local_25.flags
            v7 = None
            self.defaultTransform = v7
            f9 = 1
            b6 = True
            if b6:
                _hx_local_27 = self
                _hx_local_28 = _hx_local_27.flags
                _hx_local_27.flags = (_hx_local_28 | f9)
                _hx_local_27.flags
            else:
                _hx_local_29 = self
                _hx_local_30 = _hx_local_29.flags
                _hx_local_29.flags = (_hx_local_30 & ~f9)
                _hx_local_29.flags
        if recursive:
            _g = 0
            _g1 = self.children
            while (_g < len(_g1)):
                c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                c.applyAnimationTransform()

    def getObjectsCount(self):
        k = 0
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            k = (k + ((c.getObjectsCount() + 1)))
        return k

    def getMaterialByName(self,name):
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            o = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            m = o.getMaterialByName(name)
            if (m is not None):
                return m
        return None

    def find(self,f):
        v = f(self)
        if (v is not None):
            return v
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            o = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            v1 = o.find(f)
            if (v1 is not None):
                return v1
        return None

    def findAll(self,f,arr = None):
        if (arr is None):
            arr = []
        v = f(self)
        if (v is not None):
            arr.append(v)
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            o = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            o.findAll(f,arr)
        return arr

    def getMaterials(self,a = None):
        if (a is None):
            a = []
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            o = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            o.getMaterials(a)
        return a

    def localToGlobal(self,pt = None):
        self.syncPos()
        if (pt is None):
            pt = h3d_Vector()
        m = self.absPos
        px = ((((pt.x * m._11) + ((pt.y * m._21))) + ((pt.z * m._31))) + ((pt.w * m._41)))
        py = ((((pt.x * m._12) + ((pt.y * m._22))) + ((pt.z * m._32))) + ((pt.w * m._42)))
        pz = ((((pt.x * m._13) + ((pt.y * m._23))) + ((pt.z * m._33))) + ((pt.w * m._43)))
        pt.x = px
        pt.y = py
        pt.z = pz
        return pt

    def globalToLocal(self,pt):
        m = self.getInvPos()
        px = ((((pt.x * m._11) + ((pt.y * m._21))) + ((pt.z * m._31))) + ((pt.w * m._41)))
        py = ((((pt.x * m._12) + ((pt.y * m._22))) + ((pt.z * m._32))) + ((pt.w * m._42)))
        pz = ((((pt.x * m._13) + ((pt.y * m._23))) + ((pt.z * m._33))) + ((pt.w * m._43)))
        pt.x = px
        pt.y = py
        pt.z = pz
        return pt

    def getInvPos(self):
        self.syncPos()
        if (self.invPos is None):
            self.invPos = h3d_Matrix()
            self.invPos._44 = 0
        if (self.invPos._44 == 0):
            self.invPos.inverse3x4(self.absPos)
        return self.invPos

    def getBounds(self,b = None):
        if (b is None):
            b = h3d_col_Bounds()
        if (self.parent is not None):
            self.parent.syncPos()
        return self.getBoundsRec(b)

    def getBoundsRec(self,b):
        if (((self.flags & 1)) != 0):
            _g = 0
            _g1 = self.children
            while (_g < len(_g1)):
                c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                f = 1
                b1 = True
                if b1:
                    c.flags = (c.flags | f)
                else:
                    c.flags = (c.flags & ~f)
            f1 = 1
            b2 = (self.follow is not None)
            if b2:
                _hx_local_3 = self
                _hx_local_4 = _hx_local_3.flags
                _hx_local_3.flags = (_hx_local_4 | f1)
                _hx_local_3.flags
            else:
                _hx_local_5 = self
                _hx_local_6 = _hx_local_5.flags
                _hx_local_5.flags = (_hx_local_6 & ~f1)
                _hx_local_5.flags
            self.calcAbsPos()
        _g2 = 0
        _g11 = self.children
        while (_g2 < len(_g11)):
            c1 = (_g11[_g2] if _g2 >= 0 and _g2 < len(_g11) else None)
            _g2 = (_g2 + 1)
            c1.getBoundsRec(b)
        return b

    def getMeshes(self,out = None):
        if (out is None):
            out = []
        m = Std.downcast(self,h3d_scene_Mesh)
        if (m is not None):
            out.append(m)
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            c.getMeshes(out)
        return out

    def getMeshByName(self,name):
        return Std.downcast(self.getObjectByName(name),h3d_scene_Mesh)

    def getObjectByName(self,name):
        if (self.name == name):
            return self
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            o = c.getObjectByName(name)
            if (o is not None):
                return o
        return None

    def clone(self,o = None):
        if (o is None):
            o = h3d_scene_Object()
        v = self.x
        o.x = v
        f = 1
        b = True
        if b:
            o.flags = (o.flags | f)
        else:
            o.flags = (o.flags & ~f)
        v1 = self.y
        o.y = v1
        f1 = 1
        b1 = True
        if b1:
            o.flags = (o.flags | f1)
        else:
            o.flags = (o.flags & ~f1)
        v2 = self.z
        o.z = v2
        f2 = 1
        b2 = True
        if b2:
            o.flags = (o.flags | f2)
        else:
            o.flags = (o.flags & ~f2)
        v3 = self.scaleX
        o.scaleX = v3
        f3 = 1
        b3 = True
        if b3:
            o.flags = (o.flags | f3)
        else:
            o.flags = (o.flags & ~f3)
        v4 = self.scaleY
        o.scaleY = v4
        f4 = 1
        b4 = True
        if b4:
            o.flags = (o.flags | f4)
        else:
            o.flags = (o.flags & ~f4)
        v5 = self.scaleZ
        o.scaleZ = v5
        f5 = 1
        b5 = True
        if b5:
            o.flags = (o.flags | f5)
        else:
            o.flags = (o.flags & ~f5)
        _this = o.qRot
        q = self.qRot
        _this.x = q.x
        _this.y = q.y
        _this.z = q.z
        _this.w = q.w
        o.name = self.name
        o.set_follow(self.follow)
        b6 = (((self.flags & 8)) != 0)
        f6 = 8
        if b6:
            o.flags = (o.flags | f6)
        else:
            o.flags = (o.flags & ~f6)
        b7 = (((self.flags & 2)) != 0)
        f7 = 2
        if b7:
            o.flags = (o.flags | f7)
        else:
            o.flags = (o.flags & ~f7)
        if (self.defaultTransform is not None):
            v6 = self.defaultTransform.clone()
            o.defaultTransform = v6
            f8 = 1
            b8 = True
            if b8:
                o.flags = (o.flags | f8)
            else:
                o.flags = (o.flags & ~f8)
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            c1 = c.clone()
            c1.parent = o
            _this1 = o.children
            _this1.append(c1)
        return o

    def addChild(self,o):
        self.addChildAt(o,len(self.children))

    def addChildAt(self,o,pos):
        if (pos < 0):
            pos = 0
        if (pos > len(self.children)):
            pos = len(self.children)
        p = self
        while (p is not None):
            if (p == o):
                raise _HxException("Recursive addChild")
            p = p.parent
        if (o.parent is not None):
            old = (((o.flags & 32)) != 0)
            f = 32
            o.flags = (o.flags & ~f)
            o.parent.removeChild(o)
            f1 = 32
            if old:
                o.flags = (o.flags | f1)
            else:
                o.flags = (o.flags & ~f1)
        self.children.insert(pos, o)
        if ((((self.flags & 32)) == 0) and ((((o.flags & 32)) != 0))):
            o.onRemove()
        o.parent = self
        f2 = 1
        b = True
        if b:
            o.flags = (o.flags | f2)
        else:
            o.flags = (o.flags & ~f2)
        if (((self.flags & 32)) != 0):
            if (((o.flags & 32)) == 0):
                o.onAdd()
            else:
                o.onParentChanged()

    def iterVisibleMeshes(self,callb):
        if ((((self.flags & 2)) == 0) or (((((self.flags & 4)) != 0) and ((((self.flags & 128)) != 0))))):
            return
        if (((self.flags & 4)) == 0):
            m = Std.downcast(self,h3d_scene_Mesh)
            if (m is not None):
                callb(m)
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            o = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            o.iterVisibleMeshes(callb)

    def onParentChanged(self):
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            c.onParentChanged()

    def onAdd(self):
        f = 32
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.flags
        _hx_local_0.flags = (_hx_local_1 | f)
        _hx_local_0.flags
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            c.onAdd()

    def onRemove(self):
        f = 32
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.flags
        _hx_local_0.flags = (_hx_local_1 & ~f)
        _hx_local_0.flags
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            c.onRemove()

    def removeChild(self,o):
        if python_internal_ArrayImpl.remove(self.children,o):
            if (((o.flags & 32)) != 0):
                o.onRemove()
            o.parent = None
            f = 1
            b = True
            if b:
                o.flags = (o.flags | f)
            else:
                o.flags = (o.flags & ~f)

    def removeChildren(self):
        while (len(self.children) > 0):
            self.removeChild((self.children[0] if 0 < len(self.children) else None))

    def remove(self):
        if (self.parent is not None):
            self.parent.removeChild(self)

    def getScene(self):
        p = self
        while (p.parent is not None):
            p = p.parent
        return Std.downcast(p,h3d_scene_Scene)

    def getAbsPos(self):
        self.syncPos()
        return self.absPos

    def isMesh(self):
        return (Std.downcast(self,h3d_scene_Mesh) is not None)

    def toMesh(self):
        m = Std.downcast(self,h3d_scene_Mesh)
        if (m is not None):
            return m
        raise _HxException((Std.string(self) + " is not a Mesh"))

    def getCollider(self):
        if (((self.flags & 1024)) != 0):
            return None
        colliders = []
        col = self.getGlobalCollider()
        if (col is not None):
            colliders.append(col)
        _g = 0
        _g1 = self.children
        while (_g < len(_g1)):
            obj = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            c = obj.getCollider()
            if (c is None):
                continue
            cgrp = Std.downcast(c,h3d_col_GroupCollider)
            if (cgrp is not None):
                _g2 = 0
                _g11 = cgrp.colliders
                while (_g2 < len(_g11)):
                    c1 = (_g11[_g2] if _g2 >= 0 and _g2 < len(_g11) else None)
                    _g2 = (_g2 + 1)
                    colliders.append(c1)
            else:
                colliders.append(c)
        if (len(colliders) == 0):
            return None
        if (len(colliders) == 1):
            return (colliders[0] if 0 < len(colliders) else None)
        return h3d_col_GroupCollider(colliders)

    def getGlobalCollider(self):
        if (((self.flags & 1024)) != 0):
            return None
        col = self.getLocalCollider()
        if (col is None):
            return None
        else:
            return h3d_col_ObjectCollider(self,col)

    def getLocalCollider(self):
        return None

    def draw(self,ctx):
        pass

    def set_follow(self,v):
        f = 1
        b = True
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        def _hx_local_5():
            def _hx_local_4():
                self.follow = v
                return self.follow
            return _hx_local_4()
        return _hx_local_5()

    def calcAbsPos(self):
        self.qRot.toMatrix(self.absPos)
        _hx_local_0 = self.absPos
        _hx_local_1 = _hx_local_0._11
        _hx_local_0._11 = (_hx_local_1 * self.scaleX)
        _hx_local_0._11
        _hx_local_2 = self.absPos
        _hx_local_3 = _hx_local_2._12
        _hx_local_2._12 = (_hx_local_3 * self.scaleX)
        _hx_local_2._12
        _hx_local_4 = self.absPos
        _hx_local_5 = _hx_local_4._13
        _hx_local_4._13 = (_hx_local_5 * self.scaleX)
        _hx_local_4._13
        _hx_local_6 = self.absPos
        _hx_local_7 = _hx_local_6._21
        _hx_local_6._21 = (_hx_local_7 * self.scaleY)
        _hx_local_6._21
        _hx_local_8 = self.absPos
        _hx_local_9 = _hx_local_8._22
        _hx_local_8._22 = (_hx_local_9 * self.scaleY)
        _hx_local_8._22
        _hx_local_10 = self.absPos
        _hx_local_11 = _hx_local_10._23
        _hx_local_10._23 = (_hx_local_11 * self.scaleY)
        _hx_local_10._23
        _hx_local_12 = self.absPos
        _hx_local_13 = _hx_local_12._31
        _hx_local_12._31 = (_hx_local_13 * self.scaleZ)
        _hx_local_12._31
        _hx_local_14 = self.absPos
        _hx_local_15 = _hx_local_14._32
        _hx_local_14._32 = (_hx_local_15 * self.scaleZ)
        _hx_local_14._32
        _hx_local_16 = self.absPos
        _hx_local_17 = _hx_local_16._33
        _hx_local_16._33 = (_hx_local_17 * self.scaleZ)
        _hx_local_16._33
        self.absPos._41 = self.x
        self.absPos._42 = self.y
        self.absPos._43 = self.z
        if (self.follow is not None):
            self.follow.syncPos()
            if (((self.flags & 8)) != 0):
                _this = self.absPos
                a = self.absPos
                b = self.parent.absPos
                m11 = a._11
                m12 = a._12
                m13 = a._13
                m21 = a._21
                m22 = a._22
                m23 = a._23
                a31 = a._31
                a32 = a._32
                a33 = a._33
                a41 = a._41
                a42 = a._42
                a43 = a._43
                b11 = b._11
                b12 = b._12
                b13 = b._13
                b21 = b._21
                b22 = b._22
                b23 = b._23
                b31 = b._31
                b32 = b._32
                b33 = b._33
                b41 = b._41
                b42 = b._42
                b43 = b._43
                _this._11 = (((m11 * b11) + ((m12 * b21))) + ((m13 * b31)))
                _this._12 = (((m11 * b12) + ((m12 * b22))) + ((m13 * b32)))
                _this._13 = (((m11 * b13) + ((m12 * b23))) + ((m13 * b33)))
                _this._14 = 0
                _this._21 = (((m21 * b11) + ((m22 * b21))) + ((m23 * b31)))
                _this._22 = (((m21 * b12) + ((m22 * b22))) + ((m23 * b32)))
                _this._23 = (((m21 * b13) + ((m22 * b23))) + ((m23 * b33)))
                _this._24 = 0
                _this._31 = (((a31 * b11) + ((a32 * b21))) + ((a33 * b31)))
                _this._32 = (((a31 * b12) + ((a32 * b22))) + ((a33 * b32)))
                _this._33 = (((a31 * b13) + ((a32 * b23))) + ((a33 * b33)))
                _this._34 = 0
                _this._41 = ((((a41 * b11) + ((a42 * b21))) + ((a43 * b31))) + b41)
                _this._42 = ((((a41 * b12) + ((a42 * b22))) + ((a43 * b32))) + b42)
                _this._43 = ((((a41 * b13) + ((a42 * b23))) + ((a43 * b33))) + b43)
                _this._44 = 1
                self.absPos._41 = (self.x + self.follow.absPos._41)
                self.absPos._42 = (self.y + self.follow.absPos._42)
                self.absPos._43 = (self.z + self.follow.absPos._43)
            else:
                self.absPos.multiply3x4(self.absPos,self.follow.absPos)
        elif ((self.parent is not None) and ((((self.flags & 2048)) == 0))):
            _this1 = self.absPos
            a1 = self.absPos
            b1 = self.parent.absPos
            m111 = a1._11
            m121 = a1._12
            m131 = a1._13
            m211 = a1._21
            m221 = a1._22
            m231 = a1._23
            a311 = a1._31
            a321 = a1._32
            a331 = a1._33
            a411 = a1._41
            a421 = a1._42
            a431 = a1._43
            b111 = b1._11
            b121 = b1._12
            b131 = b1._13
            b211 = b1._21
            b221 = b1._22
            b231 = b1._23
            b311 = b1._31
            b321 = b1._32
            b331 = b1._33
            b411 = b1._41
            b421 = b1._42
            b431 = b1._43
            _this1._11 = (((m111 * b111) + ((m121 * b211))) + ((m131 * b311)))
            _this1._12 = (((m111 * b121) + ((m121 * b221))) + ((m131 * b321)))
            _this1._13 = (((m111 * b131) + ((m121 * b231))) + ((m131 * b331)))
            _this1._14 = 0
            _this1._21 = (((m211 * b111) + ((m221 * b211))) + ((m231 * b311)))
            _this1._22 = (((m211 * b121) + ((m221 * b221))) + ((m231 * b321)))
            _this1._23 = (((m211 * b131) + ((m221 * b231))) + ((m231 * b331)))
            _this1._24 = 0
            _this1._31 = (((a311 * b111) + ((a321 * b211))) + ((a331 * b311)))
            _this1._32 = (((a311 * b121) + ((a321 * b221))) + ((a331 * b321)))
            _this1._33 = (((a311 * b131) + ((a321 * b231))) + ((a331 * b331)))
            _this1._34 = 0
            _this1._41 = ((((a411 * b111) + ((a421 * b211))) + ((a431 * b311))) + b411)
            _this1._42 = ((((a411 * b121) + ((a421 * b221))) + ((a431 * b321))) + b421)
            _this1._43 = ((((a411 * b131) + ((a421 * b231))) + ((a431 * b331))) + b431)
            _this1._44 = 1
        if (self.defaultTransform is not None):
            _this2 = self.absPos
            a2 = self.defaultTransform
            b2 = self.absPos
            m112 = a2._11
            m122 = a2._12
            m132 = a2._13
            m212 = a2._21
            m222 = a2._22
            m232 = a2._23
            a312 = a2._31
            a322 = a2._32
            a332 = a2._33
            a412 = a2._41
            a422 = a2._42
            a432 = a2._43
            b112 = b2._11
            b122 = b2._12
            b132 = b2._13
            b212 = b2._21
            b222 = b2._22
            b232 = b2._23
            b312 = b2._31
            b322 = b2._32
            b332 = b2._33
            b412 = b2._41
            b422 = b2._42
            b432 = b2._43
            _this2._11 = (((m112 * b112) + ((m122 * b212))) + ((m132 * b312)))
            _this2._12 = (((m112 * b122) + ((m122 * b222))) + ((m132 * b322)))
            _this2._13 = (((m112 * b132) + ((m122 * b232))) + ((m132 * b332)))
            _this2._14 = 0
            _this2._21 = (((m212 * b112) + ((m222 * b212))) + ((m232 * b312)))
            _this2._22 = (((m212 * b122) + ((m222 * b222))) + ((m232 * b322)))
            _this2._23 = (((m212 * b132) + ((m222 * b232))) + ((m232 * b332)))
            _this2._24 = 0
            _this2._31 = (((a312 * b112) + ((a322 * b212))) + ((a332 * b312)))
            _this2._32 = (((a312 * b122) + ((a322 * b222))) + ((a332 * b322)))
            _this2._33 = (((a312 * b132) + ((a322 * b232))) + ((a332 * b332)))
            _this2._34 = 0
            _this2._41 = ((((a412 * b112) + ((a422 * b212))) + ((a432 * b312))) + b412)
            _this2._42 = ((((a412 * b122) + ((a422 * b222))) + ((a432 * b322))) + b422)
            _this2._43 = ((((a412 * b132) + ((a422 * b232))) + ((a432 * b332))) + b432)
            _this2._44 = 1
        if (self.invPos is not None):
            self.invPos._44 = 0

    def sync(self,ctx):
        pass

    def syncRec(self,ctx):
        if (self.currentAnimation is not None):
            old = self.parent
            dt = ctx.elapsedTime
            while ((dt > 0) and ((self.currentAnimation is not None))):
                dt = self.currentAnimation.update(dt)
            if ((self.currentAnimation is not None) and ((((ctx.visibleFlag and ((((self.flags & 2)) != 0))) and ((((self.flags & 4)) == 0))) or ((((self.flags & 64)) != 0))))):
                self.currentAnimation.sync()
            if ((self.parent is None) and ((old is not None))):
                return
        old1 = ctx.visibleFlag
        if ((((self.flags & 2)) == 0) or (((((self.flags & 4)) != 0) and ((((self.flags & 128)) != 0))))):
            ctx.visibleFlag = False
        if ((ctx.cullingCollider is not None) and (((self.cullingCollider is None) or ((((self.flags & 4096)) != 0))))):
            self.set_cullingCollider(ctx.cullingCollider)
            f = 4096
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        elif (((self.flags & 4096)) != 0):
            self.set_cullingCollider(None)
        prevCollider = ctx.cullingCollider
        if (((self.flags & 128)) != 0):
            ctx.cullingCollider = self.cullingCollider
        changed = (((self.flags & 1)) != 0)
        if changed:
            self.calcAbsPos()
        self.sync(ctx)
        f1 = 1
        b = (self.follow is not None)
        if b:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 | f1)
            _hx_local_2.flags
        else:
            _hx_local_4 = self
            _hx_local_5 = _hx_local_4.flags
            _hx_local_4.flags = (_hx_local_5 & ~f1)
            _hx_local_4.flags
        self.lastFrame = ctx.frame
        p = 0
        _hx_len = len(self.children)
        while (p < _hx_len):
            c = (self.children[p] if p >= 0 and p < len(self.children) else None)
            if (c is None):
                break
            if (c.lastFrame != ctx.frame):
                if changed:
                    f2 = 1
                    b1 = True
                    if b1:
                        c.flags = (c.flags | f2)
                    else:
                        c.flags = (c.flags & ~f2)
                c.syncRec(ctx)
            if ((self.children[p] if p >= 0 and p < len(self.children) else None) != c):
                p = 0
                _hx_len = len(self.children)
            else:
                p = (p + 1)
        ctx.visibleFlag = old1
        ctx.cullingCollider = prevCollider

    def syncPos(self):
        if (self.parent is not None):
            self.parent.syncPos()
        if (((self.flags & 1)) != 0):
            f = 1
            b = (self.follow is not None)
            if b:
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.flags
                _hx_local_0.flags = (_hx_local_1 | f)
                _hx_local_0.flags
            else:
                _hx_local_2 = self
                _hx_local_3 = _hx_local_2.flags
                _hx_local_2.flags = (_hx_local_3 & ~f)
                _hx_local_2.flags
            self.calcAbsPos()
            _g = 0
            _g1 = self.children
            while (_g < len(_g1)):
                c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                f1 = 1
                b1 = True
                if b1:
                    c.flags = (c.flags | f1)
                else:
                    c.flags = (c.flags & ~f1)

    def emit(self,ctx):
        pass

    def emitRec(self,ctx):
        if ((((self.flags & 2)) == 0) or ((((((self.flags & 4)) != 0) and ((((self.flags & 128)) != 0))) and (not ctx.computingStatic)))):
            return
        if (((self.flags & 1)) != 0):
            if (self.currentAnimation is not None):
                self.currentAnimation.sync()
            f = 1
            b = (self.follow is not None)
            if b:
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.flags
                _hx_local_0.flags = (_hx_local_1 | f)
                _hx_local_0.flags
            else:
                _hx_local_2 = self
                _hx_local_3 = _hx_local_2.flags
                _hx_local_2.flags = (_hx_local_3 & ~f)
                _hx_local_2.flags
            self.calcAbsPos()
            _g = 0
            _g1 = self.children
            while (_g < len(_g1)):
                c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                f1 = 1
                b1 = True
                if b1:
                    c.flags = (c.flags | f1)
                else:
                    c.flags = (c.flags & ~f1)
        if ((((self.flags & 4)) == 0) or ctx.computingStatic):
            self.emit(ctx)
        _g2 = 0
        _g11 = self.children
        while (_g2 < len(_g11)):
            c1 = (_g11[_g2] if _g2 >= 0 and _g2 < len(_g11) else None)
            _g2 = (_g2 + 1)
            c1.emitRec(ctx)

    def set_x(self,v):
        self.x = v
        f = 1
        b = True
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        return v

    def set_y(self,v):
        self.y = v
        f = 1
        b = True
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        return v

    def set_z(self,v):
        self.z = v
        f = 1
        b = True
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        return v

    def set_scaleX(self,v):
        self.scaleX = v
        f = 1
        b = True
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        return v

    def set_scaleY(self,v):
        self.scaleY = v
        f = 1
        b = True
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        return v

    def set_scaleZ(self,v):
        self.scaleZ = v
        f = 1
        b = True
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        return v

    def set_defaultTransform(self,v):
        self.defaultTransform = v
        f = 1
        b = True
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        return v

    def setPosition(self,x,y,z):
        self.x = x
        f = 1
        b = True
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        self.y = y
        f1 = 1
        b1 = True
        if b1:
            _hx_local_4 = self
            _hx_local_5 = _hx_local_4.flags
            _hx_local_4.flags = (_hx_local_5 | f1)
            _hx_local_4.flags
        else:
            _hx_local_6 = self
            _hx_local_7 = _hx_local_6.flags
            _hx_local_6.flags = (_hx_local_7 & ~f1)
            _hx_local_6.flags
        self.z = z
        f2 = 1
        b2 = True
        if b2:
            _hx_local_8 = self
            _hx_local_9 = _hx_local_8.flags
            _hx_local_8.flags = (_hx_local_9 | f2)
            _hx_local_8.flags
        else:
            _hx_local_10 = self
            _hx_local_11 = _hx_local_10.flags
            _hx_local_10.flags = (_hx_local_11 & ~f2)
            _hx_local_10.flags
        f3 = 1
        b3 = True
        if b3:
            _hx_local_12 = self
            _hx_local_13 = _hx_local_12.flags
            _hx_local_12.flags = (_hx_local_13 | f3)
            _hx_local_12.flags
        else:
            _hx_local_14 = self
            _hx_local_15 = _hx_local_14.flags
            _hx_local_14.flags = (_hx_local_15 & ~f3)
            _hx_local_14.flags

    def setTransform(self,mat):
        v = h3d_scene_Object.tmpVec
        if (v is None):
            v = h3d_Vector()
        f = (((mat._11 * mat._11) + ((mat._12 * mat._12))) + ((mat._13 * mat._13)))
        v.x = (Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))
        f1 = (((mat._21 * mat._21) + ((mat._22 * mat._22))) + ((mat._23 * mat._23)))
        v.y = (Math.NaN if ((f1 < 0)) else python_lib_Math.sqrt(f1))
        f2 = (((mat._31 * mat._31) + ((mat._32 * mat._32))) + ((mat._33 * mat._33)))
        v.z = (Math.NaN if ((f2 < 0)) else python_lib_Math.sqrt(f2))
        if ((((mat._11 * (((mat._22 * mat._33) - ((mat._23 * mat._32))))) + ((mat._12 * (((mat._23 * mat._31) - ((mat._21 * mat._33))))))) + ((mat._13 * (((mat._21 * mat._32) - ((mat._22 * mat._31))))))) < 0):
            v.x = (v.x * -1)
            v.y = (v.y * -1)
            v.z = (v.z * -1)
        s = v
        v1 = mat._41
        self.x = v1
        f3 = 1
        b = True
        if b:
            _hx_local_3 = self
            _hx_local_4 = _hx_local_3.flags
            _hx_local_3.flags = (_hx_local_4 | f3)
            _hx_local_3.flags
        else:
            _hx_local_5 = self
            _hx_local_6 = _hx_local_5.flags
            _hx_local_5.flags = (_hx_local_6 & ~f3)
            _hx_local_5.flags
        v2 = mat._42
        self.y = v2
        f4 = 1
        b1 = True
        if b1:
            _hx_local_7 = self
            _hx_local_8 = _hx_local_7.flags
            _hx_local_7.flags = (_hx_local_8 | f4)
            _hx_local_7.flags
        else:
            _hx_local_9 = self
            _hx_local_10 = _hx_local_9.flags
            _hx_local_9.flags = (_hx_local_10 & ~f4)
            _hx_local_9.flags
        v3 = mat._43
        self.z = v3
        f5 = 1
        b2 = True
        if b2:
            _hx_local_11 = self
            _hx_local_12 = _hx_local_11.flags
            _hx_local_11.flags = (_hx_local_12 | f5)
            _hx_local_11.flags
        else:
            _hx_local_13 = self
            _hx_local_14 = _hx_local_13.flags
            _hx_local_13.flags = (_hx_local_14 & ~f5)
            _hx_local_13.flags
        v4 = s.x
        self.scaleX = v4
        f6 = 1
        b3 = True
        if b3:
            _hx_local_15 = self
            _hx_local_16 = _hx_local_15.flags
            _hx_local_15.flags = (_hx_local_16 | f6)
            _hx_local_15.flags
        else:
            _hx_local_17 = self
            _hx_local_18 = _hx_local_17.flags
            _hx_local_17.flags = (_hx_local_18 & ~f6)
            _hx_local_17.flags
        v5 = s.y
        self.scaleY = v5
        f7 = 1
        b4 = True
        if b4:
            _hx_local_19 = self
            _hx_local_20 = _hx_local_19.flags
            _hx_local_19.flags = (_hx_local_20 | f7)
            _hx_local_19.flags
        else:
            _hx_local_21 = self
            _hx_local_22 = _hx_local_21.flags
            _hx_local_21.flags = (_hx_local_22 & ~f7)
            _hx_local_21.flags
        v6 = s.z
        self.scaleZ = v6
        f8 = 1
        b5 = True
        if b5:
            _hx_local_23 = self
            _hx_local_24 = _hx_local_23.flags
            _hx_local_23.flags = (_hx_local_24 | f8)
            _hx_local_23.flags
        else:
            _hx_local_25 = self
            _hx_local_26 = _hx_local_25.flags
            _hx_local_25.flags = (_hx_local_26 & ~f8)
            _hx_local_25.flags
        h3d_scene_Object.tmpMat.load(mat)
        h3d_scene_Object.tmpMat.prependScale((1.0 / s.x),(1.0 / s.y),(1.0 / s.z))
        self.qRot.initRotateMatrix(h3d_scene_Object.tmpMat)
        f9 = 1
        b6 = True
        if b6:
            _hx_local_27 = self
            _hx_local_28 = _hx_local_27.flags
            _hx_local_27.flags = (_hx_local_28 | f9)
            _hx_local_27.flags
        else:
            _hx_local_29 = self
            _hx_local_30 = _hx_local_29.flags
            _hx_local_29.flags = (_hx_local_30 & ~f9)
            _hx_local_29.flags

    def rotate(self,rx,ry,rz):
        qTmp = h3d_Quat()
        qTmp.initRotation(rx,ry,rz)
        self.qRot.multiply(qTmp,self.qRot)
        f = 1
        b = True
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags

    def setRotation(self,rx,ry,rz):
        self.qRot.initRotation(rx,ry,rz)
        f = 1
        b = True
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags

    def setRotationAxis(self,ax,ay,az,angle):
        self.qRot.initRotateAxis(ax,ay,az,angle)
        f = 1
        b = True
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags

    def setDirection(self,v):
        self.qRot.initDirection(v)
        f = 1
        b = True
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags

    def getDirection(self):
        _this = self.qRot
        return h3d_Vector((1 - ((2 * (((_this.y * _this.y) + ((_this.z * _this.z))))))),(2 * (((_this.x * _this.y) - ((_this.z * _this.w))))),(2 * (((_this.x * _this.z) + ((_this.y * _this.w))))))

    def getRotationQuat(self):
        return self.qRot

    def setRotationQuat(self,q):
        self.qRot = q
        f = 1
        b = True
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags

    def scale(self,v):
        _g = self
        v1 = (_g.scaleX * v)
        _g.scaleX = v1
        f = 1
        b = True
        if b:
            _g.flags = (_g.flags | f)
        else:
            _g.flags = (_g.flags & ~f)
        _g1 = self
        v2 = (_g1.scaleY * v)
        _g1.scaleY = v2
        f1 = 1
        b1 = True
        if b1:
            _g1.flags = (_g1.flags | f1)
        else:
            _g1.flags = (_g1.flags & ~f1)
        _g2 = self
        v3 = (_g2.scaleZ * v)
        _g2.scaleZ = v3
        f2 = 1
        b2 = True
        if b2:
            _g2.flags = (_g2.flags | f2)
        else:
            _g2.flags = (_g2.flags & ~f2)
        f3 = 1
        b3 = True
        if b3:
            _hx_local_6 = self
            _hx_local_7 = _hx_local_6.flags
            _hx_local_6.flags = (_hx_local_7 | f3)
            _hx_local_6.flags
        else:
            _hx_local_8 = self
            _hx_local_9 = _hx_local_8.flags
            _hx_local_8.flags = (_hx_local_9 & ~f3)
            _hx_local_8.flags

    def setScale(self,v):
        self.scaleX = v
        f = 1
        b = True
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | f)
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ~f)
            _hx_local_2.flags
        self.scaleY = v
        f1 = 1
        b1 = True
        if b1:
            _hx_local_4 = self
            _hx_local_5 = _hx_local_4.flags
            _hx_local_4.flags = (_hx_local_5 | f1)
            _hx_local_4.flags
        else:
            _hx_local_6 = self
            _hx_local_7 = _hx_local_6.flags
            _hx_local_6.flags = (_hx_local_7 & ~f1)
            _hx_local_6.flags
        self.scaleZ = v
        f2 = 1
        b2 = True
        if b2:
            _hx_local_8 = self
            _hx_local_9 = _hx_local_8.flags
            _hx_local_8.flags = (_hx_local_9 | f2)
            _hx_local_8.flags
        else:
            _hx_local_10 = self
            _hx_local_11 = _hx_local_10.flags
            _hx_local_10.flags = (_hx_local_11 & ~f2)
            _hx_local_10.flags
        f3 = 1
        b3 = True
        if b3:
            _hx_local_12 = self
            _hx_local_13 = _hx_local_12.flags
            _hx_local_12.flags = (_hx_local_13 | f3)
            _hx_local_12.flags
        else:
            _hx_local_14 = self
            _hx_local_15 = _hx_local_14.flags
            _hx_local_14.flags = (_hx_local_15 & ~f3)
            _hx_local_14.flags

    def toString(self):
        _this = Type.getClassName(Type.getClass(self))
        _this1 = _this.split(".")
        return (HxOverrides.stringOrNull(((None if ((len(_this1) == 0)) else _this1.pop()))) + HxOverrides.stringOrNull((("" if ((self.name is None)) else (("(" + HxOverrides.stringOrNull(self.name)) + ")")))))

    def getChildAt(self,n):
        return (self.children[n] if n >= 0 and n < len(self.children) else None)

    def getChildIndex(self,o):
        _g = 0
        _g1 = len(self.children)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if ((self.children[i] if i >= 0 and i < len(self.children) else None) == o):
                return i
        return -1

    def get_numChildren(self):
        return len(self.children)

    def iterator(self):
        return hxd_impl_ArrayIterator_h3d_scene_Object(self.children)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.flags = None
        _hx_o.children = None
        _hx_o.parent = None
        _hx_o.name = None
        _hx_o.x = None
        _hx_o.y = None
        _hx_o.z = None
        _hx_o.scaleX = None
        _hx_o.scaleY = None
        _hx_o.scaleZ = None
        _hx_o.follow = None
        _hx_o.defaultTransform = None
        _hx_o.currentAnimation = None
        _hx_o.cullingCollider = None
        _hx_o.absPos = None
        _hx_o.invPos = None
        _hx_o.qRot = None
        _hx_o.lastFrame = None
h3d_scene_Object._hx_class = h3d_scene_Object
_hx_classes["h3d.scene.Object"] = h3d_scene_Object


class h3d_scene_CameraController(h3d_scene_Object):
    _hx_class_name = "h3d.scene.CameraController"
    _hx_is_interface = "False"
    _hx_fields = ["friction", "rotateSpeed", "zoomAmount", "fovZoomAmount", "panSpeed", "smooth", "lockZPlanes", "scene", "pushing", "pushX", "pushY", "pushStartX", "pushStartY", "moveX", "moveY", "pushTime", "curPos", "curOffset", "targetPos", "targetOffset"]
    _hx_methods = ["get_distance", "get_theta", "get_phi", "get_fovY", "get_target", "set", "loadFromCamera", "initFromScene", "toTarget", "onAdd", "onRemove", "onClick", "onEvent", "fov", "zoom", "rot", "pan", "syncCamera", "sync"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_scene_Object


    def __init__(self,distance = None,parent = None):
        self.pushTime = None
        self.scene = None
        self.targetOffset = h3d_Vector(0,0,0,0)
        self.targetPos = h3d_Vector(0.4,(Math.PI / 4),((Math.PI * 5) / 13))
        self.curOffset = h3d_Vector()
        self.curPos = h3d_Vector()
        self.moveY = 0.
        self.moveX = 0.
        self.pushStartY = 0.
        self.pushStartX = 0.
        self.pushY = 0.
        self.pushX = 0.
        self.pushing = -1
        self.lockZPlanes = False
        self.smooth = 0.6
        self.panSpeed = 1.
        self.fovZoomAmount = 1.1
        self.zoomAmount = 1.15
        self.rotateSpeed = 1.
        self.friction = 0.4
        super().__init__(parent)
        self.name = "CameraController"
        self.set(distance)
        f = 256
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.flags
        _hx_local_0.flags = (_hx_local_1 | f)
        _hx_local_0.flags
        _this = self.curPos
        v = self.targetPos
        _this.x = v.x
        _this.y = v.y
        _this.z = v.z
        _this.w = v.w
        _this1 = self.curOffset
        v1 = self.targetOffset
        _this1.x = v1.x
        _this1.y = v1.y
        _this1.z = v1.z
        _this1.w = v1.w

    def get_distance(self):
        return (self.curPos.x / self.curOffset.w)

    def get_theta(self):
        return self.curPos.y

    def get_phi(self):
        return self.curPos.z

    def get_fovY(self):
        return self.curOffset.w

    def get_target(self):
        _this = self.curOffset
        return h3d_col_Point(_this.x,_this.y,_this.z)

    def set(self,distance = None,theta = None,phi = None,target = None,fovY = None):
        if (theta is not None):
            self.targetPos.y = theta
        if (phi is not None):
            self.targetPos.z = phi
        if (target is not None):
            _this = self.targetOffset
            x = target.x
            y = target.y
            z = target.z
            w = self.targetOffset.w
            if (w is None):
                w = 1.
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            _this.x = x
            _this.y = y
            _this.z = z
            _this.w = w
        if (fovY is not None):
            self.targetOffset.w = fovY
        if (distance is not None):
            self.targetPos.x = (distance * ((1 if ((self.targetOffset.w == 0)) else self.targetOffset.w)))

    def loadFromCamera(self,animate = None):
        if (animate is None):
            animate = False
        scene = (self.getScene() if ((self.scene is None)) else self.scene)
        if (scene is None):
            raise _HxException("Not in scene")
        _this = self.targetOffset
        v = scene.camera.target
        _this.x = v.x
        _this.y = v.y
        _this.z = v.z
        _this.w = v.w
        self.targetOffset.w = scene.camera.fovY
        _this1 = scene.camera.pos
        v1 = scene.camera.target
        x = (_this1.x - v1.x)
        y = (_this1.y - v1.y)
        z = (_this1.z - v1.z)
        w = (_this1.w - v1.w)
        if (w is None):
            w = 1.
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        pos_x = x
        pos_y = y
        pos_z = z
        pos_w = w
        f = (((pos_x * pos_x) + ((pos_y * pos_y))) + ((pos_z * pos_z)))
        r = (Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))
        _this2 = self.targetPos
        x1 = r
        y1 = Math.atan2(pos_y,pos_x)
        z1 = Math.acos((pos_z / r))
        if (z1 is None):
            z1 = 0.
        if (y1 is None):
            y1 = 0.
        if (x1 is None):
            x1 = 0.
        _this2.x = x1
        _this2.y = y1
        _this2.z = z1
        _this2.w = 1.
        _hx_local_0 = self.targetPos
        _hx_local_1 = _hx_local_0.x
        _hx_local_0.x = (_hx_local_1 * self.targetOffset.w)
        _hx_local_0.x
        self.curOffset.w = scene.camera.fovY
        if (not animate):
            self.toTarget()
        else:
            self.syncCamera()

    def initFromScene(self):
        scene = self.getScene()
        if (scene is None):
            raise _HxException("Not in scene")
        bounds = scene.getBounds()
        x = (((bounds.xMin + bounds.xMax)) * 0.5)
        y = (((bounds.yMin + bounds.yMax)) * 0.5)
        z = (((bounds.zMin + bounds.zMax)) * 0.5)
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        center_x = x
        center_y = y
        center_z = z
        _this = scene.camera.target
        x1 = center_x
        y1 = center_y
        z1 = center_z
        if (z1 is None):
            z1 = 0.
        if (y1 is None):
            y1 = 0.
        if (x1 is None):
            x1 = 0.
        v_x = x1
        v_y = y1
        v_z = z1
        v_w = 1.
        _this.x = v_x
        _this.y = v_y
        _this.z = v_z
        _this.w = v_w
        x2 = bounds.xMax
        y2 = bounds.yMax
        z2 = bounds.zMax
        if (z2 is None):
            z2 = 0.
        if (y2 is None):
            y2 = 0.
        if (x2 is None):
            x2 = 0.
        _this_x = x2
        _this_y = y2
        _this_z = z2
        d = h3d_col_Point((_this_x - center_x),(_this_y - center_y),(_this_z - center_z))
        d.x = (d.x * 5)
        d.y = (d.y * 5)
        d.z = (d.z * 5)
        d.z = (d.z * 0.5)
        d = h3d_col_Point((d.x + center_x),(d.y + center_y),(d.z + center_z))
        _this1 = scene.camera.pos
        x3 = d.x
        y3 = d.y
        z3 = d.z
        if (z3 is None):
            z3 = 0.
        if (y3 is None):
            y3 = 0.
        if (x3 is None):
            x3 = 0.
        v_x1 = x3
        v_y1 = y3
        v_z1 = z3
        v_w1 = 1.
        _this1.x = v_x1
        _this1.y = v_y1
        _this1.z = v_z1
        _this1.w = v_w1
        self.loadFromCamera()

    def toTarget(self):
        _this = self.curPos
        v = self.targetPos
        _this.x = v.x
        _this.y = v.y
        _this.z = v.z
        _this.w = v.w
        _this1 = self.curOffset
        v1 = self.targetOffset
        _this1.x = v1.x
        _this1.y = v1.y
        _this1.z = v1.z
        _this1.w = v1.w
        self.syncCamera()

    def onAdd(self):
        super().onAdd()
        self.scene = self.getScene()
        self.scene.addEventListener(self.onEvent)
        if (self.curOffset.w == 0):
            _hx_local_0 = self.curPos
            _hx_local_1 = _hx_local_0.x
            _hx_local_0.x = (_hx_local_1 * self.scene.camera.fovY)
            _hx_local_0.x
        self.curOffset.w = self.scene.camera.fovY
        _this = self.targetPos
        v = self.curPos
        _this.x = v.x
        _this.y = v.y
        _this.z = v.z
        _this.w = v.w
        _this1 = self.targetOffset
        v1 = self.curOffset
        _this1.x = v1.x
        _this1.y = v1.y
        _this1.z = v1.z
        _this1.w = v1.w

    def onRemove(self):
        super().onRemove()
        self.scene.removeEventListener(self.onEvent)
        self.scene = None

    def onClick(self,e):
        pass

    def onEvent(self,e):
        _gthis = self
        p = self
        while (p is not None):
            if (((p.flags & 2)) == 0):
                e.propagate = True
                return
            p = p.parent
        tmp = e.kind.index
        if (tmp == 0):
            def _hx_local_0():
                _gthis.pushing = -1
            self.scene.events.startDrag(self.onEvent,_hx_local_0,e)
            self.pushing = e.button
            self.pushTime = python_lib_Timeit.default_timer()
            def _hx_local_1():
                self.pushX = e.relX
                return self.pushX
            self.pushStartX = _hx_local_1()
            def _hx_local_2():
                self.pushY = e.relY
                return self.pushY
            self.pushStartY = _hx_local_2()
        elif ((tmp == 10) or ((tmp == 1))):
            if (self.pushing == e.button):
                self.pushing = -1
                self.scene.events.stopDrag()
                tmp1 = None
                if ((e.kind == hxd_EventKind.ERelease) and (((python_lib_Timeit.default_timer() - self.pushTime) < 0.2))):
                    dx = (e.relX - self.pushStartX)
                    dy = (e.relY - self.pushStartY)
                    dz = 0.
                    if (dz is None):
                        dz = 0.
                    f = (((dx * dx) + ((dy * dy))) + ((dz * dz)))
                    tmp1 = (((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))) < 5)
                else:
                    tmp1 = False
                if tmp1:
                    self.onClick(e)
        elif (tmp == 2):
            _g = self.pushing
            if (_g == 0):
                if hxd_Key.isDown(18):
                    self.zoom((-(((e.relX - self.pushX) + ((e.relY - self.pushY)))) * 0.03))
                else:
                    self.rot((e.relX - self.pushX),(e.relY - self.pushY))
                self.pushX = e.relX
                self.pushY = e.relY
            elif (_g == 1):
                m = (((0.001 * self.curPos.x) * self.panSpeed) / 25)
                self.pan((-((e.relX - self.pushX)) * m),(((e.relY - self.pushY)) * m))
                self.pushX = e.relX
                self.pushY = e.relY
            elif (_g == 2):
                self.rot((e.relX - self.pushX),(e.relY - self.pushY))
                self.pushX = e.relX
                self.pushY = e.relY
            else:
                pass
        elif (tmp == 5):
            if hxd_Key.isDown(17):
                self.fov(((e.wheelDelta * self.fovZoomAmount) * 2))
            else:
                self.zoom(e.wheelDelta)
        else:
            pass

    def fov(self,delta):
        _hx_local_0 = self.targetOffset
        _hx_local_1 = _hx_local_0.w
        _hx_local_0.w = (_hx_local_1 + delta)
        _hx_local_0.w
        if (self.targetOffset.w >= 179):
            self.targetOffset.w = 179
        if (self.targetOffset.w < 1):
            self.targetOffset.w = 1

    def zoom(self,delta):
        _hx_local_0 = self.targetPos
        _hx_local_1 = _hx_local_0.x
        _hx_local_0.x = (_hx_local_1 * Math.pow(self.zoomAmount,delta))
        _hx_local_0.x

    def rot(self,dx,dy):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.moveX
        _hx_local_0.moveX = (_hx_local_1 + dx)
        _hx_local_0.moveX
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.moveY
        _hx_local_2.moveY = (_hx_local_3 + dy)
        _hx_local_2.moveY

    def pan(self,dx,dy):
        x = dx
        y = dy
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = 0.
        v_w = 1.
        self.scene.camera.update()
        m = self.scene.camera.getInverseView()
        px = (((v_x * m._11) + ((v_y * m._21))) + ((v_z * m._31)))
        py = (((v_x * m._12) + ((v_y * m._22))) + ((v_z * m._32)))
        pz = (((v_x * m._13) + ((v_y * m._23))) + ((v_z * m._33)))
        v_x = px
        v_y = py
        v_z = pz
        v_w = 0
        _this = self.targetOffset
        self.targetOffset = h3d_Vector((_this.x + v_x),(_this.y + v_y),(_this.z + v_z),(_this.w + v_w))

    def syncCamera(self):
        cam = self.getScene().camera
        distance = (self.curPos.x / self.curOffset.w)
        _this = cam.target
        v = self.curOffset
        _this.x = v.x
        _this.y = v.y
        _this.z = v.z
        _this.w = v.w
        cam.target.w = 1
        _this1 = cam.pos
        v1 = self.curPos.y
        x = (Math.NaN if (((v1 == Math.POSITIVE_INFINITY) or ((v1 == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(v1))
        v2 = self.curPos.z
        x1 = (((distance * x) * ((Math.NaN if (((v2 == Math.POSITIVE_INFINITY) or ((v2 == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(v2)))) + cam.target.x)
        v3 = self.curPos.y
        y = (Math.NaN if (((v3 == Math.POSITIVE_INFINITY) or ((v3 == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(v3))
        v4 = self.curPos.z
        y1 = (((distance * y) * ((Math.NaN if (((v4 == Math.POSITIVE_INFINITY) or ((v4 == Math.NEGATIVE_INFINITY)))) else python_lib_Math.sin(v4)))) + cam.target.y)
        v5 = self.curPos.z
        z = ((distance * ((Math.NaN if (((v5 == Math.POSITIVE_INFINITY) or ((v5 == Math.NEGATIVE_INFINITY)))) else python_lib_Math.cos(v5)))) + cam.target.z)
        if (z is None):
            z = 0.
        if (y1 is None):
            y1 = 0.
        if (x1 is None):
            x1 = 0.
        _this1.x = x1
        _this1.y = y1
        _this1.z = z
        _this1.w = 1.
        if (not self.lockZPlanes):
            cam.zNear = (distance * 0.01)
            cam.zFar = (distance * 100)
        cam.fovY = self.curOffset.w

    def sync(self,ctx):
        if ((not ctx.visibleFlag) and ((((self.flags & 64)) == 0))):
            super().sync(ctx)
            return
        if (self.moveX != 0):
            _hx_local_0 = self.targetPos
            _hx_local_1 = _hx_local_0.y
            _hx_local_0.y = (_hx_local_1 + (((self.moveX * 0.003) * self.rotateSpeed)))
            _hx_local_0.y
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.moveX
            _hx_local_2.moveX = (_hx_local_3 * ((1 - self.friction)))
            _hx_local_2.moveX
            if (Reflect.field(Math,"fabs")(self.moveX) < 1):
                self.moveX = 0
        if (self.moveY != 0):
            _hx_local_4 = self.targetPos
            _hx_local_5 = _hx_local_4.z
            _hx_local_4.z = (_hx_local_5 - (((self.moveY * 0.003) * self.rotateSpeed)))
            _hx_local_4.z
            E = 2e-5
            bound = (Math.PI - E)
            if (self.targetPos.z < E):
                self.targetPos.z = E
            if (self.targetPos.z > bound):
                self.targetPos.z = bound
            _hx_local_6 = self
            _hx_local_7 = _hx_local_6.moveY
            _hx_local_6.moveY = (_hx_local_7 * ((1 - self.friction)))
            _hx_local_6.moveY
            if (Reflect.field(Math,"fabs")(self.moveY) < 1):
                self.moveY = 0
        b = (1 - Math.pow(self.smooth,(ctx.elapsedTime * 60)))
        dt = (b if ((1 > b)) else 1)
        cam = self.scene.camera
        _this = self.curOffset
        v1 = self.curOffset
        v2 = self.targetOffset
        a = v1.x
        x = (a + ((dt * ((v2.x - a)))))
        a1 = v1.y
        y = (a1 + ((dt * ((v2.y - a1)))))
        a2 = v1.z
        z = (a2 + ((dt * ((v2.z - a2)))))
        a3 = v1.w
        w = (a3 + ((dt * ((v2.w - a3)))))
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = w
        _this1 = self.curPos
        v11 = self.curPos
        v21 = self.targetPos
        a4 = v11.x
        x1 = (a4 + ((dt * ((v21.x - a4)))))
        a5 = v11.y
        y1 = (a5 + ((dt * ((v21.y - a5)))))
        a6 = v11.z
        z1 = (a6 + ((dt * ((v21.z - a6)))))
        a7 = v11.w
        w1 = (a7 + ((dt * ((v21.w - a7)))))
        _this1.x = x1
        _this1.y = y1
        _this1.z = z1
        _this1.w = w1
        self.syncCamera()
        super().sync(ctx)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.friction = None
        _hx_o.rotateSpeed = None
        _hx_o.zoomAmount = None
        _hx_o.fovZoomAmount = None
        _hx_o.panSpeed = None
        _hx_o.smooth = None
        _hx_o.lockZPlanes = None
        _hx_o.scene = None
        _hx_o.pushing = None
        _hx_o.pushX = None
        _hx_o.pushY = None
        _hx_o.pushStartX = None
        _hx_o.pushStartY = None
        _hx_o.moveX = None
        _hx_o.moveY = None
        _hx_o.pushTime = None
        _hx_o.curPos = None
        _hx_o.curOffset = None
        _hx_o.targetPos = None
        _hx_o.targetOffset = None
h3d_scene_CameraController._hx_class = h3d_scene_CameraController
_hx_classes["h3d.scene.CameraController"] = h3d_scene_CameraController


class h3d_scene__Graphics_GPoint:
    _hx_class_name = "h3d.scene._Graphics.GPoint"
    _hx_is_interface = "False"
    __slots__ = ("x", "y", "z", "r", "g", "b", "a")
    _hx_fields = ["x", "y", "z", "r", "g", "b", "a"]

    def __init__(self,x,y,z,r,g,b,a):
        self.x = x
        self.y = y
        self.z = z
        self.r = r
        self.g = g
        self.b = b
        self.a = a

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.x = None
        _hx_o.y = None
        _hx_o.z = None
        _hx_o.r = None
        _hx_o.g = None
        _hx_o.b = None
        _hx_o.a = None
h3d_scene__Graphics_GPoint._hx_class = h3d_scene__Graphics_GPoint
_hx_classes["h3d.scene._Graphics.GPoint"] = h3d_scene__Graphics_GPoint


class h3d_scene_Mesh(h3d_scene_Object):
    _hx_class_name = "h3d.scene.Mesh"
    _hx_is_interface = "False"
    __slots__ = ("primitive", "material")
    _hx_fields = ["primitive", "material"]
    _hx_methods = ["getMeshMaterials", "getBoundsRec", "clone", "getLocalCollider", "draw", "emit", "getMaterialByName", "getMaterials", "onAdd", "onRemove", "set_primitive"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_scene_Object


    def __init__(self,primitive,material = None,parent = None):
        self.material = None
        self.primitive = None
        super().__init__(parent)
        self.set_primitive(primitive)
        if (material is None):
            material = h3d_mat_MaterialSetup.current.createMaterial()
            material.set_props(material.getDefaultProps())
        self.material = material

    def getMeshMaterials(self):
        return [self.material]

    def getBoundsRec(self,b):
        b = super().getBoundsRec(b)
        if ((self.primitive is None) or ((((self.flags & 512)) != 0))):
            return b
        _this = self.primitive.getBounds()
        b1 = h3d_col_Bounds()
        b1.xMin = _this.xMin
        b1.xMax = _this.xMax
        b1.yMin = _this.yMin
        b1.yMax = _this.yMax
        b1.zMin = _this.zMin
        b1.zMax = _this.zMax
        tmp = b1
        tmp.transform(self.absPos)
        if (tmp.xMin < b.xMin):
            b.xMin = tmp.xMin
        if (tmp.xMax > b.xMax):
            b.xMax = tmp.xMax
        if (tmp.yMin < b.yMin):
            b.yMin = tmp.yMin
        if (tmp.yMax > b.yMax):
            b.yMax = tmp.yMax
        if (tmp.zMin < b.zMin):
            b.zMin = tmp.zMin
        if (tmp.zMax > b.zMax):
            b.zMax = tmp.zMax
        return b

    def clone(self,o = None):
        m = (h3d_scene_Mesh(None,self.material) if ((o is None)) else o)
        m.set_primitive(self.primitive)
        m.material = self.material.clone()
        super().clone(m)
        return m

    def getLocalCollider(self):
        return self.primitive.getCollider()

    def draw(self,ctx):
        self.primitive.render(ctx.engine)

    def emit(self,ctx):
        p = self.material.passes
        while (p is not None):
            ctx.emitPass(p,self).index = 0
            p = p.nextPass

    def getMaterialByName(self,name):
        if ((self.material is not None) and ((self.material.name == name))):
            return self.material
        return super().getMaterialByName(name)

    def getMaterials(self,a = None):
        if (a is None):
            a = []
        if ((self.material is not None) and ((python_internal_ArrayImpl.indexOf(a,self.material,None) < 0))):
            x = self.material
            a.append(x)
        return super().getMaterials(a)

    def onAdd(self):
        super().onAdd()
        if (self.primitive is not None):
            self.primitive.incref()

    def onRemove(self):
        if (self.primitive is not None):
            self.primitive.decref()
        super().onRemove()

    def set_primitive(self,prim):
        if ((prim != self.primitive) and ((((self.flags & 32)) != 0))):
            if (self.primitive is not None):
                self.primitive.decref()
            if (prim is not None):
                prim.incref()
        def _hx_local_1():
            def _hx_local_0():
                self.primitive = prim
                return self.primitive
            return _hx_local_0()
        return _hx_local_1()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.primitive = None
        _hx_o.material = None
h3d_scene_Mesh._hx_class = h3d_scene_Mesh
_hx_classes["h3d.scene.Mesh"] = h3d_scene_Mesh


class h3d_scene_Graphics(h3d_scene_Mesh):
    _hx_class_name = "h3d.scene.Graphics"
    _hx_is_interface = "False"
    __slots__ = ("bprim", "curX", "curY", "curZ", "curR", "curG", "curB", "curA", "lineSize", "lineShader", "tmpPoints", "is3D")
    _hx_fields = ["bprim", "curX", "curY", "curZ", "curR", "curG", "curB", "curA", "lineSize", "lineShader", "tmpPoints", "is3D"]
    _hx_methods = ["onRemove", "set_is3D", "flushLine", "flush", "sync", "draw", "clear", "lineStyle", "setColor", "drawLine", "moveTo", "addVertex", "lineTo"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_scene_Mesh


    def __init__(self,parent = None):
        self.is3D = None
        self.tmpPoints = None
        self.lineShader = None
        self.curA = None
        self.curB = None
        self.curG = None
        self.lineSize = 0.
        self.curR = 0.
        self.curZ = 0.
        self.curY = 0.
        self.curX = 0.
        self.bprim = h3d_prim_BigPrimitive(12)
        self.bprim.isStatic = False
        super().__init__(self.bprim,None,parent)
        self.tmpPoints = []
        self.lineShader = h3d_shader_LineShader()
        self.lineShader.setPriority(-100)
        _this = self.material
        _this.set_castShadows(False)
        _this.set_receiveShadows(False)
        self.material.passes.set_enableLights(False)
        self.material.passes.addShader(self.lineShader)
        vcolor = h3d_shader_VertexColorAlpha()
        vcolor.setPriority(-100)
        self.material.passes.addShader(vcolor)
        self.material.passes.set_culling(h3d_mat_Face._hx_None)

    def onRemove(self):
        super().onRemove()
        self.bprim.clear()

    def set_is3D(self,v):
        if (self.is3D == v):
            return v
        if v:
            self.material.passes.removeShader(self.lineShader)
        else:
            self.material.passes.addShader(self.lineShader)
        self.bprim.clear()
        self.tmpPoints = []
        def _hx_local_1():
            def _hx_local_0():
                self.is3D = v
                return self.is3D
            return _hx_local_0()
        return _hx_local_1()

    def flushLine(self):
        _gthis = self
        pts = self.tmpPoints
        last = (len(pts) - 1)
        prev = (pts[last] if last >= 0 and last < len(pts) else None)
        p = (pts[0] if 0 < len(pts) else None)
        closed = (((p.x == prev.x) and ((p.y == prev.y))) and ((p.z == prev.z)))
        count = len(pts)
        if (not closed):
            prevLast = python_internal_ArrayImpl._get(pts, (last - 1))
            if (prevLast is None):
                prevLast = p
            x = h3d_scene__Graphics_GPoint(((prev.x * 2) - prevLast.x),((prev.y * 2) - prevLast.y),((prev.z * 2) - prevLast.z),0,0,0,0)
            pts.append(x)
            pNext = (pts[1] if 1 < len(pts) else None)
            if (pNext is None):
                pNext = p
            prev = h3d_scene__Graphics_GPoint(((p.x * 2) - pNext.x),((p.y * 2) - pNext.y),((p.z * 2) - pNext.z),0,0,0,0)
        elif (p != prev):
            count = (count - 1)
            last = (last - 1)
            prev = (pts[last] if last >= 0 and last < len(pts) else None)
        start = self.bprim.vertexCount()
        pindex = start
        v = 0.
        _g = 0
        _g1 = count
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            next = python_internal_ArrayImpl._get(pts, HxOverrides.mod(((i + 1)), len(pts)))
            nx1 = (prev.y - p.y)
            ny1 = (p.x - prev.x)
            f = ((nx1 * nx1) + ((ny1 * ny1)))
            ns1 = (1. / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
            nx2 = (p.y - next.y)
            ny2 = (next.x - p.x)
            f1 = ((nx2 * nx2) + ((ny2 * ny2)))
            ns2 = (1. / ((Math.NaN if ((f1 < 0)) else python_lib_Math.sqrt(f1))))
            nx = ((nx1 * ns1) + ((nx2 * ns2)))
            ny = ((ny1 * ns1) + ((ny2 * ns2)))
            f2 = ((nx * nx) + ((ny * ny)))
            ns = (1. / ((Math.NaN if ((f2 < 0)) else python_lib_Math.sqrt(f2))))
            nx = (nx * ns)
            ny = (ny * ns)
            size = (((nx * nx1) * ns1) + (((ny * ny1) * ns1)))
            d = ((self.lineSize * 0.5) / size)
            nx = (nx * d)
            ny = (ny * d)
            hasIndex = ((i < ((count - 1))) or closed)
            self.bprim.begin(2,(6 if hasIndex else 0))
            _this = _gthis.bprim
            def _hx_local_7():
                _hx_local_6 = _this.bufPos
                _this.bufPos = (_this.bufPos + 1)
                return _hx_local_6
            key = _hx_local_7()
            python_internal_ArrayImpl._set(_this.tmpBuf, key, (p.x + nx))
            _this1 = _gthis.bprim
            def _hx_local_9():
                _hx_local_8 = _this1.bufPos
                _this1.bufPos = (_this1.bufPos + 1)
                return _hx_local_8
            key1 = _hx_local_9()
            python_internal_ArrayImpl._set(_this1.tmpBuf, key1, (p.y + ny))
            _this2 = _gthis.bprim
            def _hx_local_11():
                _hx_local_10 = _this2.bufPos
                _this2.bufPos = (_this2.bufPos + 1)
                return _hx_local_10
            key2 = _hx_local_11()
            python_internal_ArrayImpl._set(_this2.tmpBuf, key2, p.z)
            _this3 = _gthis.bprim
            def _hx_local_13():
                _hx_local_12 = _this3.bufPos
                _this3.bufPos = (_this3.bufPos + 1)
                return _hx_local_12
            key3 = _hx_local_13()
            python_internal_ArrayImpl._set(_this3.tmpBuf, key3, 0)
            _this4 = _gthis.bprim
            def _hx_local_15():
                _hx_local_14 = _this4.bufPos
                _this4.bufPos = (_this4.bufPos + 1)
                return _hx_local_14
            key4 = _hx_local_15()
            python_internal_ArrayImpl._set(_this4.tmpBuf, key4, 0)
            _this5 = _gthis.bprim
            def _hx_local_17():
                _hx_local_16 = _this5.bufPos
                _this5.bufPos = (_this5.bufPos + 1)
                return _hx_local_16
            key5 = _hx_local_17()
            python_internal_ArrayImpl._set(_this5.tmpBuf, key5, 1)
            _this6 = _gthis.bprim
            def _hx_local_19():
                _hx_local_18 = _this6.bufPos
                _this6.bufPos = (_this6.bufPos + 1)
                return _hx_local_18
            key6 = _hx_local_19()
            python_internal_ArrayImpl._set(_this6.tmpBuf, key6, 0)
            _this7 = _gthis.bprim
            def _hx_local_21():
                _hx_local_20 = _this7.bufPos
                _this7.bufPos = (_this7.bufPos + 1)
                return _hx_local_20
            key7 = _hx_local_21()
            python_internal_ArrayImpl._set(_this7.tmpBuf, key7, v)
            _this8 = _gthis.bprim
            def _hx_local_23():
                _hx_local_22 = _this8.bufPos
                _this8.bufPos = (_this8.bufPos + 1)
                return _hx_local_22
            key8 = _hx_local_23()
            python_internal_ArrayImpl._set(_this8.tmpBuf, key8, p.r)
            _this9 = _gthis.bprim
            def _hx_local_25():
                _hx_local_24 = _this9.bufPos
                _this9.bufPos = (_this9.bufPos + 1)
                return _hx_local_24
            key9 = _hx_local_25()
            python_internal_ArrayImpl._set(_this9.tmpBuf, key9, p.g)
            _this10 = _gthis.bprim
            def _hx_local_27():
                _hx_local_26 = _this10.bufPos
                _this10.bufPos = (_this10.bufPos + 1)
                return _hx_local_26
            key10 = _hx_local_27()
            python_internal_ArrayImpl._set(_this10.tmpBuf, key10, p.b)
            _this11 = _gthis.bprim
            def _hx_local_29():
                _hx_local_28 = _this11.bufPos
                _this11.bufPos = (_this11.bufPos + 1)
                return _hx_local_28
            key11 = _hx_local_29()
            python_internal_ArrayImpl._set(_this11.tmpBuf, key11, p.a)
            _this12 = _gthis.bprim
            def _hx_local_31():
                _hx_local_30 = _this12.bufPos
                _this12.bufPos = (_this12.bufPos + 1)
                return _hx_local_30
            key12 = _hx_local_31()
            python_internal_ArrayImpl._set(_this12.tmpBuf, key12, (p.x - nx))
            _this13 = _gthis.bprim
            def _hx_local_33():
                _hx_local_32 = _this13.bufPos
                _this13.bufPos = (_this13.bufPos + 1)
                return _hx_local_32
            key13 = _hx_local_33()
            python_internal_ArrayImpl._set(_this13.tmpBuf, key13, (p.y - ny))
            _this14 = _gthis.bprim
            def _hx_local_35():
                _hx_local_34 = _this14.bufPos
                _this14.bufPos = (_this14.bufPos + 1)
                return _hx_local_34
            key14 = _hx_local_35()
            python_internal_ArrayImpl._set(_this14.tmpBuf, key14, p.z)
            _this15 = _gthis.bprim
            def _hx_local_37():
                _hx_local_36 = _this15.bufPos
                _this15.bufPos = (_this15.bufPos + 1)
                return _hx_local_36
            key15 = _hx_local_37()
            python_internal_ArrayImpl._set(_this15.tmpBuf, key15, 0)
            _this16 = _gthis.bprim
            def _hx_local_39():
                _hx_local_38 = _this16.bufPos
                _this16.bufPos = (_this16.bufPos + 1)
                return _hx_local_38
            key16 = _hx_local_39()
            python_internal_ArrayImpl._set(_this16.tmpBuf, key16, 0)
            _this17 = _gthis.bprim
            def _hx_local_41():
                _hx_local_40 = _this17.bufPos
                _this17.bufPos = (_this17.bufPos + 1)
                return _hx_local_40
            key17 = _hx_local_41()
            python_internal_ArrayImpl._set(_this17.tmpBuf, key17, 1)
            _this18 = _gthis.bprim
            def _hx_local_43():
                _hx_local_42 = _this18.bufPos
                _this18.bufPos = (_this18.bufPos + 1)
                return _hx_local_42
            key18 = _hx_local_43()
            python_internal_ArrayImpl._set(_this18.tmpBuf, key18, 1)
            _this19 = _gthis.bprim
            def _hx_local_45():
                _hx_local_44 = _this19.bufPos
                _this19.bufPos = (_this19.bufPos + 1)
                return _hx_local_44
            key19 = _hx_local_45()
            python_internal_ArrayImpl._set(_this19.tmpBuf, key19, v)
            _this20 = _gthis.bprim
            def _hx_local_47():
                _hx_local_46 = _this20.bufPos
                _this20.bufPos = (_this20.bufPos + 1)
                return _hx_local_46
            key20 = _hx_local_47()
            python_internal_ArrayImpl._set(_this20.tmpBuf, key20, p.r)
            _this21 = _gthis.bprim
            def _hx_local_49():
                _hx_local_48 = _this21.bufPos
                _this21.bufPos = (_this21.bufPos + 1)
                return _hx_local_48
            key21 = _hx_local_49()
            python_internal_ArrayImpl._set(_this21.tmpBuf, key21, p.g)
            _this22 = _gthis.bprim
            def _hx_local_51():
                _hx_local_50 = _this22.bufPos
                _this22.bufPos = (_this22.bufPos + 1)
                return _hx_local_50
            key22 = _hx_local_51()
            python_internal_ArrayImpl._set(_this22.tmpBuf, key22, p.b)
            _this23 = _gthis.bprim
            def _hx_local_53():
                _hx_local_52 = _this23.bufPos
                _this23.bufPos = (_this23.bufPos + 1)
                return _hx_local_52
            key23 = _hx_local_53()
            python_internal_ArrayImpl._set(_this23.tmpBuf, key23, p.a)
            v = (1 - v)
            if hasIndex:
                pnext = ((start - pindex) if ((i == last)) else 2)
                _this24 = self.bprim
                def _hx_local_55():
                    _hx_local_54 = _this24.idxPos
                    _this24.idxPos = (_this24.idxPos + 1)
                    return _hx_local_54
                key24 = _hx_local_55()
                python_internal_ArrayImpl._set(_this24.tmpIdx, key24, _this24.startIndex)
                _this25 = self.bprim
                def _hx_local_57():
                    _hx_local_56 = _this25.idxPos
                    _this25.idxPos = (_this25.idxPos + 1)
                    return _hx_local_56
                key25 = _hx_local_57()
                python_internal_ArrayImpl._set(_this25.tmpIdx, key25, (1 + _this25.startIndex))
                _this26 = self.bprim
                def _hx_local_59():
                    _hx_local_58 = _this26.idxPos
                    _this26.idxPos = (_this26.idxPos + 1)
                    return _hx_local_58
                key26 = _hx_local_59()
                python_internal_ArrayImpl._set(_this26.tmpIdx, key26, (pnext + _this26.startIndex))
                _this27 = self.bprim
                def _hx_local_61():
                    _hx_local_60 = _this27.idxPos
                    _this27.idxPos = (_this27.idxPos + 1)
                    return _hx_local_60
                key27 = _hx_local_61()
                python_internal_ArrayImpl._set(_this27.tmpIdx, key27, (pnext + _this27.startIndex))
                _this28 = self.bprim
                def _hx_local_63():
                    _hx_local_62 = _this28.idxPos
                    _this28.idxPos = (_this28.idxPos + 1)
                    return _hx_local_62
                key28 = _hx_local_63()
                python_internal_ArrayImpl._set(_this28.tmpIdx, key28, (1 + _this28.startIndex))
                _this29 = self.bprim
                def _hx_local_65():
                    _hx_local_64 = _this29.idxPos
                    _this29.idxPos = (_this29.idxPos + 1)
                    return _hx_local_64
                key29 = _hx_local_65()
                python_internal_ArrayImpl._set(_this29.tmpIdx, key29, ((pnext + 1) + _this29.startIndex))
            pindex = (pindex + 2)
            prev = p
            p = next

    def flush(self):
        if (len(self.tmpPoints) == 0):
            return
        if self.is3D:
            self.flushLine()
            self.tmpPoints = []

    def sync(self,ctx):
        super().sync(ctx)
        self.flush()
        self.bprim.flush()

    def draw(self,ctx):
        self.flush()
        self.bprim.flush()
        super().draw(ctx)

    def clear(self):
        self.flush()
        self.bprim.clear()

    def lineStyle(self,size = None,color = None,alpha = None):
        if (size is None):
            size = 0.
        if (color is None):
            color = 0
        if (alpha is None):
            alpha = 1.
        self.flush()
        if ((size > 0) and ((self.lineSize != size))):
            self.lineSize = size
            if (not self.is3D):
                self.lineShader.width__ = self.lineSize
        self.setColor(color,alpha)

    def setColor(self,color,alpha = None):
        if (alpha is None):
            alpha = 1.
        self.curA = alpha
        self.curR = ((((color >> 16) & 255)) / 255.)
        self.curG = ((((color >> 8) & 255)) / 255.)
        self.curB = (((color & 255)) / 255.)

    def drawLine(self,p1,p2):
        self.moveTo(p1.x,p1.y,p1.z)
        self.lineTo(p2.x,p2.y,p2.z)

    def moveTo(self,x,y,z):
        if self.is3D:
            self.flush()
            self.lineTo(x,y,z)
        else:
            self.curX = x
            self.curY = y
            self.curZ = z

    def addVertex(self,x,y,z,r,g,b,a):
        _this = self.tmpPoints
        x1 = h3d_scene__Graphics_GPoint(x,y,z,r,g,b,a)
        _this.append(x1)

    def lineTo(self,x,y,z):
        _gthis = self
        if self.is3D:
            _this = self.tmpPoints
            x1 = h3d_scene__Graphics_GPoint(x,y,z,self.curR,self.curG,self.curB,self.curA)
            _this.append(x1)
            return
        self.bprim.begin(4,6)
        nx = (x - self.curX)
        ny = (y - self.curY)
        nz = (z - self.curZ)
        x2 = self.curX
        y1 = self.curY
        z1 = self.curZ
        _this1 = self.bprim.bounds
        if (x2 < _this1.xMin):
            _this1.xMin = x2
        if (x2 > _this1.xMax):
            _this1.xMax = x2
        if (y1 < _this1.yMin):
            _this1.yMin = y1
        if (y1 > _this1.yMax):
            _this1.yMax = y1
        if (z1 < _this1.zMin):
            _this1.zMin = z1
        if (z1 > _this1.zMax):
            _this1.zMax = z1
        _this2 = self.bprim.bounds
        if (x < _this2.xMin):
            _this2.xMin = x
        if (x > _this2.xMax):
            _this2.xMax = x
        if (y < _this2.yMin):
            _this2.yMin = y
        if (y > _this2.yMax):
            _this2.yMax = y
        if (z < _this2.zMin):
            _this2.zMin = z
        if (z > _this2.zMax):
            _this2.zMax = z
        _this3 = _gthis.bprim
        def _hx_local_1():
            _hx_local_0 = _this3.bufPos
            _this3.bufPos = (_this3.bufPos + 1)
            return _hx_local_0
        key = _hx_local_1()
        python_internal_ArrayImpl._set(_this3.tmpBuf, key, _gthis.curX)
        _this4 = _gthis.bprim
        def _hx_local_3():
            _hx_local_2 = _this4.bufPos
            _this4.bufPos = (_this4.bufPos + 1)
            return _hx_local_2
        key1 = _hx_local_3()
        python_internal_ArrayImpl._set(_this4.tmpBuf, key1, _gthis.curY)
        _this5 = _gthis.bprim
        def _hx_local_5():
            _hx_local_4 = _this5.bufPos
            _this5.bufPos = (_this5.bufPos + 1)
            return _hx_local_4
        key2 = _hx_local_5()
        python_internal_ArrayImpl._set(_this5.tmpBuf, key2, _gthis.curZ)
        _this6 = _gthis.bprim
        def _hx_local_7():
            _hx_local_6 = _this6.bufPos
            _this6.bufPos = (_this6.bufPos + 1)
            return _hx_local_6
        key3 = _hx_local_7()
        python_internal_ArrayImpl._set(_this6.tmpBuf, key3, nx)
        _this7 = _gthis.bprim
        def _hx_local_9():
            _hx_local_8 = _this7.bufPos
            _this7.bufPos = (_this7.bufPos + 1)
            return _hx_local_8
        key4 = _hx_local_9()
        python_internal_ArrayImpl._set(_this7.tmpBuf, key4, ny)
        _this8 = _gthis.bprim
        def _hx_local_11():
            _hx_local_10 = _this8.bufPos
            _this8.bufPos = (_this8.bufPos + 1)
            return _hx_local_10
        key5 = _hx_local_11()
        python_internal_ArrayImpl._set(_this8.tmpBuf, key5, nz)
        _this9 = _gthis.bprim
        def _hx_local_13():
            _hx_local_12 = _this9.bufPos
            _this9.bufPos = (_this9.bufPos + 1)
            return _hx_local_12
        key6 = _hx_local_13()
        python_internal_ArrayImpl._set(_this9.tmpBuf, key6, 0)
        _this10 = _gthis.bprim
        def _hx_local_15():
            _hx_local_14 = _this10.bufPos
            _this10.bufPos = (_this10.bufPos + 1)
            return _hx_local_14
        key7 = _hx_local_15()
        python_internal_ArrayImpl._set(_this10.tmpBuf, key7, 0)
        _this11 = _gthis.bprim
        def _hx_local_17():
            _hx_local_16 = _this11.bufPos
            _this11.bufPos = (_this11.bufPos + 1)
            return _hx_local_16
        key8 = _hx_local_17()
        python_internal_ArrayImpl._set(_this11.tmpBuf, key8, _gthis.curR)
        _this12 = _gthis.bprim
        def _hx_local_19():
            _hx_local_18 = _this12.bufPos
            _this12.bufPos = (_this12.bufPos + 1)
            return _hx_local_18
        key9 = _hx_local_19()
        python_internal_ArrayImpl._set(_this12.tmpBuf, key9, _gthis.curG)
        _this13 = _gthis.bprim
        def _hx_local_21():
            _hx_local_20 = _this13.bufPos
            _this13.bufPos = (_this13.bufPos + 1)
            return _hx_local_20
        key10 = _hx_local_21()
        python_internal_ArrayImpl._set(_this13.tmpBuf, key10, _gthis.curB)
        _this14 = _gthis.bprim
        def _hx_local_23():
            _hx_local_22 = _this14.bufPos
            _this14.bufPos = (_this14.bufPos + 1)
            return _hx_local_22
        key11 = _hx_local_23()
        python_internal_ArrayImpl._set(_this14.tmpBuf, key11, _gthis.curA)
        _this15 = _gthis.bprim
        def _hx_local_25():
            _hx_local_24 = _this15.bufPos
            _this15.bufPos = (_this15.bufPos + 1)
            return _hx_local_24
        key12 = _hx_local_25()
        python_internal_ArrayImpl._set(_this15.tmpBuf, key12, _gthis.curX)
        _this16 = _gthis.bprim
        def _hx_local_27():
            _hx_local_26 = _this16.bufPos
            _this16.bufPos = (_this16.bufPos + 1)
            return _hx_local_26
        key13 = _hx_local_27()
        python_internal_ArrayImpl._set(_this16.tmpBuf, key13, _gthis.curY)
        _this17 = _gthis.bprim
        def _hx_local_29():
            _hx_local_28 = _this17.bufPos
            _this17.bufPos = (_this17.bufPos + 1)
            return _hx_local_28
        key14 = _hx_local_29()
        python_internal_ArrayImpl._set(_this17.tmpBuf, key14, _gthis.curZ)
        _this18 = _gthis.bprim
        def _hx_local_31():
            _hx_local_30 = _this18.bufPos
            _this18.bufPos = (_this18.bufPos + 1)
            return _hx_local_30
        key15 = _hx_local_31()
        python_internal_ArrayImpl._set(_this18.tmpBuf, key15, nx)
        _this19 = _gthis.bprim
        def _hx_local_33():
            _hx_local_32 = _this19.bufPos
            _this19.bufPos = (_this19.bufPos + 1)
            return _hx_local_32
        key16 = _hx_local_33()
        python_internal_ArrayImpl._set(_this19.tmpBuf, key16, ny)
        _this20 = _gthis.bprim
        def _hx_local_35():
            _hx_local_34 = _this20.bufPos
            _this20.bufPos = (_this20.bufPos + 1)
            return _hx_local_34
        key17 = _hx_local_35()
        python_internal_ArrayImpl._set(_this20.tmpBuf, key17, nz)
        _this21 = _gthis.bprim
        def _hx_local_37():
            _hx_local_36 = _this21.bufPos
            _this21.bufPos = (_this21.bufPos + 1)
            return _hx_local_36
        key18 = _hx_local_37()
        python_internal_ArrayImpl._set(_this21.tmpBuf, key18, 0)
        _this22 = _gthis.bprim
        def _hx_local_39():
            _hx_local_38 = _this22.bufPos
            _this22.bufPos = (_this22.bufPos + 1)
            return _hx_local_38
        key19 = _hx_local_39()
        python_internal_ArrayImpl._set(_this22.tmpBuf, key19, 1)
        _this23 = _gthis.bprim
        def _hx_local_41():
            _hx_local_40 = _this23.bufPos
            _this23.bufPos = (_this23.bufPos + 1)
            return _hx_local_40
        key20 = _hx_local_41()
        python_internal_ArrayImpl._set(_this23.tmpBuf, key20, _gthis.curR)
        _this24 = _gthis.bprim
        def _hx_local_43():
            _hx_local_42 = _this24.bufPos
            _this24.bufPos = (_this24.bufPos + 1)
            return _hx_local_42
        key21 = _hx_local_43()
        python_internal_ArrayImpl._set(_this24.tmpBuf, key21, _gthis.curG)
        _this25 = _gthis.bprim
        def _hx_local_45():
            _hx_local_44 = _this25.bufPos
            _this25.bufPos = (_this25.bufPos + 1)
            return _hx_local_44
        key22 = _hx_local_45()
        python_internal_ArrayImpl._set(_this25.tmpBuf, key22, _gthis.curB)
        _this26 = _gthis.bprim
        def _hx_local_47():
            _hx_local_46 = _this26.bufPos
            _this26.bufPos = (_this26.bufPos + 1)
            return _hx_local_46
        key23 = _hx_local_47()
        python_internal_ArrayImpl._set(_this26.tmpBuf, key23, _gthis.curA)
        _this27 = _gthis.bprim
        def _hx_local_49():
            _hx_local_48 = _this27.bufPos
            _this27.bufPos = (_this27.bufPos + 1)
            return _hx_local_48
        key24 = _hx_local_49()
        python_internal_ArrayImpl._set(_this27.tmpBuf, key24, _gthis.curX)
        _this28 = _gthis.bprim
        def _hx_local_51():
            _hx_local_50 = _this28.bufPos
            _this28.bufPos = (_this28.bufPos + 1)
            return _hx_local_50
        key25 = _hx_local_51()
        python_internal_ArrayImpl._set(_this28.tmpBuf, key25, _gthis.curY)
        _this29 = _gthis.bprim
        def _hx_local_53():
            _hx_local_52 = _this29.bufPos
            _this29.bufPos = (_this29.bufPos + 1)
            return _hx_local_52
        key26 = _hx_local_53()
        python_internal_ArrayImpl._set(_this29.tmpBuf, key26, _gthis.curZ)
        _this30 = _gthis.bprim
        def _hx_local_55():
            _hx_local_54 = _this30.bufPos
            _this30.bufPos = (_this30.bufPos + 1)
            return _hx_local_54
        key27 = _hx_local_55()
        python_internal_ArrayImpl._set(_this30.tmpBuf, key27, nx)
        _this31 = _gthis.bprim
        def _hx_local_57():
            _hx_local_56 = _this31.bufPos
            _this31.bufPos = (_this31.bufPos + 1)
            return _hx_local_56
        key28 = _hx_local_57()
        python_internal_ArrayImpl._set(_this31.tmpBuf, key28, ny)
        _this32 = _gthis.bprim
        def _hx_local_59():
            _hx_local_58 = _this32.bufPos
            _this32.bufPos = (_this32.bufPos + 1)
            return _hx_local_58
        key29 = _hx_local_59()
        python_internal_ArrayImpl._set(_this32.tmpBuf, key29, nz)
        _this33 = _gthis.bprim
        def _hx_local_61():
            _hx_local_60 = _this33.bufPos
            _this33.bufPos = (_this33.bufPos + 1)
            return _hx_local_60
        key30 = _hx_local_61()
        python_internal_ArrayImpl._set(_this33.tmpBuf, key30, 1)
        _this34 = _gthis.bprim
        def _hx_local_63():
            _hx_local_62 = _this34.bufPos
            _this34.bufPos = (_this34.bufPos + 1)
            return _hx_local_62
        key31 = _hx_local_63()
        python_internal_ArrayImpl._set(_this34.tmpBuf, key31, 0)
        _this35 = _gthis.bprim
        def _hx_local_65():
            _hx_local_64 = _this35.bufPos
            _this35.bufPos = (_this35.bufPos + 1)
            return _hx_local_64
        key32 = _hx_local_65()
        python_internal_ArrayImpl._set(_this35.tmpBuf, key32, _gthis.curR)
        _this36 = _gthis.bprim
        def _hx_local_67():
            _hx_local_66 = _this36.bufPos
            _this36.bufPos = (_this36.bufPos + 1)
            return _hx_local_66
        key33 = _hx_local_67()
        python_internal_ArrayImpl._set(_this36.tmpBuf, key33, _gthis.curG)
        _this37 = _gthis.bprim
        def _hx_local_69():
            _hx_local_68 = _this37.bufPos
            _this37.bufPos = (_this37.bufPos + 1)
            return _hx_local_68
        key34 = _hx_local_69()
        python_internal_ArrayImpl._set(_this37.tmpBuf, key34, _gthis.curB)
        _this38 = _gthis.bprim
        def _hx_local_71():
            _hx_local_70 = _this38.bufPos
            _this38.bufPos = (_this38.bufPos + 1)
            return _hx_local_70
        key35 = _hx_local_71()
        python_internal_ArrayImpl._set(_this38.tmpBuf, key35, _gthis.curA)
        _this39 = _gthis.bprim
        def _hx_local_73():
            _hx_local_72 = _this39.bufPos
            _this39.bufPos = (_this39.bufPos + 1)
            return _hx_local_72
        key36 = _hx_local_73()
        python_internal_ArrayImpl._set(_this39.tmpBuf, key36, _gthis.curX)
        _this40 = _gthis.bprim
        def _hx_local_75():
            _hx_local_74 = _this40.bufPos
            _this40.bufPos = (_this40.bufPos + 1)
            return _hx_local_74
        key37 = _hx_local_75()
        python_internal_ArrayImpl._set(_this40.tmpBuf, key37, _gthis.curY)
        _this41 = _gthis.bprim
        def _hx_local_77():
            _hx_local_76 = _this41.bufPos
            _this41.bufPos = (_this41.bufPos + 1)
            return _hx_local_76
        key38 = _hx_local_77()
        python_internal_ArrayImpl._set(_this41.tmpBuf, key38, _gthis.curZ)
        _this42 = _gthis.bprim
        def _hx_local_79():
            _hx_local_78 = _this42.bufPos
            _this42.bufPos = (_this42.bufPos + 1)
            return _hx_local_78
        key39 = _hx_local_79()
        python_internal_ArrayImpl._set(_this42.tmpBuf, key39, nx)
        _this43 = _gthis.bprim
        def _hx_local_81():
            _hx_local_80 = _this43.bufPos
            _this43.bufPos = (_this43.bufPos + 1)
            return _hx_local_80
        key40 = _hx_local_81()
        python_internal_ArrayImpl._set(_this43.tmpBuf, key40, ny)
        _this44 = _gthis.bprim
        def _hx_local_83():
            _hx_local_82 = _this44.bufPos
            _this44.bufPos = (_this44.bufPos + 1)
            return _hx_local_82
        key41 = _hx_local_83()
        python_internal_ArrayImpl._set(_this44.tmpBuf, key41, nz)
        _this45 = _gthis.bprim
        def _hx_local_85():
            _hx_local_84 = _this45.bufPos
            _this45.bufPos = (_this45.bufPos + 1)
            return _hx_local_84
        key42 = _hx_local_85()
        python_internal_ArrayImpl._set(_this45.tmpBuf, key42, 1)
        _this46 = _gthis.bprim
        def _hx_local_87():
            _hx_local_86 = _this46.bufPos
            _this46.bufPos = (_this46.bufPos + 1)
            return _hx_local_86
        key43 = _hx_local_87()
        python_internal_ArrayImpl._set(_this46.tmpBuf, key43, 1)
        _this47 = _gthis.bprim
        def _hx_local_89():
            _hx_local_88 = _this47.bufPos
            _this47.bufPos = (_this47.bufPos + 1)
            return _hx_local_88
        key44 = _hx_local_89()
        python_internal_ArrayImpl._set(_this47.tmpBuf, key44, _gthis.curR)
        _this48 = _gthis.bprim
        def _hx_local_91():
            _hx_local_90 = _this48.bufPos
            _this48.bufPos = (_this48.bufPos + 1)
            return _hx_local_90
        key45 = _hx_local_91()
        python_internal_ArrayImpl._set(_this48.tmpBuf, key45, _gthis.curG)
        _this49 = _gthis.bprim
        def _hx_local_93():
            _hx_local_92 = _this49.bufPos
            _this49.bufPos = (_this49.bufPos + 1)
            return _hx_local_92
        key46 = _hx_local_93()
        python_internal_ArrayImpl._set(_this49.tmpBuf, key46, _gthis.curB)
        _this50 = _gthis.bprim
        def _hx_local_95():
            _hx_local_94 = _this50.bufPos
            _this50.bufPos = (_this50.bufPos + 1)
            return _hx_local_94
        key47 = _hx_local_95()
        python_internal_ArrayImpl._set(_this50.tmpBuf, key47, _gthis.curA)
        _this51 = self.bprim
        def _hx_local_97():
            _hx_local_96 = _this51.idxPos
            _this51.idxPos = (_this51.idxPos + 1)
            return _hx_local_96
        key48 = _hx_local_97()
        python_internal_ArrayImpl._set(_this51.tmpIdx, key48, _this51.startIndex)
        _this52 = self.bprim
        def _hx_local_99():
            _hx_local_98 = _this52.idxPos
            _this52.idxPos = (_this52.idxPos + 1)
            return _hx_local_98
        key49 = _hx_local_99()
        python_internal_ArrayImpl._set(_this52.tmpIdx, key49, (1 + _this52.startIndex))
        _this53 = self.bprim
        def _hx_local_101():
            _hx_local_100 = _this53.idxPos
            _this53.idxPos = (_this53.idxPos + 1)
            return _hx_local_100
        key50 = _hx_local_101()
        python_internal_ArrayImpl._set(_this53.tmpIdx, key50, (2 + _this53.startIndex))
        _this54 = self.bprim
        def _hx_local_103():
            _hx_local_102 = _this54.idxPos
            _this54.idxPos = (_this54.idxPos + 1)
            return _hx_local_102
        key51 = _hx_local_103()
        python_internal_ArrayImpl._set(_this54.tmpIdx, key51, (2 + _this54.startIndex))
        _this55 = self.bprim
        def _hx_local_105():
            _hx_local_104 = _this55.idxPos
            _this55.idxPos = (_this55.idxPos + 1)
            return _hx_local_104
        key52 = _hx_local_105()
        python_internal_ArrayImpl._set(_this55.tmpIdx, key52, (3 + _this55.startIndex))
        _this56 = self.bprim
        def _hx_local_107():
            _hx_local_106 = _this56.idxPos
            _this56.idxPos = (_this56.idxPos + 1)
            return _hx_local_106
        key53 = _hx_local_107()
        python_internal_ArrayImpl._set(_this56.tmpIdx, key53, (1 + _this56.startIndex))
        self.curX = x
        self.curY = y
        self.curZ = z

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.bprim = None
        _hx_o.curX = None
        _hx_o.curY = None
        _hx_o.curZ = None
        _hx_o.curR = None
        _hx_o.curG = None
        _hx_o.curB = None
        _hx_o.curA = None
        _hx_o.lineSize = None
        _hx_o.lineShader = None
        _hx_o.tmpPoints = None
        _hx_o.is3D = None
h3d_scene_Graphics._hx_class = h3d_scene_Graphics
_hx_classes["h3d.scene.Graphics"] = h3d_scene_Graphics


class h3d_scene_Interactive(h3d_scene_Object):
    _hx_class_name = "h3d.scene.Interactive"
    _hx_is_interface = "False"
    _hx_fields = ["shape", "preciseShape", "priority", "cursor", "cancelEvents", "propagateEvents", "enableRightButton", "bestMatch", "scene", "mouseDownButton", "hitPoint"]
    _hx_methods = ["onAdd", "onRemove", "preventClick", "getInteractiveScene", "handleEvent", "set_cursor", "focus", "blur", "isOver", "hasFocus", "onOver", "onOut", "onPush", "onRelease", "onReleaseOutside", "onClick", "onMove", "onWheel", "onFocus", "onFocusLost", "onKeyUp", "onKeyDown", "onCheck", "onTextInput"]
    _hx_statics = []
    _hx_interfaces = [hxd_Interactive]
    _hx_super = h3d_scene_Object


    def __init__(self,shape,parent = None):
        self.scene = None
        self.bestMatch = None
        self.enableRightButton = None
        self.cursor = None
        self.priority = None
        self.preciseShape = None
        self.shape = None
        self.hitPoint = h3d_Vector()
        self.mouseDownButton = -1
        self.propagateEvents = False
        self.cancelEvents = False
        super().__init__(parent)
        self.shape = shape
        self.set_cursor(hxd_Cursor.Button)

    def onAdd(self):
        self.scene = self.getScene()
        if (self.scene is not None):
            self.scene.addEventTarget(self)
        super().onAdd()

    def onRemove(self):
        if (self.scene is not None):
            self.scene.removeEventTarget(self)
            self.scene = None
        super().onRemove()

    def preventClick(self):
        self.mouseDownButton = -1

    def getInteractiveScene(self):
        return self.scene

    def handleEvent(self,e):
        if self.propagateEvents:
            e.propagate = True
        if self.cancelEvents:
            e.cancel = True
        tmp = e.kind.index
        if (tmp == 0):
            if (self.enableRightButton or ((e.button == 0))):
                self.mouseDownButton = e.button
                self.onPush(e)
        elif (tmp == 1):
            if (self.enableRightButton or ((e.button == 0))):
                self.onRelease(e)
                if (self.mouseDownButton == e.button):
                    self.onClick(e)
            self.mouseDownButton = -1
        elif (tmp == 2):
            self.onMove(e)
        elif (tmp == 3):
            self.onOver(e)
        elif (tmp == 4):
            self.onOut(e)
        elif (tmp == 5):
            self.onWheel(e)
        elif (tmp == 6):
            self.onFocus(e)
        elif (tmp == 7):
            self.onFocusLost(e)
        elif (tmp == 8):
            self.onKeyDown(e)
        elif (tmp == 9):
            self.onKeyUp(e)
        elif (tmp == 10):
            if (self.enableRightButton or ((e.button == 0))):
                self.onRelease(e)
                if (self.mouseDownButton == e.button):
                    self.onReleaseOutside(e)
            self.mouseDownButton = -1
        elif (tmp == 11):
            self.onTextInput(e)
        elif (tmp == 12):
            self.onCheck(e)
        else:
            pass

    def set_cursor(self,c):
        self.cursor = c
        if ((self.scene is not None) and ((self.scene.events is not None))):
            self.scene.events.updateCursor(self)
        return c

    def focus(self):
        if ((self.scene is None) or ((self.scene.events is None))):
            return
        self.scene.events.focus(self)

    def blur(self):
        if self.hasFocus():
            self.scene.events.blur()

    def isOver(self):
        if ((self.scene is not None) and ((self.scene.events is not None))):
            return (python_internal_ArrayImpl.indexOf(self.scene.events.overList,self,None) != -1)
        else:
            return False

    def hasFocus(self):
        if ((self.scene is not None) and ((self.scene.events is not None))):
            return (self.scene.events.currentFocus == self)
        else:
            return False

    def onOver(self,e):
        pass

    def onOut(self,e):
        pass

    def onPush(self,e):
        pass

    def onRelease(self,e):
        pass

    def onReleaseOutside(self,e):
        pass

    def onClick(self,e):
        pass

    def onMove(self,e):
        pass

    def onWheel(self,e):
        pass

    def onFocus(self,e):
        pass

    def onFocusLost(self,e):
        pass

    def onKeyUp(self,e):
        pass

    def onKeyDown(self,e):
        pass

    def onCheck(self,e):
        pass

    def onTextInput(self,e):
        pass

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.shape = None
        _hx_o.preciseShape = None
        _hx_o.priority = None
        _hx_o.cursor = None
        _hx_o.cancelEvents = None
        _hx_o.propagateEvents = None
        _hx_o.enableRightButton = None
        _hx_o.bestMatch = None
        _hx_o.scene = None
        _hx_o.mouseDownButton = None
        _hx_o.hitPoint = None
h3d_scene_Interactive._hx_class = h3d_scene_Interactive
_hx_classes["h3d.scene.Interactive"] = h3d_scene_Interactive


class h3d_scene_Light(h3d_scene_Object):
    _hx_class_name = "h3d.scene.Light"
    _hx_is_interface = "False"
    __slots__ = ("shader", "objectDistance", "next", "cullingDistance", "priority")
    _hx_fields = ["shader", "objectDistance", "next", "cullingDistance", "priority"]
    _hx_methods = ["get_color", "set_color", "get_enableSpecular", "set_enableSpecular", "emit", "getShadowDirection"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_scene_Object


    def __init__(self,shader,parent = None):
        self.next = None
        self.objectDistance = None
        self.shader = None
        self.priority = 0
        self.cullingDistance = -1
        super().__init__(parent)
        self.shader = shader

    def get_color(self):
        return h3d_Vector()

    def set_color(self,v):
        return v

    def get_enableSpecular(self):
        return False

    def set_enableSpecular(self,b):
        if b:
            raise _HxException("Not implemented for this light")
        return False

    def emit(self,ctx):
        ctx.emitLight(self)

    def getShadowDirection(self):
        return None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.shader = None
        _hx_o.objectDistance = None
        _hx_o.next = None
        _hx_o.cullingDistance = None
        _hx_o.priority = None
h3d_scene_Light._hx_class = h3d_scene_Light
_hx_classes["h3d.scene.Light"] = h3d_scene_Light


class h3d_scene_LightSystem:
    _hx_class_name = "h3d.scene.LightSystem"
    _hx_is_interface = "False"
    __slots__ = ("drawPasses", "ambientLight", "shadowLight", "lightCount", "ctx")
    _hx_fields = ["drawPasses", "ambientLight", "shadowLight", "lightCount", "ctx"]
    _hx_methods = ["initGlobals", "cullLights", "initLights", "computeLight"]

    def __init__(self):
        self.ctx = None
        self.lightCount = None
        self.shadowLight = None
        self.drawPasses = 0
        self.ambientLight = h3d_Vector(1,1,1)

    def initGlobals(self,globals):
        pass

    def cullLights(self):
        l = self.ctx.lights
        prev = None
        s = h3d_col_Sphere()
        while (l is not None):
            s.x = l.absPos._41
            s.y = l.absPos._42
            s.z = l.absPos._43
            s.r = l.cullingDistance
            if (((l.cullingDistance > 0) and (not self.ctx.computingStatic)) and (not self.ctx.camera.frustum.hasSphere(s))):
                if (prev is None):
                    self.ctx.lights = l.next
                else:
                    prev.next = l.next
                l = l.next
                continue
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.lightCount
            _hx_local_0.lightCount = (_hx_local_1 + 1)
            _hx_local_1
            l.objectDistance = 0.
            prev = l
            l = l.next

    def initLights(self,ctx):
        self.lightCount = 0
        self.ctx = ctx
        self.cullLights()
        if ((self.shadowLight is None) or ((((self.shadowLight.flags & 32)) == 0))):
            l = ctx.lights
            while (l is not None):
                dir = l.getShadowDirection()
                if (dir is not None):
                    self.shadowLight = l
                    break
                l = l.next

    def computeLight(self,obj,shaders):
        return shaders

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.drawPasses = None
        _hx_o.ambientLight = None
        _hx_o.shadowLight = None
        _hx_o.lightCount = None
        _hx_o.ctx = None
h3d_scene_LightSystem._hx_class = h3d_scene_LightSystem
_hx_classes["h3d.scene.LightSystem"] = h3d_scene_LightSystem


class h3d_scene__MeshBatch_BatchData:
    _hx_class_name = "h3d.scene._MeshBatch.BatchData"
    _hx_is_interface = "False"
    __slots__ = ("count", "buffer", "data", "params", "shader", "shaders", "_hx_pass", "next")
    _hx_fields = ["count", "buffer", "data", "params", "shader", "shaders", "pass", "next"]

    def __init__(self):
        self.next = None
        self._hx_pass = None
        self.shaders = None
        self.shader = None
        self.params = None
        self.data = None
        self.buffer = None
        self.count = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.count = None
        _hx_o.buffer = None
        _hx_o.data = None
        _hx_o.params = None
        _hx_o.shader = None
        _hx_o.shaders = None
        _hx_o._hx_pass = None
        _hx_o.next = None
h3d_scene__MeshBatch_BatchData._hx_class = h3d_scene__MeshBatch_BatchData
_hx_classes["h3d.scene._MeshBatch.BatchData"] = h3d_scene__MeshBatch_BatchData


class h3d_scene_MeshBatch(h3d_scene_Mesh):
    _hx_class_name = "h3d.scene.MeshBatch"
    _hx_is_interface = "False"
    __slots__ = ("instanced", "curInstances", "maxInstances", "shaderInstances", "dataBuffer", "dataPasses", "indexCount", "modelViewID", "modelViewInverseID", "colorSave", "colorMult", "allowGlobalMaterialColor", "worldPosition", "invWorldPosition", "shadersChanged")
    _hx_fields = ["instanced", "curInstances", "maxInstances", "shaderInstances", "dataBuffer", "dataPasses", "indexCount", "modelViewID", "modelViewInverseID", "colorSave", "colorMult", "allowGlobalMaterialColor", "worldPosition", "invWorldPosition", "shadersChanged"]
    _hx_methods = ["onRemove", "cleanPasses", "initShadersMapping", "begin", "syncData", "emitInstance", "sync", "emit"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_scene_Mesh


    def __init__(self,primitive,material = None,parent = None):
        self.invWorldPosition = None
        self.worldPosition = None
        self.colorMult = None
        self.indexCount = None
        self.dataPasses = None
        self.dataBuffer = None
        self.shadersChanged = True
        self.allowGlobalMaterialColor = True
        self.colorSave = h3d_Vector()
        self.modelViewInverseID = hxsl_Globals.allocID("global.modelViewInverse")
        self.modelViewID = hxsl_Globals.allocID("global.modelView")
        self.shaderInstances = 0
        self.maxInstances = 0
        self.curInstances = 0
        self.instanced = h3d_prim_Instanced()
        self.instanced.commands = h3d_impl_InstanceBuffer()
        self.instanced.setMesh(primitive)
        super().__init__(self.instanced,material,parent)
        _g = 0
        _g1 = self.material.getPasses()
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            p.set_batchMode(True)
        self.indexCount = ((primitive.triCount() * 3) if ((primitive.indexes is None)) else primitive.indexes.count)

    def onRemove(self):
        super().onRemove()
        self.cleanPasses()

    def cleanPasses(self):
        alloc = hxd_impl_Allocator.get()
        while (self.dataPasses is not None):
            self.dataPasses._hx_pass.removeShader(self.dataPasses.shader)
            alloc.disposeBuffer(self.dataPasses.buffer)
            alloc.disposeFloats(self.dataPasses.data)
            self.dataPasses = self.dataPasses.next
        self.instanced.commands.dispose()
        self.shaderInstances = 0
        self.shadersChanged = True

    def initShadersMapping(self):
        scene = self.getScene()
        if (scene is None):
            return
        self.cleanPasses()
        self.shaderInstances = self.maxInstances
        _g = 0
        _g1 = self.material.getPasses()
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            ctx = scene.renderer.getPassByName(p.name)
            if (ctx is None):
                raise _HxException(("Could't find renderer pass " + HxOverrides.stringOrNull(p.name)))
            def _hx_local_2():
                _hx_local_1 = ctx
                if (Std._hx_is(_hx_local_1,h3d_pass_Default) or ((_hx_local_1 is None))):
                    _hx_local_1
                else:
                    raise _HxException("Class cast error")
                return _hx_local_1
            manager = (_hx_local_2()).manager
            shaders = p.getShadersRec()
            rt = manager.compileShaders(shaders,False)
            shader = manager.shaderCache.makeBatchShader(rt)
            b = h3d_scene__MeshBatch_BatchData()
            b.count = (rt.vertex.paramsSize + rt.fragment.paramsSize)
            b.params = (None if ((rt.fragment.params is None)) else rt.fragment.params.clone())
            hd = b.params
            while (hd is not None):
                hd.pos = (hd.pos + ((rt.vertex.paramsSize << 2)))
                hd = hd.next
            if (b.params is None):
                b.params = rt.vertex.params
            elif (rt.vertex is not None):
                vl = rt.vertex.params.clone()
                hd1 = vl
                while (vl.next is not None):
                    vl = vl.next
                vl.next = b.params
                b.params = hd1
            tot = (b.count * self.shaderInstances)
            b.shader = shader
            b._hx_pass = p
            b.shaders = [None]
            alloc = hxd_impl_Allocator.get()
            b.buffer = alloc.allocBuffer(tot,4,1)
            b.data = alloc.allocFloats((tot * 4))
            b.next = self.dataPasses
            self.dataPasses = b
            sl = shaders
            while (sl is not None):
                _this = b.shaders
                x = sl.s
                _this.append(x)
                sl = sl.next
            shader.constModified = True
            shader.Batch_Count__ = tot
            shader.Batch_Buffer__ = b.buffer
            shader.constBits = tot
            shader.updateConstants(None)
        p1 = self.dataPasses
        while (p1 is not None):
            p1._hx_pass.addShader(p1.shader)
            p1 = p1.next

    def begin(self,maxCount):
        if (maxCount > self.shaderInstances):
            self.shadersChanged = True
        _this = self.colorSave
        v = self.material.mshader.color__
        _this.x = v.x
        _this.y = v.y
        _this.z = v.z
        _this.w = v.w
        self.curInstances = 0
        self.maxInstances = maxCount
        if self.shadersChanged:
            if (self.colorMult is not None):
                self.material.passes.removeShader(self.colorMult)
                self.colorMult = None
            self.initShadersMapping()
            self.shadersChanged = False
            if self.allowGlobalMaterialColor:
                if (self.colorMult is None):
                    self.colorMult = h3d_shader_ColorMult()
                    self.material.passes.addShader(self.colorMult)
            elif (self.colorMult is not None):
                self.material.passes.removeShader(self.colorMult)
                self.colorMult = None

    def syncData(self,data):
        p = data.params
        buf = data.data
        shaders = data.shaders
        startPos = ((data.count * self.curInstances) * 4)
        calcInv = False
        while (p is not None):
            pos = (startPos + p.pos)
            if (p.perObjectGlobal is not None):
                if (p.perObjectGlobal.gid == self.modelViewID):
                    m = (self.worldPosition if ((self.worldPosition is not None)) else self.absPos)
                    key = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(buf, key, m._11)
                    key1 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(buf, key1, m._21)
                    key2 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(buf, key2, m._31)
                    key3 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(buf, key3, m._41)
                    key4 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(buf, key4, m._12)
                    key5 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(buf, key5, m._22)
                    key6 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(buf, key6, m._32)
                    key7 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(buf, key7, m._42)
                    key8 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(buf, key8, m._13)
                    key9 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(buf, key9, m._23)
                    key10 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(buf, key10, m._33)
                    key11 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(buf, key11, m._43)
                    key12 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(buf, key12, m._14)
                    key13 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(buf, key13, m._24)
                    key14 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(buf, key14, m._34)
                    key15 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(buf, key15, m._44)
                elif (p.perObjectGlobal.gid == self.modelViewInverseID):
                    if (self.worldPosition is None):
                        m1 = self.getInvPos()
                        key16 = pos
                        pos = (pos + 1)
                        python_internal_ArrayImpl._set(buf, key16, m1._11)
                        key17 = pos
                        pos = (pos + 1)
                        python_internal_ArrayImpl._set(buf, key17, m1._21)
                        key18 = pos
                        pos = (pos + 1)
                        python_internal_ArrayImpl._set(buf, key18, m1._31)
                        key19 = pos
                        pos = (pos + 1)
                        python_internal_ArrayImpl._set(buf, key19, m1._41)
                        key20 = pos
                        pos = (pos + 1)
                        python_internal_ArrayImpl._set(buf, key20, m1._12)
                        key21 = pos
                        pos = (pos + 1)
                        python_internal_ArrayImpl._set(buf, key21, m1._22)
                        key22 = pos
                        pos = (pos + 1)
                        python_internal_ArrayImpl._set(buf, key22, m1._32)
                        key23 = pos
                        pos = (pos + 1)
                        python_internal_ArrayImpl._set(buf, key23, m1._42)
                        key24 = pos
                        pos = (pos + 1)
                        python_internal_ArrayImpl._set(buf, key24, m1._13)
                        key25 = pos
                        pos = (pos + 1)
                        python_internal_ArrayImpl._set(buf, key25, m1._23)
                        key26 = pos
                        pos = (pos + 1)
                        python_internal_ArrayImpl._set(buf, key26, m1._33)
                        key27 = pos
                        pos = (pos + 1)
                        python_internal_ArrayImpl._set(buf, key27, m1._43)
                        key28 = pos
                        pos = (pos + 1)
                        python_internal_ArrayImpl._set(buf, key28, m1._14)
                        key29 = pos
                        pos = (pos + 1)
                        python_internal_ArrayImpl._set(buf, key29, m1._24)
                        key30 = pos
                        pos = (pos + 1)
                        python_internal_ArrayImpl._set(buf, key30, m1._34)
                        key31 = pos
                        pos = (pos + 1)
                        python_internal_ArrayImpl._set(buf, key31, m1._44)
                    else:
                        if (not calcInv):
                            calcInv = True
                            if (self.invWorldPosition is None):
                                self.invWorldPosition = h3d_Matrix()
                            self.invWorldPosition.initInverse(self.worldPosition)
                        m2 = self.invWorldPosition
                        key32 = pos
                        pos = (pos + 1)
                        python_internal_ArrayImpl._set(buf, key32, m2._11)
                        key33 = pos
                        pos = (pos + 1)
                        python_internal_ArrayImpl._set(buf, key33, m2._21)
                        key34 = pos
                        pos = (pos + 1)
                        python_internal_ArrayImpl._set(buf, key34, m2._31)
                        key35 = pos
                        pos = (pos + 1)
                        python_internal_ArrayImpl._set(buf, key35, m2._41)
                        key36 = pos
                        pos = (pos + 1)
                        python_internal_ArrayImpl._set(buf, key36, m2._12)
                        key37 = pos
                        pos = (pos + 1)
                        python_internal_ArrayImpl._set(buf, key37, m2._22)
                        key38 = pos
                        pos = (pos + 1)
                        python_internal_ArrayImpl._set(buf, key38, m2._32)
                        key39 = pos
                        pos = (pos + 1)
                        python_internal_ArrayImpl._set(buf, key39, m2._42)
                        key40 = pos
                        pos = (pos + 1)
                        python_internal_ArrayImpl._set(buf, key40, m2._13)
                        key41 = pos
                        pos = (pos + 1)
                        python_internal_ArrayImpl._set(buf, key41, m2._23)
                        key42 = pos
                        pos = (pos + 1)
                        python_internal_ArrayImpl._set(buf, key42, m2._33)
                        key43 = pos
                        pos = (pos + 1)
                        python_internal_ArrayImpl._set(buf, key43, m2._43)
                        key44 = pos
                        pos = (pos + 1)
                        python_internal_ArrayImpl._set(buf, key44, m2._14)
                        key45 = pos
                        pos = (pos + 1)
                        python_internal_ArrayImpl._set(buf, key45, m2._24)
                        key46 = pos
                        pos = (pos + 1)
                        python_internal_ArrayImpl._set(buf, key46, m2._34)
                        key47 = pos
                        pos = (pos + 1)
                        python_internal_ArrayImpl._set(buf, key47, m2._44)
                else:
                    raise _HxException(("Unsupported global param " + HxOverrides.stringOrNull(p.perObjectGlobal.path)))
                p = p.next
                continue
            curShader = python_internal_ArrayImpl._get(shaders, p.instance)
            _g = p.type
            tmp = _g.index
            if (tmp == 3):
                key48 = pos
                pos = (pos + 1)
                python_internal_ArrayImpl._set(buf, key48, curShader.getParamFloatValue(p.index))
            elif (tmp == 5):
                _g2 = _g.params[1]
                size = _g.params[0]
                v = curShader.getParamValue(p.index)
                size1 = size
                if (size1 == 2):
                    key49 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(buf, key49, v.x)
                    key50 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(buf, key50, v.y)
                elif (size1 == 3):
                    key51 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(buf, key51, v.x)
                    key52 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(buf, key52, v.y)
                    key53 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(buf, key53, v.z)
                else:
                    key54 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(buf, key54, v.x)
                    key55 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(buf, key55, v.y)
                    key56 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(buf, key56, v.z)
                    key57 = pos
                    pos = (pos + 1)
                    python_internal_ArrayImpl._set(buf, key57, v.w)
            elif (tmp == 7):
                m3 = curShader.getParamValue(p.index)
                key58 = pos
                pos = (pos + 1)
                python_internal_ArrayImpl._set(buf, key58, m3._11)
                key59 = pos
                pos = (pos + 1)
                python_internal_ArrayImpl._set(buf, key59, m3._21)
                key60 = pos
                pos = (pos + 1)
                python_internal_ArrayImpl._set(buf, key60, m3._31)
                key61 = pos
                pos = (pos + 1)
                python_internal_ArrayImpl._set(buf, key61, m3._41)
                key62 = pos
                pos = (pos + 1)
                python_internal_ArrayImpl._set(buf, key62, m3._12)
                key63 = pos
                pos = (pos + 1)
                python_internal_ArrayImpl._set(buf, key63, m3._22)
                key64 = pos
                pos = (pos + 1)
                python_internal_ArrayImpl._set(buf, key64, m3._32)
                key65 = pos
                pos = (pos + 1)
                python_internal_ArrayImpl._set(buf, key65, m3._42)
                key66 = pos
                pos = (pos + 1)
                python_internal_ArrayImpl._set(buf, key66, m3._13)
                key67 = pos
                pos = (pos + 1)
                python_internal_ArrayImpl._set(buf, key67, m3._23)
                key68 = pos
                pos = (pos + 1)
                python_internal_ArrayImpl._set(buf, key68, m3._33)
                key69 = pos
                pos = (pos + 1)
                python_internal_ArrayImpl._set(buf, key69, m3._43)
                key70 = pos
                pos = (pos + 1)
                python_internal_ArrayImpl._set(buf, key70, m3._14)
                key71 = pos
                pos = (pos + 1)
                python_internal_ArrayImpl._set(buf, key71, m3._24)
                key72 = pos
                pos = (pos + 1)
                python_internal_ArrayImpl._set(buf, key72, m3._34)
                key73 = pos
                pos = (pos + 1)
                python_internal_ArrayImpl._set(buf, key73, m3._44)
            else:
                raise _HxException(("Unsupported batch type " + Std.string(p.type)))
            p = p.next

    def emitInstance(self):
        if (self.curInstances == self.maxInstances):
            raise _HxException("Too many instances")
        self.syncPos()
        p = self.dataPasses
        while (p is not None):
            self.syncData(p)
            p = p.next
        if self.allowGlobalMaterialColor:
            _this = self.material.mshader.color__
            v = self.colorSave
            _this.x = v.x
            _this.y = v.y
            _this.z = v.z
            _this.w = v.w
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.curInstances
        _hx_local_0.curInstances = (_hx_local_1 + 1)
        _hx_local_1

    def sync(self,ctx):
        super().sync(ctx)
        if (self.curInstances == 0):
            return
        p = self.dataPasses
        while (p is not None):
            if p.buffer.isDisposed():
                p.buffer = hxd_impl_Allocator.get().allocBuffer((p.count * self.shaderInstances),4,1)
                p.shader.Batch_Buffer__ = p.buffer
            p.buffer.uploadVector(p.data,0,(self.curInstances * p.count))
            p = p.next
        self.instanced.commands.setCommand(self.curInstances,self.indexCount)
        if (self.colorMult is not None):
            _this = self.colorMult.color__
            v = self.material.mshader.color__
            _this.x = v.x
            _this.y = v.y
            _this.z = v.z
            _this.w = v.w

    def emit(self,ctx):
        if (self.curInstances == 0):
            return
        super().emit(ctx)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.instanced = None
        _hx_o.curInstances = None
        _hx_o.maxInstances = None
        _hx_o.shaderInstances = None
        _hx_o.dataBuffer = None
        _hx_o.dataPasses = None
        _hx_o.indexCount = None
        _hx_o.modelViewID = None
        _hx_o.modelViewInverseID = None
        _hx_o.colorSave = None
        _hx_o.colorMult = None
        _hx_o.allowGlobalMaterialColor = None
        _hx_o.worldPosition = None
        _hx_o.invWorldPosition = None
        _hx_o.shadersChanged = None
h3d_scene_MeshBatch._hx_class = h3d_scene_MeshBatch
_hx_classes["h3d.scene.MeshBatch"] = h3d_scene_MeshBatch


class h3d_scene_MultiMaterial(h3d_scene_Mesh):
    _hx_class_name = "h3d.scene.MultiMaterial"
    _hx_is_interface = "False"
    __slots__ = ("materials",)
    _hx_fields = ["materials"]
    _hx_methods = ["getMeshMaterials", "clone", "emit", "getMaterialByName", "getMaterials", "draw"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_scene_Mesh


    def __init__(self,prim,mats = None,parent = None):
        self.materials = None
        super().__init__(prim,(None if ((mats is None)) else (mats[0] if 0 < len(mats) else None)),parent)
        self.materials = ([self.material] if ((mats is None)) else mats)

    def getMeshMaterials(self):
        return list(self.materials)

    def clone(self,o = None):
        m = (h3d_scene_MultiMaterial(None,self.materials) if ((o is None)) else o)
        m.materials = []
        _g = 0
        _g1 = self.materials
        while (_g < len(_g1)):
            mat = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            _this = m.materials
            x = (None if ((mat is None)) else mat.clone())
            _this.append(x)
        super().clone(m)
        m.material = (m.materials[0] if 0 < len(m.materials) else None)
        return m

    def emit(self,ctx):
        _g = 0
        _g1 = len(self.materials)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            m = (self.materials[i] if i >= 0 and i < len(self.materials) else None)
            if (m is not None):
                index = i
                if (index is None):
                    index = 0
                p = m.passes
                while (p is not None):
                    ctx.emitPass(p,self).index = index
                    p = p.nextPass

    def getMaterialByName(self,name):
        _g = 0
        _g1 = self.materials
        while (_g < len(_g1)):
            m = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if ((m is not None) and ((m.name == name))):
                return m
        return super().getMaterialByName(name)

    def getMaterials(self,a = None):
        if (a is None):
            a = []
        _g = 0
        _g1 = self.materials
        while (_g < len(_g1)):
            m = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if ((m is not None) and ((python_internal_ArrayImpl.indexOf(a,m,None) < 0))):
                a.append(m)
        _g2 = 0
        _g3 = self.children
        while (_g2 < len(_g3)):
            o = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
            _g2 = (_g2 + 1)
            o.getMaterials(a)
        return a

    def draw(self,ctx):
        if (len(self.materials) > 1):
            self.primitive.selectMaterial(ctx.drawPass.index)
        super().draw(ctx)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.materials = None
h3d_scene_MultiMaterial._hx_class = h3d_scene_MultiMaterial
_hx_classes["h3d.scene.MultiMaterial"] = h3d_scene_MultiMaterial


class h3d_scene__Object_ObjectFlags_Impl_:
    _hx_class_name = "h3d.scene._Object.ObjectFlags_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["FPosChanged", "FVisible", "FCulled", "FFollowPositionOnly", "FLightCameraCenter", "FAllocated", "FAlwaysSync", "FInheritCulled", "FNoSerialize", "FIgnoreBounds", "FIgnoreCollide", "FIgnoreParentTransform", "FCullingColliderInherited", "_new", "toInt", "has", "set"]

    @staticmethod
    def _new(value):
        this1 = value
        return this1

    @staticmethod
    def toInt(this1):
        return this1

    @staticmethod
    def has(this1,f):
        return (((this1 & f)) != 0)

    @staticmethod
    def set(this1,f,b):
        if b:
            this1 = (this1 | f)
        else:
            this1 = (this1 & ~f)
        return b
h3d_scene__Object_ObjectFlags_Impl_._hx_class = h3d_scene__Object_ObjectFlags_Impl_
_hx_classes["h3d.scene._Object.ObjectFlags_Impl_"] = h3d_scene__Object_ObjectFlags_Impl_


class h3d_scene__RenderContext_SharedGlobal:
    _hx_class_name = "h3d.scene._RenderContext.SharedGlobal"
    _hx_is_interface = "False"
    __slots__ = ("gid", "value")
    _hx_fields = ["gid", "value"]

    def __init__(self,gid,value):
        self.gid = gid
        self.value = value

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.gid = None
        _hx_o.value = None
h3d_scene__RenderContext_SharedGlobal._hx_class = h3d_scene__RenderContext_SharedGlobal
_hx_classes["h3d.scene._RenderContext.SharedGlobal"] = h3d_scene__RenderContext_SharedGlobal


class h3d_scene_RenderContext(h3d_impl_RenderContext):
    _hx_class_name = "h3d.scene.RenderContext"
    _hx_is_interface = "False"
    __slots__ = ("camera", "scene", "drawPass", "pbrLightPass", "computingStatic", "sharedGlobals", "lightSystem", "extraShaders", "visibleFlag", "shaderBuffers", "cullingCollider", "allocPool", "allocFirst", "cachedShaderList", "cachedPassObjects", "cachedPos", "passes", "lights", "currentManager")
    _hx_fields = ["camera", "scene", "drawPass", "pbrLightPass", "computingStatic", "sharedGlobals", "lightSystem", "extraShaders", "visibleFlag", "shaderBuffers", "cullingCollider", "allocPool", "allocFirst", "cachedShaderList", "cachedPassObjects", "cachedPos", "passes", "lights", "currentManager"]
    _hx_methods = ["emit", "start", "nextPass", "getGlobal", "setGlobal", "setGlobalID", "emitPass", "allocShaderList", "emitLight", "uploadParams", "done"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_impl_RenderContext


    def __init__(self):
        self.currentManager = None
        self.lights = None
        self.passes = None
        self.cachedPos = None
        self.cachedPassObjects = None
        self.cachedShaderList = None
        self.allocFirst = None
        self.allocPool = None
        self.cullingCollider = None
        self.shaderBuffers = None
        self.visibleFlag = None
        self.extraShaders = None
        self.lightSystem = None
        self.sharedGlobals = None
        self.computingStatic = None
        self.pbrLightPass = None
        self.drawPass = None
        self.scene = None
        self.camera = None
        super().__init__()
        self.cachedShaderList = []
        self.cachedPassObjects = []

    def emit(self,mat,obj,index = None):
        if (index is None):
            index = 0
        p = mat.passes
        while (p is not None):
            self.emitPass(p,obj).index = index
            p = p.nextPass

    def start(self):
        self.sharedGlobals = []
        self.lights = None
        self.drawPass = None
        self.passes = None
        self.lights = None
        self.cachedPos = 0
        self.visibleFlag = True
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.time
        _hx_local_0.time = (_hx_local_1 + self.elapsedTime)
        _hx_local_0.time
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.frame
        _hx_local_2.frame = (_hx_local_3 + 1)
        _hx_local_3

    def nextPass(self):
        self.cachedPos = 0
        self.drawPass = None

    def getGlobal(self,name):
        id = hxsl_Globals.allocID(name)
        _g = 0
        _g1 = self.sharedGlobals
        while (_g < len(_g1)):
            g = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (g.gid == id):
                return g.value
        return None

    def setGlobal(self,name,value):
        self.setGlobalID(hxsl_Globals.allocID(name),value)

    def setGlobalID(self,gid,value):
        _g = 0
        _g1 = self.sharedGlobals
        while (_g < len(_g1)):
            g = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (g.gid == gid):
                g.value = value
                return
        _this = self.sharedGlobals
        x = h3d_scene__RenderContext_SharedGlobal(gid,value)
        _this.append(x)

    def emitPass(self,_hx_pass,obj):
        o = self.allocPool
        if (o is None):
            o = h3d_pass_PassObject()
            o.nextAlloc = self.allocFirst
            self.allocFirst = o
        else:
            self.allocPool = o.nextAlloc
        o._hx_pass = _hx_pass
        o.obj = obj
        o.next = self.passes
        self.passes = o
        return o

    def allocShaderList(self,s,next = None):
        def _hx_local_2():
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.cachedPos
            _hx_local_0.cachedPos = (_hx_local_1 + 1)
            return _hx_local_1
        sl = python_internal_ArrayImpl._get(self.cachedShaderList, _hx_local_2())
        if (sl is None):
            sl = hxsl_ShaderList(None)
            python_internal_ArrayImpl._set(self.cachedShaderList, (self.cachedPos - 1), sl)
        sl.s = s
        sl.next = next
        return sl

    def emitLight(self,l):
        l.next = self.lights
        self.lights = l

    def uploadParams(self):
        self.currentManager.fillParams(self.shaderBuffers,self.drawPass.shader,self.drawPass.shaders)
        self.engine.uploadShaderBuffers(self.shaderBuffers,1)
        self.engine.uploadShaderBuffers(self.shaderBuffers,2)

    def done(self):
        self.drawPass = None
        p = self.allocFirst
        while ((p is not None) and ((p != self.allocPool))):
            p.obj = None
            p._hx_pass = None
            p.shader = None
            p.shaders = None
            p.next = None
            p.index = 0
            p.texture = 0
            p = p.nextAlloc
        if (self.allocPool is not None):
            self.allocFirst = self.allocFirst.nextAlloc
        self.allocPool = self.allocFirst
        _g = 0
        _g1 = self.cachedShaderList
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            c.s = None
            c.next = None
        self.passes = None
        self.lights = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.camera = None
        _hx_o.scene = None
        _hx_o.drawPass = None
        _hx_o.pbrLightPass = None
        _hx_o.computingStatic = None
        _hx_o.sharedGlobals = None
        _hx_o.lightSystem = None
        _hx_o.extraShaders = None
        _hx_o.visibleFlag = None
        _hx_o.shaderBuffers = None
        _hx_o.cullingCollider = None
        _hx_o.allocPool = None
        _hx_o.allocFirst = None
        _hx_o.cachedShaderList = None
        _hx_o.cachedPassObjects = None
        _hx_o.cachedPos = None
        _hx_o.passes = None
        _hx_o.lights = None
        _hx_o.currentManager = None
h3d_scene_RenderContext._hx_class = h3d_scene_RenderContext
_hx_classes["h3d.scene.RenderContext"] = h3d_scene_RenderContext


class h3d_scene_PassObjects:
    _hx_class_name = "h3d.scene.PassObjects"
    _hx_is_interface = "False"
    __slots__ = ("name", "passes", "rendered")
    _hx_fields = ["name", "passes", "rendered"]

    def __init__(self):
        self.rendered = None
        self.name = None
        self.passes = h3d_pass_PassList()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.name = None
        _hx_o.passes = None
        _hx_o.rendered = None
h3d_scene_PassObjects._hx_class = h3d_scene_PassObjects
_hx_classes["h3d.scene.PassObjects"] = h3d_scene_PassObjects

class h3d_scene_RenderMode(Enum):
    __slots__ = ()
    _hx_class_name = "h3d.scene.RenderMode"
    _hx_constructs = ["Default", "LightProbe"]
h3d_scene_RenderMode.Default = h3d_scene_RenderMode("Default", 0, ())
h3d_scene_RenderMode.LightProbe = h3d_scene_RenderMode("LightProbe", 1, ())
h3d_scene_RenderMode._hx_class = h3d_scene_RenderMode
_hx_classes["h3d.scene.RenderMode"] = h3d_scene_RenderMode


class h3d_scene_Renderer(hxd_impl_AnyProps):
    _hx_class_name = "h3d.scene.Renderer"
    _hx_is_interface = "False"
    __slots__ = ("defaultPass", "passObjects", "allPasses", "emptyPasses", "ctx", "hasSetTarget", "frontToBack", "backToFront", "effects", "renderMode")
    _hx_fields = ["defaultPass", "passObjects", "allPasses", "emptyPasses", "ctx", "hasSetTarget", "frontToBack", "backToFront", "effects", "renderMode"]
    _hx_methods = ["dispose", "mark", "getPass", "getPassByName", "debugCompileShader", "hasFeature", "getDefaultLight", "getLightSystem", "time", "depthSort", "clear", "allocTarget", "copy", "setTarget", "setTargets", "resetTarget", "has", "get", "draw", "render", "computeStatic", "start", "process"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = hxd_impl_AnyProps


    def __init__(self):
        self.backToFront = None
        self.frontToBack = None
        self.ctx = None
        self.defaultPass = None
        self.renderMode = h3d_scene_RenderMode.Default
        self.effects = []
        self.hasSetTarget = False
        self.emptyPasses = h3d_pass_PassList()
        self.allPasses = []
        self.passObjects = haxe_ds_StringMap()
        self.set_props(self.getDefaultProps())
        f = self.depthSort
        def _hx_local_0(passes):
            f(True,passes)
        self.frontToBack = _hx_local_0
        f1 = self.depthSort
        def _hx_local_1(passes1):
            f1(False,passes1)
        self.backToFront = _hx_local_1

    def dispose(self):
        _g = 0
        _g1 = self.allPasses
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            p.dispose()
        _g2 = 0
        _g3 = self.effects
        while (_g2 < len(_g3)):
            f = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
            _g2 = (_g2 + 1)
            f.dispose()
        self.passObjects = haxe_ds_StringMap()

    def mark(self,id):
        pass

    def getPass(self,c):
        _g = 0
        _g1 = self.allPasses
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if Std._hx_is(p,c):
                return p
        return None

    def getPassByName(self,name):
        _g = 0
        _g1 = self.allPasses
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (p.name == name):
                return p
        return None

    def debugCompileShader(self,_hx_pass):
        p = self.getPassByName(_hx_pass.name)
        if (p is None):
            p = self.defaultPass
        p.setContext(self.ctx)
        return p.compileShader(_hx_pass)

    def hasFeature(self,f):
        return h3d_Engine.CURRENT.driver.hasFeature(f)

    def getDefaultLight(self,l):
        return l

    def getLightSystem(self):
        return self.ctx.scene.lightSystem

    def time(self,name):
        pass

    def depthSort(self,frontToBack,passes):
        cam = self.ctx.camera.m
        _g_o = passes.current
        while (_g_o is not None):
            tmp = _g_o
            _g_o = _g_o.next
            p = tmp
            z = ((((p.obj.absPos._41 * cam._13) + ((p.obj.absPos._42 * cam._23))) + ((p.obj.absPos._43 * cam._33))) + cam._43)
            w = ((((p.obj.absPos._41 * cam._14) + ((p.obj.absPos._42 * cam._24))) + ((p.obj.absPos._43 * cam._34))) + cam._44)
            p.depth = (z / w)
        if frontToBack:
            _hx_list = passes.current
            tmp1 = None
            if (_hx_list is None):
                tmp1 = None
            else:
                insize = 1
                nmerges = None
                psize = 0
                qsize = 0
                p1 = None
                q = None
                e = None
                tail = None
                while True:
                    p1 = _hx_list
                    _hx_list = None
                    tail = None
                    nmerges = 0
                    while (p1 is not None):
                        nmerges = (nmerges + 1)
                        q = p1
                        psize = 0
                        _g = 0
                        _g1 = insize
                        while (_g < _g1):
                            i = _g
                            _g = (_g + 1)
                            psize = (psize + 1)
                            q = q.next
                            if (q is None):
                                break
                        qsize = insize
                        while ((psize > 0) or (((qsize > 0) and ((q is not None))))):
                            if (psize == 0):
                                e = q
                                q = q.next
                                qsize = (qsize - 1)
                            elif (((qsize == 0) or ((q is None))) or (((((1 if ((p1.depth > q.depth)) else -1) if ((p1._hx_pass.layer == q._hx_pass.layer)) else (p1._hx_pass.layer - q._hx_pass.layer))) <= 0))):
                                e = p1
                                p1 = p1.next
                                psize = (psize - 1)
                            else:
                                e = q
                                q = q.next
                                qsize = (qsize - 1)
                            if (tail is not None):
                                tail.next = e
                            else:
                                _hx_list = e
                            tail = e
                        p1 = q
                    tail.next = None
                    if (nmerges <= 1):
                        break
                    insize = (insize * 2)
                tmp1 = _hx_list
            passes.current = tmp1
        else:
            list1 = passes.current
            tmp2 = None
            if (list1 is None):
                tmp2 = None
            else:
                insize1 = 1
                nmerges1 = None
                psize1 = 0
                qsize1 = 0
                p2 = None
                q1 = None
                e1 = None
                tail1 = None
                while True:
                    p2 = list1
                    list1 = None
                    tail1 = None
                    nmerges1 = 0
                    while (p2 is not None):
                        nmerges1 = (nmerges1 + 1)
                        q1 = p2
                        psize1 = 0
                        _g2 = 0
                        _g11 = insize1
                        while (_g2 < _g11):
                            i1 = _g2
                            _g2 = (_g2 + 1)
                            psize1 = (psize1 + 1)
                            q1 = q1.next
                            if (q1 is None):
                                break
                        qsize1 = insize1
                        while ((psize1 > 0) or (((qsize1 > 0) and ((q1 is not None))))):
                            if (psize1 == 0):
                                e1 = q1
                                q1 = q1.next
                                qsize1 = (qsize1 - 1)
                            elif (((qsize1 == 0) or ((q1 is None))) or (((((-1 if ((p2.depth > q1.depth)) else 1) if ((p2._hx_pass.layer == q1._hx_pass.layer)) else (p2._hx_pass.layer - q1._hx_pass.layer))) <= 0))):
                                e1 = p2
                                p2 = p2.next
                                psize1 = (psize1 - 1)
                            else:
                                e1 = q1
                                q1 = q1.next
                                qsize1 = (qsize1 - 1)
                            if (tail1 is not None):
                                tail1.next = e1
                            else:
                                list1 = e1
                            tail1 = e1
                        p2 = q1
                    tail1.next = None
                    if (nmerges1 <= 1):
                        break
                    insize1 = (insize1 * 2)
                tmp2 = list1
            passes.current = tmp2

    def clear(self,color = None,depth = None,stencil = None):
        self.ctx.engine.clear(color,depth,stencil)

    def allocTarget(self,name,depth = None,size = None,format = None):
        if (depth is None):
            depth = True
        if (size is None):
            size = 1.
        return self.ctx.textures.allocTarget(name,Math.floor(((self.ctx.engine.width * size) + 0.5)),Math.floor(((self.ctx.engine.height * size) + 0.5)),depth,format)

    def copy(self,_hx_from,to,blend = None):
        h3d_pass_Copy.run(_hx_from,to,blend)

    def setTarget(self,tex):
        if self.hasSetTarget:
            self.ctx.engine.popTarget()
        self.ctx.engine.pushTarget(tex)
        self.hasSetTarget = True

    def setTargets(self,textures):
        if self.hasSetTarget:
            self.ctx.engine.popTarget()
        self.ctx.engine.pushTargets(textures)
        self.hasSetTarget = True

    def resetTarget(self):
        if self.hasSetTarget:
            self.ctx.engine.popTarget()
            self.hasSetTarget = False

    def has(self,name):
        return (self.passObjects.h.get(name,None) is not None)

    def get(self,name):
        p = self.passObjects.h.get(name,None)
        if (p is None):
            return self.emptyPasses
        p.rendered = True
        return p.passes

    def draw(self,name):
        self.defaultPass.draw(self.get(name))

    def render(self):
        raise _HxException("Not implemented")

    def computeStatic(self):
        raise _HxException("Not implemented")

    def start(self):
        pass

    def process(self,passes):
        self.hasSetTarget = False
        _g = 0
        _g1 = self.allPasses
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            p.setContext(self.ctx)
        _g2 = 0
        while (_g2 < len(passes)):
            p1 = (passes[_g2] if _g2 >= 0 and _g2 < len(passes) else None)
            _g2 = (_g2 + 1)
            self.passObjects.h[p1.name] = p1
        self.ctx.textures.begin()
        if self.ctx.computingStatic:
            self.computeStatic()
        else:
            self.render()
        self.resetTarget()
        _g3 = 0
        while (_g3 < len(passes)):
            p2 = (passes[_g3] if _g3 >= 0 and _g3 < len(passes) else None)
            _g3 = (_g3 + 1)
            self.passObjects.h[p2.name] = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.defaultPass = None
        _hx_o.passObjects = None
        _hx_o.allPasses = None
        _hx_o.emptyPasses = None
        _hx_o.ctx = None
        _hx_o.hasSetTarget = None
        _hx_o.frontToBack = None
        _hx_o.backToFront = None
        _hx_o.effects = None
        _hx_o.renderMode = None
h3d_scene_Renderer._hx_class = h3d_scene_Renderer
_hx_classes["h3d.scene.Renderer"] = h3d_scene_Renderer


class h3d_scene_Scene(h3d_scene_Object):
    _hx_class_name = "h3d.scene.Scene"
    _hx_is_interface = "False"
    __slots__ = ("camera", "lightSystem", "renderer", "ctx", "interactives", "events", "hitInteractives", "eventListeners", "window", "hardwarePass")
    _hx_fields = ["camera", "lightSystem", "renderer", "ctx", "interactives", "events", "hitInteractives", "eventListeners", "window", "hardwarePass"]
    _hx_methods = ["setEvents", "addEventListener", "removeEventListener", "dispatchListeners", "set_renderer", "sortHitPointByCameraDistance", "dispatchEvent", "isInteractiveVisible", "handleEvent", "clone", "dispose", "addEventTarget", "removeEventTarget", "setElapsedTime", "hardwarePick", "syncOnly", "computeStatic", "render", "serializeScene"]
    _hx_statics = []
    _hx_interfaces = [hxd_InteractiveScene, h3d_IDrawable]
    _hx_super = h3d_scene_Object


    def __init__(self,createRenderer = None,createLightSystem = None):
        if (createRenderer is None):
            createRenderer = True
        if (createLightSystem is None):
            createLightSystem = True
        self.hardwarePass = None
        self.window = None
        self.eventListeners = None
        self.hitInteractives = None
        self.events = None
        self.interactives = None
        self.ctx = None
        self.renderer = None
        self.lightSystem = None
        self.camera = None
        super().__init__(None)
        self.window = hxd_Window.getInstance()
        self.eventListeners = []
        self.hitInteractives = []
        self.interactives = []
        self.camera = h3d_Camera()
        engine = h3d_Engine.CURRENT
        if (engine is not None):
            self.camera.screenRatio = (engine.width / engine.height)
        self.ctx = h3d_scene_RenderContext()
        if createRenderer:
            self.set_renderer(h3d_mat_MaterialSetup.current.createRenderer())
        if createLightSystem:
            self.lightSystem = h3d_mat_MaterialSetup.current.createLightSystem()

    def setEvents(self,events):
        self.events = events

    def addEventListener(self,f):
        _this = self.eventListeners
        _this.append(f)

    def removeEventListener(self,f):
        _g = 0
        _g1 = self.eventListeners
        while (_g < len(_g1)):
            e = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if Reflect.compareMethods(e,f):
                python_internal_ArrayImpl.remove(self.eventListeners,e)
                return True
        return False

    def dispatchListeners(self,event):
        _g = 0
        _g1 = self.eventListeners
        while (_g < len(_g1)):
            l = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            l(event)
            if (not event.propagate):
                break

    def set_renderer(self,r):
        self.renderer = r
        if (r is not None):
            r.ctx = self.ctx
        return r

    def sortHitPointByCameraDistance(self,i1,i2):
        z1 = i1.hitPoint.w
        z2 = i2.hitPoint.w
        if (z1 > z2):
            return -1
        return 1

    def dispatchEvent(self,event,to):
        i = to
        i.handleEvent(event)

    def isInteractiveVisible(self,i):
        o = i
        while (o != self):
            if ((o is None) or ((((o.flags & 2)) == 0))):
                return False
            o = o.parent
        return True

    def handleEvent(self,event,last):
        if (len(self.interactives) == 0):
            return None
        if (len(self.hitInteractives) == 0):
            screenX = ((((event.relX / self.window.get_width()) - 0.5)) * 2)
            screenY = (-(((event.relY / self.window.get_height()) - 0.5)) * 2)
            p0 = self.camera.unproject(screenX,screenY,0)
            p1 = self.camera.unproject(screenX,screenY,1)
            x = p0.x
            y = p0.y
            z = p0.z
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            p1_x = x
            p1_y = y
            p1_z = z
            x1 = p1.x
            y1 = p1.y
            z1 = p1.z
            if (z1 is None):
                z1 = 0.
            if (y1 is None):
                y1 = 0.
            if (x1 is None):
                x1 = 0.
            p2_x = x1
            p2_y = y1
            p2_z = z1
            r = h3d_col_Ray()
            r.px = p1_x
            r.py = p1_y
            r.pz = p1_z
            r.lx = (p2_x - p1_x)
            r.ly = (p2_y - p1_y)
            r.lz = (p2_z - p1_z)
            r.normalize()
            r1 = r
            saveR_px = r1.px
            saveR_py = r1.py
            saveR_pz = r1.pz
            saveR_lx = r1.lx
            saveR_ly = r1.ly
            saveR_lz = r1.lz
            priority = -2147483648
            _g = 0
            _g1 = self.interactives
            while (_g < len(_g1)):
                i = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (i.priority < priority):
                    continue
                p = i
                while ((p is not None) and ((((p.flags & 2)) != 0))):
                    p = p.parent
                if (p is not None):
                    continue
                minv = i.getInvPos()
                x2 = r1.px
                y2 = r1.py
                z2 = r1.pz
                if (z2 is None):
                    z2 = 0.
                if (y2 is None):
                    y2 = 0.
                if (x2 is None):
                    x2 = 0.
                p_x = x2
                p_y = y2
                p_z = z2
                p_w = 1.
                px = ((((p_x * minv._11) + ((p_y * minv._21))) + ((p_z * minv._31))) + ((p_w * minv._41)))
                py = ((((p_x * minv._12) + ((p_y * minv._22))) + ((p_z * minv._32))) + ((p_w * minv._42)))
                pz = ((((p_x * minv._13) + ((p_y * minv._23))) + ((p_z * minv._33))) + ((p_w * minv._43)))
                p_x = px
                p_y = py
                p_z = pz
                r1.px = p_x
                r1.py = p_y
                r1.pz = p_z
                x3 = r1.lx
                y3 = r1.ly
                z3 = r1.lz
                if (z3 is None):
                    z3 = 0.
                if (y3 is None):
                    y3 = 0.
                if (x3 is None):
                    x3 = 0.
                l_x = x3
                l_y = y3
                l_z = z3
                l_w = 1.
                px1 = (((l_x * minv._11) + ((l_y * minv._21))) + ((l_z * minv._31)))
                py1 = (((l_x * minv._12) + ((l_y * minv._22))) + ((l_z * minv._32)))
                pz1 = (((l_x * minv._13) + ((l_y * minv._23))) + ((l_z * minv._33)))
                l_x = px1
                l_y = py1
                l_z = pz1
                r1.lx = l_x
                r1.ly = l_y
                r1.lz = l_z
                r1.normalize()
                if (r1.lx != r1.lx):
                    r1.px = saveR_px
                    r1.py = saveR_py
                    r1.pz = saveR_pz
                    r1.lx = saveR_lx
                    r1.ly = saveR_ly
                    r1.lz = saveR_lz
                    continue
                hit = i.shape.rayIntersection(r1,i.bestMatch)
                if (hit < 0):
                    r1.px = saveR_px
                    r1.py = saveR_py
                    r1.pz = saveR_pz
                    r1.lx = saveR_lx
                    r1.ly = saveR_ly
                    r1.lz = saveR_lz
                    continue
                x4 = (r1.px + ((hit * r1.lx)))
                y4 = (r1.py + ((hit * r1.ly)))
                z4 = (r1.pz + ((hit * r1.lz)))
                if (z4 is None):
                    z4 = 0.
                if (y4 is None):
                    y4 = 0.
                if (x4 is None):
                    x4 = 0.
                hitPoint_x = x4
                hitPoint_y = y4
                hitPoint_z = z4
                r1.px = saveR_px
                r1.py = saveR_py
                r1.pz = saveR_pz
                r1.lx = saveR_lx
                r1.ly = saveR_ly
                r1.lz = saveR_lz
                i.hitPoint.x = hitPoint_x
                i.hitPoint.y = hitPoint_y
                i.hitPoint.z = hitPoint_z
                if (i.priority > priority):
                    while (len(self.hitInteractives) > 0):
                        _this = self.hitInteractives
                        if (len(_this) != 0):
                            _this.pop()
                    priority = i.priority
                _this1 = self.hitInteractives
                _this1.append(i)
            if (len(self.hitInteractives) == 0):
                return None
            if (len(self.hitInteractives) > 1):
                _g2 = 0
                _g3 = self.hitInteractives
                while (_g2 < len(_g3)):
                    i1 = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                    _g2 = (_g2 + 1)
                    m = i1.invPos
                    wfactor = 0.
                    if (i1.preciseShape is not None):
                        x5 = r1.px
                        y5 = r1.py
                        z5 = r1.pz
                        if (z5 is None):
                            z5 = 0.
                        if (y5 is None):
                            y5 = 0.
                        if (x5 is None):
                            x5 = 0.
                        p_x1 = x5
                        p_y1 = y5
                        p_z1 = z5
                        p_w1 = 1.
                        px2 = ((((p_x1 * m._11) + ((p_y1 * m._21))) + ((p_z1 * m._31))) + ((p_w1 * m._41)))
                        py2 = ((((p_x1 * m._12) + ((p_y1 * m._22))) + ((p_z1 * m._32))) + ((p_w1 * m._42)))
                        pz2 = ((((p_x1 * m._13) + ((p_y1 * m._23))) + ((p_z1 * m._33))) + ((p_w1 * m._43)))
                        p_x1 = px2
                        p_y1 = py2
                        p_z1 = pz2
                        r1.px = p_x1
                        r1.py = p_y1
                        r1.pz = p_z1
                        x6 = r1.lx
                        y6 = r1.ly
                        z6 = r1.lz
                        if (z6 is None):
                            z6 = 0.
                        if (y6 is None):
                            y6 = 0.
                        if (x6 is None):
                            x6 = 0.
                        l_x1 = x6
                        l_y1 = y6
                        l_z1 = z6
                        l_w1 = 1.
                        px3 = (((l_x1 * m._11) + ((l_y1 * m._21))) + ((l_z1 * m._31)))
                        py3 = (((l_x1 * m._12) + ((l_y1 * m._22))) + ((l_z1 * m._32)))
                        pz3 = (((l_x1 * m._13) + ((l_y1 * m._23))) + ((l_z1 * m._33)))
                        l_x1 = px3
                        l_y1 = py3
                        l_z1 = pz3
                        r1.lx = l_x1
                        r1.ly = l_y1
                        r1.lz = l_z1
                        r1.normalize()
                        hit1 = i1.preciseShape.rayIntersection(r1,i1.bestMatch)
                        if (hit1 > 0):
                            x7 = (r1.px + ((hit1 * r1.lx)))
                            y7 = (r1.py + ((hit1 * r1.ly)))
                            z7 = (r1.pz + ((hit1 * r1.lz)))
                            if (z7 is None):
                                z7 = 0.
                            if (y7 is None):
                                y7 = 0.
                            if (x7 is None):
                                x7 = 0.
                            hitPoint_x1 = x7
                            hitPoint_y1 = y7
                            hitPoint_z1 = z7
                            i1.hitPoint.x = hitPoint_x1
                            i1.hitPoint.y = hitPoint_y1
                            i1.hitPoint.z = hitPoint_z1
                        else:
                            wfactor = 1.
                        r1.px = saveR_px
                        r1.py = saveR_py
                        r1.pz = saveR_pz
                        r1.lx = saveR_lx
                        r1.ly = saveR_ly
                        r1.lz = saveR_lz
                    _this2 = i1.hitPoint
                    x8 = _this2.x
                    y8 = _this2.y
                    z8 = _this2.z
                    w = _this2.w
                    if (w is None):
                        w = 1.
                    if (z8 is None):
                        z8 = 0.
                    if (y8 is None):
                        y8 = 0.
                    if (x8 is None):
                        x8 = 0.
                    p_x2 = x8
                    p_y2 = y8
                    p_z2 = z8
                    p_w2 = w
                    p_w2 = 1
                    m1 = i1.absPos
                    px4 = ((((p_x2 * m1._11) + ((p_y2 * m1._21))) + ((p_z2 * m1._31))) + ((p_w2 * m1._41)))
                    py4 = ((((p_x2 * m1._12) + ((p_y2 * m1._22))) + ((p_z2 * m1._32))) + ((p_w2 * m1._42)))
                    pz4 = ((((p_x2 * m1._13) + ((p_y2 * m1._23))) + ((p_z2 * m1._33))) + ((p_w2 * m1._43)))
                    p_x2 = px4
                    p_y2 = py4
                    p_z2 = pz4
                    m2 = self.camera.m
                    px5 = ((((p_x2 * m2._11) + ((p_y2 * m2._21))) + ((p_z2 * m2._31))) + ((p_w2 * m2._41)))
                    py5 = ((((p_x2 * m2._12) + ((p_y2 * m2._22))) + ((p_z2 * m2._32))) + ((p_w2 * m2._42)))
                    pz5 = ((((p_x2 * m2._13) + ((p_y2 * m2._23))) + ((p_z2 * m2._33))) + ((p_w2 * m2._43)))
                    iw = (1 / (((((p_x2 * m2._14) + ((p_y2 * m2._24))) + ((p_z2 * m2._34))) + ((p_w2 * m2._44)))))
                    p_x2 = (px5 * iw)
                    p_y2 = (py5 * iw)
                    p_z2 = (pz5 * iw)
                    p_w2 = 1
                    i1.hitPoint.w = (p_z2 + wfactor)
                self.hitInteractives.sort(key= python_lib_Functools.cmp_to_key(self.sortHitPointByCameraDistance))
            self.hitInteractives.insert(0, None)
        while (len(self.hitInteractives) > 0):
            _this3 = self.hitInteractives
            i2 = (None if ((len(_this3) == 0)) else _this3.pop())
            if (i2 is None):
                return None
            event.relX = i2.hitPoint.x
            event.relY = i2.hitPoint.y
            event.relZ = i2.hitPoint.z
            i2.handleEvent(event)
            if event.cancel:
                event.cancel = False
                event.propagate = False
                continue
            if (not event.propagate):
                while (len(self.hitInteractives) > 0):
                    _this4 = self.hitInteractives
                    if (len(_this4) != 0):
                        _this4.pop()
            return i2
        return None

    def clone(self,o = None):
        s = (h3d_scene_Scene() if ((o is None)) else o)
        s.camera = self.camera.clone()
        super().clone(s)
        return s

    def dispose(self):
        if (((self.flags & 32)) != 0):
            self.onRemove()
        if (self.hardwarePass is not None):
            self.hardwarePass.dispose()
            self.hardwarePass = None
        self.ctx.dispose()
        if (self.renderer is not None):
            self.renderer.dispose()
            self.set_renderer(h3d_scene_Renderer())

    def addEventTarget(self,i):
        if (python_internal_ArrayImpl.indexOf(self.interactives,i,None) >= 0):
            raise _HxException("assert")
        _this = self.interactives
        _this.append(i)

    def removeEventTarget(self,i):
        if python_internal_ArrayImpl.remove(self.interactives,i):
            if (self.events is not None):
                self.events.onRemove(i)
            python_internal_ArrayImpl.remove(self.hitInteractives,i)

    def setElapsedTime(self,elapsedTime):
        self.ctx.elapsedTime = elapsedTime

    def hardwarePick(self,pixelX,pixelY):
        _gthis = self
        engine = h3d_Engine.CURRENT
        self.camera.screenRatio = (engine.width / engine.height)
        self.camera.update()
        self.ctx.camera = self.camera
        self.ctx.engine = engine
        self.ctx.scene = self
        self.ctx.start()
        ray = self.camera.rayFromScreen(pixelX,pixelY)
        savedRay_pz = None
        savedRay_py = None
        savedRay_px = None
        savedRay_lz = None
        savedRay_ly = None
        savedRay_lx = None
        savedRay_px = ray.px
        savedRay_py = ray.py
        savedRay_pz = ray.pz
        savedRay_lx = ray.lx
        savedRay_ly = ray.ly
        savedRay_lz = ray.lz
        def _hx_local_0(m):
            if (m.primitive is None):
                return
            m1 = m.getInvPos()
            x = ray.px
            y = ray.py
            z = ray.pz
            if (z is None):
                z = 0.
            if (y is None):
                y = 0.
            if (x is None):
                x = 0.
            p_x = x
            p_y = y
            p_z = z
            p_w = 1.
            px = ((((p_x * m1._11) + ((p_y * m1._21))) + ((p_z * m1._31))) + ((p_w * m1._41)))
            py = ((((p_x * m1._12) + ((p_y * m1._22))) + ((p_z * m1._32))) + ((p_w * m1._42)))
            pz = ((((p_x * m1._13) + ((p_y * m1._23))) + ((p_z * m1._33))) + ((p_w * m1._43)))
            p_x = px
            p_y = py
            p_z = pz
            ray.px = p_x
            ray.py = p_y
            ray.pz = p_z
            x1 = ray.lx
            y1 = ray.ly
            z1 = ray.lz
            if (z1 is None):
                z1 = 0.
            if (y1 is None):
                y1 = 0.
            if (x1 is None):
                x1 = 0.
            l_x = x1
            l_y = y1
            l_z = z1
            l_w = 1.
            px1 = (((l_x * m1._11) + ((l_y * m1._21))) + ((l_z * m1._31)))
            py1 = (((l_x * m1._12) + ((l_y * m1._22))) + ((l_z * m1._32)))
            pz1 = (((l_x * m1._13) + ((l_y * m1._23))) + ((l_z * m1._33)))
            l_x = px1
            l_y = py1
            l_z = pz1
            ray.lx = l_x
            ray.ly = l_y
            ray.lz = l_z
            ray.normalize()
            if (m.primitive.getBounds().rayIntersection(ray,False) >= 0):
                _gthis.ctx.emitPass(m.material.passes,m)
            ray.px = savedRay_px
            ray.py = savedRay_py
            ray.pz = savedRay_pz
            ray.lx = savedRay_lx
            ray.ly = savedRay_ly
            ray.lz = savedRay_lz
        self.iterVisibleMeshes(_hx_local_0)
        self.ctx.lightSystem = None
        found = None
        passes = h3d_pass_PassList(self.ctx.passes)
        if (passes.current is not None):
            p = self.hardwarePass
            if (p is None):
                p = h3d_pass_HardwarePick()
                self.hardwarePass = p
            _this = self.ctx
            value = _hx_AnonObject({'texture': h3d_mat_Texture.fromColor(267386880,0)})
            _this.setGlobalID(hxsl_Globals.allocID("depthMap"),value)
            p.pickX = pixelX
            p.pickY = pixelY
            p.setContext(self.ctx)
            p.draw(passes)
            if (p.pickedIndex >= 0):
                _g_o = passes.current
                while (_g_o is not None):
                    tmp = _g_o
                    _g_o = _g_o.next
                    po = tmp
                    def _hx_local_2():
                        _hx_local_1 = p.pickedIndex
                        p.pickedIndex = (p.pickedIndex - 1)
                        return _hx_local_1
                    tmp1 = (_hx_local_2() == 0)
                    if tmp1:
                        found = po.obj
                        break
        self.ctx.done()
        self.ctx.camera = None
        self.ctx.engine = None
        self.ctx.scene = None
        return found

    def syncOnly(self,et):
        engine = h3d_Engine.CURRENT
        self.setElapsedTime(et)
        t = engine.getCurrentTarget()
        if (t is None):
            self.camera.screenRatio = (engine.width / engine.height)
        else:
            self.camera.screenRatio = (t.width / t.height)
        self.camera.update()
        self.ctx.camera = self.camera
        self.ctx.engine = engine
        self.ctx.scene = self
        self.ctx.start()
        self.syncRec(self.ctx)
        self.ctx.camera = None
        self.ctx.engine = None
        self.ctx.scene = None

    def computeStatic(self):
        old = self.ctx.elapsedTime
        self.ctx.elapsedTime = 0
        self.ctx.computingStatic = True
        self.render(h3d_Engine.CURRENT)
        self.ctx.computingStatic = False
        self.ctx.elapsedTime = old

    def render(self,engine):
        if (((self.flags & 32)) == 0):
            self.onAdd()
        t = engine.getCurrentTarget()
        if (t is None):
            self.camera.screenRatio = (engine.width / engine.height)
        else:
            self.camera.screenRatio = (t.width / t.height)
        self.camera.update()
        if self.camera.rightHanded:
            engine.driver.setRenderFlag(h3d_impl_RenderFlag.CameraHandness,1)
        self.ctx.camera = self.camera
        self.ctx.engine = engine
        self.ctx.scene = self
        self.ctx.start()
        self.renderer.start()
        self.syncRec(self.ctx)
        self.emitRec(self.ctx)
        _hx_list = self.ctx.passes
        tmp = None
        if (_hx_list is None):
            tmp = None
        else:
            insize = 1
            nmerges = None
            psize = 0
            qsize = 0
            p = None
            q = None
            e = None
            tail = None
            while True:
                p = _hx_list
                _hx_list = None
                tail = None
                nmerges = 0
                while (p is not None):
                    nmerges = (nmerges + 1)
                    q = p
                    psize = 0
                    _g = 0
                    _g1 = insize
                    while (_g < _g1):
                        i = _g
                        _g = (_g + 1)
                        psize = (psize + 1)
                        q = q.next
                        if (q is None):
                            break
                    qsize = insize
                    while ((psize > 0) or (((qsize > 0) and ((q is not None))))):
                        if (psize == 0):
                            e = q
                            q = q.next
                            qsize = (qsize - 1)
                        elif (((qsize == 0) or ((q is None))) or (((p._hx_pass.passId - q._hx_pass.passId) <= 0))):
                            e = p
                            p = p.next
                            psize = (psize - 1)
                        else:
                            e = q
                            q = q.next
                            qsize = (qsize - 1)
                        if (tail is not None):
                            tail.next = e
                        else:
                            _hx_list = e
                        tail = e
                    p = q
                tail.next = None
                if (nmerges <= 1):
                    break
                insize = (insize * 2)
            tmp = _hx_list
        self.ctx.passes = tmp
        curPass = self.ctx.passes
        passes = []
        passIndex = -1
        while (curPass is not None):
            passId = curPass._hx_pass.passId
            p1 = curPass
            prev = None
            while ((p1 is not None) and ((p1._hx_pass.passId == passId))):
                prev = p1
                p1 = p1.next
            prev.next = None
            passIndex = (passIndex + 1)
            pobjs = passIndex
            pobjs1 = python_internal_ArrayImpl._get(self.ctx.cachedPassObjects, pobjs)
            if (pobjs1 is None):
                pobjs1 = h3d_scene_PassObjects()
                python_internal_ArrayImpl._set(self.ctx.cachedPassObjects, passIndex, pobjs1)
            pobjs1.name = curPass._hx_pass.name
            _this = pobjs1.passes
            _this.current = curPass
            def _hx_local_6():
                _this.lastDisc = None
                return _this.lastDisc
            _this.discarded = _hx_local_6()
            passes.append(pobjs1)
            curPass = p1
        if (self.lightSystem is not None):
            self.ctx.lightSystem = self.lightSystem
            self.lightSystem.initLights(self.ctx)
        self.renderer.process(passes)
        if self.camera.rightHanded:
            engine.driver.setRenderFlag(h3d_impl_RenderFlag.CameraHandness,0)
        self.ctx.done()
        self.ctx.scene = None
        self.ctx.camera = None
        self.ctx.engine = None
        _g2 = 0
        _g11 = passIndex
        while (_g2 < _g11):
            i1 = _g2
            _g2 = (_g2 + 1)
            p2 = python_internal_ArrayImpl._get(self.ctx.cachedPassObjects, i1)
            p2.name = None
            _this1 = p2.passes
            _this1.current = None
            def _hx_local_7():
                _this1.lastDisc = None
                return _this1.lastDisc
            _this1.discarded = _hx_local_7()

    def serializeScene(self):
        raise _HxException("You need -lib hxbit to serialize the scene data")

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.camera = None
        _hx_o.lightSystem = None
        _hx_o.renderer = None
        _hx_o.ctx = None
        _hx_o.interactives = None
        _hx_o.events = None
        _hx_o.hitInteractives = None
        _hx_o.eventListeners = None
        _hx_o.window = None
        _hx_o.hardwarePass = None
h3d_scene_Scene._hx_class = h3d_scene_Scene
_hx_classes["h3d.scene.Scene"] = h3d_scene_Scene


class h3d_scene_Joint(h3d_scene_Object):
    _hx_class_name = "h3d.scene.Joint"
    _hx_is_interface = "False"
    __slots__ = ("skin", "index")
    _hx_fields = ["skin", "index"]
    _hx_methods = ["getObjectByName", "syncPos"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_scene_Object


    def __init__(self,skin,j):
        self.index = None
        self.skin = None
        super().__init__(None)
        self.name = j.name
        self.skin = skin
        self.parent = skin
        self.index = j.index

    def getObjectByName(self,name):
        sk = self.skin.getSkinData()
        j = sk.namedJoints.h.get(name,None)
        if (j is None):
            return None
        cur = python_internal_ArrayImpl._get(sk.allJoints, self.index)
        if (cur.index != self.index):
            raise _HxException("assert")
        jp = j.parent
        while (jp is not None):
            if (jp == cur):
                jo = h3d_scene_Joint(self.skin,j)
                jo.parent = self
                return jo
            jp = jp.parent
        return None

    def syncPos(self):
        p = self.parent
        while (p is not None):
            if (((p.flags & 1)) != 0):
                if (self.skin.jointsAbsPosInv is None):
                    self.skin.jointsAbsPosInv = h3d_Matrix()
                    self.skin.jointsAbsPosInv.zero()
                if (self.skin.jointsAbsPosInv._44 == 0):
                    self.skin.jointsAbsPosInv.inverse3x4(self.parent.absPos)
                self.parent.syncPos()
                self.lastFrame = -1
                break
            p = p.parent
        if (self.lastFrame != self.skin.lastFrame):
            self.lastFrame = self.skin.lastFrame
            self.absPos.load(python_internal_ArrayImpl._get(self.skin.currentAbsPose, self.index))
            if ((self.skin.jointsAbsPosInv is not None) and ((self.skin.jointsAbsPosInv._44 != 0))):
                self.absPos.multiply3x4(self.absPos,self.skin.jointsAbsPosInv)
                self.absPos.multiply3x4(self.absPos,self.parent.absPos)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.skin = None
        _hx_o.index = None
h3d_scene_Joint._hx_class = h3d_scene_Joint
_hx_classes["h3d.scene.Joint"] = h3d_scene_Joint


class h3d_scene_Skin(h3d_scene_MultiMaterial):
    _hx_class_name = "h3d.scene.Skin"
    _hx_is_interface = "False"
    __slots__ = ("skinData", "currentRelPose", "currentAbsPose", "currentPalette", "splitPalette", "jointsUpdated", "jointsAbsPosInv", "paletteChanged", "skinShader", "jointsGraphics", "showJoints")
    _hx_fields = ["skinData", "currentRelPose", "currentAbsPose", "currentPalette", "splitPalette", "jointsUpdated", "jointsAbsPosInv", "paletteChanged", "skinShader", "jointsGraphics", "showJoints"]
    _hx_methods = ["clone", "getBoundsRec", "getObjectByName", "getLocalCollider", "getGlobalCollider", "calcAbsPos", "getSkinData", "setSkinData", "sync", "syncJoints", "emit", "draw"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_scene_MultiMaterial


    def __init__(self,s,mat = None,parent = None):
        self.showJoints = None
        self.jointsGraphics = None
        self.skinShader = None
        self.paletteChanged = None
        self.jointsAbsPosInv = None
        self.jointsUpdated = None
        self.splitPalette = None
        self.currentPalette = None
        self.currentAbsPose = None
        self.currentRelPose = None
        self.skinData = None
        super().__init__(None,mat,parent)
        if (s is not None):
            self.setSkinData(s)

    def clone(self,o = None):
        s = (h3d_scene_Skin(None,list(self.materials)) if ((o is None)) else o)
        super().clone(s)
        s.setSkinData(self.skinData)
        s.currentRelPose = list(self.currentRelPose)
        return s

    def getBoundsRec(self,b):
        b = super().getBoundsRec(b)
        _this = self.primitive.getBounds()
        b1 = h3d_col_Bounds()
        b1.xMin = _this.xMin
        b1.xMax = _this.xMax
        b1.yMin = _this.yMin
        b1.yMax = _this.yMax
        b1.zMin = _this.zMin
        b1.zMax = _this.zMax
        tmp = b1
        b0 = python_internal_ArrayImpl._get(self.skinData.allJoints, 0)
        if ((b0 is not None) and ((b0.parent is None))):
            mtmp = self.absPos.clone()
            r = python_internal_ArrayImpl._get(self.currentRelPose, b0.index)
            if (r is not None):
                mtmp.multiply3x4(r,mtmp)
            else:
                mtmp.multiply3x4(b0.defMat,mtmp)
            if (b0.transPos is not None):
                mtmp.multiply3x4(b0.transPos,mtmp)
            tmp.transform(mtmp)
        else:
            tmp.transform(self.absPos)
        if (tmp.xMin < b.xMin):
            b.xMin = tmp.xMin
        if (tmp.xMax > b.xMax):
            b.xMax = tmp.xMax
        if (tmp.yMin < b.yMin):
            b.yMin = tmp.yMin
        if (tmp.yMax > b.yMax):
            b.yMax = tmp.yMax
        if (tmp.zMin < b.zMin):
            b.zMin = tmp.zMin
        if (tmp.zMax > b.zMax):
            b.zMax = tmp.zMax
        return b

    def getObjectByName(self,name):
        if ((self.skinData is not None) and ((self.skinData.name == name))):
            return self
        o = super().getObjectByName(name)
        if (o is not None):
            return o
        if (self.skinData is not None):
            j = self.skinData.namedJoints.h.get(name,None)
            if (j is not None):
                return h3d_scene_Joint(self,j)
        return None

    def getLocalCollider(self):
        raise _HxException("Not implemented")

    def getGlobalCollider(self):
        def _hx_local_1():
            _hx_local_0 = self.primitive.getCollider()
            if (Std._hx_is(_hx_local_0,h3d_col_OptimizedCollider) or ((_hx_local_0 is None))):
                _hx_local_0
            else:
                raise _HxException("Class cast error")
            return _hx_local_0
        col = _hx_local_1()
        def _hx_local_3():
            _hx_local_2 = self.primitive
            if (Std._hx_is(_hx_local_2,h3d_prim_HMDModel) or ((_hx_local_2 is None))):
                _hx_local_2
            else:
                raise _HxException("Class cast error")
            return _hx_local_2
        (_hx_local_3()).loadSkin(self.skinData)
        def _hx_local_6():
            def _hx_local_5():
                _hx_local_4 = col.b
                if (Std._hx_is(_hx_local_4,h3d_col_PolygonBuffer) or ((_hx_local_4 is None))):
                    _hx_local_4
                else:
                    raise _HxException("Class cast error")
                return _hx_local_4
            return h3d_col_SkinCollider(self,_hx_local_5())
        return _hx_local_6()

    def calcAbsPos(self):
        super().calcAbsPos()
        self.jointsUpdated = True

    def getSkinData(self):
        return self.skinData

    def setSkinData(self,s,shaderInit = None):
        if (shaderInit is None):
            shaderInit = True
        self.skinData = s
        self.jointsUpdated = True
        self.set_primitive(s.primitive)
        if shaderInit:
            hasNormalMap = False
            _g = 0
            _g1 = self.materials
            while (_g < len(_g1)):
                m = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if ((m is not None) and ((m.get_normalMap() is not None))):
                    hasNormalMap = True
                    break
            self.skinShader = (h3d_shader_SkinTangent() if hasNormalMap else h3d_shader_Skin())
            maxBones = 0
            if (self.skinData.splitJoints is not None):
                _g2 = 0
                _g3 = self.skinData.splitJoints
                while (_g2 < len(_g3)):
                    s1 = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                    _g2 = (_g2 + 1)
                    if (len(s1.joints) > maxBones):
                        maxBones = len(s1.joints)
            else:
                maxBones = len(self.skinData.boundJoints)
            if (self.skinShader.MaxBones__ < maxBones):
                _this = self.skinShader
                _this.constModified = True
                _this.MaxBones__ = maxBones
            _g21 = 0
            _g31 = self.materials
            while (_g21 < len(_g31)):
                m1 = (_g31[_g21] if _g21 >= 0 and _g21 < len(_g31) else None)
                _g21 = (_g21 + 1)
                if (m1 is not None):
                    if (m1.get_normalMap() is not None):
                        m1.passes.addShaderAtIndex(self.skinShader,(m1.passes.getShaderIndex(m1.normalShader) + 1))
                    else:
                        m1.passes.addShader(self.skinShader)
                    if (self.skinData.splitJoints is not None):
                        m1.passes.set_dynamicParameters(True)
        self.currentRelPose = []
        self.currentAbsPose = []
        self.currentPalette = []
        self.paletteChanged = True
        _g4 = 0
        _g11 = self.skinData.allJoints
        while (_g4 < len(_g11)):
            j = (_g11[_g4] if _g4 >= 0 and _g4 < len(_g11) else None)
            _g4 = (_g4 + 1)
            _this1 = self.currentAbsPose
            x = h3d_Matrix.I()
            _this1.append(x)
        _g22 = 0
        _g32 = len(self.skinData.boundJoints)
        while (_g22 < _g32):
            i = _g22
            _g22 = (_g22 + 1)
            _this2 = self.currentPalette
            x1 = h3d_Matrix.I()
            _this2.append(x1)
        if (self.skinData.splitJoints is not None):
            self.splitPalette = []
            _g41 = 0
            _g5 = self.skinData.splitJoints
            while (_g41 < len(_g5)):
                a = (_g5[_g41] if _g41 >= 0 and _g41 < len(_g5) else None)
                _g41 = (_g41 + 1)
                _this3 = self.splitPalette
                _g42 = []
                _g51 = 0
                _g6 = a.joints
                while (_g51 < len(_g6)):
                    j1 = (_g6[_g51] if _g51 >= 0 and _g51 < len(_g6) else None)
                    _g51 = (_g51 + 1)
                    x2 = python_internal_ArrayImpl._get(self.currentPalette, j1.bindIndex)
                    _g42.append(x2)
                _this3.append(_g42)
        else:
            self.splitPalette = None

    def sync(self,ctx):
        if ((not ctx.visibleFlag) and ((((self.flags & 64)) == 0))):
            return
        self.syncJoints()

    def syncJoints(self):
        if (not self.jointsUpdated):
            return
        _g = 0
        _g1 = self.skinData.allJoints
        while (_g < len(_g1)):
            j = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            id = j.index
            m = (self.currentAbsPose[id] if id >= 0 and id < len(self.currentAbsPose) else None)
            r = (self.currentRelPose[id] if id >= 0 and id < len(self.currentRelPose) else None)
            bid = j.bindIndex
            if (r is None):
                r = j.defMat
            elif j.retargetAnim:
                r._41 = j.defMat._41
                r._42 = j.defMat._42
                r._43 = j.defMat._43
            if (j.parent is None):
                b = self.absPos
                m11 = r._11
                m12 = r._12
                m13 = r._13
                m21 = r._21
                m22 = r._22
                m23 = r._23
                a31 = r._31
                a32 = r._32
                a33 = r._33
                a41 = r._41
                a42 = r._42
                a43 = r._43
                b11 = b._11
                b12 = b._12
                b13 = b._13
                b21 = b._21
                b22 = b._22
                b23 = b._23
                b31 = b._31
                b32 = b._32
                b33 = b._33
                b41 = b._41
                b42 = b._42
                b43 = b._43
                m._11 = (((m11 * b11) + ((m12 * b21))) + ((m13 * b31)))
                m._12 = (((m11 * b12) + ((m12 * b22))) + ((m13 * b32)))
                m._13 = (((m11 * b13) + ((m12 * b23))) + ((m13 * b33)))
                m._14 = 0
                m._21 = (((m21 * b11) + ((m22 * b21))) + ((m23 * b31)))
                m._22 = (((m21 * b12) + ((m22 * b22))) + ((m23 * b32)))
                m._23 = (((m21 * b13) + ((m22 * b23))) + ((m23 * b33)))
                m._24 = 0
                m._31 = (((a31 * b11) + ((a32 * b21))) + ((a33 * b31)))
                m._32 = (((a31 * b12) + ((a32 * b22))) + ((a33 * b32)))
                m._33 = (((a31 * b13) + ((a32 * b23))) + ((a33 * b33)))
                m._34 = 0
                m._41 = ((((a41 * b11) + ((a42 * b21))) + ((a43 * b31))) + b41)
                m._42 = ((((a41 * b12) + ((a42 * b22))) + ((a43 * b32))) + b42)
                m._43 = ((((a41 * b13) + ((a42 * b23))) + ((a43 * b33))) + b43)
                m._44 = 1
            else:
                b1 = python_internal_ArrayImpl._get(self.currentAbsPose, j.parent.index)
                m111 = r._11
                m121 = r._12
                m131 = r._13
                m211 = r._21
                m221 = r._22
                m231 = r._23
                a311 = r._31
                a321 = r._32
                a331 = r._33
                a411 = r._41
                a421 = r._42
                a431 = r._43
                b111 = b1._11
                b121 = b1._12
                b131 = b1._13
                b211 = b1._21
                b221 = b1._22
                b231 = b1._23
                b311 = b1._31
                b321 = b1._32
                b331 = b1._33
                b411 = b1._41
                b421 = b1._42
                b431 = b1._43
                m._11 = (((m111 * b111) + ((m121 * b211))) + ((m131 * b311)))
                m._12 = (((m111 * b121) + ((m121 * b221))) + ((m131 * b321)))
                m._13 = (((m111 * b131) + ((m121 * b231))) + ((m131 * b331)))
                m._14 = 0
                m._21 = (((m211 * b111) + ((m221 * b211))) + ((m231 * b311)))
                m._22 = (((m211 * b121) + ((m221 * b221))) + ((m231 * b321)))
                m._23 = (((m211 * b131) + ((m221 * b231))) + ((m231 * b331)))
                m._24 = 0
                m._31 = (((a311 * b111) + ((a321 * b211))) + ((a331 * b311)))
                m._32 = (((a311 * b121) + ((a321 * b221))) + ((a331 * b321)))
                m._33 = (((a311 * b131) + ((a321 * b231))) + ((a331 * b331)))
                m._34 = 0
                m._41 = ((((a411 * b111) + ((a421 * b211))) + ((a431 * b311))) + b411)
                m._42 = ((((a411 * b121) + ((a421 * b221))) + ((a431 * b321))) + b421)
                m._43 = ((((a411 * b131) + ((a421 * b231))) + ((a431 * b331))) + b431)
                m._44 = 1
            if (bid >= 0):
                _this = (self.currentPalette[bid] if bid >= 0 and bid < len(self.currentPalette) else None)
                a = j.transPos
                m112 = a._11
                m122 = a._12
                m132 = a._13
                m212 = a._21
                m222 = a._22
                m232 = a._23
                a312 = a._31
                a322 = a._32
                a332 = a._33
                a412 = a._41
                a422 = a._42
                a432 = a._43
                b112 = m._11
                b122 = m._12
                b132 = m._13
                b212 = m._21
                b222 = m._22
                b232 = m._23
                b312 = m._31
                b322 = m._32
                b332 = m._33
                b412 = m._41
                b422 = m._42
                b432 = m._43
                _this._11 = (((m112 * b112) + ((m122 * b212))) + ((m132 * b312)))
                _this._12 = (((m112 * b122) + ((m122 * b222))) + ((m132 * b322)))
                _this._13 = (((m112 * b132) + ((m122 * b232))) + ((m132 * b332)))
                _this._14 = 0
                _this._21 = (((m212 * b112) + ((m222 * b212))) + ((m232 * b312)))
                _this._22 = (((m212 * b122) + ((m222 * b222))) + ((m232 * b322)))
                _this._23 = (((m212 * b132) + ((m222 * b232))) + ((m232 * b332)))
                _this._24 = 0
                _this._31 = (((a312 * b112) + ((a322 * b212))) + ((a332 * b312)))
                _this._32 = (((a312 * b122) + ((a322 * b222))) + ((a332 * b322)))
                _this._33 = (((a312 * b132) + ((a322 * b232))) + ((a332 * b332)))
                _this._34 = 0
                _this._41 = ((((a412 * b112) + ((a422 * b212))) + ((a432 * b312))) + b412)
                _this._42 = ((((a412 * b122) + ((a422 * b222))) + ((a432 * b322))) + b422)
                _this._43 = ((((a412 * b132) + ((a422 * b232))) + ((a432 * b332))) + b432)
                _this._44 = 1
        self.skinShader.bonesMatrixes__ = self.currentPalette
        if (self.jointsAbsPosInv is not None):
            self.jointsAbsPosInv._44 = 0
        self.jointsUpdated = False

    def emit(self,ctx):
        if (self.splitPalette is None):
            super().emit(ctx)
        else:
            _g = 0
            _g1 = len(self.splitPalette)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                m = python_internal_ArrayImpl._get(self.materials, python_internal_ArrayImpl._get(self.skinData.splitJoints, i).material)
                if (m is not None):
                    index = i
                    if (index is None):
                        index = 0
                    p = m.passes
                    while (p is not None):
                        ctx.emitPass(p,self).index = index
                        p = p.nextPass
        if self.showJoints:
            if (self.jointsGraphics is None):
                self.jointsGraphics = h3d_scene_Graphics(self)
                self.jointsGraphics.material.passes.depth(False,h3d_mat_Compare.Always)
                self.jointsGraphics.material.passes.setPassName("add")
            topParent = self
            while (topParent.parent is not None):
                topParent = topParent.parent
            self.jointsGraphics.set_follow(topParent)
            g = self.jointsGraphics
            g.clear()
            _g2 = 0
            _g11 = self.skinData.allJoints
            while (_g2 < len(_g11)):
                j = (_g11[_g2] if _g2 >= 0 and _g2 < len(_g11) else None)
                _g2 = (_g2 + 1)
                m1 = python_internal_ArrayImpl._get(self.currentAbsPose, j.index)
                mp = (self.absPos if ((j.parent is None)) else python_internal_ArrayImpl._get(self.currentAbsPose, j.parent.index))
                g.lineStyle(1,(-16776961 if ((j.parent is None)) else -256))
                g.moveTo(mp._41,mp._42,mp._43)
                g.lineTo(m1._41,m1._42,m1._43)
        elif (self.jointsGraphics is not None):
            _this = self.jointsGraphics
            if ((_this is not None) and ((_this.parent is not None))):
                _this.parent.removeChild(_this)
            self.jointsGraphics = None

    def draw(self,ctx):
        if (self.splitPalette is None):
            super().draw(ctx)
        else:
            i = ctx.drawPass.index
            self.skinShader.bonesMatrixes__ = (self.splitPalette[i] if i >= 0 and i < len(self.splitPalette) else None)
            self.primitive.selectMaterial(i)
            ctx.uploadParams()
            self.primitive.render(ctx.engine)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.skinData = None
        _hx_o.currentRelPose = None
        _hx_o.currentAbsPose = None
        _hx_o.currentPalette = None
        _hx_o.splitPalette = None
        _hx_o.jointsUpdated = None
        _hx_o.jointsAbsPosInv = None
        _hx_o.paletteChanged = None
        _hx_o.skinShader = None
        _hx_o.jointsGraphics = None
        _hx_o.showJoints = None
h3d_scene_Skin._hx_class = h3d_scene_Skin
_hx_classes["h3d.scene.Skin"] = h3d_scene_Skin


class h3d_scene_fwd_DirLight(h3d_scene_Light):
    _hx_class_name = "h3d.scene.fwd.DirLight"
    _hx_is_interface = "False"
    __slots__ = ("dshader",)
    _hx_fields = ["dshader"]
    _hx_methods = ["get_color", "set_color", "get_enableSpecular", "set_enableSpecular", "getShadowDirection", "emit"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_scene_Light


    def __init__(self,dir = None,parent = None):
        self.dshader = h3d_shader_DirLight()
        super().__init__(self.dshader,parent)
        self.priority = 100
        if (dir is not None):
            self.setDirection(dir)

    def get_color(self):
        return self.dshader.color__

    def set_color(self,v):
        def _hx_local_1():
            def _hx_local_0():
                self.dshader.color__ = v
                return self.dshader.color__
            return _hx_local_0()
        return _hx_local_1()

    def get_enableSpecular(self):
        return self.dshader.enableSpecular__

    def set_enableSpecular(self,b):
        _this = self.dshader
        _this.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                _this.enableSpecular__ = b
                return _this.enableSpecular__
            return _hx_local_0()
        return _hx_local_1()

    def getShadowDirection(self):
        _this = self.absPos
        v = h3d_Vector(_this._11,_this._12,_this._13)
        f = (((v.x * v.x) + ((v.y * v.y))) + ((v.z * v.z)))
        k = (1. / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
        v.x = (v.x * k)
        v.y = (v.y * k)
        v.z = (v.z * k)
        return v

    def emit(self,ctx):
        _this = self.dshader.direction__
        _this1 = self.absPos
        x = _this1._11
        y = _this1._12
        z = _this1._13
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        v_x = x
        v_y = y
        v_z = z
        v_w = 1.
        f = (((v_x * v_x) + ((v_y * v_y))) + ((v_z * v_z)))
        k = (1. / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))
        v_x = (v_x * k)
        v_y = (v_y * k)
        v_z = (v_z * k)
        _this.x = v_x
        _this.y = v_y
        _this.z = v_z
        _this.w = v_w
        self.dshader.direction__.normalize()
        super().emit(ctx)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.dshader = None
h3d_scene_fwd_DirLight._hx_class = h3d_scene_fwd_DirLight
_hx_classes["h3d.scene.fwd.DirLight"] = h3d_scene_fwd_DirLight


class h3d_scene_fwd_LightSystem(h3d_scene_LightSystem):
    _hx_class_name = "h3d.scene.fwd.LightSystem"
    _hx_is_interface = "False"
    __slots__ = ("maxLightsPerObject", "globals", "ambientShader", "perPixelLighting")
    _hx_fields = ["maxLightsPerObject", "globals", "ambientShader", "perPixelLighting"]
    _hx_methods = ["get_additiveLighting", "set_additiveLighting", "initLights", "initGlobals", "sortLight", "computeLight"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_scene_LightSystem


    def __init__(self):
        self.ambientShader = None
        self.globals = None
        self.perPixelLighting = True
        self.maxLightsPerObject = 6
        super().__init__()
        _this = self.ambientLight
        x = 0.5
        y = 0.5
        z = 0.5
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.
        self.ambientShader = h3d_shader_AmbientLight()
        self.set_additiveLighting(True)

    def get_additiveLighting(self):
        return Std.downcast(self.ambientShader,h3d_shader_AmbientLight).additive__

    def set_additiveLighting(self,b):
        _this = Std.downcast(self.ambientShader,h3d_shader_AmbientLight)
        _this.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                _this.additive__ = b
                return _this.additive__
            return _hx_local_0()
        return _hx_local_1()

    def initLights(self,ctx):
        super().initLights(ctx)
        if (self.lightCount <= self.maxLightsPerObject):
            _hx_list = ctx.lights
            cmp = self.sortLight
            tmp = None
            if (_hx_list is None):
                tmp = None
            else:
                insize = 1
                nmerges = None
                psize = 0
                qsize = 0
                p = None
                q = None
                e = None
                tail = None
                while True:
                    p = _hx_list
                    _hx_list = None
                    tail = None
                    nmerges = 0
                    while (p is not None):
                        nmerges = (nmerges + 1)
                        q = p
                        psize = 0
                        _g = 0
                        _g1 = insize
                        while (_g < _g1):
                            i = _g
                            _g = (_g + 1)
                            psize = (psize + 1)
                            q = q.next
                            if (q is None):
                                break
                        qsize = insize
                        while ((psize > 0) or (((qsize > 0) and ((q is not None))))):
                            if (psize == 0):
                                e = q
                                q = q.next
                                qsize = (qsize - 1)
                            elif (((qsize == 0) or ((q is None))) or ((cmp(p,q) <= 0))):
                                e = p
                                p = p.next
                                psize = (psize - 1)
                            else:
                                e = q
                                q = q.next
                                qsize = (qsize - 1)
                            if (tail is not None):
                                tail.next = e
                            else:
                                _hx_list = e
                            tail = e
                        p = q
                    tail.next = None
                    if (nmerges <= 1):
                        break
                    insize = (insize * 2)
                tmp = _hx_list
            ctx.lights = tmp

    def initGlobals(self,globals):
        globals.set("global.ambientLight",self.ambientLight)
        globals.set("global.perPixelLighting",self.perPixelLighting)

    def sortLight(self,l1,l2):
        p = (l1.priority - l2.priority)
        if (p != 0):
            return -p
        if (l1.objectDistance < l2.objectDistance):
            return -1
        else:
            return 1

    def computeLight(self,obj,shaders):
        _gthis = self
        if (self.lightCount > self.maxLightsPerObject):
            l = self.ctx.lights
            while (l is not None):
                if (((obj.flags & 16)) != 0):
                    dx = (l.absPos._41 - self.ctx.camera.target.x)
                    dy = (l.absPos._42 - self.ctx.camera.target.y)
                    dz = (l.absPos._43 - self.ctx.camera.target.z)
                    if (dz is None):
                        dz = 0.
                    l.objectDistance = (((dx * dx) + ((dy * dy))) + ((dz * dz)))
                else:
                    dx1 = (l.absPos._41 - obj.absPos._41)
                    dy1 = (l.absPos._42 - obj.absPos._42)
                    dz1 = (l.absPos._43 - obj.absPos._43)
                    if (dz1 is None):
                        dz1 = 0.
                    l.objectDistance = (((dx1 * dx1) + ((dy1 * dy1))) + ((dz1 * dz1)))
                l = l.next
            _hx_list = self.ctx.lights
            cmp = self.sortLight
            tmp = None
            if (_hx_list is None):
                tmp = None
            else:
                insize = 1
                nmerges = None
                psize = 0
                qsize = 0
                p = None
                q = None
                e = None
                tail = None
                while True:
                    p = _hx_list
                    _hx_list = None
                    tail = None
                    nmerges = 0
                    while (p is not None):
                        nmerges = (nmerges + 1)
                        q = p
                        psize = 0
                        _g = 0
                        _g1 = insize
                        while (_g < _g1):
                            i = _g
                            _g = (_g + 1)
                            psize = (psize + 1)
                            q = q.next
                            if (q is None):
                                break
                        qsize = insize
                        while ((psize > 0) or (((qsize > 0) and ((q is not None))))):
                            if (psize == 0):
                                e = q
                                q = q.next
                                qsize = (qsize - 1)
                            elif (((qsize == 0) or ((q is None))) or ((cmp(p,q) <= 0))):
                                e = p
                                p = p.next
                                psize = (psize - 1)
                            else:
                                e = q
                                q = q.next
                                qsize = (qsize - 1)
                            if (tail is not None):
                                tail.next = e
                            else:
                                _hx_list = e
                            tail = e
                        p = q
                    tail.next = None
                    if (nmerges <= 1):
                        break
                    insize = (insize * 2)
                tmp = _hx_list
            self.ctx.lights = tmp
        shaders = _gthis.ctx.allocShaderList(self.ambientShader,shaders)
        l1 = self.ctx.lights
        i1 = 0
        while (l1 is not None):
            tmp1 = i1
            i1 = (i1 + 1)
            if (tmp1 == self.maxLightsPerObject):
                break
            shaders = _gthis.ctx.allocShaderList(l1.shader,shaders)
            l1 = l1.next
        return shaders

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.maxLightsPerObject = None
        _hx_o.globals = None
        _hx_o.ambientShader = None
        _hx_o.perPixelLighting = None
h3d_scene_fwd_LightSystem._hx_class = h3d_scene_fwd_LightSystem
_hx_classes["h3d.scene.fwd.LightSystem"] = h3d_scene_fwd_LightSystem


class h3d_scene_fwd_DepthPass(h3d_pass_Default):
    _hx_class_name = "h3d.scene.fwd.DepthPass"
    _hx_is_interface = "False"
    __slots__ = ("depthMapId", "enableSky")
    _hx_fields = ["depthMapId", "enableSky"]
    _hx_methods = ["getOutputs", "draw"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_pass_Default


    def __init__(self):
        self.depthMapId = None
        self.enableSky = False
        super().__init__("depth")
        self.depthMapId = hxsl_Globals.allocID("depthMap")

    def getOutputs(self):
        return [hxsl_Output.PackFloat(hxsl_Output.Value("output.depth"))]

    def draw(self,passes,sort = None):
        texture = self.ctx.textures.allocTarget("depthMap",self.ctx.engine.width,self.ctx.engine.height,True)
        self.ctx.engine.pushTarget(texture)
        self.ctx.engine.clear((0 if (self.enableSky) else 16711680),1)
        super().draw(passes,sort)
        self.ctx.engine.popTarget()
        self.ctx.setGlobalID(self.depthMapId,_hx_AnonObject({'texture': texture}))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.depthMapId = None
        _hx_o.enableSky = None
h3d_scene_fwd_DepthPass._hx_class = h3d_scene_fwd_DepthPass
_hx_classes["h3d.scene.fwd.DepthPass"] = h3d_scene_fwd_DepthPass


class h3d_scene_fwd_NormalPass(h3d_pass_Default):
    _hx_class_name = "h3d.scene.fwd.NormalPass"
    _hx_is_interface = "False"
    __slots__ = ("normalMapId",)
    _hx_fields = ["normalMapId"]
    _hx_methods = ["getOutputs", "draw"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_pass_Default


    def __init__(self):
        self.normalMapId = None
        super().__init__("normal")
        self.normalMapId = hxsl_Globals.allocID("normalMap")

    def getOutputs(self):
        return [hxsl_Output.PackNormal(hxsl_Output.Value("output.normal"))]

    def draw(self,passes,sort = None):
        texture = self.ctx.textures.allocTarget("normalMap",self.ctx.engine.width,self.ctx.engine.height)
        self.ctx.engine.pushTarget(texture)
        self.ctx.engine.clear(8421504,1)
        super().draw(passes,sort)
        self.ctx.engine.popTarget()
        self.ctx.setGlobalID(self.normalMapId,texture)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.normalMapId = None
h3d_scene_fwd_NormalPass._hx_class = h3d_scene_fwd_NormalPass
_hx_classes["h3d.scene.fwd.NormalPass"] = h3d_scene_fwd_NormalPass


class h3d_scene_fwd_Renderer(h3d_scene_Renderer):
    _hx_class_name = "h3d.scene.fwd.Renderer"
    _hx_is_interface = "False"
    __slots__ = ("depth", "normal", "shadow")
    _hx_fields = ["depth", "normal", "shadow"]
    _hx_methods = ["get_def", "renderPass", "getPassByName", "render"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = h3d_scene_Renderer


    def __init__(self):
        self.shadow = h3d_pass_DefaultShadowMap(1024)
        self.normal = h3d_scene_fwd_NormalPass()
        self.depth = h3d_scene_fwd_DepthPass()
        super().__init__()
        self.defaultPass = h3d_pass_Default("default")
        self.allPasses = [self.defaultPass, self.depth, self.normal, self.shadow]

    def get_def(self):
        return self.defaultPass

    def renderPass(self,p,passes,sort = None):
        p.draw(passes,sort)

    def getPassByName(self,name):
        if ((name == "alpha") or ((name == "additive"))):
            return self.defaultPass
        return super().getPassByName(name)

    def render(self):
        if self.has("shadow"):
            self.renderPass(self.shadow,self.get("shadow"))
        if self.has("depth"):
            self.renderPass(self.depth,self.get("depth"))
        if self.has("normal"):
            self.renderPass(self.normal,self.get("normal"))
        self.renderPass(self.defaultPass,self.get("default"))
        self.renderPass(self.defaultPass,self.get("alpha"),self.backToFront)
        self.renderPass(self.defaultPass,self.get("additive"))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.depth = None
        _hx_o.normal = None
        _hx_o.shadow = None
h3d_scene_fwd_Renderer._hx_class = h3d_scene_fwd_Renderer
_hx_classes["h3d.scene.fwd.Renderer"] = h3d_scene_fwd_Renderer


class h3d_shader_AmbientLight(hxsl_Shader):
    _hx_class_name = "h3d.shader.AmbientLight"
    _hx_is_interface = "False"
    __slots__ = ("additive__",)
    _hx_fields = ["additive__"]
    _hx_methods = ["get_additive", "set_additive", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader


    def __init__(self):
        self.additive__ = None
        super().__init__()

    def get_additive(self):
        return self.additive__

    def set_additive(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.additive__ = _v
                return self.additive__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        if self.additive__:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.constBits
            _hx_local_0.constBits = (_hx_local_1 | 2)
            _hx_local_0.constBits
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        if (index == 0):
            return self.additive__
        return None

    def getParamFloatValue(self,index):
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_AmbientLight)
        s.shader = self.shader
        s.additive__ = self.additive__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.additive__ = None
h3d_shader_AmbientLight._hx_class = h3d_shader_AmbientLight
_hx_classes["h3d.shader.AmbientLight"] = h3d_shader_AmbientLight


class h3d_shader_Base2d(hxsl_Shader):
    _hx_class_name = "h3d.shader.Base2d"
    _hx_is_interface = "False"
    __slots__ = ("zValue__", "texture__", "isRelative__", "color__", "absoluteMatrixA__", "absoluteMatrixB__", "filterMatrixA__", "filterMatrixB__", "hasUVPos__", "uvPos__", "killAlpha__", "pixelAlign__", "halfPixelInverse__", "viewport__")
    _hx_fields = ["zValue__", "texture__", "isRelative__", "color__", "absoluteMatrixA__", "absoluteMatrixB__", "filterMatrixA__", "filterMatrixB__", "hasUVPos__", "uvPos__", "killAlpha__", "pixelAlign__", "halfPixelInverse__", "viewport__"]
    _hx_methods = ["get_zValue", "set_zValue", "get_texture", "set_texture", "get_isRelative", "set_isRelative", "get_color", "set_color", "get_absoluteMatrixA", "set_absoluteMatrixA", "get_absoluteMatrixB", "set_absoluteMatrixB", "get_filterMatrixA", "set_filterMatrixA", "get_filterMatrixB", "set_filterMatrixB", "get_hasUVPos", "set_hasUVPos", "get_uvPos", "set_uvPos", "get_killAlpha", "set_killAlpha", "get_pixelAlign", "set_pixelAlign", "get_halfPixelInverse", "set_halfPixelInverse", "get_viewport", "set_viewport", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader


    def __init__(self):
        self.pixelAlign__ = None
        self.killAlpha__ = None
        self.hasUVPos__ = None
        self.isRelative__ = None
        self.texture__ = None
        self.viewport__ = h3d_Vector()
        self.halfPixelInverse__ = h3d_Vector()
        self.uvPos__ = h3d_Vector()
        self.filterMatrixB__ = h3d_Vector()
        self.filterMatrixA__ = h3d_Vector()
        self.absoluteMatrixB__ = h3d_Vector()
        self.absoluteMatrixA__ = h3d_Vector()
        self.color__ = h3d_Vector()
        self.zValue__ = 0
        super().__init__()

    def get_zValue(self):
        return self.zValue__

    def set_zValue(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.zValue__ = _v
                return self.zValue__
            return _hx_local_0()
        return _hx_local_1()

    def get_texture(self):
        return self.texture__

    def set_texture(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.texture__ = _v
                return self.texture__
            return _hx_local_0()
        return _hx_local_1()

    def get_isRelative(self):
        return self.isRelative__

    def set_isRelative(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.isRelative__ = _v
                return self.isRelative__
            return _hx_local_0()
        return _hx_local_1()

    def get_color(self):
        return self.color__

    def set_color(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.color__ = _v
                return self.color__
            return _hx_local_0()
        return _hx_local_1()

    def get_absoluteMatrixA(self):
        return self.absoluteMatrixA__

    def set_absoluteMatrixA(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.absoluteMatrixA__ = _v
                return self.absoluteMatrixA__
            return _hx_local_0()
        return _hx_local_1()

    def get_absoluteMatrixB(self):
        return self.absoluteMatrixB__

    def set_absoluteMatrixB(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.absoluteMatrixB__ = _v
                return self.absoluteMatrixB__
            return _hx_local_0()
        return _hx_local_1()

    def get_filterMatrixA(self):
        return self.filterMatrixA__

    def set_filterMatrixA(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.filterMatrixA__ = _v
                return self.filterMatrixA__
            return _hx_local_0()
        return _hx_local_1()

    def get_filterMatrixB(self):
        return self.filterMatrixB__

    def set_filterMatrixB(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.filterMatrixB__ = _v
                return self.filterMatrixB__
            return _hx_local_0()
        return _hx_local_1()

    def get_hasUVPos(self):
        return self.hasUVPos__

    def set_hasUVPos(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.hasUVPos__ = _v
                return self.hasUVPos__
            return _hx_local_0()
        return _hx_local_1()

    def get_uvPos(self):
        return self.uvPos__

    def set_uvPos(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.uvPos__ = _v
                return self.uvPos__
            return _hx_local_0()
        return _hx_local_1()

    def get_killAlpha(self):
        return self.killAlpha__

    def set_killAlpha(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.killAlpha__ = _v
                return self.killAlpha__
            return _hx_local_0()
        return _hx_local_1()

    def get_pixelAlign(self):
        return self.pixelAlign__

    def set_pixelAlign(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.pixelAlign__ = _v
                return self.pixelAlign__
            return _hx_local_0()
        return _hx_local_1()

    def get_halfPixelInverse(self):
        return self.halfPixelInverse__

    def set_halfPixelInverse(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.halfPixelInverse__ = _v
                return self.halfPixelInverse__
            return _hx_local_0()
        return _hx_local_1()

    def get_viewport(self):
        return self.viewport__

    def set_viewport(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.viewport__ = _v
                return self.viewport__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        if self.isRelative__:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.constBits
            _hx_local_0.constBits = (_hx_local_1 | 1)
            _hx_local_0.constBits
        if self.hasUVPos__:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.constBits
            _hx_local_2.constBits = (_hx_local_3 | 2)
            _hx_local_2.constBits
        if self.killAlpha__:
            _hx_local_4 = self
            _hx_local_5 = _hx_local_4.constBits
            _hx_local_4.constBits = (_hx_local_5 | 4)
            _hx_local_4.constBits
        if self.pixelAlign__:
            _hx_local_6 = self
            _hx_local_7 = _hx_local_6.constBits
            _hx_local_6.constBits = (_hx_local_7 | 8)
            _hx_local_6.constBits
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.zValue__
        elif (index1 == 1):
            return self.texture__
        elif (index1 == 2):
            return self.isRelative__
        elif (index1 == 3):
            return self.color__
        elif (index1 == 4):
            return self.absoluteMatrixA__
        elif (index1 == 5):
            return self.absoluteMatrixB__
        elif (index1 == 6):
            return self.filterMatrixA__
        elif (index1 == 7):
            return self.filterMatrixB__
        elif (index1 == 8):
            return self.hasUVPos__
        elif (index1 == 9):
            return self.uvPos__
        elif (index1 == 10):
            return self.killAlpha__
        elif (index1 == 11):
            return self.pixelAlign__
        elif (index1 == 12):
            return self.halfPixelInverse__
        elif (index1 == 13):
            return self.viewport__
        else:
            pass
        return None

    def getParamFloatValue(self,index):
        if (index == 0):
            return self.zValue__
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_Base2d)
        s.shader = self.shader
        s.zValue__ = self.zValue__
        s.texture__ = self.texture__
        s.isRelative__ = self.isRelative__
        s.color__ = self.color__
        s.absoluteMatrixA__ = self.absoluteMatrixA__
        s.absoluteMatrixB__ = self.absoluteMatrixB__
        s.filterMatrixA__ = self.filterMatrixA__
        s.filterMatrixB__ = self.filterMatrixB__
        s.hasUVPos__ = self.hasUVPos__
        s.uvPos__ = self.uvPos__
        s.killAlpha__ = self.killAlpha__
        s.pixelAlign__ = self.pixelAlign__
        s.halfPixelInverse__ = self.halfPixelInverse__
        s.viewport__ = self.viewport__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.zValue__ = None
        _hx_o.texture__ = None
        _hx_o.isRelative__ = None
        _hx_o.color__ = None
        _hx_o.absoluteMatrixA__ = None
        _hx_o.absoluteMatrixB__ = None
        _hx_o.filterMatrixA__ = None
        _hx_o.filterMatrixB__ = None
        _hx_o.hasUVPos__ = None
        _hx_o.uvPos__ = None
        _hx_o.killAlpha__ = None
        _hx_o.pixelAlign__ = None
        _hx_o.halfPixelInverse__ = None
        _hx_o.viewport__ = None
h3d_shader_Base2d._hx_class = h3d_shader_Base2d
_hx_classes["h3d.shader.Base2d"] = h3d_shader_Base2d


class h3d_shader_BaseMesh(hxsl_Shader):
    _hx_class_name = "h3d.shader.BaseMesh"
    _hx_is_interface = "False"
    __slots__ = ("color__", "specularPower__", "specularAmount__", "specularColor__")
    _hx_fields = ["color__", "specularPower__", "specularAmount__", "specularColor__"]
    _hx_methods = ["get_color", "set_color", "get_specularPower", "set_specularPower", "get_specularAmount", "set_specularAmount", "get_specularColor", "set_specularColor", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader


    def __init__(self):
        self.specularColor__ = h3d_Vector()
        self.specularAmount__ = 0
        self.specularPower__ = 0
        self.color__ = h3d_Vector()
        super().__init__()
        _this = self.color__
        x = 1
        y = 1
        z = 1
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.
        _this1 = self.specularColor__
        x1 = 1
        y1 = 1
        z1 = 1
        if (z1 is None):
            z1 = 0.
        if (y1 is None):
            y1 = 0.
        if (x1 is None):
            x1 = 0.
        _this1.x = x1
        _this1.y = y1
        _this1.z = z1
        _this1.w = 1.
        self.specularPower__ = 50
        self.specularAmount__ = 1

    def get_color(self):
        return self.color__

    def set_color(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.color__ = _v
                return self.color__
            return _hx_local_0()
        return _hx_local_1()

    def get_specularPower(self):
        return self.specularPower__

    def set_specularPower(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.specularPower__ = _v
                return self.specularPower__
            return _hx_local_0()
        return _hx_local_1()

    def get_specularAmount(self):
        return self.specularAmount__

    def set_specularAmount(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.specularAmount__ = _v
                return self.specularAmount__
            return _hx_local_0()
        return _hx_local_1()

    def get_specularColor(self):
        return self.specularColor__

    def set_specularColor(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.specularColor__ = _v
                return self.specularColor__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.color__
        elif (index1 == 1):
            return self.specularPower__
        elif (index1 == 2):
            return self.specularAmount__
        elif (index1 == 3):
            return self.specularColor__
        else:
            pass
        return None

    def getParamFloatValue(self,index):
        index1 = index
        if (index1 == 1):
            return self.specularPower__
        elif (index1 == 2):
            return self.specularAmount__
        else:
            pass
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_BaseMesh)
        s.shader = self.shader
        s.color__ = self.color__
        s.specularPower__ = self.specularPower__
        s.specularAmount__ = self.specularAmount__
        s.specularColor__ = self.specularColor__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.color__ = None
        _hx_o.specularPower__ = None
        _hx_o.specularAmount__ = None
        _hx_o.specularColor__ = None
h3d_shader_BaseMesh._hx_class = h3d_shader_BaseMesh
_hx_classes["h3d.shader.BaseMesh"] = h3d_shader_BaseMesh


class h3d_shader_Blur(h3d_shader_ScreenShader):
    _hx_class_name = "h3d.shader.Blur"
    _hx_is_interface = "False"
    __slots__ = ("cameraInverseViewProj__", "texture__", "depthTexture__", "Quality__", "isDepth__", "values__", "offsets__", "pixel__", "hasFixedColor__", "smoothFixedColor__", "fixedColor__", "isDepthDependant__", "hasNormal__", "normalTexture__", "isCube__", "cubeTexture__", "cubeDir__")
    _hx_fields = ["cameraInverseViewProj__", "texture__", "depthTexture__", "Quality__", "isDepth__", "values__", "offsets__", "pixel__", "hasFixedColor__", "smoothFixedColor__", "fixedColor__", "isDepthDependant__", "hasNormal__", "normalTexture__", "isCube__", "cubeTexture__", "cubeDir__"]
    _hx_methods = ["get_cameraInverseViewProj", "set_cameraInverseViewProj", "get_texture", "set_texture", "get_depthTexture", "set_depthTexture", "get_Quality", "set_Quality", "get_isDepth", "set_isDepth", "get_values", "set_values", "get_offsets", "set_offsets", "get_pixel", "set_pixel", "get_hasFixedColor", "set_hasFixedColor", "get_smoothFixedColor", "set_smoothFixedColor", "get_fixedColor", "set_fixedColor", "get_isDepthDependant", "set_isDepthDependant", "get_hasNormal", "set_hasNormal", "get_normalTexture", "set_normalTexture", "get_isCube", "set_isCube", "get_cubeTexture", "set_cubeTexture", "get_cubeDir", "set_cubeDir", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = h3d_shader_ScreenShader


    def __init__(self):
        self.cubeTexture__ = None
        self.isCube__ = None
        self.normalTexture__ = None
        self.hasNormal__ = None
        self.isDepthDependant__ = None
        self.smoothFixedColor__ = None
        self.hasFixedColor__ = None
        self.isDepth__ = None
        self.depthTexture__ = None
        self.texture__ = None
        self.cubeDir__ = h3d_Matrix()
        self.fixedColor__ = h3d_Vector()
        self.pixel__ = h3d_Vector()
        self.offsets__ = list()
        self.values__ = list()
        self.Quality__ = 0
        self.cameraInverseViewProj__ = h3d_Matrix()
        super().__init__()

    def get_cameraInverseViewProj(self):
        return self.cameraInverseViewProj__

    def set_cameraInverseViewProj(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.cameraInverseViewProj__ = _v
                return self.cameraInverseViewProj__
            return _hx_local_0()
        return _hx_local_1()

    def get_texture(self):
        return self.texture__

    def set_texture(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.texture__ = _v
                return self.texture__
            return _hx_local_0()
        return _hx_local_1()

    def get_depthTexture(self):
        return self.depthTexture__

    def set_depthTexture(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.depthTexture__ = _v
                return self.depthTexture__
            return _hx_local_0()
        return _hx_local_1()

    def get_Quality(self):
        return self.Quality__

    def set_Quality(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.Quality__ = _v
                return self.Quality__
            return _hx_local_0()
        return _hx_local_1()

    def get_isDepth(self):
        return self.isDepth__

    def set_isDepth(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.isDepth__ = _v
                return self.isDepth__
            return _hx_local_0()
        return _hx_local_1()

    def get_values(self):
        return self.values__

    def set_values(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.values__ = _v
                return self.values__
            return _hx_local_0()
        return _hx_local_1()

    def get_offsets(self):
        return self.offsets__

    def set_offsets(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.offsets__ = _v
                return self.offsets__
            return _hx_local_0()
        return _hx_local_1()

    def get_pixel(self):
        return self.pixel__

    def set_pixel(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.pixel__ = _v
                return self.pixel__
            return _hx_local_0()
        return _hx_local_1()

    def get_hasFixedColor(self):
        return self.hasFixedColor__

    def set_hasFixedColor(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.hasFixedColor__ = _v
                return self.hasFixedColor__
            return _hx_local_0()
        return _hx_local_1()

    def get_smoothFixedColor(self):
        return self.smoothFixedColor__

    def set_smoothFixedColor(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.smoothFixedColor__ = _v
                return self.smoothFixedColor__
            return _hx_local_0()
        return _hx_local_1()

    def get_fixedColor(self):
        return self.fixedColor__

    def set_fixedColor(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.fixedColor__ = _v
                return self.fixedColor__
            return _hx_local_0()
        return _hx_local_1()

    def get_isDepthDependant(self):
        return self.isDepthDependant__

    def set_isDepthDependant(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.isDepthDependant__ = _v
                return self.isDepthDependant__
            return _hx_local_0()
        return _hx_local_1()

    def get_hasNormal(self):
        return self.hasNormal__

    def set_hasNormal(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.hasNormal__ = _v
                return self.hasNormal__
            return _hx_local_0()
        return _hx_local_1()

    def get_normalTexture(self):
        return self.normalTexture__

    def set_normalTexture(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.normalTexture__ = _v
                return self.normalTexture__
            return _hx_local_0()
        return _hx_local_1()

    def get_isCube(self):
        return self.isCube__

    def set_isCube(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.isCube__ = _v
                return self.isCube__
            return _hx_local_0()
        return _hx_local_1()

    def get_cubeTexture(self):
        return self.cubeTexture__

    def set_cubeTexture(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.cubeTexture__ = _v
                return self.cubeTexture__
            return _hx_local_0()
        return _hx_local_1()

    def get_cubeDir(self):
        return self.cubeDir__

    def set_cubeDir(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.cubeDir__ = _v
                return self.cubeDir__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        v = self.Quality__
        if (HxOverrides.rshift(v, 8) != 0):
            raise _HxException((((("Quality" + " is out of range ") + Std.string(v)) + ">") + Std.string(255)))
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.constBits
        _hx_local_0.constBits = (_hx_local_1 | v)
        _hx_local_0.constBits
        if self.isDepth__:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.constBits
            _hx_local_2.constBits = (_hx_local_3 | 256)
            _hx_local_2.constBits
        if self.hasFixedColor__:
            _hx_local_4 = self
            _hx_local_5 = _hx_local_4.constBits
            _hx_local_4.constBits = (_hx_local_5 | 512)
            _hx_local_4.constBits
        if self.smoothFixedColor__:
            _hx_local_6 = self
            _hx_local_7 = _hx_local_6.constBits
            _hx_local_6.constBits = (_hx_local_7 | 1024)
            _hx_local_6.constBits
        if self.isDepthDependant__:
            _hx_local_8 = self
            _hx_local_9 = _hx_local_8.constBits
            _hx_local_8.constBits = (_hx_local_9 | 2048)
            _hx_local_8.constBits
        if self.hasNormal__:
            _hx_local_10 = self
            _hx_local_11 = _hx_local_10.constBits
            _hx_local_10.constBits = (_hx_local_11 | 4096)
            _hx_local_10.constBits
        if self.isCube__:
            _hx_local_12 = self
            _hx_local_13 = _hx_local_12.constBits
            _hx_local_12.constBits = (_hx_local_13 | 8192)
            _hx_local_12.constBits
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.flipY__
        elif (index1 == 1):
            return self.cameraInverseViewProj__
        elif (index1 == 2):
            return self.texture__
        elif (index1 == 3):
            return self.depthTexture__
        elif (index1 == 4):
            return self.Quality__
        elif (index1 == 5):
            return self.isDepth__
        elif (index1 == 6):
            return self.values__
        elif (index1 == 7):
            return self.offsets__
        elif (index1 == 8):
            return self.pixel__
        elif (index1 == 9):
            return self.hasFixedColor__
        elif (index1 == 10):
            return self.smoothFixedColor__
        elif (index1 == 11):
            return self.fixedColor__
        elif (index1 == 12):
            return self.isDepthDependant__
        elif (index1 == 13):
            return self.hasNormal__
        elif (index1 == 14):
            return self.normalTexture__
        elif (index1 == 15):
            return self.isCube__
        elif (index1 == 16):
            return self.cubeTexture__
        elif (index1 == 17):
            return self.cubeDir__
        else:
            pass
        return None

    def getParamFloatValue(self,index):
        if (index == 0):
            return self.flipY__
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_Blur)
        s.shader = self.shader
        s.flipY__ = self.flipY__
        s.cameraInverseViewProj__ = self.cameraInverseViewProj__
        s.texture__ = self.texture__
        s.depthTexture__ = self.depthTexture__
        s.Quality__ = self.Quality__
        s.isDepth__ = self.isDepth__
        s.values__ = self.values__
        s.offsets__ = self.offsets__
        s.pixel__ = self.pixel__
        s.hasFixedColor__ = self.hasFixedColor__
        s.smoothFixedColor__ = self.smoothFixedColor__
        s.fixedColor__ = self.fixedColor__
        s.isDepthDependant__ = self.isDepthDependant__
        s.hasNormal__ = self.hasNormal__
        s.normalTexture__ = self.normalTexture__
        s.isCube__ = self.isCube__
        s.cubeTexture__ = self.cubeTexture__
        s.cubeDir__ = self.cubeDir__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.cameraInverseViewProj__ = None
        _hx_o.texture__ = None
        _hx_o.depthTexture__ = None
        _hx_o.Quality__ = None
        _hx_o.isDepth__ = None
        _hx_o.values__ = None
        _hx_o.offsets__ = None
        _hx_o.pixel__ = None
        _hx_o.hasFixedColor__ = None
        _hx_o.smoothFixedColor__ = None
        _hx_o.fixedColor__ = None
        _hx_o.isDepthDependant__ = None
        _hx_o.hasNormal__ = None
        _hx_o.normalTexture__ = None
        _hx_o.isCube__ = None
        _hx_o.cubeTexture__ = None
        _hx_o.cubeDir__ = None
h3d_shader_Blur._hx_class = h3d_shader_Blur
_hx_classes["h3d.shader.Blur"] = h3d_shader_Blur


class h3d_shader_ShaderBuffers:
    _hx_class_name = "h3d.shader.ShaderBuffers"
    _hx_is_interface = "False"
    __slots__ = ("globals", "params", "tex", "buffers")
    _hx_fields = ["globals", "params", "tex", "buffers"]
    _hx_methods = ["grow"]

    def __init__(self,s):
        this1 = [None]*(s.globalsSize << 2)
        self.globals = this1
        this2 = [None]*(s.paramsSize << 2)
        self.params = this2
        this3 = [None]*s.texturesCount
        self.tex = this3
        tmp = None
        if (s.bufferCount > 0):
            this4 = [None]*s.bufferCount
            tmp = this4
        else:
            tmp = None
        self.buffers = tmp

    def grow(self,s):
        ng = (s.globalsSize << 2)
        np = (s.paramsSize << 2)
        nt = s.texturesCount
        nb = s.bufferCount
        if (len(self.globals) < ng):
            this1 = [None]*ng
            self.globals = this1
        if (len(self.params) < np):
            this2 = [None]*np
            self.params = this2
        if (len(self.tex) < nt):
            this3 = [None]*nt
            self.tex = this3
        if ((nb > 0) and (((self.buffers is None) or ((len(self.buffers) < nb))))):
            this4 = [None]*nb
            self.buffers = this4

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.globals = None
        _hx_o.params = None
        _hx_o.tex = None
        _hx_o.buffers = None
h3d_shader_ShaderBuffers._hx_class = h3d_shader_ShaderBuffers
_hx_classes["h3d.shader.ShaderBuffers"] = h3d_shader_ShaderBuffers


class h3d_shader_Buffers:
    _hx_class_name = "h3d.shader.Buffers"
    _hx_is_interface = "False"
    __slots__ = ("vertex", "fragment")
    _hx_fields = ["vertex", "fragment"]
    _hx_methods = ["grow"]

    def __init__(self,s):
        self.vertex = h3d_shader_ShaderBuffers(s.vertex)
        self.fragment = h3d_shader_ShaderBuffers(s.fragment)

    def grow(self,s):
        self.vertex.grow(s.vertex)
        self.fragment.grow(s.fragment)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.vertex = None
        _hx_o.fragment = None
h3d_shader_Buffers._hx_class = h3d_shader_Buffers
_hx_classes["h3d.shader.Buffers"] = h3d_shader_Buffers


class h3d_shader_ColorAdd(hxsl_Shader):
    _hx_class_name = "h3d.shader.ColorAdd"
    _hx_is_interface = "False"
    __slots__ = ("color__",)
    _hx_fields = ["color__"]
    _hx_methods = ["get_color", "set_color", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader


    def __init__(self,color = None):
        if (color is None):
            color = 0
        self.color__ = h3d_Vector()
        super().__init__()
        _this = self.color__
        _this.x = ((((color >> 16) & 255)) / 255)
        _this.y = ((((color >> 8) & 255)) / 255)
        _this.z = (((color & 255)) / 255)
        _this.w = ((HxOverrides.rshift(color, 24)) / 255)

    def get_color(self):
        return self.color__

    def set_color(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.color__ = _v
                return self.color__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        if (index == 0):
            return self.color__
        return None

    def getParamFloatValue(self,index):
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_ColorAdd)
        s.shader = self.shader
        s.color__ = self.color__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.color__ = None
h3d_shader_ColorAdd._hx_class = h3d_shader_ColorAdd
_hx_classes["h3d.shader.ColorAdd"] = h3d_shader_ColorAdd


class h3d_shader_ColorKey(hxsl_Shader):
    _hx_class_name = "h3d.shader.ColorKey"
    _hx_is_interface = "False"
    __slots__ = ("colorKey__",)
    _hx_fields = ["colorKey__"]
    _hx_methods = ["get_colorKey", "set_colorKey", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader


    def __init__(self,v = None):
        if (v is None):
            v = 0
        self.colorKey__ = h3d_Vector()
        super().__init__()
        _this = self.colorKey__
        _this.x = ((((v >> 16) & 255)) / 255)
        _this.y = ((((v >> 8) & 255)) / 255)
        _this.z = (((v & 255)) / 255)
        _this.w = ((HxOverrides.rshift(v, 24)) / 255)

    def get_colorKey(self):
        return self.colorKey__

    def set_colorKey(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.colorKey__ = _v
                return self.colorKey__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        if (index == 0):
            return self.colorKey__
        return None

    def getParamFloatValue(self,index):
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_ColorKey)
        s.shader = self.shader
        s.colorKey__ = self.colorKey__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.colorKey__ = None
h3d_shader_ColorKey._hx_class = h3d_shader_ColorKey
_hx_classes["h3d.shader.ColorKey"] = h3d_shader_ColorKey


class h3d_shader_ColorMatrix(hxsl_Shader):
    _hx_class_name = "h3d.shader.ColorMatrix"
    _hx_is_interface = "False"
    __slots__ = ("matrix__",)
    _hx_fields = ["matrix__"]
    _hx_methods = ["get_matrix", "set_matrix", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader


    def __init__(self,m = None):
        self.matrix__ = h3d_Matrix()
        super().__init__()
        if (m is not None):
            self.matrix__.loadValues(m)
        else:
            self.matrix__.identity()

    def get_matrix(self):
        return self.matrix__

    def set_matrix(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.matrix__ = _v
                return self.matrix__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        if (index == 0):
            return self.matrix__
        return None

    def getParamFloatValue(self,index):
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_ColorMatrix)
        s.shader = self.shader
        s.matrix__ = self.matrix__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.matrix__ = None
h3d_shader_ColorMatrix._hx_class = h3d_shader_ColorMatrix
_hx_classes["h3d.shader.ColorMatrix"] = h3d_shader_ColorMatrix


class h3d_shader_ColorMult(hxsl_Shader):
    _hx_class_name = "h3d.shader.ColorMult"
    _hx_is_interface = "False"
    __slots__ = ("color__",)
    _hx_fields = ["color__"]
    _hx_methods = ["get_color", "set_color", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader


    def __init__(self):
        self.color__ = h3d_Vector()
        super().__init__()

    def get_color(self):
        return self.color__

    def set_color(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.color__ = _v
                return self.color__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        if (index == 0):
            return self.color__
        return None

    def getParamFloatValue(self,index):
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_ColorMult)
        s.shader = self.shader
        s.color__ = self.color__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.color__ = None
h3d_shader_ColorMult._hx_class = h3d_shader_ColorMult
_hx_classes["h3d.shader.ColorMult"] = h3d_shader_ColorMult


class h3d_shader_DirLight(hxsl_Shader):
    _hx_class_name = "h3d.shader.DirLight"
    _hx_is_interface = "False"
    __slots__ = ("color__", "direction__", "enableSpecular__")
    _hx_fields = ["color__", "direction__", "enableSpecular__"]
    _hx_methods = ["get_color", "set_color", "get_direction", "set_direction", "get_enableSpecular", "set_enableSpecular", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader


    def __init__(self):
        self.enableSpecular__ = None
        self.direction__ = h3d_Vector()
        self.color__ = h3d_Vector()
        super().__init__()
        _this = self.color__
        x = 1
        y = 1
        z = 1
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.

    def get_color(self):
        return self.color__

    def set_color(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.color__ = _v
                return self.color__
            return _hx_local_0()
        return _hx_local_1()

    def get_direction(self):
        return self.direction__

    def set_direction(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.direction__ = _v
                return self.direction__
            return _hx_local_0()
        return _hx_local_1()

    def get_enableSpecular(self):
        return self.enableSpecular__

    def set_enableSpecular(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.enableSpecular__ = _v
                return self.enableSpecular__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        if self.enableSpecular__:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.constBits
            _hx_local_0.constBits = (_hx_local_1 | 1)
            _hx_local_0.constBits
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.color__
        elif (index1 == 1):
            return self.direction__
        elif (index1 == 2):
            return self.enableSpecular__
        else:
            pass
        return None

    def getParamFloatValue(self,index):
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_DirLight)
        s.shader = self.shader
        s.color__ = self.color__
        s.direction__ = self.direction__
        s.enableSpecular__ = self.enableSpecular__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.color__ = None
        _hx_o.direction__ = None
        _hx_o.enableSpecular__ = None
h3d_shader_DirLight._hx_class = h3d_shader_DirLight
_hx_classes["h3d.shader.DirLight"] = h3d_shader_DirLight


class h3d_shader_DirShadow(hxsl_Shader):
    _hx_class_name = "h3d.shader.DirShadow"
    _hx_is_interface = "False"
    __slots__ = ("enable__", "USE_ESM__", "shadowPower__", "USE_PCF__", "pcfQuality__", "pcfScale__", "shadowRes__", "shadowMap__", "shadowMapChannel__", "shadowProj__", "shadowBias__", "poissonDiskLow__", "poissonDiskHigh__", "poissonDiskVeryHigh__")
    _hx_fields = ["enable__", "USE_ESM__", "shadowPower__", "USE_PCF__", "pcfQuality__", "pcfScale__", "shadowRes__", "shadowMap__", "shadowMapChannel__", "shadowProj__", "shadowBias__", "poissonDiskLow__", "poissonDiskHigh__", "poissonDiskVeryHigh__"]
    _hx_methods = ["get_enable", "set_enable", "get_USE_ESM", "set_USE_ESM", "get_shadowPower", "set_shadowPower", "get_USE_PCF", "set_USE_PCF", "get_pcfQuality", "set_pcfQuality", "get_pcfScale", "set_pcfScale", "get_shadowRes", "set_shadowRes", "get_shadowMap", "set_shadowMap", "get_shadowMapChannel", "set_shadowMapChannel", "get_shadowProj", "set_shadowProj", "get_shadowBias", "set_shadowBias", "get_poissonDiskLow", "set_poissonDiskLow", "get_poissonDiskHigh", "set_poissonDiskHigh", "get_poissonDiskVeryHigh", "set_poissonDiskVeryHigh", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader


    def __init__(self):
        self.shadowMap__ = None
        self.USE_PCF__ = None
        self.USE_ESM__ = None
        self.enable__ = None
        self.poissonDiskVeryHigh__ = list()
        self.poissonDiskHigh__ = list()
        self.poissonDiskLow__ = list()
        self.shadowBias__ = 0
        self.shadowProj__ = h3d_Matrix()
        self.shadowMapChannel__ = hxsl_Channel.Unknown
        self.shadowRes__ = h3d_Vector()
        self.pcfScale__ = 0
        self.pcfQuality__ = 0
        self.shadowPower__ = 0
        super().__init__()
        self.poissonDiskLow__ = [h3d_Vector(-0.942,-0.399), h3d_Vector(0.945,-0.768), h3d_Vector(-0.094,-0.929), h3d_Vector(0.344,0.293)]
        self.poissonDiskHigh__ = [h3d_Vector(-0.326,-0.406), h3d_Vector(-0.840,-0.074), h3d_Vector(-0.696,0.457), h3d_Vector(-0.203,0.621), h3d_Vector(0.962,-0.195), h3d_Vector(0.473,-0.480), h3d_Vector(0.519,0.767), h3d_Vector(0.185,-0.893), h3d_Vector(0.507,0.064), h3d_Vector(0.896,0.412), h3d_Vector(-0.322,-0.933), h3d_Vector(-0.792,-0.598)]
        self.poissonDiskVeryHigh__ = [h3d_Vector(-0.613392,0.617481), h3d_Vector(0.170019,-0.040254), h3d_Vector(-0.299417,0.791925), h3d_Vector(0.645680,0.493210), h3d_Vector(-0.651784,0.717887), h3d_Vector(0.421003,0.027070), h3d_Vector(-0.817194,-0.271096), h3d_Vector(-0.705374,-0.668203), h3d_Vector(0.977050,-0.108615), h3d_Vector(0.063326,0.142369), h3d_Vector(0.203528,0.214331), h3d_Vector(-0.667531,0.326090), h3d_Vector(-0.098422,-0.295755), h3d_Vector(-0.885922,0.215369), h3d_Vector(0.566637,0.605213), h3d_Vector(0.039766,-0.396100), h3d_Vector(0.751946,0.453352), h3d_Vector(0.078707,-0.715323), h3d_Vector(-0.075838,-0.529344), h3d_Vector(0.724479,-0.580798), h3d_Vector(0.222999,-0.215125), h3d_Vector(-0.467574,-0.405438), h3d_Vector(-0.248268,-0.814753), h3d_Vector(0.354411,-0.887570), h3d_Vector(0.175817,0.382366), h3d_Vector(0.487472,-0.063082), h3d_Vector(-0.084078,0.898312), h3d_Vector(0.488876,-0.783441), h3d_Vector(0.470016,0.217933), h3d_Vector(-0.696890,-0.549791), h3d_Vector(-0.149693,0.605762), h3d_Vector(0.034211,0.979980), h3d_Vector(0.503098,-0.308878), h3d_Vector(-0.016205,-0.872921), h3d_Vector(0.385784,-0.393902), h3d_Vector(-0.146886,-0.859249), h3d_Vector(0.643361,0.164098), h3d_Vector(0.634388,-0.049471), h3d_Vector(-0.688894,0.007843), h3d_Vector(0.464034,-0.188818), h3d_Vector(-0.440840,0.137486), h3d_Vector(0.364483,0.511704), h3d_Vector(0.034028,0.325968), h3d_Vector(0.099094,-0.308023), h3d_Vector(0.693960,-0.366253), h3d_Vector(0.678884,-0.204688), h3d_Vector(0.001801,0.780328), h3d_Vector(0.145177,-0.898984), h3d_Vector(0.062655,-0.611866), h3d_Vector(0.315226,-0.604297), h3d_Vector(-0.780145,0.486251), h3d_Vector(-0.371868,0.882138), h3d_Vector(0.200476,0.494430), h3d_Vector(-0.494552,-0.711051), h3d_Vector(0.612476,0.705252), h3d_Vector(-0.578845,-0.768792), h3d_Vector(-0.772454,-0.090976), h3d_Vector(0.504440,0.372295), h3d_Vector(0.155736,0.065157), h3d_Vector(0.391522,0.849605), h3d_Vector(-0.620106,-0.328104), h3d_Vector(0.789239,-0.419965), h3d_Vector(-0.545396,0.538133), h3d_Vector(-0.178564,-0.596057)]

    def get_enable(self):
        return self.enable__

    def set_enable(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.enable__ = _v
                return self.enable__
            return _hx_local_0()
        return _hx_local_1()

    def get_USE_ESM(self):
        return self.USE_ESM__

    def set_USE_ESM(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.USE_ESM__ = _v
                return self.USE_ESM__
            return _hx_local_0()
        return _hx_local_1()

    def get_shadowPower(self):
        return self.shadowPower__

    def set_shadowPower(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.shadowPower__ = _v
                return self.shadowPower__
            return _hx_local_0()
        return _hx_local_1()

    def get_USE_PCF(self):
        return self.USE_PCF__

    def set_USE_PCF(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.USE_PCF__ = _v
                return self.USE_PCF__
            return _hx_local_0()
        return _hx_local_1()

    def get_pcfQuality(self):
        return self.pcfQuality__

    def set_pcfQuality(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.pcfQuality__ = _v
                return self.pcfQuality__
            return _hx_local_0()
        return _hx_local_1()

    def get_pcfScale(self):
        return self.pcfScale__

    def set_pcfScale(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.pcfScale__ = _v
                return self.pcfScale__
            return _hx_local_0()
        return _hx_local_1()

    def get_shadowRes(self):
        return self.shadowRes__

    def set_shadowRes(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.shadowRes__ = _v
                return self.shadowRes__
            return _hx_local_0()
        return _hx_local_1()

    def get_shadowMap(self):
        return self.shadowMap__

    def set_shadowMap(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.shadowMap__ = _v
                return self.shadowMap__
            return _hx_local_0()
        return _hx_local_1()

    def get_shadowMapChannel(self):
        return self.shadowMapChannel__

    def set_shadowMapChannel(self,v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.shadowMapChannel__ = v
                return self.shadowMapChannel__
            return _hx_local_0()
        return _hx_local_1()

    def get_shadowProj(self):
        return self.shadowProj__

    def set_shadowProj(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.shadowProj__ = _v
                return self.shadowProj__
            return _hx_local_0()
        return _hx_local_1()

    def get_shadowBias(self):
        return self.shadowBias__

    def set_shadowBias(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.shadowBias__ = _v
                return self.shadowBias__
            return _hx_local_0()
        return _hx_local_1()

    def get_poissonDiskLow(self):
        return self.poissonDiskLow__

    def set_poissonDiskLow(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.poissonDiskLow__ = _v
                return self.poissonDiskLow__
            return _hx_local_0()
        return _hx_local_1()

    def get_poissonDiskHigh(self):
        return self.poissonDiskHigh__

    def set_poissonDiskHigh(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.poissonDiskHigh__ = _v
                return self.poissonDiskHigh__
            return _hx_local_0()
        return _hx_local_1()

    def get_poissonDiskVeryHigh(self):
        return self.poissonDiskVeryHigh__

    def set_poissonDiskVeryHigh(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.poissonDiskVeryHigh__ = _v
                return self.poissonDiskVeryHigh__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        if self.enable__:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.constBits
            _hx_local_0.constBits = (_hx_local_1 | 1)
            _hx_local_0.constBits
        if self.USE_ESM__:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.constBits
            _hx_local_2.constBits = (_hx_local_3 | 2)
            _hx_local_2.constBits
        if self.USE_PCF__:
            _hx_local_4 = self
            _hx_local_5 = _hx_local_4.constBits
            _hx_local_4.constBits = (_hx_local_5 | 4)
            _hx_local_4.constBits
        v = self.pcfQuality__
        if (HxOverrides.rshift(v, 8) != 0):
            raise _HxException((((("pcfQuality" + " is out of range ") + Std.string(v)) + ">") + Std.string(255)))
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6.constBits
        _hx_local_6.constBits = (_hx_local_7 | ((v << 3)))
        _hx_local_6.constBits
        if (self.shadowMap__ is None):
            self.shadowMapChannel__ = hxsl_Channel.Unknown
        elif (self.shadowMapChannel__ == hxsl_Channel.Unknown):
            if (self.shadowMap__.format == h3d_mat_Texture.nativeFormat):
                self.shadowMapChannel__ = hxsl_Channel.PackedFloat
            else:
                raise _HxException(("shadowMap" + "Channel is not set"))
        _hx_local_8 = self
        _hx_local_9 = _hx_local_8.constBits
        _hx_local_8.constBits = (_hx_local_9 | (((((globals.allocChannelID(self.shadowMap__) << 3) | self.shadowMapChannel__.index)) << 11)))
        _hx_local_8.constBits
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.enable__
        elif (index1 == 1):
            return self.USE_ESM__
        elif (index1 == 2):
            return self.shadowPower__
        elif (index1 == 3):
            return self.USE_PCF__
        elif (index1 == 4):
            return self.pcfQuality__
        elif (index1 == 5):
            return self.pcfScale__
        elif (index1 == 6):
            return self.shadowRes__
        elif (index1 == 7):
            return self.shadowMap__
        elif (index1 == 8):
            return self.shadowProj__
        elif (index1 == 9):
            return self.shadowBias__
        elif (index1 == 10):
            return self.poissonDiskLow__
        elif (index1 == 11):
            return self.poissonDiskHigh__
        elif (index1 == 12):
            return self.poissonDiskVeryHigh__
        else:
            pass
        return None

    def getParamFloatValue(self,index):
        index1 = index
        if (index1 == 2):
            return self.shadowPower__
        elif (index1 == 5):
            return self.pcfScale__
        elif (index1 == 9):
            return self.shadowBias__
        else:
            pass
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_DirShadow)
        s.shader = self.shader
        s.enable__ = self.enable__
        s.USE_ESM__ = self.USE_ESM__
        s.shadowPower__ = self.shadowPower__
        s.USE_PCF__ = self.USE_PCF__
        s.pcfQuality__ = self.pcfQuality__
        s.pcfScale__ = self.pcfScale__
        s.shadowRes__ = self.shadowRes__
        s.shadowMap__ = self.shadowMap__
        s.shadowProj__ = self.shadowProj__
        s.shadowBias__ = self.shadowBias__
        s.poissonDiskLow__ = self.poissonDiskLow__
        s.poissonDiskHigh__ = self.poissonDiskHigh__
        s.poissonDiskVeryHigh__ = self.poissonDiskVeryHigh__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.enable__ = None
        _hx_o.USE_ESM__ = None
        _hx_o.shadowPower__ = None
        _hx_o.USE_PCF__ = None
        _hx_o.pcfQuality__ = None
        _hx_o.pcfScale__ = None
        _hx_o.shadowRes__ = None
        _hx_o.shadowMap__ = None
        _hx_o.shadowMapChannel__ = None
        _hx_o.shadowProj__ = None
        _hx_o.shadowBias__ = None
        _hx_o.poissonDiskLow__ = None
        _hx_o.poissonDiskHigh__ = None
        _hx_o.poissonDiskVeryHigh__ = None
h3d_shader_DirShadow._hx_class = h3d_shader_DirShadow
_hx_classes["h3d.shader.DirShadow"] = h3d_shader_DirShadow


class h3d_shader_GenTexture(h3d_shader_ScreenShader):
    _hx_class_name = "h3d.shader.GenTexture"
    _hx_is_interface = "False"
    __slots__ = ("mode__", "color__")
    _hx_fields = ["mode__", "color__"]
    _hx_methods = ["get_mode", "set_mode", "get_color", "set_color", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = h3d_shader_ScreenShader


    def __init__(self):
        self.color__ = h3d_Vector()
        self.mode__ = 0
        super().__init__()

    def get_mode(self):
        return self.mode__

    def set_mode(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.mode__ = _v
                return self.mode__
            return _hx_local_0()
        return _hx_local_1()

    def get_color(self):
        return self.color__

    def set_color(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.color__ = _v
                return self.color__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        v = self.mode__
        if (HxOverrides.rshift(v, 8) != 0):
            raise _HxException((((("mode" + " is out of range ") + Std.string(v)) + ">") + Std.string(255)))
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.constBits
        _hx_local_0.constBits = (_hx_local_1 | v)
        _hx_local_0.constBits
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.flipY__
        elif (index1 == 1):
            return self.mode__
        elif (index1 == 2):
            return self.color__
        else:
            pass
        return None

    def getParamFloatValue(self,index):
        if (index == 0):
            return self.flipY__
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_GenTexture)
        s.shader = self.shader
        s.flipY__ = self.flipY__
        s.mode__ = self.mode__
        s.color__ = self.color__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.mode__ = None
        _hx_o.color__ = None
h3d_shader_GenTexture._hx_class = h3d_shader_GenTexture
_hx_classes["h3d.shader.GenTexture"] = h3d_shader_GenTexture


class h3d_shader_LineShader(hxsl_Shader):
    _hx_class_name = "h3d.shader.LineShader"
    _hx_is_interface = "False"
    __slots__ = ("lengthScale__", "width__")
    _hx_fields = ["lengthScale__", "width__"]
    _hx_methods = ["get_lengthScale", "set_lengthScale", "get_width", "set_width", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader


    def __init__(self,width = None,lengthScale = None):
        if (width is None):
            width = 1.5
        if (lengthScale is None):
            lengthScale = 1.
        self.width__ = 0
        self.lengthScale__ = 0
        super().__init__()
        self.width__ = width
        self.lengthScale__ = lengthScale

    def get_lengthScale(self):
        return self.lengthScale__

    def set_lengthScale(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.lengthScale__ = _v
                return self.lengthScale__
            return _hx_local_0()
        return _hx_local_1()

    def get_width(self):
        return self.width__

    def set_width(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.width__ = _v
                return self.width__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.lengthScale__
        elif (index1 == 1):
            return self.width__
        else:
            pass
        return None

    def getParamFloatValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.lengthScale__
        elif (index1 == 1):
            return self.width__
        else:
            pass
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_LineShader)
        s.shader = self.shader
        s.lengthScale__ = self.lengthScale__
        s.width__ = self.width__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.lengthScale__ = None
        _hx_o.width__ = None
h3d_shader_LineShader._hx_class = h3d_shader_LineShader
_hx_classes["h3d.shader.LineShader"] = h3d_shader_LineShader


class h3d_shader_MinMaxShader(h3d_shader_ScreenShader):
    _hx_class_name = "h3d.shader.MinMaxShader"
    _hx_is_interface = "False"
    __slots__ = ("texA__", "texB__", "isMax__")
    _hx_fields = ["texA__", "texB__", "isMax__"]
    _hx_methods = ["get_texA", "set_texA", "get_texB", "set_texB", "get_isMax", "set_isMax", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = h3d_shader_ScreenShader


    def __init__(self):
        self.isMax__ = None
        self.texB__ = None
        self.texA__ = None
        super().__init__()

    def get_texA(self):
        return self.texA__

    def set_texA(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.texA__ = _v
                return self.texA__
            return _hx_local_0()
        return _hx_local_1()

    def get_texB(self):
        return self.texB__

    def set_texB(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.texB__ = _v
                return self.texB__
            return _hx_local_0()
        return _hx_local_1()

    def get_isMax(self):
        return self.isMax__

    def set_isMax(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.isMax__ = _v
                return self.isMax__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        if self.isMax__:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.constBits
            _hx_local_0.constBits = (_hx_local_1 | 1)
            _hx_local_0.constBits
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.flipY__
        elif (index1 == 1):
            return self.texA__
        elif (index1 == 2):
            return self.texB__
        elif (index1 == 3):
            return self.isMax__
        else:
            pass
        return None

    def getParamFloatValue(self,index):
        if (index == 0):
            return self.flipY__
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_MinMaxShader)
        s.shader = self.shader
        s.flipY__ = self.flipY__
        s.texA__ = self.texA__
        s.texB__ = self.texB__
        s.isMax__ = self.isMax__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.texA__ = None
        _hx_o.texB__ = None
        _hx_o.isMax__ = None
h3d_shader_MinMaxShader._hx_class = h3d_shader_MinMaxShader
_hx_classes["h3d.shader.MinMaxShader"] = h3d_shader_MinMaxShader


class h3d_shader_CubeMinMaxShader(h3d_shader_ScreenShader):
    _hx_class_name = "h3d.shader.CubeMinMaxShader"
    _hx_is_interface = "False"
    __slots__ = ("texA__", "texB__", "isMax__", "mat__")
    _hx_fields = ["texA__", "texB__", "isMax__", "mat__"]
    _hx_methods = ["get_texA", "set_texA", "get_texB", "set_texB", "get_isMax", "set_isMax", "get_mat", "set_mat", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = h3d_shader_ScreenShader


    def __init__(self):
        self.isMax__ = None
        self.texB__ = None
        self.texA__ = None
        self.mat__ = h3d_Matrix()
        super().__init__()

    def get_texA(self):
        return self.texA__

    def set_texA(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.texA__ = _v
                return self.texA__
            return _hx_local_0()
        return _hx_local_1()

    def get_texB(self):
        return self.texB__

    def set_texB(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.texB__ = _v
                return self.texB__
            return _hx_local_0()
        return _hx_local_1()

    def get_isMax(self):
        return self.isMax__

    def set_isMax(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.isMax__ = _v
                return self.isMax__
            return _hx_local_0()
        return _hx_local_1()

    def get_mat(self):
        return self.mat__

    def set_mat(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.mat__ = _v
                return self.mat__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        if self.isMax__:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.constBits
            _hx_local_0.constBits = (_hx_local_1 | 1)
            _hx_local_0.constBits
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.flipY__
        elif (index1 == 1):
            return self.texA__
        elif (index1 == 2):
            return self.texB__
        elif (index1 == 3):
            return self.isMax__
        elif (index1 == 4):
            return self.mat__
        else:
            pass
        return None

    def getParamFloatValue(self,index):
        if (index == 0):
            return self.flipY__
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_CubeMinMaxShader)
        s.shader = self.shader
        s.flipY__ = self.flipY__
        s.texA__ = self.texA__
        s.texB__ = self.texB__
        s.isMax__ = self.isMax__
        s.mat__ = self.mat__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.texA__ = None
        _hx_o.texB__ = None
        _hx_o.isMax__ = None
        _hx_o.mat__ = None
h3d_shader_CubeMinMaxShader._hx_class = h3d_shader_CubeMinMaxShader
_hx_classes["h3d.shader.CubeMinMaxShader"] = h3d_shader_CubeMinMaxShader


class h3d_shader_NormalMap(hxsl_Shader):
    _hx_class_name = "h3d.shader.NormalMap"
    _hx_is_interface = "False"
    __slots__ = ("texture__",)
    _hx_fields = ["texture__"]
    _hx_methods = ["get_texture", "set_texture", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader


    def __init__(self,texture = None):
        self.texture__ = None
        super().__init__()
        self.texture__ = texture

    def get_texture(self):
        return self.texture__

    def set_texture(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.texture__ = _v
                return self.texture__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        if (index == 0):
            return self.texture__
        return None

    def getParamFloatValue(self,index):
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_NormalMap)
        s.shader = self.shader
        s.texture__ = self.texture__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.texture__ = None
h3d_shader_NormalMap._hx_class = h3d_shader_NormalMap
_hx_classes["h3d.shader.NormalMap"] = h3d_shader_NormalMap


class h3d_shader_Shadow(hxsl_Shader):
    _hx_class_name = "h3d.shader.Shadow"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["updateConstants", "getParamValue", "getParamFloatValue"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader


    def __init__(self):
        super().__init__()

    def updateConstants(self,globals):
        self.constBits = 0
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        return None

    def getParamFloatValue(self,index):
        return 0.
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
h3d_shader_Shadow._hx_class = h3d_shader_Shadow
_hx_classes["h3d.shader.Shadow"] = h3d_shader_Shadow


class h3d_shader_SkinBase(hxsl_Shader):
    _hx_class_name = "h3d.shader.SkinBase"
    _hx_is_interface = "False"
    __slots__ = ("MaxBones__", "bonesMatrixes__")
    _hx_fields = ["MaxBones__", "bonesMatrixes__"]
    _hx_methods = ["get_MaxBones", "set_MaxBones", "get_bonesMatrixes", "set_bonesMatrixes", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader


    def __init__(self):
        self.bonesMatrixes__ = list()
        self.MaxBones__ = 0
        super().__init__()
        self.constModified = True
        self.MaxBones__ = 34

    def get_MaxBones(self):
        return self.MaxBones__

    def set_MaxBones(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.MaxBones__ = _v
                return self.MaxBones__
            return _hx_local_0()
        return _hx_local_1()

    def get_bonesMatrixes(self):
        return self.bonesMatrixes__

    def set_bonesMatrixes(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.bonesMatrixes__ = _v
                return self.bonesMatrixes__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        v = self.MaxBones__
        if (HxOverrides.rshift(v, 8) != 0):
            raise _HxException((((("MaxBones" + " is out of range ") + Std.string(v)) + ">") + Std.string(255)))
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.constBits
        _hx_local_0.constBits = (_hx_local_1 | v)
        _hx_local_0.constBits
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.MaxBones__
        elif (index1 == 1):
            return self.bonesMatrixes__
        else:
            pass
        return None

    def getParamFloatValue(self,index):
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_SkinBase)
        s.shader = self.shader
        s.MaxBones__ = self.MaxBones__
        s.bonesMatrixes__ = self.bonesMatrixes__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.MaxBones__ = None
        _hx_o.bonesMatrixes__ = None
h3d_shader_SkinBase._hx_class = h3d_shader_SkinBase
_hx_classes["h3d.shader.SkinBase"] = h3d_shader_SkinBase


class h3d_shader_Skin(h3d_shader_SkinBase):
    _hx_class_name = "h3d.shader.Skin"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = h3d_shader_SkinBase


    def __init__(self):
        super().__init__()

    def updateConstants(self,globals):
        self.constBits = 0
        v = self.MaxBones__
        if (HxOverrides.rshift(v, 8) != 0):
            raise _HxException((((("MaxBones" + " is out of range ") + Std.string(v)) + ">") + Std.string(255)))
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.constBits
        _hx_local_0.constBits = (_hx_local_1 | v)
        _hx_local_0.constBits
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.MaxBones__
        elif (index1 == 1):
            return self.bonesMatrixes__
        else:
            pass
        return None

    def getParamFloatValue(self,index):
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_Skin)
        s.shader = self.shader
        s.MaxBones__ = self.MaxBones__
        s.bonesMatrixes__ = self.bonesMatrixes__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
h3d_shader_Skin._hx_class = h3d_shader_Skin
_hx_classes["h3d.shader.Skin"] = h3d_shader_Skin


class h3d_shader_SkinTangent(h3d_shader_SkinBase):
    _hx_class_name = "h3d.shader.SkinTangent"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = h3d_shader_SkinBase


    def __init__(self):
        super().__init__()

    def updateConstants(self,globals):
        self.constBits = 0
        v = self.MaxBones__
        if (HxOverrides.rshift(v, 8) != 0):
            raise _HxException((((("MaxBones" + " is out of range ") + Std.string(v)) + ">") + Std.string(255)))
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.constBits
        _hx_local_0.constBits = (_hx_local_1 | v)
        _hx_local_0.constBits
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.MaxBones__
        elif (index1 == 1):
            return self.bonesMatrixes__
        else:
            pass
        return None

    def getParamFloatValue(self,index):
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_SkinTangent)
        s.shader = self.shader
        s.MaxBones__ = self.MaxBones__
        s.bonesMatrixes__ = self.bonesMatrixes__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
h3d_shader_SkinTangent._hx_class = h3d_shader_SkinTangent
_hx_classes["h3d.shader.SkinTangent"] = h3d_shader_SkinTangent


class h3d_shader_SpecularTexture(hxsl_Shader):
    _hx_class_name = "h3d.shader.SpecularTexture"
    _hx_is_interface = "False"
    __slots__ = ("texture__",)
    _hx_fields = ["texture__"]
    _hx_methods = ["get_texture", "set_texture", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader


    def __init__(self,tex = None):
        self.texture__ = None
        super().__init__()
        self.texture__ = tex

    def get_texture(self):
        return self.texture__

    def set_texture(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.texture__ = _v
                return self.texture__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        if (index == 0):
            return self.texture__
        return None

    def getParamFloatValue(self,index):
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_SpecularTexture)
        s.shader = self.shader
        s.texture__ = self.texture__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.texture__ = None
h3d_shader_SpecularTexture._hx_class = h3d_shader_SpecularTexture
_hx_classes["h3d.shader.SpecularTexture"] = h3d_shader_SpecularTexture


class h3d_shader_Texture(hxsl_Shader):
    _hx_class_name = "h3d.shader.Texture"
    _hx_is_interface = "False"
    __slots__ = ("additive__", "killAlpha__", "specularAlpha__", "killAlphaThreshold__", "texture__")
    _hx_fields = ["additive__", "killAlpha__", "specularAlpha__", "killAlphaThreshold__", "texture__"]
    _hx_methods = ["get_additive", "set_additive", "get_killAlpha", "set_killAlpha", "get_specularAlpha", "set_specularAlpha", "get_killAlphaThreshold", "set_killAlphaThreshold", "get_texture", "set_texture", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader


    def __init__(self,tex = None):
        self.texture__ = None
        self.specularAlpha__ = None
        self.killAlpha__ = None
        self.additive__ = None
        self.killAlphaThreshold__ = 0
        super().__init__()
        self.texture__ = tex
        self.killAlphaThreshold__ = h3d_mat_Defaults.defaultKillAlphaThreshold

    def get_additive(self):
        return self.additive__

    def set_additive(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.additive__ = _v
                return self.additive__
            return _hx_local_0()
        return _hx_local_1()

    def get_killAlpha(self):
        return self.killAlpha__

    def set_killAlpha(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.killAlpha__ = _v
                return self.killAlpha__
            return _hx_local_0()
        return _hx_local_1()

    def get_specularAlpha(self):
        return self.specularAlpha__

    def set_specularAlpha(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.specularAlpha__ = _v
                return self.specularAlpha__
            return _hx_local_0()
        return _hx_local_1()

    def get_killAlphaThreshold(self):
        return self.killAlphaThreshold__

    def set_killAlphaThreshold(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.killAlphaThreshold__ = _v
                return self.killAlphaThreshold__
            return _hx_local_0()
        return _hx_local_1()

    def get_texture(self):
        return self.texture__

    def set_texture(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.texture__ = _v
                return self.texture__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        if self.additive__:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.constBits
            _hx_local_0.constBits = (_hx_local_1 | 1)
            _hx_local_0.constBits
        if self.killAlpha__:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.constBits
            _hx_local_2.constBits = (_hx_local_3 | 2)
            _hx_local_2.constBits
        if self.specularAlpha__:
            _hx_local_4 = self
            _hx_local_5 = _hx_local_4.constBits
            _hx_local_4.constBits = (_hx_local_5 | 4)
            _hx_local_4.constBits
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.additive__
        elif (index1 == 1):
            return self.killAlpha__
        elif (index1 == 2):
            return self.specularAlpha__
        elif (index1 == 3):
            return self.killAlphaThreshold__
        elif (index1 == 4):
            return self.texture__
        else:
            pass
        return None

    def getParamFloatValue(self,index):
        if (index == 3):
            return self.killAlphaThreshold__
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_Texture)
        s.shader = self.shader
        s.additive__ = self.additive__
        s.killAlpha__ = self.killAlpha__
        s.specularAlpha__ = self.specularAlpha__
        s.killAlphaThreshold__ = self.killAlphaThreshold__
        s.texture__ = self.texture__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.additive__ = None
        _hx_o.killAlpha__ = None
        _hx_o.specularAlpha__ = None
        _hx_o.killAlphaThreshold__ = None
        _hx_o.texture__ = None
h3d_shader_Texture._hx_class = h3d_shader_Texture
_hx_classes["h3d.shader.Texture"] = h3d_shader_Texture


class h3d_shader_UVDelta(hxsl_Shader):
    _hx_class_name = "h3d.shader.UVDelta"
    _hx_is_interface = "False"
    __slots__ = ("uvDelta__", "uvScale__")
    _hx_fields = ["uvDelta__", "uvScale__"]
    _hx_methods = ["get_uvDelta", "set_uvDelta", "get_uvScale", "set_uvScale", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader


    def __init__(self,dx = None,dy = None,sx = None,sy = None):
        if (dx is None):
            dx = 0.
        if (dy is None):
            dy = 0.
        if (sx is None):
            sx = 1.
        if (sy is None):
            sy = 1.
        self.uvScale__ = h3d_Vector()
        self.uvDelta__ = h3d_Vector()
        super().__init__()
        _this = self.uvDelta__
        x = dx
        y = dy
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = 0.
        _this.w = 1.
        _this1 = self.uvScale__
        x1 = sx
        y1 = sy
        if (y1 is None):
            y1 = 0.
        if (x1 is None):
            x1 = 0.
        _this1.x = x1
        _this1.y = y1
        _this1.z = 0.
        _this1.w = 1.

    def get_uvDelta(self):
        return self.uvDelta__

    def set_uvDelta(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.uvDelta__ = _v
                return self.uvDelta__
            return _hx_local_0()
        return _hx_local_1()

    def get_uvScale(self):
        return self.uvScale__

    def set_uvScale(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.uvScale__ = _v
                return self.uvScale__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.uvDelta__
        elif (index1 == 1):
            return self.uvScale__
        else:
            pass
        return None

    def getParamFloatValue(self,index):
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_UVDelta)
        s.shader = self.shader
        s.uvDelta__ = self.uvDelta__
        s.uvScale__ = self.uvScale__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.uvDelta__ = None
        _hx_o.uvScale__ = None
h3d_shader_UVDelta._hx_class = h3d_shader_UVDelta
_hx_classes["h3d.shader.UVDelta"] = h3d_shader_UVDelta


class h3d_shader_VertexColorAlpha(hxsl_Shader):
    _hx_class_name = "h3d.shader.VertexColorAlpha"
    _hx_is_interface = "False"
    __slots__ = ("additive__",)
    _hx_fields = ["additive__"]
    _hx_methods = ["get_additive", "set_additive", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader


    def __init__(self):
        self.additive__ = None
        super().__init__()

    def get_additive(self):
        return self.additive__

    def set_additive(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.additive__ = _v
                return self.additive__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        if self.additive__:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.constBits
            _hx_local_0.constBits = (_hx_local_1 | 1)
            _hx_local_0.constBits
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        if (index == 0):
            return self.additive__
        return None

    def getParamFloatValue(self,index):
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_VertexColorAlpha)
        s.shader = self.shader
        s.additive__ = self.additive__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.additive__ = None
h3d_shader_VertexColorAlpha._hx_class = h3d_shader_VertexColorAlpha
_hx_classes["h3d.shader.VertexColorAlpha"] = h3d_shader_VertexColorAlpha


class h3d_shader_VolumeDecal(hxsl_Shader):
    _hx_class_name = "h3d.shader.VolumeDecal"
    _hx_is_interface = "False"
    __slots__ = ("scale__", "normal__", "tangent__", "isCentered__")
    _hx_fields = ["scale__", "normal__", "tangent__", "isCentered__"]
    _hx_methods = ["get_scale", "set_scale", "get_normal", "set_normal", "get_tangent", "set_tangent", "get_isCentered", "set_isCentered", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader


    def __init__(self,objectWidth,objectHeight):
        self.isCentered__ = True
        self.tangent__ = h3d_Vector()
        self.normal__ = h3d_Vector()
        self.scale__ = h3d_Vector()
        super().__init__()
        _this = self.normal__
        x = 0
        y = 0
        z = 1
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this.x = x
        _this.y = y
        _this.z = z
        _this.w = 1.
        _this1 = self.tangent__
        x1 = 1
        y1 = 0
        z1 = 0
        if (z1 is None):
            z1 = 0.
        if (y1 is None):
            y1 = 0.
        if (x1 is None):
            x1 = 0.
        _this1.x = x1
        _this1.y = y1
        _this1.z = z1
        _this1.w = 1.
        _this2 = self.scale__
        x2 = (1 / objectWidth)
        y2 = (1 / objectHeight)
        if (y2 is None):
            y2 = 0.
        if (x2 is None):
            x2 = 0.
        _this2.x = x2
        _this2.y = y2
        _this2.z = 0.
        _this2.w = 1.

    def get_scale(self):
        return self.scale__

    def set_scale(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.scale__ = _v
                return self.scale__
            return _hx_local_0()
        return _hx_local_1()

    def get_normal(self):
        return self.normal__

    def set_normal(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.normal__ = _v
                return self.normal__
            return _hx_local_0()
        return _hx_local_1()

    def get_tangent(self):
        return self.tangent__

    def set_tangent(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.tangent__ = _v
                return self.tangent__
            return _hx_local_0()
        return _hx_local_1()

    def get_isCentered(self):
        return self.isCentered__

    def set_isCentered(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.isCentered__ = _v
                return self.isCentered__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        if self.isCentered__:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.constBits
            _hx_local_0.constBits = (_hx_local_1 | 64)
            _hx_local_0.constBits
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.scale__
        elif (index1 == 1):
            return self.normal__
        elif (index1 == 2):
            return self.tangent__
        elif (index1 == 3):
            return self.isCentered__
        else:
            pass
        return None

    def getParamFloatValue(self,index):
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(h3d_shader_VolumeDecal)
        s.shader = self.shader
        s.scale__ = self.scale__
        s.normal__ = self.normal__
        s.tangent__ = self.tangent__
        s.isCentered__ = self.isCentered__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.scale__ = None
        _hx_o.normal__ = None
        _hx_o.tangent__ = None
        _hx_o.isCentered__ = None
h3d_shader_VolumeDecal._hx_class = h3d_shader_VolumeDecal
_hx_classes["h3d.shader.VolumeDecal"] = h3d_shader_VolumeDecal


class haxe_EntryPoint:
    _hx_class_name = "haxe.EntryPoint"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["pending", "threadCount", "processEvents", "run"]

    @staticmethod
    def processEvents():
        while True:
            _this = haxe_EntryPoint.pending
            f = (None if ((len(_this) == 0)) else _this.pop(0))
            if (f is None):
                break
            f()
        time = haxe_MainLoop.tick()
        if ((not haxe_MainLoop.hasEvents()) and ((haxe_EntryPoint.threadCount == 0))):
            return -1
        return time

    @staticmethod
    def run():
        while True:
            nextTick = haxe_EntryPoint.processEvents()
            if (nextTick < 0):
                break
            tmp = (nextTick > 0)
haxe_EntryPoint._hx_class = haxe_EntryPoint
_hx_classes["haxe.EntryPoint"] = haxe_EntryPoint


class haxe__Int64____Int64:
    _hx_class_name = "haxe._Int64.___Int64"
    _hx_is_interface = "False"
    __slots__ = ("high", "low")
    _hx_fields = ["high", "low"]

    def __init__(self,high,low):
        self.high = high
        self.low = low

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.high = None
        _hx_o.low = None
haxe__Int64____Int64._hx_class = haxe__Int64____Int64
_hx_classes["haxe._Int64.___Int64"] = haxe__Int64____Int64


class haxe_Log:
    _hx_class_name = "haxe.Log"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["formatOutput", "trace"]

    @staticmethod
    def formatOutput(v,infos):
        _hx_str = Std.string(v)
        if (infos is None):
            return _hx_str
        pstr = ((HxOverrides.stringOrNull(infos.fileName) + ":") + Std.string(infos.lineNumber))
        if (Reflect.field(infos,"customParams") is not None):
            _g = 0
            _g1 = Reflect.field(infos,"customParams")
            while (_g < len(_g1)):
                v1 = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                _hx_str = (("null" if _hx_str is None else _hx_str) + ((", " + Std.string(v1))))
        return ((("null" if pstr is None else pstr) + ": ") + ("null" if _hx_str is None else _hx_str))

    @staticmethod
    def trace(v,infos = None):
        _hx_str = haxe_Log.formatOutput(v,infos)
        str1 = Std.string(_hx_str)
        python_Lib.printString((("" + ("null" if str1 is None else str1)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))
haxe_Log._hx_class = haxe_Log
_hx_classes["haxe.Log"] = haxe_Log


class haxe_MainEvent:
    _hx_class_name = "haxe.MainEvent"
    _hx_is_interface = "False"
    __slots__ = ("f", "prev", "next", "isBlocking", "nextRun", "priority")
    _hx_fields = ["f", "prev", "next", "isBlocking", "nextRun", "priority"]
    _hx_methods = ["delay", "stop"]

    def __init__(self,f,p):
        self.next = None
        self.prev = None
        self.isBlocking = True
        self.f = f
        self.priority = p
        self.nextRun = Math.NEGATIVE_INFINITY

    def delay(self,t):
        self.nextRun = (Math.NEGATIVE_INFINITY if ((t is None)) else (python_lib_Timeit.default_timer() + t))

    def stop(self):
        if (self.f is None):
            return
        self.f = None
        self.nextRun = Math.NEGATIVE_INFINITY
        if (self.prev is None):
            haxe_MainLoop.pending = self.next
        else:
            self.prev.next = self.next
        if (self.next is not None):
            self.next.prev = self.prev

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.f = None
        _hx_o.prev = None
        _hx_o.next = None
        _hx_o.isBlocking = None
        _hx_o.nextRun = None
        _hx_o.priority = None
haxe_MainEvent._hx_class = haxe_MainEvent
_hx_classes["haxe.MainEvent"] = haxe_MainEvent


class haxe_MainLoop:
    _hx_class_name = "haxe.MainLoop"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["pending", "hasEvents", "add", "sortEvents", "tick"]
    pending = None
    threadCount = None

    @staticmethod
    def hasEvents():
        p = haxe_MainLoop.pending
        while (p is not None):
            if p.isBlocking:
                return True
            p = p.next
        return False

    @staticmethod
    def add(f,priority = None):
        if (priority is None):
            priority = 0
        if (f is None):
            raise _HxException("Event function is null")
        e = haxe_MainEvent(f,priority)
        head = haxe_MainLoop.pending
        if (head is not None):
            head.prev = e
        e.next = head
        haxe_MainLoop.pending = e
        return e

    @staticmethod
    def sortEvents():
        _hx_list = haxe_MainLoop.pending
        if (_hx_list is None):
            return
        insize = 1
        nmerges = None
        psize = 0
        qsize = 0
        p = None
        q = None
        e = None
        tail = None
        while True:
            p = _hx_list
            _hx_list = None
            tail = None
            nmerges = 0
            while (p is not None):
                nmerges = (nmerges + 1)
                q = p
                psize = 0
                _g = 0
                _g1 = insize
                while (_g < _g1):
                    i = _g
                    _g = (_g + 1)
                    psize = (psize + 1)
                    q = q.next
                    if (q is None):
                        break
                qsize = insize
                while ((psize > 0) or (((qsize > 0) and ((q is not None))))):
                    if (psize == 0):
                        e = q
                        q = q.next
                        qsize = (qsize - 1)
                    elif (((qsize == 0) or ((q is None))) or (((p.priority > q.priority) or (((p.priority == q.priority) and ((p.nextRun <= q.nextRun))))))):
                        e = p
                        p = p.next
                        psize = (psize - 1)
                    else:
                        e = q
                        q = q.next
                        qsize = (qsize - 1)
                    if (tail is not None):
                        tail.next = e
                    else:
                        _hx_list = e
                    e.prev = tail
                    tail = e
                p = q
            tail.next = None
            if (nmerges <= 1):
                break
            insize = (insize * 2)
        _hx_list.prev = None
        haxe_MainLoop.pending = _hx_list

    @staticmethod
    def tick():
        haxe_MainLoop.sortEvents()
        e = haxe_MainLoop.pending
        now = python_lib_Timeit.default_timer()
        wait = 1e9
        while (e is not None):
            next = e.next
            wt = (e.nextRun - now)
            if (wt <= 0):
                wait = 0
                if (e.f is not None):
                    e.f()
            elif (wait > wt):
                wait = wt
            e = next
        return wait
haxe_MainLoop._hx_class = haxe_MainLoop
_hx_classes["haxe.MainLoop"] = haxe_MainLoop


class haxe_Resource:
    _hx_class_name = "haxe.Resource"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["content", "getContent", "getBytes"]
    content = None

    @staticmethod
    def getContent():
        if (haxe_Resource.content is None):
            haxe_Resource.content = _hx_resources__()
        return haxe_Resource.content

    @staticmethod
    def getBytes(name):
        data = haxe_Resource.getContent().get(name,None)
        if (data is None):
            return None
        return haxe_io_Bytes.ofData(data)
haxe_Resource._hx_class = haxe_Resource
_hx_classes["haxe.Resource"] = haxe_Resource


class haxe_Serializer:
    _hx_class_name = "haxe.Serializer"
    _hx_is_interface = "False"
    __slots__ = ("buf", "cache", "shash", "scount", "useCache", "useEnumIndex")
    _hx_fields = ["buf", "cache", "shash", "scount", "useCache", "useEnumIndex"]
    _hx_methods = ["toString", "serializeString", "serializeRef", "serializeFields", "serialize"]
    _hx_statics = ["USE_CACHE", "USE_ENUM_INDEX", "BASE64", "BASE64_CODES", "run"]

    def __init__(self):
        self.buf = StringBuf()
        self.cache = list()
        self.useCache = haxe_Serializer.USE_CACHE
        self.useEnumIndex = haxe_Serializer.USE_ENUM_INDEX
        self.shash = haxe_ds_StringMap()
        self.scount = 0

    def toString(self):
        return self.buf.b.getvalue()

    def serializeString(self,s):
        x = self.shash.h.get(s,None)
        if (x is not None):
            self.buf.b.write("R")
            _this = self.buf
            s1 = Std.string(x)
            _this.b.write(s1)
            return
        value = self.scount
        self.scount = (self.scount + 1)
        self.shash.h[s] = value
        self.buf.b.write("y")
        s = python_lib_urllib_Parse.quote(s,"")
        _this1 = self.buf
        s2 = Std.string(len(s))
        _this1.b.write(s2)
        self.buf.b.write(":")
        _this2 = self.buf
        s3 = Std.string(s)
        _this2.b.write(s3)

    def serializeRef(self,v):
        _g = 0
        _g1 = len(self.cache)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if HxOverrides.eq((self.cache[i] if i >= 0 and i < len(self.cache) else None),v):
                self.buf.b.write("r")
                _this = self.buf
                s = Std.string(i)
                _this.b.write(s)
                return True
        _this1 = self.cache
        _this1.append(v)
        return False

    def serializeFields(self,v):
        _g = 0
        _g1 = python_Boot.fields(v)
        while (_g < len(_g1)):
            f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            self.serializeString(f)
            self.serialize(Reflect.field(v,f))
        self.buf.b.write("g")

    def serialize(self,v):
        _g = Type.typeof(v)
        tmp = _g.index
        if (tmp == 0):
            self.buf.b.write("n")
        elif (tmp == 1):
            v1 = v
            if (v1 == 0):
                self.buf.b.write("z")
                return
            self.buf.b.write("i")
            _this = self.buf
            s = Std.string(v1)
            _this.b.write(s)
        elif (tmp == 2):
            v2 = v
            if python_lib_Math.isnan(v2):
                self.buf.b.write("k")
            elif (not ((((v2 != Math.POSITIVE_INFINITY) and ((v2 != Math.NEGATIVE_INFINITY))) and (not python_lib_Math.isnan(v2))))):
                self.buf.b.write(("m" if ((v2 < 0)) else "p"))
            else:
                self.buf.b.write("d")
                _this1 = self.buf
                s1 = Std.string(v2)
                _this1.b.write(s1)
        elif (tmp == 3):
            self.buf.b.write(("t" if v else "f"))
        elif (tmp == 4):
            if Std._hx_is(v,Class):
                className = Type.getClassName(v)
                self.buf.b.write("A")
                self.serializeString(className)
            elif Std._hx_is(v,Enum):
                self.buf.b.write("B")
                self.serializeString(Type.getEnumName(v))
            else:
                if (self.useCache and self.serializeRef(v)):
                    return
                self.buf.b.write("o")
                self.serializeFields(v)
        elif (tmp == 5):
            raise _HxException("Cannot serialize function")
        elif (tmp == 6):
            c = _g.params[0]
            if (c == str):
                self.serializeString(v)
                return
            if (self.useCache and self.serializeRef(v)):
                return
            _g1 = Type.getClassName(c)
            _hx_local_0 = len(_g1)
            if (_hx_local_0 == 17):
                if (_g1 == "haxe.ds.ObjectMap"):
                    self.buf.b.write("M")
                    v6 = v
                    k2 = v6.keys()
                    while k2.hasNext():
                        k3 = k2.next()
                        self.serialize(k3)
                        self.serialize(v6.h.get(k3,None))
                    self.buf.b.write("h")
                elif (_g1 == "haxe.ds.StringMap"):
                    self.buf.b.write("b")
                    v7 = v
                    k4 = v7.keys()
                    while k4.hasNext():
                        k5 = k4.next()
                        self.serializeString(k5)
                        self.serialize(v7.h.get(k5,None))
                    self.buf.b.write("h")
                else:
                    if self.useCache:
                        _this16 = self.cache
                        if (len(_this16) != 0):
                            _this16.pop()
                    if python_Boot.hasField(v,"hxSerialize"):
                        self.buf.b.write("C")
                        self.serializeString(Type.getClassName(c))
                        if self.useCache:
                            _this17 = self.cache
                            _this17.append(v)
                        Reflect.field(v,"hxSerialize")(self)
                        self.buf.b.write("g")
                    else:
                        self.buf.b.write("c")
                        self.serializeString(Type.getClassName(c))
                        if self.useCache:
                            _this18 = self.cache
                            _this18.append(v)
                        self.serializeFields(v)
            elif (_hx_local_0 == 5):
                if (_g1 == "Array"):
                    ucount = 0
                    self.buf.b.write("a")
                    v3 = v
                    l = len(v3)
                    _g2 = 0
                    _g11 = l
                    while (_g2 < _g11):
                        i = _g2
                        _g2 = (_g2 + 1)
                        if ((v3[i] if i >= 0 and i < len(v3) else None) is None):
                            ucount = (ucount + 1)
                        else:
                            if (ucount > 0):
                                if (ucount == 1):
                                    self.buf.b.write("n")
                                else:
                                    self.buf.b.write("u")
                                    _this2 = self.buf
                                    s2 = Std.string(ucount)
                                    _this2.b.write(s2)
                                ucount = 0
                            self.serialize((v3[i] if i >= 0 and i < len(v3) else None))
                    if (ucount > 0):
                        if (ucount == 1):
                            self.buf.b.write("n")
                        else:
                            self.buf.b.write("u")
                            _this3 = self.buf
                            s3 = Std.string(ucount)
                            _this3.b.write(s3)
                    self.buf.b.write("h")
                else:
                    if self.useCache:
                        _this16 = self.cache
                        if (len(_this16) != 0):
                            _this16.pop()
                    if python_Boot.hasField(v,"hxSerialize"):
                        self.buf.b.write("C")
                        self.serializeString(Type.getClassName(c))
                        if self.useCache:
                            _this17 = self.cache
                            _this17.append(v)
                        Reflect.field(v,"hxSerialize")(self)
                        self.buf.b.write("g")
                    else:
                        self.buf.b.write("c")
                        self.serializeString(Type.getClassName(c))
                        if self.useCache:
                            _this18 = self.cache
                            _this18.append(v)
                        self.serializeFields(v)
            elif (_hx_local_0 == 4):
                if (_g1 == "Date"):
                    d = v
                    self.buf.b.write("v")
                    _this4 = self.buf
                    s4 = Std.string((d.date.timestamp() * 1000))
                    _this4.b.write(s4)
                else:
                    if self.useCache:
                        _this16 = self.cache
                        if (len(_this16) != 0):
                            _this16.pop()
                    if python_Boot.hasField(v,"hxSerialize"):
                        self.buf.b.write("C")
                        self.serializeString(Type.getClassName(c))
                        if self.useCache:
                            _this17 = self.cache
                            _this17.append(v)
                        Reflect.field(v,"hxSerialize")(self)
                        self.buf.b.write("g")
                    else:
                        self.buf.b.write("c")
                        self.serializeString(Type.getClassName(c))
                        if self.useCache:
                            _this18 = self.cache
                            _this18.append(v)
                        self.serializeFields(v)
            elif (_hx_local_0 == 12):
                if (_g1 == "haxe.ds.List"):
                    self.buf.b.write("l")
                    v5 = v
                    _g_head = v5.h
                    while (_g_head is not None):
                        val = _g_head.item
                        _g_head = _g_head.next
                        i1 = val
                        self.serialize(i1)
                    self.buf.b.write("h")
                else:
                    if self.useCache:
                        _this16 = self.cache
                        if (len(_this16) != 0):
                            _this16.pop()
                    if python_Boot.hasField(v,"hxSerialize"):
                        self.buf.b.write("C")
                        self.serializeString(Type.getClassName(c))
                        if self.useCache:
                            _this17 = self.cache
                            _this17.append(v)
                        Reflect.field(v,"hxSerialize")(self)
                        self.buf.b.write("g")
                    else:
                        self.buf.b.write("c")
                        self.serializeString(Type.getClassName(c))
                        if self.useCache:
                            _this18 = self.cache
                            _this18.append(v)
                        self.serializeFields(v)
            elif (_hx_local_0 == 13):
                if (_g1 == "haxe.io.Bytes"):
                    v8 = v
                    self.buf.b.write("s")
                    _this6 = self.buf
                    s6 = Std.string(Math.ceil(((v8.length * 8) / 6)))
                    _this6.b.write(s6)
                    self.buf.b.write(":")
                    i2 = 0
                    _hx_max = (v8.length - 2)
                    b64 = haxe_Serializer.BASE64_CODES
                    if (b64 is None):
                        this1 = [None]*len(haxe_Serializer.BASE64)
                        b64 = this1
                        _g3 = 0
                        _g12 = len(haxe_Serializer.BASE64)
                        while (_g3 < _g12):
                            i3 = _g3
                            _g3 = (_g3 + 1)
                            val1 = HxString.charCodeAt(haxe_Serializer.BASE64,i3)
                            b64[i3] = val1
                        haxe_Serializer.BASE64_CODES = b64
                    while (i2 < _hx_max):
                        pos = i2
                        i2 = (i2 + 1)
                        b1 = v8.b[pos]
                        pos1 = i2
                        i2 = (i2 + 1)
                        b2 = v8.b[pos1]
                        pos2 = i2
                        i2 = (i2 + 1)
                        b3 = v8.b[pos2]
                        _this7 = self.buf
                        c1 = b64[(b1 >> 2)]
                        s7 = "".join(map(chr,[c1]))
                        _this7.b.write(s7)
                        _this8 = self.buf
                        c2 = b64[((((b1 << 4) | ((b2 >> 4)))) & 63)]
                        s8 = "".join(map(chr,[c2]))
                        _this8.b.write(s8)
                        _this9 = self.buf
                        c3 = b64[((((b2 << 2) | ((b3 >> 6)))) & 63)]
                        s9 = "".join(map(chr,[c3]))
                        _this9.b.write(s9)
                        _this10 = self.buf
                        c4 = b64[(b3 & 63)]
                        s10 = "".join(map(chr,[c4]))
                        _this10.b.write(s10)
                    if (i2 == _hx_max):
                        pos3 = i2
                        i2 = (i2 + 1)
                        b11 = v8.b[pos3]
                        pos4 = i2
                        i2 = (i2 + 1)
                        b21 = v8.b[pos4]
                        _this11 = self.buf
                        c5 = b64[(b11 >> 2)]
                        s11 = "".join(map(chr,[c5]))
                        _this11.b.write(s11)
                        _this12 = self.buf
                        c6 = b64[((((b11 << 4) | ((b21 >> 4)))) & 63)]
                        s12 = "".join(map(chr,[c6]))
                        _this12.b.write(s12)
                        _this13 = self.buf
                        c7 = b64[((b21 << 2) & 63)]
                        s13 = "".join(map(chr,[c7]))
                        _this13.b.write(s13)
                    elif (i2 == ((_hx_max + 1))):
                        pos5 = i2
                        i2 = (i2 + 1)
                        b12 = v8.b[pos5]
                        _this14 = self.buf
                        c8 = b64[(b12 >> 2)]
                        s14 = "".join(map(chr,[c8]))
                        _this14.b.write(s14)
                        _this15 = self.buf
                        c9 = b64[((b12 << 4) & 63)]
                        s15 = "".join(map(chr,[c9]))
                        _this15.b.write(s15)
                else:
                    if self.useCache:
                        _this16 = self.cache
                        if (len(_this16) != 0):
                            _this16.pop()
                    if python_Boot.hasField(v,"hxSerialize"):
                        self.buf.b.write("C")
                        self.serializeString(Type.getClassName(c))
                        if self.useCache:
                            _this17 = self.cache
                            _this17.append(v)
                        Reflect.field(v,"hxSerialize")(self)
                        self.buf.b.write("g")
                    else:
                        self.buf.b.write("c")
                        self.serializeString(Type.getClassName(c))
                        if self.useCache:
                            _this18 = self.cache
                            _this18.append(v)
                        self.serializeFields(v)
            elif (_hx_local_0 == 14):
                if (_g1 == "haxe.ds.IntMap"):
                    self.buf.b.write("q")
                    v4 = v
                    k = v4.keys()
                    while k.hasNext():
                        k1 = k.next()
                        self.buf.b.write(":")
                        _this5 = self.buf
                        s5 = Std.string(k1)
                        _this5.b.write(s5)
                        self.serialize(v4.h.get(k1,None))
                    self.buf.b.write("h")
                else:
                    if self.useCache:
                        _this16 = self.cache
                        if (len(_this16) != 0):
                            _this16.pop()
                    if python_Boot.hasField(v,"hxSerialize"):
                        self.buf.b.write("C")
                        self.serializeString(Type.getClassName(c))
                        if self.useCache:
                            _this17 = self.cache
                            _this17.append(v)
                        Reflect.field(v,"hxSerialize")(self)
                        self.buf.b.write("g")
                    else:
                        self.buf.b.write("c")
                        self.serializeString(Type.getClassName(c))
                        if self.useCache:
                            _this18 = self.cache
                            _this18.append(v)
                        self.serializeFields(v)
            else:
                if self.useCache:
                    _this16 = self.cache
                    if (len(_this16) != 0):
                        _this16.pop()
                if python_Boot.hasField(v,"hxSerialize"):
                    self.buf.b.write("C")
                    self.serializeString(Type.getClassName(c))
                    if self.useCache:
                        _this17 = self.cache
                        _this17.append(v)
                    Reflect.field(v,"hxSerialize")(self)
                    self.buf.b.write("g")
                else:
                    self.buf.b.write("c")
                    self.serializeString(Type.getClassName(c))
                    if self.useCache:
                        _this18 = self.cache
                        _this18.append(v)
                    self.serializeFields(v)
        elif (tmp == 7):
            e = _g.params[0]
            if self.useCache:
                if self.serializeRef(v):
                    return
                _this19 = self.cache
                if (len(_this19) != 0):
                    _this19.pop()
            _this20 = self.buf
            s16 = Std.string(("j" if (self.useEnumIndex) else "w"))
            _this20.b.write(s16)
            self.serializeString(Type.getEnumName(e))
            if self.useEnumIndex:
                self.buf.b.write(":")
                _this21 = self.buf
                s17 = Std.string(v.index)
                _this21.b.write(s17)
            else:
                self.serializeString(v.tag)
            self.buf.b.write(":")
            arr = list(v.params)
            if (arr is not None):
                _this22 = self.buf
                s18 = Std.string(len(arr))
                _this22.b.write(s18)
                _g4 = 0
                while (_g4 < len(arr)):
                    v9 = (arr[_g4] if _g4 >= 0 and _g4 < len(arr) else None)
                    _g4 = (_g4 + 1)
                    self.serialize(v9)
            else:
                self.buf.b.write("0")
            if self.useCache:
                _this23 = self.cache
                _this23.append(v)
        else:
            raise _HxException(("Cannot serialize " + Std.string(v)))

    @staticmethod
    def run(v):
        s = haxe_Serializer()
        s.serialize(v)
        return s.toString()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.buf = None
        _hx_o.cache = None
        _hx_o.shash = None
        _hx_o.scount = None
        _hx_o.useCache = None
        _hx_o.useEnumIndex = None
haxe_Serializer._hx_class = haxe_Serializer
_hx_classes["haxe.Serializer"] = haxe_Serializer


class haxe_Timer:
    _hx_class_name = "haxe.Timer"
    _hx_is_interface = "False"
    _hx_fields = ["event"]
    _hx_methods = ["stop", "run"]
    _hx_statics = ["delay"]

    def __init__(self,time_ms):
        self.event = None
        _gthis = self
        dt = (time_ms / 1000)
        def _hx_local_2():
            _hx_local_0 = _gthis.event
            _hx_local_1 = _hx_local_0.nextRun
            _hx_local_0.nextRun = (_hx_local_1 + dt)
            _hx_local_0.nextRun
            _gthis.run()
        self.event = haxe_MainLoop.add(_hx_local_2)
        self.event.delay(dt)

    def stop(self):
        if (self.event is not None):
            self.event.stop()
            self.event = None

    def run(self):
        pass

    @staticmethod
    def delay(f,time_ms):
        t = haxe_Timer(time_ms)
        def _hx_local_0():
            t.stop()
            f()
        t.run = _hx_local_0
        return t

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.event = None
haxe_Timer._hx_class = haxe_Timer
_hx_classes["haxe.Timer"] = haxe_Timer


class haxe__Unserializer_DefaultResolver:
    _hx_class_name = "haxe._Unserializer.DefaultResolver"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_methods = ["resolveClass", "resolveEnum"]

    def __init__(self):
        pass

    def resolveClass(self,name):
        return Type.resolveClass(name)

    def resolveEnum(self,name):
        return Type.resolveEnum(name)

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
haxe__Unserializer_DefaultResolver._hx_class = haxe__Unserializer_DefaultResolver
_hx_classes["haxe._Unserializer.DefaultResolver"] = haxe__Unserializer_DefaultResolver


class haxe_Unserializer:
    _hx_class_name = "haxe.Unserializer"
    _hx_is_interface = "False"
    __slots__ = ("buf", "pos", "length", "cache", "scache", "resolver")
    _hx_fields = ["buf", "pos", "length", "cache", "scache", "resolver"]
    _hx_methods = ["readDigits", "readFloat", "unserializeObject", "unserializeEnum", "unserialize"]
    _hx_statics = ["DEFAULT_RESOLVER", "BASE64", "CODES", "initCodes", "run"]

    def __init__(self,buf):
        self.buf = buf
        self.length = len(buf)
        self.pos = 0
        self.scache = list()
        self.cache = list()
        r = haxe_Unserializer.DEFAULT_RESOLVER
        if (r is None):
            r = haxe__Unserializer_DefaultResolver()
            haxe_Unserializer.DEFAULT_RESOLVER = r
        self.resolver = r

    def readDigits(self):
        k = 0
        s = False
        fpos = self.pos
        while True:
            p = self.pos
            s1 = self.buf
            c = (-1 if ((p >= len(s1))) else ord(s1[p]))
            if (c == -1):
                break
            if (c == 45):
                if (self.pos != fpos):
                    break
                s = True
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.pos
                _hx_local_0.pos = (_hx_local_1 + 1)
                _hx_local_1
                continue
            if ((c < 48) or ((c > 57))):
                break
            k = ((k * 10) + ((c - 48)))
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.pos
            _hx_local_2.pos = (_hx_local_3 + 1)
            _hx_local_3
        if s:
            k = (k * -1)
        return k

    def readFloat(self):
        p1 = self.pos
        while True:
            p = self.pos
            s = self.buf
            c = (-1 if ((p >= len(s))) else ord(s[p]))
            if (c == -1):
                break
            if ((((c >= 43) and ((c < 58))) or ((c == 101))) or ((c == 69))):
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.pos
                _hx_local_0.pos = (_hx_local_1 + 1)
                _hx_local_1
            else:
                break
        return Std.parseFloat(HxString.substr(self.buf,p1,(self.pos - p1)))

    def unserializeObject(self,o):
        while True:
            if (self.pos >= self.length):
                raise _HxException("Invalid object")
            p = self.pos
            s = self.buf
            if (((-1 if ((p >= len(s))) else ord(s[p]))) == 103):
                break
            k = self.unserialize()
            if (not Std._hx_is(k,str)):
                raise _HxException("Invalid object key")
            v = self.unserialize()
            field = k
            setattr(o,(("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field)),v)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + 1)
        _hx_local_1

    def unserializeEnum(self,edecl,tag):
        p = self.pos
        self.pos = (self.pos + 1)
        s = self.buf
        if (((-1 if ((p >= len(s))) else ord(s[p]))) != 58):
            raise _HxException("Invalid enum format")
        nargs = self.readDigits()
        if (nargs == 0):
            return Type.createEnum(edecl,tag)
        args = list()
        while True:
            tmp = nargs
            nargs = (nargs - 1)
            if (not ((tmp > 0))):
                break
            x = self.unserialize()
            args.append(x)
        return Type.createEnum(edecl,tag,args)

    def unserialize(self):
        p = self.pos
        self.pos = (self.pos + 1)
        s = self.buf
        _g = (-1 if ((p >= len(s))) else ord(s[p]))
        if (_g == 65):
            name = self.unserialize()
            cl = self.resolver.resolveClass(name)
            if (cl is None):
                raise _HxException(("Class not found " + ("null" if name is None else name)))
            return cl
        elif (_g == 66):
            name1 = self.unserialize()
            e = self.resolver.resolveEnum(name1)
            if (e is None):
                raise _HxException(("Enum not found " + ("null" if name1 is None else name1)))
            return e
        elif (_g == 67):
            name2 = self.unserialize()
            cl1 = self.resolver.resolveClass(name2)
            if (cl1 is None):
                raise _HxException(("Class not found " + ("null" if name2 is None else name2)))
            o = Type.createEmptyInstance(cl1)
            _this = self.cache
            _this.append(o)
            Reflect.field(o,"hxUnserialize")(self)
            p1 = self.pos
            self.pos = (self.pos + 1)
            s1 = self.buf
            if (((-1 if ((p1 >= len(s1))) else ord(s1[p1]))) != 103):
                raise _HxException("Invalid custom data")
            return o
        elif (_g == 77):
            h = haxe_ds_ObjectMap()
            _this1 = self.cache
            _this1.append(h)
            buf = self.buf
            while True:
                p2 = self.pos
                s2 = self.buf
                if (not ((((-1 if ((p2 >= len(s2))) else ord(s2[p2]))) != 104))):
                    break
                s3 = self.unserialize()
                h.set(s3,self.unserialize())
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.pos
            _hx_local_0.pos = (_hx_local_1 + 1)
            _hx_local_1
            return h
        elif (_g == 82):
            n = self.readDigits()
            if ((n < 0) or ((n >= len(self.scache)))):
                raise _HxException("Invalid string reference")
            return (self.scache[n] if n >= 0 and n < len(self.scache) else None)
        elif (_g == 97):
            buf1 = self.buf
            a = list()
            _this2 = self.cache
            _this2.append(a)
            while True:
                p3 = self.pos
                s4 = self.buf
                c = (-1 if ((p3 >= len(s4))) else ord(s4[p3]))
                if (c == 104):
                    _hx_local_2 = self
                    _hx_local_3 = _hx_local_2.pos
                    _hx_local_2.pos = (_hx_local_3 + 1)
                    _hx_local_3
                    break
                if (c == 117):
                    _hx_local_4 = self
                    _hx_local_5 = _hx_local_4.pos
                    _hx_local_4.pos = (_hx_local_5 + 1)
                    _hx_local_5
                    n1 = self.readDigits()
                    python_internal_ArrayImpl._set(a, ((len(a) + n1) - 1), None)
                else:
                    x = self.unserialize()
                    a.append(x)
            return a
        elif (_g == 98):
            h1 = haxe_ds_StringMap()
            _this3 = self.cache
            _this3.append(h1)
            buf2 = self.buf
            while True:
                p4 = self.pos
                s5 = self.buf
                if (not ((((-1 if ((p4 >= len(s5))) else ord(s5[p4]))) != 104))):
                    break
                s6 = self.unserialize()
                value = self.unserialize()
                h1.h[s6] = value
            _hx_local_6 = self
            _hx_local_7 = _hx_local_6.pos
            _hx_local_6.pos = (_hx_local_7 + 1)
            _hx_local_7
            return h1
        elif (_g == 99):
            name3 = self.unserialize()
            cl2 = self.resolver.resolveClass(name3)
            if (cl2 is None):
                raise _HxException(("Class not found " + ("null" if name3 is None else name3)))
            o1 = Type.createEmptyInstance(cl2)
            _this4 = self.cache
            _this4.append(o1)
            self.unserializeObject(o1)
            return o1
        elif (_g == 100):
            return self.readFloat()
        elif (_g == 102):
            return False
        elif (_g == 105):
            return self.readDigits()
        elif (_g == 106):
            name4 = self.unserialize()
            edecl = self.resolver.resolveEnum(name4)
            if (edecl is None):
                raise _HxException(("Enum not found " + ("null" if name4 is None else name4)))
            _hx_local_8 = self
            _hx_local_9 = _hx_local_8.pos
            _hx_local_8.pos = (_hx_local_9 + 1)
            _hx_local_9
            index = self.readDigits()
            tag = python_internal_ArrayImpl._get(Type.getEnumConstructs(edecl), index)
            if (tag is None):
                raise _HxException(((("Unknown enum index " + ("null" if name4 is None else name4)) + "@") + Std.string(index)))
            e1 = self.unserializeEnum(edecl,tag)
            _this5 = self.cache
            _this5.append(e1)
            return e1
        elif (_g == 107):
            return Math.NaN
        elif (_g == 108):
            l = haxe_ds_List()
            _this6 = self.cache
            _this6.append(l)
            buf3 = self.buf
            while True:
                p5 = self.pos
                s7 = self.buf
                if (not ((((-1 if ((p5 >= len(s7))) else ord(s7[p5]))) != 104))):
                    break
                l.add(self.unserialize())
            _hx_local_10 = self
            _hx_local_11 = _hx_local_10.pos
            _hx_local_10.pos = (_hx_local_11 + 1)
            _hx_local_11
            return l
        elif (_g == 109):
            return Math.NEGATIVE_INFINITY
        elif (_g == 110):
            return None
        elif (_g == 111):
            o2 = _hx_AnonObject({})
            _this7 = self.cache
            _this7.append(o2)
            self.unserializeObject(o2)
            return o2
        elif (_g == 112):
            return Math.POSITIVE_INFINITY
        elif (_g == 113):
            h2 = haxe_ds_IntMap()
            _this8 = self.cache
            _this8.append(h2)
            buf4 = self.buf
            p6 = self.pos
            self.pos = (self.pos + 1)
            s8 = self.buf
            c1 = (-1 if ((p6 >= len(s8))) else ord(s8[p6]))
            while (c1 == 58):
                i = self.readDigits()
                h2.set(i,self.unserialize())
                p7 = self.pos
                self.pos = (self.pos + 1)
                s9 = self.buf
                c1 = (-1 if ((p7 >= len(s9))) else ord(s9[p7]))
            if (c1 != 104):
                raise _HxException("Invalid IntMap format")
            return h2
        elif (_g == 114):
            n2 = self.readDigits()
            if ((n2 < 0) or ((n2 >= len(self.cache)))):
                raise _HxException("Invalid reference")
            return (self.cache[n2] if n2 >= 0 and n2 < len(self.cache) else None)
        elif (_g == 115):
            _hx_len = self.readDigits()
            buf5 = self.buf
            p8 = self.pos
            self.pos = (self.pos + 1)
            s10 = self.buf
            if ((((-1 if ((p8 >= len(s10))) else ord(s10[p8]))) != 58) or (((self.length - self.pos) < _hx_len))):
                raise _HxException("Invalid bytes length")
            codes = haxe_Unserializer.CODES
            if (codes is None):
                codes = haxe_Unserializer.initCodes()
                haxe_Unserializer.CODES = codes
            i1 = self.pos
            rest = (_hx_len & 3)
            size = ((((_hx_len >> 2)) * 3) + (((rest - 1) if ((rest >= 2)) else 0)))
            _hx_max = (i1 + ((_hx_len - rest)))
            _hx_bytes = haxe_io_Bytes.alloc(size)
            bpos = 0
            while (i1 < _hx_max):
                index1 = i1
                i1 = (i1 + 1)
                c11 = python_internal_ArrayImpl._get(codes, (-1 if ((index1 >= len(buf5))) else ord(buf5[index1])))
                index2 = i1
                i1 = (i1 + 1)
                c2 = python_internal_ArrayImpl._get(codes, (-1 if ((index2 >= len(buf5))) else ord(buf5[index2])))
                pos = bpos
                bpos = (bpos + 1)
                _hx_bytes.b[pos] = ((((c11 << 2) | ((c2 >> 4)))) & 255)
                index3 = i1
                i1 = (i1 + 1)
                c3 = python_internal_ArrayImpl._get(codes, (-1 if ((index3 >= len(buf5))) else ord(buf5[index3])))
                pos1 = bpos
                bpos = (bpos + 1)
                _hx_bytes.b[pos1] = ((((c2 << 4) | ((c3 >> 2)))) & 255)
                index4 = i1
                i1 = (i1 + 1)
                c4 = python_internal_ArrayImpl._get(codes, (-1 if ((index4 >= len(buf5))) else ord(buf5[index4])))
                pos2 = bpos
                bpos = (bpos + 1)
                _hx_bytes.b[pos2] = ((((c3 << 6) | c4)) & 255)
            if (rest >= 2):
                index5 = i1
                i1 = (i1 + 1)
                c12 = python_internal_ArrayImpl._get(codes, (-1 if ((index5 >= len(buf5))) else ord(buf5[index5])))
                index6 = i1
                i1 = (i1 + 1)
                c21 = python_internal_ArrayImpl._get(codes, (-1 if ((index6 >= len(buf5))) else ord(buf5[index6])))
                pos3 = bpos
                bpos = (bpos + 1)
                _hx_bytes.b[pos3] = ((((c12 << 2) | ((c21 >> 4)))) & 255)
                if (rest == 3):
                    index7 = i1
                    i1 = (i1 + 1)
                    c31 = python_internal_ArrayImpl._get(codes, (-1 if ((index7 >= len(buf5))) else ord(buf5[index7])))
                    pos4 = bpos
                    bpos = (bpos + 1)
                    _hx_bytes.b[pos4] = ((((c21 << 4) | ((c31 >> 2)))) & 255)
            _hx_local_12 = self
            _hx_local_13 = _hx_local_12.pos
            _hx_local_12.pos = (_hx_local_13 + _hx_len)
            _hx_local_12.pos
            _this9 = self.cache
            _this9.append(_hx_bytes)
            return _hx_bytes
        elif (_g == 116):
            return True
        elif (_g == 118):
            d = None
            tmp = None
            tmp1 = None
            tmp2 = None
            tmp3 = None
            tmp4 = None
            tmp5 = None
            tmp6 = None
            tmp7 = None
            p9 = self.pos
            s11 = self.buf
            if (((-1 if ((p9 >= len(s11))) else ord(s11[p9]))) >= 48):
                p10 = self.pos
                s12 = self.buf
                tmp7 = (((-1 if ((p10 >= len(s12))) else ord(s12[p10]))) <= 57)
            else:
                tmp7 = False
            if tmp7:
                p11 = (self.pos + 1)
                s13 = self.buf
                tmp6 = (((-1 if ((p11 >= len(s13))) else ord(s13[p11]))) >= 48)
            else:
                tmp6 = False
            if tmp6:
                p12 = (self.pos + 1)
                s14 = self.buf
                tmp5 = (((-1 if ((p12 >= len(s14))) else ord(s14[p12]))) <= 57)
            else:
                tmp5 = False
            if tmp5:
                p13 = (self.pos + 2)
                s15 = self.buf
                tmp4 = (((-1 if ((p13 >= len(s15))) else ord(s15[p13]))) >= 48)
            else:
                tmp4 = False
            if tmp4:
                p14 = (self.pos + 2)
                s16 = self.buf
                tmp3 = (((-1 if ((p14 >= len(s16))) else ord(s16[p14]))) <= 57)
            else:
                tmp3 = False
            if tmp3:
                p15 = (self.pos + 3)
                s17 = self.buf
                tmp2 = (((-1 if ((p15 >= len(s17))) else ord(s17[p15]))) >= 48)
            else:
                tmp2 = False
            if tmp2:
                p16 = (self.pos + 3)
                s18 = self.buf
                tmp1 = (((-1 if ((p16 >= len(s18))) else ord(s18[p16]))) <= 57)
            else:
                tmp1 = False
            if tmp1:
                p17 = (self.pos + 4)
                s19 = self.buf
                tmp = (((-1 if ((p17 >= len(s19))) else ord(s19[p17]))) == 45)
            else:
                tmp = False
            if tmp:
                d = Date.fromString(HxString.substr(self.buf,self.pos,19))
                _hx_local_14 = self
                _hx_local_15 = _hx_local_14.pos
                _hx_local_14.pos = (_hx_local_15 + 19)
                _hx_local_14.pos
            else:
                d = Date.fromTime(self.readFloat())
            _this10 = self.cache
            _this10.append(d)
            return d
        elif (_g == 119):
            name5 = self.unserialize()
            edecl1 = self.resolver.resolveEnum(name5)
            if (edecl1 is None):
                raise _HxException(("Enum not found " + ("null" if name5 is None else name5)))
            e2 = self.unserializeEnum(edecl1,self.unserialize())
            _this11 = self.cache
            _this11.append(e2)
            return e2
        elif (_g == 120):
            raise _HxException(self.unserialize())
        elif (_g == 121):
            len1 = self.readDigits()
            p18 = self.pos
            self.pos = (self.pos + 1)
            s20 = self.buf
            if ((((-1 if ((p18 >= len(s20))) else ord(s20[p18]))) != 58) or (((self.length - self.pos) < len1))):
                raise _HxException("Invalid string length")
            s21 = HxString.substr(self.buf,self.pos,len1)
            _hx_local_16 = self
            _hx_local_17 = _hx_local_16.pos
            _hx_local_16.pos = (_hx_local_17 + len1)
            _hx_local_16.pos
            s21 = python_lib_urllib_Parse.unquote(s21)
            _this12 = self.scache
            _this12.append(s21)
            return s21
        elif (_g == 122):
            return 0
        else:
            pass
        _hx_local_18 = self
        _hx_local_19 = _hx_local_18.pos
        _hx_local_18.pos = (_hx_local_19 - 1)
        _hx_local_19
        _this13 = self.buf
        index8 = self.pos
        raise _HxException(((("Invalid char " + HxOverrides.stringOrNull((("" if (((index8 < 0) or ((index8 >= len(_this13))))) else _this13[index8])))) + " at position ") + Std.string(self.pos)))

    @staticmethod
    def initCodes():
        codes = list()
        _g = 0
        _g1 = len(haxe_Unserializer.BASE64)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            s = haxe_Unserializer.BASE64
            python_internal_ArrayImpl._set(codes, (-1 if ((i >= len(s))) else ord(s[i])), i)
        return codes

    @staticmethod
    def run(v):
        return haxe_Unserializer(v).unserialize()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.buf = None
        _hx_o.pos = None
        _hx_o.length = None
        _hx_o.cache = None
        _hx_o.scache = None
        _hx_o.resolver = None
haxe_Unserializer._hx_class = haxe_Unserializer
_hx_classes["haxe.Unserializer"] = haxe_Unserializer


class haxe_crypto_Adler32:
    _hx_class_name = "haxe.crypto.Adler32"
    _hx_is_interface = "False"
    __slots__ = ("a1", "a2")
    _hx_fields = ["a1", "a2"]
    _hx_methods = ["update", "equals"]
    _hx_statics = ["read"]

    def __init__(self):
        self.a1 = 1
        self.a2 = 0

    def update(self,b,pos,_hx_len):
        a1 = self.a1
        a2 = self.a2
        _g = pos
        _g1 = (pos + _hx_len)
        while (_g < _g1):
            p = _g
            _g = (_g + 1)
            c = b.b[p]
            a1 = HxOverrides.mod(((a1 + c)), 65521)
            a2 = HxOverrides.mod(((a2 + a1)), 65521)
        self.a1 = a1
        self.a2 = a2

    def equals(self,a):
        if (a.a1 == self.a1):
            return (a.a2 == self.a2)
        else:
            return False

    @staticmethod
    def read(i):
        a = haxe_crypto_Adler32()
        a2a = i.readByte()
        a2b = i.readByte()
        a1a = i.readByte()
        a1b = i.readByte()
        a.a1 = ((a1a << 8) | a1b)
        a.a2 = ((a2a << 8) | a2b)
        return a

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.a1 = None
        _hx_o.a2 = None
haxe_crypto_Adler32._hx_class = haxe_crypto_Adler32
_hx_classes["haxe.crypto.Adler32"] = haxe_crypto_Adler32


class haxe_io_Bytes:
    _hx_class_name = "haxe.io.Bytes"
    _hx_is_interface = "False"
    __slots__ = ("length", "b")
    _hx_fields = ["length", "b"]
    _hx_methods = ["blit", "fill", "sub", "getDouble", "getFloat", "setFloat", "getString", "toString", "toHex"]
    _hx_statics = ["alloc", "ofString", "ofData"]

    def __init__(self,length,b):
        self.length = length
        self.b = b

    def blit(self,pos,src,srcpos,_hx_len):
        if (((((pos < 0) or ((srcpos < 0))) or ((_hx_len < 0))) or (((pos + _hx_len) > self.length))) or (((srcpos + _hx_len) > src.length))):
            raise _HxException(haxe_io_Error.OutsideBounds)
        self.b[pos:pos+_hx_len] = src.b[srcpos:srcpos+_hx_len]

    def fill(self,pos,_hx_len,value):
        _g = 0
        _g1 = _hx_len
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            pos1 = pos
            pos = (pos + 1)
            self.b[pos1] = (value & 255)

    def sub(self,pos,_hx_len):
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > self.length))):
            raise _HxException(haxe_io_Error.OutsideBounds)
        return haxe_io_Bytes(_hx_len,self.b[pos:(pos + _hx_len)])

    def getDouble(self,pos):
        v = (((self.b[pos] | ((self.b[(pos + 1)] << 8))) | ((self.b[(pos + 2)] << 16))) | ((self.b[(pos + 3)] << 24)))
        pos1 = (pos + 4)
        v1 = (((self.b[pos1] | ((self.b[(pos1 + 1)] << 8))) | ((self.b[(pos1 + 2)] << 16))) | ((self.b[(pos1 + 3)] << 24)))
        return haxe_io_FPHelper.i64ToDouble(((v | -2147483648) if ((((v & -2147483648)) != 0)) else v),((v1 | -2147483648) if ((((v1 & -2147483648)) != 0)) else v1))

    def getFloat(self,pos):
        v = (((self.b[pos] | ((self.b[(pos + 1)] << 8))) | ((self.b[(pos + 2)] << 16))) | ((self.b[(pos + 3)] << 24)))
        return haxe_io_FPHelper.i32ToFloat(((v | -2147483648) if ((((v & -2147483648)) != 0)) else v))

    def setFloat(self,pos,v):
        v1 = haxe_io_FPHelper.floatToI32(v)
        self.b[pos] = (v1 & 255)
        self.b[(pos + 1)] = ((v1 >> 8) & 255)
        self.b[(pos + 2)] = ((v1 >> 16) & 255)
        self.b[(pos + 3)] = (HxOverrides.rshift(v1, 24) & 255)

    def getString(self,pos,_hx_len,encoding = None):
        tmp = (encoding is None)
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > self.length))):
            raise _HxException(haxe_io_Error.OutsideBounds)
        return self.b[pos:pos+_hx_len].decode('UTF-8','replace')

    def toString(self):
        return self.getString(0,self.length)

    def toHex(self):
        s_b = python_lib_io_StringIO()
        chars = []
        _hx_str = "0123456789abcdef"
        _g = 0
        _g1 = len(_hx_str)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            x = HxString.charCodeAt(_hx_str,i)
            chars.append(x)
        _g2 = 0
        _g3 = self.length
        while (_g2 < _g3):
            i1 = _g2
            _g2 = (_g2 + 1)
            c = self.b[i1]
            s_b.write("".join(map(chr,[python_internal_ArrayImpl._get(chars, (c >> 4))])))
            s_b.write("".join(map(chr,[python_internal_ArrayImpl._get(chars, (c & 15))])))
        return s_b.getvalue()

    @staticmethod
    def alloc(length):
        return haxe_io_Bytes(length,bytearray(length))

    @staticmethod
    def ofString(s,encoding = None):
        b = bytearray(s,"UTF-8")
        return haxe_io_Bytes(len(b),b)

    @staticmethod
    def ofData(b):
        return haxe_io_Bytes(len(b),b)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.length = None
        _hx_o.b = None
haxe_io_Bytes._hx_class = haxe_io_Bytes
_hx_classes["haxe.io.Bytes"] = haxe_io_Bytes


class haxe_crypto_Base64:
    _hx_class_name = "haxe.crypto.Base64"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["CHARS", "BYTES", "encode", "decode"]

    @staticmethod
    def encode(_hx_bytes,complement = None):
        if (complement is None):
            complement = True
        _hx_str = haxe_crypto_BaseCode(haxe_crypto_Base64.BYTES).encodeBytes(_hx_bytes).toString()
        if complement:
            _g = HxOverrides.mod(_hx_bytes.length, 3)
            if (_g == 1):
                _hx_str = (("null" if _hx_str is None else _hx_str) + "==")
            elif (_g == 2):
                _hx_str = (("null" if _hx_str is None else _hx_str) + "=")
            else:
                pass
        return _hx_str

    @staticmethod
    def decode(_hx_str,complement = None):
        if (complement is None):
            complement = True
        if complement:
            while (HxString.charCodeAt(_hx_str,(len(_hx_str) - 1)) == 61):
                _hx_str = HxString.substr(_hx_str,0,-1)
        return haxe_crypto_BaseCode(haxe_crypto_Base64.BYTES).decodeBytes(haxe_io_Bytes.ofString(_hx_str))
haxe_crypto_Base64._hx_class = haxe_crypto_Base64
_hx_classes["haxe.crypto.Base64"] = haxe_crypto_Base64


class haxe_crypto_BaseCode:
    _hx_class_name = "haxe.crypto.BaseCode"
    _hx_is_interface = "False"
    __slots__ = ("base", "nbits", "tbl")
    _hx_fields = ["base", "nbits", "tbl"]
    _hx_methods = ["encodeBytes", "initTable", "decodeBytes"]

    def __init__(self,base):
        self.tbl = None
        _hx_len = base.length
        nbits = 1
        while (_hx_len > ((1 << nbits))):
            nbits = (nbits + 1)
        if ((nbits > 8) or ((_hx_len != ((1 << nbits))))):
            raise _HxException("BaseCode : base length must be a power of two.")
        self.base = base
        self.nbits = nbits

    def encodeBytes(self,b):
        nbits = self.nbits
        base = self.base
        x = ((b.length * 8) / nbits)
        size = None
        try:
            size = int(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            size = None
        out = haxe_io_Bytes.alloc((size + ((0 if ((HxOverrides.mod((b.length * 8), nbits) == 0)) else 1))))
        buf = 0
        curbits = 0
        mask = (((1 << nbits)) - 1)
        pin = 0
        pout = 0
        while (pout < size):
            while (curbits < nbits):
                curbits = (curbits + 8)
                buf = (buf << 8)
                pos = pin
                pin = (pin + 1)
                buf = (buf | b.b[pos])
            curbits = (curbits - nbits)
            pos1 = pout
            pout = (pout + 1)
            v = base.b[((buf >> curbits) & mask)]
            out.b[pos1] = (v & 255)
        if (curbits > 0):
            pos2 = pout
            pout = (pout + 1)
            v1 = base.b[((buf << ((nbits - curbits))) & mask)]
            out.b[pos2] = (v1 & 255)
        return out

    def initTable(self):
        tbl = list()
        _g = 0
        while (_g < 256):
            i = _g
            _g = (_g + 1)
            python_internal_ArrayImpl._set(tbl, i, -1)
        _g1 = 0
        _g2 = self.base.length
        while (_g1 < _g2):
            i1 = _g1
            _g1 = (_g1 + 1)
            python_internal_ArrayImpl._set(tbl, self.base.b[i1], i1)
        self.tbl = tbl

    def decodeBytes(self,b):
        nbits = self.nbits
        base = self.base
        if (self.tbl is None):
            self.initTable()
        tbl = self.tbl
        size = ((b.length * nbits) >> 3)
        out = haxe_io_Bytes.alloc(size)
        buf = 0
        curbits = 0
        pin = 0
        pout = 0
        while (pout < size):
            while (curbits < 8):
                curbits = (curbits + nbits)
                buf = (buf << nbits)
                pos = pin
                pin = (pin + 1)
                i = python_internal_ArrayImpl._get(tbl, b.b[pos])
                if (i == -1):
                    raise _HxException("BaseCode : invalid encoded char")
                buf = (buf | i)
            curbits = (curbits - 8)
            pos1 = pout
            pout = (pout + 1)
            out.b[pos1] = (((buf >> curbits) & 255) & 255)
        return out

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.base = None
        _hx_o.nbits = None
        _hx_o.tbl = None
haxe_crypto_BaseCode._hx_class = haxe_crypto_BaseCode
_hx_classes["haxe.crypto.BaseCode"] = haxe_crypto_BaseCode


class haxe_crypto_Md5:
    _hx_class_name = "haxe.crypto.Md5"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_methods = ["bitOR", "bitXOR", "bitAND", "addme", "hex", "rol", "cmn", "ff", "gg", "hh", "ii", "doEncode"]
    _hx_statics = ["encode", "str2blks"]

    def __init__(self):
        pass

    def bitOR(self,a,b):
        lsb = ((a & 1) | ((b & 1)))
        msb31 = (HxOverrides.rshift(a, 1) | (HxOverrides.rshift(b, 1)))
        return ((msb31 << 1) | lsb)

    def bitXOR(self,a,b):
        lsb = ((a & 1) ^ ((b & 1)))
        msb31 = (HxOverrides.rshift(a, 1) ^ (HxOverrides.rshift(b, 1)))
        return ((msb31 << 1) | lsb)

    def bitAND(self,a,b):
        lsb = ((a & 1) & ((b & 1)))
        msb31 = (HxOverrides.rshift(a, 1) & (HxOverrides.rshift(b, 1)))
        return ((msb31 << 1) | lsb)

    def addme(self,x,y):
        lsw = (((x & 65535)) + ((y & 65535)))
        msw = ((((x >> 16)) + ((y >> 16))) + ((lsw >> 16)))
        return ((msw << 16) | ((lsw & 65535)))

    def hex(self,a):
        _hx_str = ""
        hex_chr = "0123456789abcdef"
        _g = 0
        while (_g < len(a)):
            num = (a[_g] if _g >= 0 and _g < len(a) else None)
            _g = (_g + 1)
            index = ((num >> 4) & 15)
            index1 = (num & 15)
            _hx_str = (("null" if _hx_str is None else _hx_str) + HxOverrides.stringOrNull(((HxOverrides.stringOrNull((("" if (((index < 0) or ((index >= len(hex_chr))))) else hex_chr[index]))) + HxOverrides.stringOrNull((("" if (((index1 < 0) or ((index1 >= len(hex_chr))))) else hex_chr[index1])))))))
            index2 = ((num >> 12) & 15)
            index3 = ((num >> 8) & 15)
            _hx_str = (("null" if _hx_str is None else _hx_str) + HxOverrides.stringOrNull(((HxOverrides.stringOrNull((("" if (((index2 < 0) or ((index2 >= len(hex_chr))))) else hex_chr[index2]))) + HxOverrides.stringOrNull((("" if (((index3 < 0) or ((index3 >= len(hex_chr))))) else hex_chr[index3])))))))
            index4 = ((num >> 20) & 15)
            index5 = ((num >> 16) & 15)
            _hx_str = (("null" if _hx_str is None else _hx_str) + HxOverrides.stringOrNull(((HxOverrides.stringOrNull((("" if (((index4 < 0) or ((index4 >= len(hex_chr))))) else hex_chr[index4]))) + HxOverrides.stringOrNull((("" if (((index5 < 0) or ((index5 >= len(hex_chr))))) else hex_chr[index5])))))))
            index6 = ((num >> 28) & 15)
            index7 = ((num >> 24) & 15)
            _hx_str = (("null" if _hx_str is None else _hx_str) + HxOverrides.stringOrNull(((HxOverrides.stringOrNull((("" if (((index6 < 0) or ((index6 >= len(hex_chr))))) else hex_chr[index6]))) + HxOverrides.stringOrNull((("" if (((index7 < 0) or ((index7 >= len(hex_chr))))) else hex_chr[index7])))))))
        return _hx_str

    def rol(self,num,cnt):
        return ((num << cnt) | (HxOverrides.rshift(num, ((32 - cnt)))))

    def cmn(self,q,a,b,x,s,t):
        return self.addme(self.rol(self.addme(self.addme(a,q),self.addme(x,t)),s),b)

    def ff(self,a,b,c,d,x,s,t):
        return self.cmn(self.bitOR(self.bitAND(b,c),self.bitAND(~b,d)),a,b,x,s,t)

    def gg(self,a,b,c,d,x,s,t):
        return self.cmn(self.bitOR(self.bitAND(b,d),self.bitAND(c,~d)),a,b,x,s,t)

    def hh(self,a,b,c,d,x,s,t):
        return self.cmn(self.bitXOR(self.bitXOR(b,c),d),a,b,x,s,t)

    def ii(self,a,b,c,d,x,s,t):
        return self.cmn(self.bitXOR(c,self.bitOR(b,~d)),a,b,x,s,t)

    def doEncode(self,x):
        a = 1732584193
        b = -271733879
        c = -1732584194
        d = 271733878
        step = None
        i = 0
        while (i < len(x)):
            olda = a
            oldb = b
            oldc = c
            oldd = d
            step = 0
            a = self.ff(a,b,c,d,(x[i] if i >= 0 and i < len(x) else None),7,-680876936)
            d = self.ff(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 1)),12,-389564586)
            c = self.ff(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 2)),17,606105819)
            b = self.ff(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 3)),22,-1044525330)
            a = self.ff(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 4)),7,-176418897)
            d = self.ff(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 5)),12,1200080426)
            c = self.ff(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 6)),17,-1473231341)
            b = self.ff(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 7)),22,-45705983)
            a = self.ff(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 8)),7,1770035416)
            d = self.ff(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 9)),12,-1958414417)
            c = self.ff(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 10)),17,-42063)
            b = self.ff(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 11)),22,-1990404162)
            a = self.ff(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 12)),7,1804603682)
            d = self.ff(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 13)),12,-40341101)
            c = self.ff(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 14)),17,-1502002290)
            b = self.ff(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 15)),22,1236535329)
            a = self.gg(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 1)),5,-165796510)
            d = self.gg(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 6)),9,-1069501632)
            c = self.gg(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 11)),14,643717713)
            b = self.gg(b,c,d,a,(x[i] if i >= 0 and i < len(x) else None),20,-373897302)
            a = self.gg(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 5)),5,-701558691)
            d = self.gg(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 10)),9,38016083)
            c = self.gg(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 15)),14,-660478335)
            b = self.gg(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 4)),20,-405537848)
            a = self.gg(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 9)),5,568446438)
            d = self.gg(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 14)),9,-1019803690)
            c = self.gg(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 3)),14,-187363961)
            b = self.gg(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 8)),20,1163531501)
            a = self.gg(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 13)),5,-1444681467)
            d = self.gg(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 2)),9,-51403784)
            c = self.gg(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 7)),14,1735328473)
            b = self.gg(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 12)),20,-1926607734)
            a = self.hh(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 5)),4,-378558)
            d = self.hh(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 8)),11,-2022574463)
            c = self.hh(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 11)),16,1839030562)
            b = self.hh(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 14)),23,-35309556)
            a = self.hh(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 1)),4,-1530992060)
            d = self.hh(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 4)),11,1272893353)
            c = self.hh(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 7)),16,-155497632)
            b = self.hh(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 10)),23,-1094730640)
            a = self.hh(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 13)),4,681279174)
            d = self.hh(d,a,b,c,(x[i] if i >= 0 and i < len(x) else None),11,-358537222)
            c = self.hh(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 3)),16,-722521979)
            b = self.hh(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 6)),23,76029189)
            a = self.hh(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 9)),4,-640364487)
            d = self.hh(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 12)),11,-421815835)
            c = self.hh(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 15)),16,530742520)
            b = self.hh(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 2)),23,-995338651)
            a = self.ii(a,b,c,d,(x[i] if i >= 0 and i < len(x) else None),6,-198630844)
            d = self.ii(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 7)),10,1126891415)
            c = self.ii(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 14)),15,-1416354905)
            b = self.ii(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 5)),21,-57434055)
            a = self.ii(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 12)),6,1700485571)
            d = self.ii(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 3)),10,-1894986606)
            c = self.ii(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 10)),15,-1051523)
            b = self.ii(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 1)),21,-2054922799)
            a = self.ii(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 8)),6,1873313359)
            d = self.ii(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 15)),10,-30611744)
            c = self.ii(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 6)),15,-1560198380)
            b = self.ii(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 13)),21,1309151649)
            a = self.ii(a,b,c,d,python_internal_ArrayImpl._get(x, (i + 4)),6,-145523070)
            d = self.ii(d,a,b,c,python_internal_ArrayImpl._get(x, (i + 11)),10,-1120210379)
            c = self.ii(c,d,a,b,python_internal_ArrayImpl._get(x, (i + 2)),15,718787259)
            b = self.ii(b,c,d,a,python_internal_ArrayImpl._get(x, (i + 9)),21,-343485551)
            a = self.addme(a,olda)
            b = self.addme(b,oldb)
            c = self.addme(c,oldc)
            d = self.addme(d,oldd)
            i = (i + 16)
        return [a, b, c, d]

    @staticmethod
    def encode(s):
        m = haxe_crypto_Md5()
        h = m.doEncode(haxe_crypto_Md5.str2blks(s))
        return m.hex(h)

    @staticmethod
    def str2blks(_hx_str):
        str1 = haxe_io_Bytes.ofString(_hx_str)
        nblk = ((((str1.length + 8) >> 6)) + 1)
        blks = list()
        blksSize = (nblk * 16)
        _g = 0
        _g1 = blksSize
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            python_internal_ArrayImpl._set(blks, i, 0)
        i1 = 0
        _hx_max = str1.length
        l = (_hx_max * 8)
        while (i1 < _hx_max):
            _hx_local_0 = blks
            _hx_local_1 = (i1 >> 2)
            _hx_local_2 = (_hx_local_0[_hx_local_1] if _hx_local_1 >= 0 and _hx_local_1 < len(_hx_local_0) else None)
            python_internal_ArrayImpl._set(_hx_local_0, _hx_local_1, (_hx_local_2 | ((str1.b[i1] << ((HxOverrides.mod(((l + i1)), 4) * 8))))))
            (_hx_local_0[_hx_local_1] if _hx_local_1 >= 0 and _hx_local_1 < len(_hx_local_0) else None)
            i1 = (i1 + 1)
        _hx_local_4 = blks
        _hx_local_5 = (i1 >> 2)
        _hx_local_6 = (_hx_local_4[_hx_local_5] if _hx_local_5 >= 0 and _hx_local_5 < len(_hx_local_4) else None)
        python_internal_ArrayImpl._set(_hx_local_4, _hx_local_5, (_hx_local_6 | ((128 << ((HxOverrides.mod(((l + i1)), 4) * 8))))))
        (_hx_local_4[_hx_local_5] if _hx_local_5 >= 0 and _hx_local_5 < len(_hx_local_4) else None)
        k = ((nblk * 16) - 2)
        python_internal_ArrayImpl._set(blks, k, (l & 255))
        python_internal_ArrayImpl._set(blks, k, ((blks[k] if k >= 0 and k < len(blks) else None) | ((((HxOverrides.rshift(l, 8) & 255)) << 8))))
        python_internal_ArrayImpl._set(blks, k, ((blks[k] if k >= 0 and k < len(blks) else None) | ((((HxOverrides.rshift(l, 16) & 255)) << 16))))
        python_internal_ArrayImpl._set(blks, k, ((blks[k] if k >= 0 and k < len(blks) else None) | ((((HxOverrides.rshift(l, 24) & 255)) << 24))))
        return blks

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
haxe_crypto_Md5._hx_class = haxe_crypto_Md5
_hx_classes["haxe.crypto.Md5"] = haxe_crypto_Md5


class haxe_crypto_Sha1:
    _hx_class_name = "haxe.crypto.Sha1"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_methods = ["doEncode", "ft", "kt"]
    _hx_statics = ["make", "bytes2blks"]

    def __init__(self):
        pass

    def doEncode(self,x):
        w = list()
        a = 1732584193
        b = -271733879
        c = -1732584194
        d = 271733878
        e = -1009589776
        i = 0
        while (i < len(x)):
            olda = a
            oldb = b
            oldc = c
            oldd = d
            olde = e
            j = 0
            while (j < 80):
                if (j < 16):
                    python_internal_ArrayImpl._set(w, j, python_internal_ArrayImpl._get(x, (i + j)))
                else:
                    num = (((python_internal_ArrayImpl._get(w, (j - 3)) ^ python_internal_ArrayImpl._get(w, (j - 8))) ^ python_internal_ArrayImpl._get(w, (j - 14))) ^ python_internal_ArrayImpl._get(w, (j - 16)))
                    python_internal_ArrayImpl._set(w, j, ((num << 1) | (HxOverrides.rshift(num, 31))))
                t = (((((((a << 5) | (HxOverrides.rshift(a, 27)))) + self.ft(j,b,c,d)) + e) + (w[j] if j >= 0 and j < len(w) else None)) + self.kt(j))
                e = d
                d = c
                c = ((b << 30) | (HxOverrides.rshift(b, 2)))
                b = a
                a = t
                j = (j + 1)
            a = (a + olda)
            b = (b + oldb)
            c = (c + oldc)
            d = (d + oldd)
            e = (e + olde)
            i = (i + 16)
        return [a, b, c, d, e]

    def ft(self,t,b,c,d):
        if (t < 20):
            return ((b & c) | ((~b & d)))
        if (t < 40):
            return ((b ^ c) ^ d)
        if (t < 60):
            return (((b & c) | ((b & d))) | ((c & d)))
        return ((b ^ c) ^ d)

    def kt(self,t):
        if (t < 20):
            return 1518500249
        if (t < 40):
            return 1859775393
        if (t < 60):
            return -1894007588
        return -899497514

    @staticmethod
    def make(b):
        h = haxe_crypto_Sha1().doEncode(haxe_crypto_Sha1.bytes2blks(b))
        out = haxe_io_Bytes.alloc(20)
        p = 0
        pos = p
        p = (p + 1)
        out.b[pos] = (HxOverrides.rshift((h[0] if 0 < len(h) else None), 24) & 255)
        pos1 = p
        p = (p + 1)
        out.b[pos1] = ((((h[0] if 0 < len(h) else None) >> 16) & 255) & 255)
        pos2 = p
        p = (p + 1)
        out.b[pos2] = ((((h[0] if 0 < len(h) else None) >> 8) & 255) & 255)
        pos3 = p
        p = (p + 1)
        out.b[pos3] = (((h[0] if 0 < len(h) else None) & 255) & 255)
        pos4 = p
        p = (p + 1)
        out.b[pos4] = (HxOverrides.rshift((h[1] if 1 < len(h) else None), 24) & 255)
        pos5 = p
        p = (p + 1)
        out.b[pos5] = ((((h[1] if 1 < len(h) else None) >> 16) & 255) & 255)
        pos6 = p
        p = (p + 1)
        out.b[pos6] = ((((h[1] if 1 < len(h) else None) >> 8) & 255) & 255)
        pos7 = p
        p = (p + 1)
        out.b[pos7] = (((h[1] if 1 < len(h) else None) & 255) & 255)
        pos8 = p
        p = (p + 1)
        out.b[pos8] = (HxOverrides.rshift((h[2] if 2 < len(h) else None), 24) & 255)
        pos9 = p
        p = (p + 1)
        out.b[pos9] = ((((h[2] if 2 < len(h) else None) >> 16) & 255) & 255)
        pos10 = p
        p = (p + 1)
        out.b[pos10] = ((((h[2] if 2 < len(h) else None) >> 8) & 255) & 255)
        pos11 = p
        p = (p + 1)
        out.b[pos11] = (((h[2] if 2 < len(h) else None) & 255) & 255)
        pos12 = p
        p = (p + 1)
        out.b[pos12] = (HxOverrides.rshift((h[3] if 3 < len(h) else None), 24) & 255)
        pos13 = p
        p = (p + 1)
        out.b[pos13] = ((((h[3] if 3 < len(h) else None) >> 16) & 255) & 255)
        pos14 = p
        p = (p + 1)
        out.b[pos14] = ((((h[3] if 3 < len(h) else None) >> 8) & 255) & 255)
        pos15 = p
        p = (p + 1)
        out.b[pos15] = (((h[3] if 3 < len(h) else None) & 255) & 255)
        pos16 = p
        p = (p + 1)
        out.b[pos16] = (HxOverrides.rshift((h[4] if 4 < len(h) else None), 24) & 255)
        pos17 = p
        p = (p + 1)
        out.b[pos17] = ((((h[4] if 4 < len(h) else None) >> 16) & 255) & 255)
        pos18 = p
        p = (p + 1)
        out.b[pos18] = ((((h[4] if 4 < len(h) else None) >> 8) & 255) & 255)
        pos19 = p
        p = (p + 1)
        out.b[pos19] = (((h[4] if 4 < len(h) else None) & 255) & 255)
        return out

    @staticmethod
    def bytes2blks(b):
        nblk = ((((b.length + 8) >> 6)) + 1)
        blks = list()
        _g = 0
        _g1 = (nblk * 16)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            python_internal_ArrayImpl._set(blks, i, 0)
        _g2 = 0
        _g3 = b.length
        while (_g2 < _g3):
            i1 = _g2
            _g2 = (_g2 + 1)
            p = (i1 >> 2)
            python_internal_ArrayImpl._set(blks, p, ((blks[p] if p >= 0 and p < len(blks) else None) | ((b.b[i1] << ((24 - ((((i1 & 3)) << 3))))))))
        i2 = b.length
        p1 = (i2 >> 2)
        python_internal_ArrayImpl._set(blks, p1, ((blks[p1] if p1 >= 0 and p1 < len(blks) else None) | ((128 << ((24 - ((((i2 & 3)) << 3))))))))
        python_internal_ArrayImpl._set(blks, ((nblk * 16) - 1), (b.length * 8))
        return blks

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
haxe_crypto_Sha1._hx_class = haxe_crypto_Sha1
_hx_classes["haxe.crypto.Sha1"] = haxe_crypto_Sha1


class haxe_ds_ArraySort:
    _hx_class_name = "haxe.ds.ArraySort"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["sort", "rec", "doMerge", "rotate", "gcd", "upper", "lower", "swap"]

    @staticmethod
    def sort(a,cmp):
        haxe_ds_ArraySort.rec(a,cmp,0,len(a))

    @staticmethod
    def rec(a,cmp,_hx_from,to):
        middle = ((_hx_from + to) >> 1)
        if ((to - _hx_from) < 12):
            if (to <= _hx_from):
                return
            _g = (_hx_from + 1)
            _g1 = to
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                j = i
                while (j > _hx_from):
                    if (cmp((a[j] if j >= 0 and j < len(a) else None),python_internal_ArrayImpl._get(a, (j - 1))) < 0):
                        haxe_ds_ArraySort.swap(a,(j - 1),j)
                    else:
                        break
                    j = (j - 1)
            return
        haxe_ds_ArraySort.rec(a,cmp,_hx_from,middle)
        haxe_ds_ArraySort.rec(a,cmp,middle,to)
        haxe_ds_ArraySort.doMerge(a,cmp,_hx_from,middle,to,(middle - _hx_from),(to - middle))

    @staticmethod
    def doMerge(a,cmp,_hx_from,pivot,to,len1,len2):
        first_cut = None
        second_cut = None
        len11 = None
        len22 = None
        if ((len1 == 0) or ((len2 == 0))):
            return
        if ((len1 + len2) == 2):
            if (cmp((a[pivot] if pivot >= 0 and pivot < len(a) else None),(a[_hx_from] if _hx_from >= 0 and _hx_from < len(a) else None)) < 0):
                haxe_ds_ArraySort.swap(a,pivot,_hx_from)
            return
        if (len1 > len2):
            len11 = (len1 >> 1)
            first_cut = (_hx_from + len11)
            second_cut = haxe_ds_ArraySort.lower(a,cmp,pivot,to,first_cut)
            len22 = (second_cut - pivot)
        else:
            len22 = (len2 >> 1)
            second_cut = (pivot + len22)
            first_cut = haxe_ds_ArraySort.upper(a,cmp,_hx_from,pivot,second_cut)
            len11 = (first_cut - _hx_from)
        haxe_ds_ArraySort.rotate(a,cmp,first_cut,pivot,second_cut)
        new_mid = (first_cut + len22)
        haxe_ds_ArraySort.doMerge(a,cmp,_hx_from,first_cut,new_mid,len11,len22)
        haxe_ds_ArraySort.doMerge(a,cmp,new_mid,second_cut,to,(len1 - len11),(len2 - len22))

    @staticmethod
    def rotate(a,cmp,_hx_from,mid,to):
        if ((_hx_from == mid) or ((mid == to))):
            return
        n = haxe_ds_ArraySort.gcd((to - _hx_from),(mid - _hx_from))
        while True:
            tmp = n
            n = (n - 1)
            if (not ((tmp != 0))):
                break
            val = python_internal_ArrayImpl._get(a, (_hx_from + n))
            shift = (mid - _hx_from)
            p1 = (_hx_from + n)
            p2 = ((_hx_from + n) + shift)
            while (p2 != ((_hx_from + n))):
                python_internal_ArrayImpl._set(a, p1, (a[p2] if p2 >= 0 and p2 < len(a) else None))
                p1 = p2
                if ((to - p2) > shift):
                    p2 = (p2 + shift)
                else:
                    p2 = (_hx_from + ((shift - ((to - p2)))))
            python_internal_ArrayImpl._set(a, p1, val)

    @staticmethod
    def gcd(m,n):
        while (n != 0):
            t = HxOverrides.mod(m, n)
            m = n
            n = t
        return m

    @staticmethod
    def upper(a,cmp,_hx_from,to,val):
        _hx_len = (to - _hx_from)
        half = None
        mid = None
        while (_hx_len > 0):
            half = (_hx_len >> 1)
            mid = (_hx_from + half)
            if (cmp((a[val] if val >= 0 and val < len(a) else None),(a[mid] if mid >= 0 and mid < len(a) else None)) < 0):
                _hx_len = half
            else:
                _hx_from = (mid + 1)
                _hx_len = ((_hx_len - half) - 1)
        return _hx_from

    @staticmethod
    def lower(a,cmp,_hx_from,to,val):
        _hx_len = (to - _hx_from)
        half = None
        mid = None
        while (_hx_len > 0):
            half = (_hx_len >> 1)
            mid = (_hx_from + half)
            if (cmp((a[mid] if mid >= 0 and mid < len(a) else None),(a[val] if val >= 0 and val < len(a) else None)) < 0):
                _hx_from = (mid + 1)
                _hx_len = ((_hx_len - half) - 1)
            else:
                _hx_len = half
        return _hx_from

    @staticmethod
    def swap(a,i,j):
        tmp = (a[i] if i >= 0 and i < len(a) else None)
        python_internal_ArrayImpl._set(a, i, (a[j] if j >= 0 and j < len(a) else None))
        python_internal_ArrayImpl._set(a, j, tmp)
haxe_ds_ArraySort._hx_class = haxe_ds_ArraySort
_hx_classes["haxe.ds.ArraySort"] = haxe_ds_ArraySort


class haxe_ds_BalancedTree:
    _hx_class_name = "haxe.ds.BalancedTree"
    _hx_is_interface = "False"
    __slots__ = ("root",)
    _hx_fields = ["root"]
    _hx_methods = ["set", "get", "setLoop", "balance", "compare"]
    _hx_interfaces = [haxe_IMap]

    def __init__(self):
        self.root = None

    def set(self,key,value):
        self.root = self.setLoop(key,value,self.root)

    def get(self,key):
        node = self.root
        while (node is not None):
            c = self.compare(key,node.key)
            if (c == 0):
                return node.value
            if (c < 0):
                node = node.left
            else:
                node = node.right
        return None

    def setLoop(self,k,v,node):
        if (node is None):
            return haxe_ds_TreeNode(None,k,v,None)
        c = self.compare(k,node.key)
        if (c == 0):
            return haxe_ds_TreeNode(node.left,k,v,node.right,(0 if ((node is None)) else node._height))
        elif (c < 0):
            nl = self.setLoop(k,v,node.left)
            return self.balance(nl,node.key,node.value,node.right)
        else:
            nr = self.setLoop(k,v,node.right)
            return self.balance(node.left,node.key,node.value,nr)

    def balance(self,l,k,v,r):
        hl = (0 if ((l is None)) else l._height)
        hr = (0 if ((r is None)) else r._height)
        if (hl > ((hr + 2))):
            _this = l.left
            _this1 = l.right
            if (((0 if ((_this is None)) else _this._height)) >= ((0 if ((_this1 is None)) else _this1._height))):
                return haxe_ds_TreeNode(l.left,l.key,l.value,haxe_ds_TreeNode(l.right,k,v,r))
            else:
                return haxe_ds_TreeNode(haxe_ds_TreeNode(l.left,l.key,l.value,l.right.left),l.right.key,l.right.value,haxe_ds_TreeNode(l.right.right,k,v,r))
        elif (hr > ((hl + 2))):
            _this2 = r.right
            _this3 = r.left
            if (((0 if ((_this2 is None)) else _this2._height)) > ((0 if ((_this3 is None)) else _this3._height))):
                return haxe_ds_TreeNode(haxe_ds_TreeNode(l,k,v,r.left),r.key,r.value,r.right)
            else:
                return haxe_ds_TreeNode(haxe_ds_TreeNode(l,k,v,r.left.left),r.left.key,r.left.value,haxe_ds_TreeNode(r.left.right,r.key,r.value,r.right))
        else:
            return haxe_ds_TreeNode(l,k,v,r,(((hl if ((hl > hr)) else hr)) + 1))

    def compare(self,k1,k2):
        return Reflect.compare(k1,k2)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.root = None
haxe_ds_BalancedTree._hx_class = haxe_ds_BalancedTree
_hx_classes["haxe.ds.BalancedTree"] = haxe_ds_BalancedTree


class haxe_ds_TreeNode:
    _hx_class_name = "haxe.ds.TreeNode"
    _hx_is_interface = "False"
    __slots__ = ("left", "right", "key", "value", "_height")
    _hx_fields = ["left", "right", "key", "value", "_height"]

    def __init__(self,l,k,v,r,h = None):
        if (h is None):
            h = -1
        self._height = None
        self.left = l
        self.key = k
        self.value = v
        self.right = r
        if (h == -1):
            tmp = None
            _this = self.left
            _this1 = self.right
            if (((0 if ((_this is None)) else _this._height)) > ((0 if ((_this1 is None)) else _this1._height))):
                _this2 = self.left
                tmp = (0 if ((_this2 is None)) else _this2._height)
            else:
                _this3 = self.right
                tmp = (0 if ((_this3 is None)) else _this3._height)
            self._height = (tmp + 1)
        else:
            self._height = h

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.left = None
        _hx_o.right = None
        _hx_o.key = None
        _hx_o.value = None
        _hx_o._height = None
haxe_ds_TreeNode._hx_class = haxe_ds_TreeNode
_hx_classes["haxe.ds.TreeNode"] = haxe_ds_TreeNode


class haxe_ds_EnumValueMap(haxe_ds_BalancedTree):
    _hx_class_name = "haxe.ds.EnumValueMap"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["compare", "compareArgs", "compareArg"]
    _hx_statics = []
    _hx_interfaces = [haxe_IMap]
    _hx_super = haxe_ds_BalancedTree


    def __init__(self):
        super().__init__()

    def compare(self,k1,k2):
        d = (k1.index - k2.index)
        if (d != 0):
            return d
        p1 = list(k1.params)
        p2 = list(k2.params)
        if ((len(p1) == 0) and ((len(p2) == 0))):
            return 0
        return self.compareArgs(p1,p2)

    def compareArgs(self,a1,a2):
        ld = (len(a1) - len(a2))
        if (ld != 0):
            return ld
        _g = 0
        _g1 = len(a1)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            d = self.compareArg((a1[i] if i >= 0 and i < len(a1) else None),(a2[i] if i >= 0 and i < len(a2) else None))
            if (d != 0):
                return d
        return 0

    def compareArg(self,v1,v2):
        if (Reflect.isEnumValue(v1) and Reflect.isEnumValue(v2)):
            return self.compare(v1,v2)
        elif (Std._hx_is(v1,list) and Std._hx_is(v2,list)):
            return self.compareArgs(v1,v2)
        else:
            return Reflect.compare(v1,v2)

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
haxe_ds_EnumValueMap._hx_class = haxe_ds_EnumValueMap
_hx_classes["haxe.ds.EnumValueMap"] = haxe_ds_EnumValueMap


class haxe_ds_IntMap:
    _hx_class_name = "haxe.ds.IntMap"
    _hx_is_interface = "False"
    __slots__ = ("h",)
    _hx_fields = ["h"]
    _hx_methods = ["set", "remove", "keys", "iterator"]
    _hx_interfaces = [haxe_IMap]

    def __init__(self):
        self.h = dict()

    def set(self,key,value):
        self.h[key] = value

    def remove(self,key):
        if (not (key in self.h)):
            return False
        del self.h[key]
        return True

    def keys(self):
        return python_HaxeIterator(iter(self.h.keys()))

    def iterator(self):
        return python_HaxeIterator(iter(self.h.values()))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.h = None
haxe_ds_IntMap._hx_class = haxe_ds_IntMap
_hx_classes["haxe.ds.IntMap"] = haxe_ds_IntMap


class haxe_ds_List:
    _hx_class_name = "haxe.ds.List"
    _hx_is_interface = "False"
    __slots__ = ("h", "q", "length")
    _hx_fields = ["h", "q", "length"]
    _hx_methods = ["add", "push", "remove"]

    def __init__(self):
        self.q = None
        self.h = None
        self.length = 0

    def add(self,item):
        x = haxe_ds__List_ListNode(item,None)
        if (self.h is None):
            self.h = x
        else:
            self.q.next = x
        self.q = x
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.length
        _hx_local_0.length = (_hx_local_1 + 1)
        _hx_local_1

    def push(self,item):
        x = haxe_ds__List_ListNode(item,self.h)
        self.h = x
        if (self.q is None):
            self.q = x
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.length
        _hx_local_0.length = (_hx_local_1 + 1)
        _hx_local_1

    def remove(self,v):
        prev = None
        l = self.h
        while (l is not None):
            if HxOverrides.eq(l.item,v):
                if (prev is None):
                    self.h = l.next
                else:
                    prev.next = l.next
                if (self.q == l):
                    self.q = prev
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.length
                _hx_local_0.length = (_hx_local_1 - 1)
                _hx_local_1
                return True
            prev = l
            l = l.next
        return False

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.h = None
        _hx_o.q = None
        _hx_o.length = None
haxe_ds_List._hx_class = haxe_ds_List
_hx_classes["haxe.ds.List"] = haxe_ds_List


class haxe_ds__List_ListNode:
    _hx_class_name = "haxe.ds._List.ListNode"
    _hx_is_interface = "False"
    __slots__ = ("item", "next")
    _hx_fields = ["item", "next"]

    def __init__(self,item,next):
        self.item = item
        self.next = next

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.item = None
        _hx_o.next = None
haxe_ds__List_ListNode._hx_class = haxe_ds__List_ListNode
_hx_classes["haxe.ds._List.ListNode"] = haxe_ds__List_ListNode


class haxe_ds_ObjectMap:
    _hx_class_name = "haxe.ds.ObjectMap"
    _hx_is_interface = "False"
    __slots__ = ("h",)
    _hx_fields = ["h"]
    _hx_methods = ["set", "remove", "keys"]
    _hx_interfaces = [haxe_IMap]

    def __init__(self):
        self.h = dict()

    def set(self,key,value):
        self.h[key] = value

    def remove(self,key):
        r = (key in self.h)
        if r:
            del self.h[key]
        return r

    def keys(self):
        return python_HaxeIterator(iter(self.h.keys()))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.h = None
haxe_ds_ObjectMap._hx_class = haxe_ds_ObjectMap
_hx_classes["haxe.ds.ObjectMap"] = haxe_ds_ObjectMap


class haxe_ds__Vector_Vector_Impl_:
    _hx_class_name = "haxe.ds._Vector.Vector_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["blit"]
    length = None

    @staticmethod
    def blit(src,srcPos,dest,destPos,_hx_len):
        if (src is dest):
            if (srcPos < destPos):
                i = (srcPos + _hx_len)
                j = (destPos + _hx_len)
                _g = 0
                _g1 = _hx_len
                while (_g < _g1):
                    k = _g
                    _g = (_g + 1)
                    i = (i - 1)
                    j = (j - 1)
                    val = src[i]
                    src[j] = val
            elif (srcPos > destPos):
                i1 = srcPos
                j1 = destPos
                _g2 = 0
                _g11 = _hx_len
                while (_g2 < _g11):
                    k1 = _g2
                    _g2 = (_g2 + 1)
                    val1 = src[i1]
                    src[j1] = val1
                    i1 = (i1 + 1)
                    j1 = (j1 + 1)
        else:
            _g3 = 0
            _g12 = _hx_len
            while (_g3 < _g12):
                i2 = _g3
                _g3 = (_g3 + 1)
                val2 = src[(srcPos + i2)]
                dest[(destPos + i2)] = val2
haxe_ds__Vector_Vector_Impl_._hx_class = haxe_ds__Vector_Vector_Impl_
_hx_classes["haxe.ds._Vector.Vector_Impl_"] = haxe_ds__Vector_Vector_Impl_


class haxe_format_JsonPrinter:
    _hx_class_name = "haxe.format.JsonPrinter"
    _hx_is_interface = "False"
    __slots__ = ("buf", "replacer", "indent", "pretty", "nind")
    _hx_fields = ["buf", "replacer", "indent", "pretty", "nind"]
    _hx_methods = ["write", "classString", "fieldsString", "quote"]
    _hx_statics = ["print"]

    def __init__(self,replacer,space):
        self.replacer = replacer
        self.indent = space
        self.pretty = (space is not None)
        self.nind = 0
        self.buf = StringBuf()

    def write(self,k,v):
        if (self.replacer is not None):
            v = self.replacer(k,v)
        _g = Type.typeof(v)
        tmp = _g.index
        if (tmp == 0):
            self.buf.b.write("null")
        elif (tmp == 1):
            _this = self.buf
            s = Std.string(v)
            _this.b.write(s)
        elif (tmp == 2):
            f = v
            v1 = (Std.string(v) if ((((f != Math.POSITIVE_INFINITY) and ((f != Math.NEGATIVE_INFINITY))) and (not python_lib_Math.isnan(f)))) else "null")
            _this1 = self.buf
            s1 = Std.string(v1)
            _this1.b.write(s1)
        elif (tmp == 3):
            _this2 = self.buf
            s2 = Std.string(v)
            _this2.b.write(s2)
        elif (tmp == 4):
            self.fieldsString(v,python_Boot.fields(v))
        elif (tmp == 5):
            self.buf.b.write("\"<fun>\"")
        elif (tmp == 6):
            c = _g.params[0]
            if (c == str):
                self.quote(v)
            elif (c == list):
                v2 = v
                _this3 = self.buf
                s3 = "".join(map(chr,[91]))
                _this3.b.write(s3)
                _hx_len = len(v2)
                last = (_hx_len - 1)
                _g1 = 0
                _g11 = _hx_len
                while (_g1 < _g11):
                    i = _g1
                    _g1 = (_g1 + 1)
                    if (i > 0):
                        _this4 = self.buf
                        s4 = "".join(map(chr,[44]))
                        _this4.b.write(s4)
                    else:
                        _hx_local_0 = self
                        _hx_local_1 = _hx_local_0.nind
                        _hx_local_0.nind = (_hx_local_1 + 1)
                        _hx_local_1
                    if self.pretty:
                        _this5 = self.buf
                        s5 = "".join(map(chr,[10]))
                        _this5.b.write(s5)
                    if self.pretty:
                        v3 = StringTools.lpad("",self.indent,(self.nind * len(self.indent)))
                        _this6 = self.buf
                        s6 = Std.string(v3)
                        _this6.b.write(s6)
                    self.write(i,(v2[i] if i >= 0 and i < len(v2) else None))
                    if (i == last):
                        _hx_local_2 = self
                        _hx_local_3 = _hx_local_2.nind
                        _hx_local_2.nind = (_hx_local_3 - 1)
                        _hx_local_3
                        if self.pretty:
                            _this7 = self.buf
                            s7 = "".join(map(chr,[10]))
                            _this7.b.write(s7)
                        if self.pretty:
                            v4 = StringTools.lpad("",self.indent,(self.nind * len(self.indent)))
                            _this8 = self.buf
                            s8 = Std.string(v4)
                            _this8.b.write(s8)
                _this9 = self.buf
                s9 = "".join(map(chr,[93]))
                _this9.b.write(s9)
            elif (c == haxe_ds_StringMap):
                v5 = v
                o = _hx_AnonObject({})
                k1 = v5.keys()
                while k1.hasNext():
                    k2 = k1.next()
                    value = v5.h.get(k2,None)
                    setattr(o,(("_hx_" + k2) if ((k2 in python_Boot.keywords)) else (("_hx_" + k2) if (((((len(k2) > 2) and ((ord(k2[0]) == 95))) and ((ord(k2[1]) == 95))) and ((ord(k2[(len(k2) - 1)]) != 95)))) else k2)),value)
                v6 = o
                self.fieldsString(v6,python_Boot.fields(v6))
            elif (c == Date):
                v7 = v
                self.quote(v7.toString())
            else:
                self.classString(v)
        elif (tmp == 7):
            _g12 = _g.params[0]
            i1 = v.index
            _this10 = self.buf
            s10 = Std.string(i1)
            _this10.b.write(s10)
        elif (tmp == 8):
            self.buf.b.write("\"???\"")
        else:
            pass

    def classString(self,v):
        self.fieldsString(v,python_Boot.getInstanceFields(Type.getClass(v)))

    def fieldsString(self,v,fields):
        _this = self.buf
        s = "".join(map(chr,[123]))
        _this.b.write(s)
        _hx_len = len(fields)
        last = (_hx_len - 1)
        first = True
        _g = 0
        _g1 = _hx_len
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            f = (fields[i] if i >= 0 and i < len(fields) else None)
            value = Reflect.field(v,f)
            if Reflect.isFunction(value):
                continue
            if first:
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.nind
                _hx_local_0.nind = (_hx_local_1 + 1)
                _hx_local_1
                first = False
            else:
                _this1 = self.buf
                s1 = "".join(map(chr,[44]))
                _this1.b.write(s1)
            if self.pretty:
                _this2 = self.buf
                s2 = "".join(map(chr,[10]))
                _this2.b.write(s2)
            if self.pretty:
                v1 = StringTools.lpad("",self.indent,(self.nind * len(self.indent)))
                _this3 = self.buf
                s3 = Std.string(v1)
                _this3.b.write(s3)
            self.quote(f)
            _this4 = self.buf
            s4 = "".join(map(chr,[58]))
            _this4.b.write(s4)
            if self.pretty:
                _this5 = self.buf
                s5 = "".join(map(chr,[32]))
                _this5.b.write(s5)
            self.write(f,value)
            if (i == last):
                _hx_local_2 = self
                _hx_local_3 = _hx_local_2.nind
                _hx_local_2.nind = (_hx_local_3 - 1)
                _hx_local_3
                if self.pretty:
                    _this6 = self.buf
                    s6 = "".join(map(chr,[10]))
                    _this6.b.write(s6)
                if self.pretty:
                    v2 = StringTools.lpad("",self.indent,(self.nind * len(self.indent)))
                    _this7 = self.buf
                    s7 = Std.string(v2)
                    _this7.b.write(s7)
        _this8 = self.buf
        s8 = "".join(map(chr,[125]))
        _this8.b.write(s8)

    def quote(self,s):
        _this = self.buf
        s1 = "".join(map(chr,[34]))
        _this.b.write(s1)
        i = 0
        while True:
            index = i
            i = (i + 1)
            c = (-1 if ((index >= len(s))) else ord(s[index]))
            if (c == -1):
                break
            c1 = c
            if (c1 == 8):
                self.buf.b.write("\\b")
            elif (c1 == 9):
                self.buf.b.write("\\t")
            elif (c1 == 10):
                self.buf.b.write("\\n")
            elif (c1 == 12):
                self.buf.b.write("\\f")
            elif (c1 == 13):
                self.buf.b.write("\\r")
            elif (c1 == 34):
                self.buf.b.write("\\\"")
            elif (c1 == 92):
                self.buf.b.write("\\\\")
            else:
                _this1 = self.buf
                s2 = "".join(map(chr,[c]))
                _this1.b.write(s2)
        _this2 = self.buf
        s3 = "".join(map(chr,[34]))
        _this2.b.write(s3)

    @staticmethod
    def print(o,replacer = None,space = None):
        printer = haxe_format_JsonPrinter(replacer,space)
        printer.write("",o)
        return printer.buf.b.getvalue()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.buf = None
        _hx_o.replacer = None
        _hx_o.indent = None
        _hx_o.pretty = None
        _hx_o.nind = None
haxe_format_JsonPrinter._hx_class = haxe_format_JsonPrinter
_hx_classes["haxe.format.JsonPrinter"] = haxe_format_JsonPrinter


class haxe_io_ArrayBufferViewImpl:
    _hx_class_name = "haxe.io.ArrayBufferViewImpl"
    _hx_is_interface = "False"
    __slots__ = ("bytes", "byteOffset", "byteLength")
    _hx_fields = ["bytes", "byteOffset", "byteLength"]

    def __init__(self,_hx_bytes,pos,length):
        self.bytes = _hx_bytes
        self.byteOffset = pos
        self.byteLength = length

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.bytes = None
        _hx_o.byteOffset = None
        _hx_o.byteLength = None
haxe_io_ArrayBufferViewImpl._hx_class = haxe_io_ArrayBufferViewImpl
_hx_classes["haxe.io.ArrayBufferViewImpl"] = haxe_io_ArrayBufferViewImpl


class haxe_io_BytesBuffer:
    _hx_class_name = "haxe.io.BytesBuffer"
    _hx_is_interface = "False"
    __slots__ = ("b",)
    _hx_fields = ["b"]
    _hx_methods = ["addInt32", "addInt64", "getBytes"]

    def __init__(self):
        self.b = bytearray()

    def addInt32(self,v):
        self.b.append((v & 255))
        self.b.append(((v >> 8) & 255))
        self.b.append(((v >> 16) & 255))
        self.b.append(HxOverrides.rshift(v, 24))

    def addInt64(self,v):
        self.addInt32(v.low)
        self.addInt32(v.high)

    def getBytes(self):
        _hx_bytes = haxe_io_Bytes(len(self.b),self.b)
        self.b = None
        return _hx_bytes

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.b = None
        _hx_o.length = None
haxe_io_BytesBuffer._hx_class = haxe_io_BytesBuffer
_hx_classes["haxe.io.BytesBuffer"] = haxe_io_BytesBuffer


class haxe_io_Input:
    _hx_class_name = "haxe.io.Input"
    _hx_is_interface = "False"
    __slots__ = ("bigEndian",)
    _hx_fields = ["bigEndian"]
    _hx_methods = ["readByte", "readBytes", "set_bigEndian", "readFullBytes", "read", "readUntil", "readFloat", "readDouble", "readInt16", "readUInt16", "readUInt24", "readInt32", "readString"]

    def readByte(self):
        raise _HxException("Not implemented")

    def readBytes(self,s,pos,_hx_len):
        k = _hx_len
        b = s.b
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > s.length))):
            raise _HxException(haxe_io_Error.OutsideBounds)
        try:
            while (k > 0):
                b[pos] = self.readByte()
                pos = (pos + 1)
                k = (k - 1)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            if isinstance(_hx_e1, haxe_io_Eof):
                    pass
            else:
                raise _hx_e
        return (_hx_len - k)

    def set_bigEndian(self,b):
        self.bigEndian = b
        return b

    def readFullBytes(self,s,pos,_hx_len):
        while (_hx_len > 0):
            k = self.readBytes(s,pos,_hx_len)
            if (k == 0):
                raise _HxException(haxe_io_Error.Blocked)
            pos = (pos + k)
            _hx_len = (_hx_len - k)

    def read(self,nbytes):
        s = haxe_io_Bytes.alloc(nbytes)
        p = 0
        while (nbytes > 0):
            k = self.readBytes(s,p,nbytes)
            if (k == 0):
                raise _HxException(haxe_io_Error.Blocked)
            p = (p + k)
            nbytes = (nbytes - k)
        return s

    def readUntil(self,end):
        buf = haxe_io_BytesBuffer()
        last = None
        while True:
            last = self.readByte()
            if (not ((last != end))):
                break
            buf.b.append(last)
        return buf.getBytes().toString()

    def readFloat(self):
        return haxe_io_FPHelper.i32ToFloat(self.readInt32())

    def readDouble(self):
        i1 = self.readInt32()
        i2 = self.readInt32()
        if self.bigEndian:
            return haxe_io_FPHelper.i64ToDouble(i2,i1)
        else:
            return haxe_io_FPHelper.i64ToDouble(i1,i2)

    def readInt16(self):
        ch1 = self.readByte()
        ch2 = self.readByte()
        n = ((ch2 | ((ch1 << 8))) if (self.bigEndian) else (ch1 | ((ch2 << 8))))
        if (((n & 32768)) != 0):
            return (n - 65536)
        return n

    def readUInt16(self):
        ch1 = self.readByte()
        ch2 = self.readByte()
        if self.bigEndian:
            return (ch2 | ((ch1 << 8)))
        else:
            return (ch1 | ((ch2 << 8)))

    def readUInt24(self):
        ch1 = self.readByte()
        ch2 = self.readByte()
        ch3 = self.readByte()
        if self.bigEndian:
            return ((ch3 | ((ch2 << 8))) | ((ch1 << 16)))
        else:
            return ((ch1 | ((ch2 << 8))) | ((ch3 << 16)))

    def readInt32(self):
        ch1 = self.readByte()
        ch2 = self.readByte()
        ch3 = self.readByte()
        ch4 = self.readByte()
        n = ((((ch4 | ((ch3 << 8))) | ((ch2 << 16))) | ((ch1 << 24))) if (self.bigEndian) else (((ch1 | ((ch2 << 8))) | ((ch3 << 16))) | ((ch4 << 24))))
        if (((n & -2147483648)) != 0):
            return (n | -2147483648)
        else:
            return n

    def readString(self,_hx_len,encoding = None):
        b = haxe_io_Bytes.alloc(_hx_len)
        self.readFullBytes(b,0,_hx_len)
        return b.getString(0,_hx_len,encoding)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.bigEndian = None
haxe_io_Input._hx_class = haxe_io_Input
_hx_classes["haxe.io.Input"] = haxe_io_Input


class haxe_io_BytesInput(haxe_io_Input):
    _hx_class_name = "haxe.io.BytesInput"
    _hx_is_interface = "False"
    __slots__ = ("b", "pos", "len", "totlen")
    _hx_fields = ["b", "pos", "len", "totlen"]
    _hx_methods = ["set_position", "readByte", "readBytes"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Input


    def __init__(self,b,pos = None,_hx_len = None):
        if (pos is None):
            pos = 0
        if (_hx_len is None):
            _hx_len = (b.length - pos)
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > b.length))):
            raise _HxException(haxe_io_Error.OutsideBounds)
        self.b = b.b
        self.pos = pos
        self.len = _hx_len
        self.totlen = _hx_len
        self.set_bigEndian(False)

    def set_position(self,p):
        if (p < 0):
            p = 0
        elif (p > self.totlen):
            p = self.totlen
        self.len = (self.totlen - p)
        def _hx_local_1():
            def _hx_local_0():
                self.pos = p
                return self.pos
            return _hx_local_0()
        return _hx_local_1()

    def readByte(self):
        if (self.len == 0):
            raise _HxException(haxe_io_Eof())
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.len
        _hx_local_0.len = (_hx_local_1 - 1)
        _hx_local_1
        b = self.b[self.pos]
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.pos
        _hx_local_2.pos = (_hx_local_3 + 1)
        _hx_local_3
        return b

    def readBytes(self,buf,pos,_hx_len):
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > buf.length))):
            raise _HxException(haxe_io_Error.OutsideBounds)
        if ((self.len == 0) and ((_hx_len > 0))):
            raise _HxException(haxe_io_Eof())
        if (self.len < _hx_len):
            _hx_len = self.len
        b1 = self.b
        b2 = buf.b
        _g = 0
        _g1 = _hx_len
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            b2[(pos + i)] = b1[(self.pos + i)]
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + _hx_len)
        _hx_local_0.pos
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.len
        _hx_local_2.len = (_hx_local_3 - _hx_len)
        _hx_local_2.len
        return _hx_len

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.b = None
        _hx_o.pos = None
        _hx_o.len = None
        _hx_o.totlen = None
        _hx_o.position = None
        _hx_o.length = None
haxe_io_BytesInput._hx_class = haxe_io_BytesInput
_hx_classes["haxe.io.BytesInput"] = haxe_io_BytesInput


class haxe_io_Output:
    _hx_class_name = "haxe.io.Output"
    _hx_is_interface = "False"
    __slots__ = ("bigEndian",)
    _hx_fields = ["bigEndian"]
    _hx_methods = ["writeByte", "writeBytes", "flush", "close", "set_bigEndian", "write", "writeFullBytes", "writeFloat", "writeInt16", "writeUInt16", "writeInt32", "writeString"]

    def writeByte(self,c):
        raise _HxException("Not implemented")

    def writeBytes(self,s,pos,_hx_len):
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > s.length))):
            raise _HxException(haxe_io_Error.OutsideBounds)
        b = s.b
        k = _hx_len
        while (k > 0):
            self.writeByte(b[pos])
            pos = (pos + 1)
            k = (k - 1)
        return _hx_len

    def flush(self):
        pass

    def close(self):
        pass

    def set_bigEndian(self,b):
        self.bigEndian = b
        return b

    def write(self,s):
        l = s.length
        p = 0
        while (l > 0):
            k = self.writeBytes(s,p,l)
            if (k == 0):
                raise _HxException(haxe_io_Error.Blocked)
            p = (p + k)
            l = (l - k)

    def writeFullBytes(self,s,pos,_hx_len):
        while (_hx_len > 0):
            k = self.writeBytes(s,pos,_hx_len)
            pos = (pos + k)
            _hx_len = (_hx_len - k)

    def writeFloat(self,x):
        self.writeInt32(haxe_io_FPHelper.floatToI32(x))

    def writeInt16(self,x):
        if ((x < -32768) or ((x >= 32768))):
            raise _HxException(haxe_io_Error.Overflow)
        self.writeUInt16((x & 65535))

    def writeUInt16(self,x):
        if ((x < 0) or ((x >= 65536))):
            raise _HxException(haxe_io_Error.Overflow)
        if self.bigEndian:
            self.writeByte((x >> 8))
            self.writeByte((x & 255))
        else:
            self.writeByte((x & 255))
            self.writeByte((x >> 8))

    def writeInt32(self,x):
        if self.bigEndian:
            self.writeByte(HxOverrides.rshift(x, 24))
            self.writeByte(((x >> 16) & 255))
            self.writeByte(((x >> 8) & 255))
            self.writeByte((x & 255))
        else:
            self.writeByte((x & 255))
            self.writeByte(((x >> 8) & 255))
            self.writeByte(((x >> 16) & 255))
            self.writeByte(HxOverrides.rshift(x, 24))

    def writeString(self,s,encoding = None):
        b = haxe_io_Bytes.ofString(s,encoding)
        self.writeFullBytes(b,0,b.length)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.bigEndian = None
haxe_io_Output._hx_class = haxe_io_Output
_hx_classes["haxe.io.Output"] = haxe_io_Output


class haxe_io_BytesOutput(haxe_io_Output):
    _hx_class_name = "haxe.io.BytesOutput"
    _hx_is_interface = "False"
    __slots__ = ("b",)
    _hx_fields = ["b"]
    _hx_methods = ["writeByte", "writeBytes", "getBytes"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Output


    def __init__(self):
        self.b = haxe_io_BytesBuffer()
        self.set_bigEndian(False)

    def writeByte(self,c):
        self.b.b.append(c)

    def writeBytes(self,buf,pos,_hx_len):
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > buf.length))):
            raise _HxException(haxe_io_Error.OutsideBounds)
        self.b.b.extend(buf.b[pos:(pos + _hx_len)])
        return _hx_len

    def getBytes(self):
        return self.b.getBytes()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.b = None
        _hx_o.length = None
haxe_io_BytesOutput._hx_class = haxe_io_BytesOutput
_hx_classes["haxe.io.BytesOutput"] = haxe_io_BytesOutput

class haxe_io_Encoding(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.io.Encoding"
    _hx_constructs = ["UTF8", "RawNative"]
haxe_io_Encoding.UTF8 = haxe_io_Encoding("UTF8", 0, ())
haxe_io_Encoding.RawNative = haxe_io_Encoding("RawNative", 1, ())
haxe_io_Encoding._hx_class = haxe_io_Encoding
_hx_classes["haxe.io.Encoding"] = haxe_io_Encoding


class haxe_io_Eof:
    _hx_class_name = "haxe.io.Eof"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_methods = ["toString"]

    def __init__(self):
        pass

    def toString(self):
        return "Eof"

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
haxe_io_Eof._hx_class = haxe_io_Eof
_hx_classes["haxe.io.Eof"] = haxe_io_Eof

class haxe_io_Error(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.io.Error"
    _hx_constructs = ["Blocked", "Overflow", "OutsideBounds", "Custom"]

    @staticmethod
    def Custom(e):
        return haxe_io_Error("Custom", 3, (e,))
haxe_io_Error.Blocked = haxe_io_Error("Blocked", 0, ())
haxe_io_Error.Overflow = haxe_io_Error("Overflow", 1, ())
haxe_io_Error.OutsideBounds = haxe_io_Error("OutsideBounds", 2, ())
haxe_io_Error._hx_class = haxe_io_Error
_hx_classes["haxe.io.Error"] = haxe_io_Error


class haxe_io_FPHelper:
    _hx_class_name = "haxe.io.FPHelper"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["i64tmp", "i32ToFloat", "floatToI32", "i64ToDouble", "doubleToI64"]

    @staticmethod
    def i32ToFloat(i):
        sign = (1 - ((HxOverrides.rshift(i, 31) << 1)))
        e = ((i >> 23) & 255)
        if (e == 255):
            if (((i & 8388607)) == 0):
                if (sign > 0):
                    return Math.POSITIVE_INFINITY
                else:
                    return Math.NEGATIVE_INFINITY
            else:
                return Math.NaN
        else:
            m = ((((i & 8388607)) << 1) if ((e == 0)) else ((i & 8388607) | 8388608))
            return ((sign * m) * Math.pow(2,(e - 150)))

    @staticmethod
    def floatToI32(f):
        if (f == 0):
            return 0
        else:
            af = (-f if ((f < 0)) else f)
            exp = Math.floor((((Math.NEGATIVE_INFINITY if ((af == 0.0)) else (Math.NaN if ((af < 0.0)) else python_lib_Math.log(af)))) / 0.6931471805599453))
            if (exp > 127):
                return 2139095040
            else:
                if (exp <= -127):
                    exp = -127
                    af = (af * 7.1362384635298e+44)
                else:
                    af = ((((af / Math.pow(2,exp)) - 1.0)) * 8388608)
                return ((((-2147483648 if ((f < 0)) else 0)) | (((exp + 127) << 23))) | Math.floor((af + 0.5)))

    @staticmethod
    def i64ToDouble(low,high):
        sign = (1 - ((HxOverrides.rshift(high, 31) << 1)))
        e = ((high >> 20) & 2047)
        if (e == 2047):
            if ((low == 0) and ((((high & 1048575)) == 0))):
                if (sign > 0):
                    return Math.POSITIVE_INFINITY
                else:
                    return Math.NEGATIVE_INFINITY
            else:
                return Math.NaN
        else:
            m = (2.220446049250313e-16 * ((((((high & 1048575)) * 4294967296.) + (((HxOverrides.rshift(low, 31)) * 2147483648.))) + ((low & 2147483647)))))
            if (e == 0):
                m = (m * 2.0)
            else:
                m = (m + 1.0)
            return ((sign * m) * Math.pow(2,(e - 1023)))

    @staticmethod
    def doubleToI64(v):
        i64 = haxe_io_FPHelper.i64tmp
        if (v == 0):
            i64.low = 0
            i64.high = 0
        elif (not ((((v != Math.POSITIVE_INFINITY) and ((v != Math.NEGATIVE_INFINITY))) and (not python_lib_Math.isnan(v))))):
            i64.low = 0
            i64.high = (2146435072 if ((v > 0)) else -1048576)
        else:
            av = (-v if ((v < 0)) else v)
            exp = Math.floor((((Math.NEGATIVE_INFINITY if ((av == 0.0)) else (Math.NaN if ((av < 0.0)) else python_lib_Math.log(av)))) / 0.6931471805599453))
            if (exp > 1023):
                i64.low = -1
                i64.high = 2146435071
            else:
                if (exp <= -1023):
                    exp = -1023
                    av = (av / 2.2250738585072014e-308)
                else:
                    av = ((av / Math.pow(2,exp)) - 1.0)
                v1 = (av * 4503599627370496.)
                sig = (v1 if (((v1 == Math.POSITIVE_INFINITY) or ((v1 == Math.NEGATIVE_INFINITY)))) else (Math.NaN if (python_lib_Math.isnan(v1)) else Math.floor((v1 + 0.5))))
                sig_l = None
                try:
                    sig_l = int(sig)
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e = _hx_e1
                    sig_l = None
                sig_l1 = sig_l
                sig_h = None
                try:
                    sig_h = int((sig / 4294967296.0))
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e1 = _hx_e1
                    sig_h = None
                sig_h1 = sig_h
                i64.low = sig_l1
                i64.high = ((((-2147483648 if ((v < 0)) else 0)) | (((exp + 1023) << 20))) | sig_h1)
        return i64
haxe_io_FPHelper._hx_class = haxe_io_FPHelper
_hx_classes["haxe.io.FPHelper"] = haxe_io_FPHelper


class haxe_io_Path:
    _hx_class_name = "haxe.io.Path"
    _hx_is_interface = "False"
    __slots__ = ("dir", "file", "ext", "backslash")
    _hx_fields = ["dir", "file", "ext", "backslash"]
    _hx_methods = ["toString"]
    _hx_statics = ["directory", "withExtension", "join", "normalize", "addTrailingSlash", "isAbsolute"]

    def __init__(self,path):
        self.backslash = None
        self.ext = None
        self.file = None
        self.dir = None
        path1 = path
        _hx_local_0 = len(path1)
        if (_hx_local_0 == 1):
            if (path1 == "."):
                self.dir = path
                self.file = ""
                return
        elif (_hx_local_0 == 2):
            if (path1 == ".."):
                self.dir = path
                self.file = ""
                return
        else:
            pass
        startIndex = None
        c1 = None
        if (startIndex is None):
            c1 = path.rfind("/", 0, len(path))
        else:
            i = path.rfind("/", 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len("/"))) if ((i == -1)) else (i + 1))
            check = path.find("/", startLeft, len(path))
            c1 = (check if (((check > i) and ((check <= startIndex)))) else i)
        startIndex1 = None
        c2 = None
        if (startIndex1 is None):
            c2 = path.rfind("\\", 0, len(path))
        else:
            i1 = path.rfind("\\", 0, (startIndex1 + 1))
            startLeft1 = (max(0,((startIndex1 + 1) - len("\\"))) if ((i1 == -1)) else (i1 + 1))
            check1 = path.find("\\", startLeft1, len(path))
            c2 = (check1 if (((check1 > i1) and ((check1 <= startIndex1)))) else i1)
        if (c1 < c2):
            self.dir = HxString.substr(path,0,c2)
            path = HxString.substr(path,(c2 + 1),None)
            self.backslash = True
        elif (c2 < c1):
            self.dir = HxString.substr(path,0,c1)
            path = HxString.substr(path,(c1 + 1),None)
        else:
            self.dir = None
        startIndex2 = None
        cp = None
        if (startIndex2 is None):
            cp = path.rfind(".", 0, len(path))
        else:
            i2 = path.rfind(".", 0, (startIndex2 + 1))
            startLeft2 = (max(0,((startIndex2 + 1) - len("."))) if ((i2 == -1)) else (i2 + 1))
            check2 = path.find(".", startLeft2, len(path))
            cp = (check2 if (((check2 > i2) and ((check2 <= startIndex2)))) else i2)
        if (cp != -1):
            self.ext = HxString.substr(path,(cp + 1),None)
            self.file = HxString.substr(path,0,cp)
        else:
            self.ext = None
            self.file = path

    def toString(self):
        return ((HxOverrides.stringOrNull((("" if ((self.dir is None)) else (HxOverrides.stringOrNull(self.dir) + HxOverrides.stringOrNull((("\\" if (self.backslash) else "/"))))))) + HxOverrides.stringOrNull(self.file)) + HxOverrides.stringOrNull((("" if ((self.ext is None)) else ("." + HxOverrides.stringOrNull(self.ext))))))

    @staticmethod
    def directory(path):
        s = haxe_io_Path(path)
        if (s.dir is None):
            return ""
        return s.dir

    @staticmethod
    def withExtension(path,ext):
        s = haxe_io_Path(path)
        s.ext = ext
        return s.toString()

    @staticmethod
    def join(paths):
        def _hx_local_0(s):
            if (s is not None):
                return (s != "")
            else:
                return False
        paths1 = list(filter(_hx_local_0,paths))
        if (len(paths1) == 0):
            return ""
        path = (paths1[0] if 0 < len(paths1) else None)
        _g = 1
        _g1 = len(paths1)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            path = haxe_io_Path.addTrailingSlash(path)
            path = (("null" if path is None else path) + HxOverrides.stringOrNull((paths1[i] if i >= 0 and i < len(paths1) else None)))
        return haxe_io_Path.normalize(path)

    @staticmethod
    def normalize(path):
        slash = "/"
        _this = path.split("\\")
        path = slash.join([python_Boot.toString1(x1,'') for x1 in _this])
        if (path == slash):
            return slash
        target = []
        _g = 0
        _g1 = (list(path) if ((slash == "")) else path.split(slash))
        while (_g < len(_g1)):
            token = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (((token == "..") and ((len(target) > 0))) and ((python_internal_ArrayImpl._get(target, (len(target) - 1)) != ".."))):
                if (len(target) != 0):
                    target.pop()
            elif (token == ""):
                if ((len(target) > 0) or ((HxString.charCodeAt(path,0) == 47))):
                    target.append(token)
            elif (token != "."):
                target.append(token)
        tmp = slash.join([python_Boot.toString1(x1,'') for x1 in target])
        acc_b = python_lib_io_StringIO()
        colon = False
        slashes = False
        _g2 = 0
        _g3 = len(tmp)
        while (_g2 < _g3):
            i = _g2
            _g2 = (_g2 + 1)
            _g21 = (-1 if ((i >= len(tmp))) else ord(tmp[i]))
            _g22 = _g21
            if (_g22 == 47):
                if (not colon):
                    slashes = True
                else:
                    i1 = _g21
                    colon = False
                    if slashes:
                        acc_b.write("/")
                        slashes = False
                    acc_b.write("".join(map(chr,[i1])))
            elif (_g22 == 58):
                acc_b.write(":")
                colon = True
            else:
                i2 = _g21
                colon = False
                if slashes:
                    acc_b.write("/")
                    slashes = False
                acc_b.write("".join(map(chr,[i2])))
        return acc_b.getvalue()

    @staticmethod
    def addTrailingSlash(path):
        if (len(path) == 0):
            return "/"
        startIndex = None
        c1 = None
        if (startIndex is None):
            c1 = path.rfind("/", 0, len(path))
        else:
            i = path.rfind("/", 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len("/"))) if ((i == -1)) else (i + 1))
            check = path.find("/", startLeft, len(path))
            c1 = (check if (((check > i) and ((check <= startIndex)))) else i)
        startIndex1 = None
        c2 = None
        if (startIndex1 is None):
            c2 = path.rfind("\\", 0, len(path))
        else:
            i1 = path.rfind("\\", 0, (startIndex1 + 1))
            startLeft1 = (max(0,((startIndex1 + 1) - len("\\"))) if ((i1 == -1)) else (i1 + 1))
            check1 = path.find("\\", startLeft1, len(path))
            c2 = (check1 if (((check1 > i1) and ((check1 <= startIndex1)))) else i1)
        if (c1 < c2):
            if (c2 != ((len(path) - 1))):
                return (("null" if path is None else path) + "\\")
            else:
                return path
        elif (c1 != ((len(path) - 1))):
            return (("null" if path is None else path) + "/")
        else:
            return path

    @staticmethod
    def isAbsolute(path):
        if path.startswith("/"):
            return True
        if ((("" if ((1 >= len(path))) else path[1])) == ":"):
            return True
        if path.startswith("\\\\"):
            return True
        return False

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.dir = None
        _hx_o.file = None
        _hx_o.ext = None
        _hx_o.backslash = None
haxe_io_Path._hx_class = haxe_io_Path
_hx_classes["haxe.io.Path"] = haxe_io_Path

class haxe_macro_Binop(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.macro.Binop"
    _hx_constructs = ["OpAdd", "OpMult", "OpDiv", "OpSub", "OpAssign", "OpEq", "OpNotEq", "OpGt", "OpGte", "OpLt", "OpLte", "OpAnd", "OpOr", "OpXor", "OpBoolAnd", "OpBoolOr", "OpShl", "OpShr", "OpUShr", "OpMod", "OpAssignOp", "OpInterval", "OpArrow", "OpIn"]

    @staticmethod
    def OpAssignOp(op):
        return haxe_macro_Binop("OpAssignOp", 20, (op,))
haxe_macro_Binop.OpAdd = haxe_macro_Binop("OpAdd", 0, ())
haxe_macro_Binop.OpMult = haxe_macro_Binop("OpMult", 1, ())
haxe_macro_Binop.OpDiv = haxe_macro_Binop("OpDiv", 2, ())
haxe_macro_Binop.OpSub = haxe_macro_Binop("OpSub", 3, ())
haxe_macro_Binop.OpAssign = haxe_macro_Binop("OpAssign", 4, ())
haxe_macro_Binop.OpEq = haxe_macro_Binop("OpEq", 5, ())
haxe_macro_Binop.OpNotEq = haxe_macro_Binop("OpNotEq", 6, ())
haxe_macro_Binop.OpGt = haxe_macro_Binop("OpGt", 7, ())
haxe_macro_Binop.OpGte = haxe_macro_Binop("OpGte", 8, ())
haxe_macro_Binop.OpLt = haxe_macro_Binop("OpLt", 9, ())
haxe_macro_Binop.OpLte = haxe_macro_Binop("OpLte", 10, ())
haxe_macro_Binop.OpAnd = haxe_macro_Binop("OpAnd", 11, ())
haxe_macro_Binop.OpOr = haxe_macro_Binop("OpOr", 12, ())
haxe_macro_Binop.OpXor = haxe_macro_Binop("OpXor", 13, ())
haxe_macro_Binop.OpBoolAnd = haxe_macro_Binop("OpBoolAnd", 14, ())
haxe_macro_Binop.OpBoolOr = haxe_macro_Binop("OpBoolOr", 15, ())
haxe_macro_Binop.OpShl = haxe_macro_Binop("OpShl", 16, ())
haxe_macro_Binop.OpShr = haxe_macro_Binop("OpShr", 17, ())
haxe_macro_Binop.OpUShr = haxe_macro_Binop("OpUShr", 18, ())
haxe_macro_Binop.OpMod = haxe_macro_Binop("OpMod", 19, ())
haxe_macro_Binop.OpInterval = haxe_macro_Binop("OpInterval", 21, ())
haxe_macro_Binop.OpArrow = haxe_macro_Binop("OpArrow", 22, ())
haxe_macro_Binop.OpIn = haxe_macro_Binop("OpIn", 23, ())
haxe_macro_Binop._hx_class = haxe_macro_Binop
_hx_classes["haxe.macro.Binop"] = haxe_macro_Binop

class haxe_macro_Unop(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.macro.Unop"
    _hx_constructs = ["OpIncrement", "OpDecrement", "OpNot", "OpNeg", "OpNegBits"]
haxe_macro_Unop.OpIncrement = haxe_macro_Unop("OpIncrement", 0, ())
haxe_macro_Unop.OpDecrement = haxe_macro_Unop("OpDecrement", 1, ())
haxe_macro_Unop.OpNot = haxe_macro_Unop("OpNot", 2, ())
haxe_macro_Unop.OpNeg = haxe_macro_Unop("OpNeg", 3, ())
haxe_macro_Unop.OpNegBits = haxe_macro_Unop("OpNegBits", 4, ())
haxe_macro_Unop._hx_class = haxe_macro_Unop
_hx_classes["haxe.macro.Unop"] = haxe_macro_Unop


class haxe_xml__Access_NodeAccess_Impl_:
    _hx_class_name = "haxe.xml._Access.NodeAccess_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["resolve"]

    @staticmethod
    def resolve(this1,name):
        x = this1.elementsNamed(name).next()
        if (x is None):
            xname = None
            if (this1.nodeType == Xml.Document):
                xname = "Document"
            else:
                if (this1.nodeType != Xml.Element):
                    raise _HxException(("Bad node type, expected Element but found " + HxOverrides.stringOrNull(_Xml_XmlType_Impl_.toString(this1.nodeType))))
                xname = this1.nodeName
            raise _HxException(((("null" if xname is None else xname) + " is missing element ") + ("null" if name is None else name)))
        if ((x.nodeType != Xml.Document) and ((x.nodeType != Xml.Element))):
            raise _HxException(("Invalid nodeType " + HxOverrides.stringOrNull(_Xml_XmlType_Impl_.toString(x.nodeType))))
        this2 = x
        return this2
haxe_xml__Access_NodeAccess_Impl_._hx_class = haxe_xml__Access_NodeAccess_Impl_
_hx_classes["haxe.xml._Access.NodeAccess_Impl_"] = haxe_xml__Access_NodeAccess_Impl_


class haxe_xml__Access_AttribAccess_Impl_:
    _hx_class_name = "haxe.xml._Access.AttribAccess_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["resolve"]

    @staticmethod
    def resolve(this1,name):
        if (this1.nodeType == Xml.Document):
            raise _HxException(("Cannot access document attribute " + ("null" if name is None else name)))
        v = this1.get(name)
        if (v is None):
            if (this1.nodeType != Xml.Element):
                raise _HxException(("Bad node type, expected Element but found " + HxOverrides.stringOrNull(_Xml_XmlType_Impl_.toString(this1.nodeType))))
            raise _HxException(((HxOverrides.stringOrNull(this1.nodeName) + " is missing attribute ") + ("null" if name is None else name)))
        return v
haxe_xml__Access_AttribAccess_Impl_._hx_class = haxe_xml__Access_AttribAccess_Impl_
_hx_classes["haxe.xml._Access.AttribAccess_Impl_"] = haxe_xml__Access_AttribAccess_Impl_


class haxe_xml__Access_HasNodeAccess_Impl_:
    _hx_class_name = "haxe.xml._Access.HasNodeAccess_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["resolve"]

    @staticmethod
    def resolve(this1,name):
        return this1.elementsNamed(name).hasNext()
haxe_xml__Access_HasNodeAccess_Impl_._hx_class = haxe_xml__Access_HasNodeAccess_Impl_
_hx_classes["haxe.xml._Access.HasNodeAccess_Impl_"] = haxe_xml__Access_HasNodeAccess_Impl_


class haxe_xml__Access_Access_Impl_:
    _hx_class_name = "haxe.xml._Access.Access_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["get_innerData"]
    x = None
    name = None
    innerData = None
    innerHTML = None
    node = None
    nodes = None
    att = None
    has = None
    hasNode = None
    elements = None

    @staticmethod
    def get_innerData(this1):
        if ((this1.nodeType != Xml.Document) and ((this1.nodeType != Xml.Element))):
            raise _HxException(("Bad node type, expected Element or Document but found " + HxOverrides.stringOrNull(_Xml_XmlType_Impl_.toString(this1.nodeType))))
        it = python_HaxeIterator(this1.children.__iter__())
        if (not it.hasNext()):
            tmp = None
            if (this1.nodeType == Xml.Document):
                tmp = "Document"
            else:
                if (this1.nodeType != Xml.Element):
                    raise _HxException(("Bad node type, expected Element but found " + HxOverrides.stringOrNull(_Xml_XmlType_Impl_.toString(this1.nodeType))))
                tmp = this1.nodeName
            raise _HxException((("null" if tmp is None else tmp) + " does not have data"))
        v = it.next()
        if it.hasNext():
            n = it.next()
            tmp1 = None
            if ((v.nodeType == Xml.PCData) and ((n.nodeType == Xml.CData))):
                if ((v.nodeType == Xml.Document) or ((v.nodeType == Xml.Element))):
                    raise _HxException(("Bad node type, unexpected " + HxOverrides.stringOrNull(_Xml_XmlType_Impl_.toString(v.nodeType))))
                tmp1 = (StringTools.trim(v.nodeValue) == "")
            else:
                tmp1 = False
            if tmp1:
                if (not it.hasNext()):
                    if ((n.nodeType == Xml.Document) or ((n.nodeType == Xml.Element))):
                        raise _HxException(("Bad node type, unexpected " + HxOverrides.stringOrNull(_Xml_XmlType_Impl_.toString(n.nodeType))))
                    return n.nodeValue
                n2 = it.next()
                tmp2 = None
                if (n2.nodeType == Xml.PCData):
                    if ((n2.nodeType == Xml.Document) or ((n2.nodeType == Xml.Element))):
                        raise _HxException(("Bad node type, unexpected " + HxOverrides.stringOrNull(_Xml_XmlType_Impl_.toString(n2.nodeType))))
                    tmp2 = (StringTools.trim(n2.nodeValue) == "")
                else:
                    tmp2 = False
                if (tmp2 and (not it.hasNext())):
                    if ((n.nodeType == Xml.Document) or ((n.nodeType == Xml.Element))):
                        raise _HxException(("Bad node type, unexpected " + HxOverrides.stringOrNull(_Xml_XmlType_Impl_.toString(n.nodeType))))
                    return n.nodeValue
            tmp3 = None
            if (this1.nodeType == Xml.Document):
                tmp3 = "Document"
            else:
                if (this1.nodeType != Xml.Element):
                    raise _HxException(("Bad node type, expected Element but found " + HxOverrides.stringOrNull(_Xml_XmlType_Impl_.toString(this1.nodeType))))
                tmp3 = this1.nodeName
            raise _HxException((("null" if tmp3 is None else tmp3) + " does not only have data"))
        if ((v.nodeType != Xml.PCData) and ((v.nodeType != Xml.CData))):
            tmp4 = None
            if (this1.nodeType == Xml.Document):
                tmp4 = "Document"
            else:
                if (this1.nodeType != Xml.Element):
                    raise _HxException(("Bad node type, expected Element but found " + HxOverrides.stringOrNull(_Xml_XmlType_Impl_.toString(this1.nodeType))))
                tmp4 = this1.nodeName
            raise _HxException((("null" if tmp4 is None else tmp4) + " does not have data"))
        if ((v.nodeType == Xml.Document) or ((v.nodeType == Xml.Element))):
            raise _HxException(("Bad node type, unexpected " + HxOverrides.stringOrNull(_Xml_XmlType_Impl_.toString(v.nodeType))))
        return v.nodeValue
haxe_xml__Access_Access_Impl_._hx_class = haxe_xml__Access_Access_Impl_
_hx_classes["haxe.xml._Access.Access_Impl_"] = haxe_xml__Access_Access_Impl_


class haxe_xml_XmlParserException:
    _hx_class_name = "haxe.xml.XmlParserException"
    _hx_is_interface = "False"
    __slots__ = ("message", "lineNumber", "positionAtLine", "position", "xml")
    _hx_fields = ["message", "lineNumber", "positionAtLine", "position", "xml"]
    _hx_methods = ["toString"]

    def __init__(self,message,xml,position):
        self.xml = xml
        self.message = message
        self.position = position
        self.lineNumber = 1
        self.positionAtLine = 0
        _g = 0
        _g1 = position
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            c = (-1 if ((i >= len(xml))) else ord(xml[i]))
            if (c == 10):
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.lineNumber
                _hx_local_0.lineNumber = (_hx_local_1 + 1)
                _hx_local_1
                self.positionAtLine = 0
            elif (c != 13):
                _hx_local_2 = self
                _hx_local_3 = _hx_local_2.positionAtLine
                _hx_local_2.positionAtLine = (_hx_local_3 + 1)
                _hx_local_3

    def toString(self):
        return ((((((HxOverrides.stringOrNull(Type.getClassName(Type.getClass(self))) + ": ") + HxOverrides.stringOrNull(self.message)) + " at line ") + Std.string(self.lineNumber)) + " char ") + Std.string(self.positionAtLine))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.message = None
        _hx_o.lineNumber = None
        _hx_o.positionAtLine = None
        _hx_o.position = None
        _hx_o.xml = None
haxe_xml_XmlParserException._hx_class = haxe_xml_XmlParserException
_hx_classes["haxe.xml.XmlParserException"] = haxe_xml_XmlParserException


class haxe_xml_Parser:
    _hx_class_name = "haxe.xml.Parser"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["escapes", "parse", "doParse"]

    @staticmethod
    def parse(_hx_str,strict = None):
        if (strict is None):
            strict = False
        doc = Xml.createDocument()
        haxe_xml_Parser.doParse(_hx_str,strict,0,doc)
        return doc

    @staticmethod
    def doParse(_hx_str,strict,p = None,parent = None):
        if (p is None):
            p = 0
        xml = None
        state = 1
        next = 1
        aname = None
        start = 0
        nsubs = 0
        nbrackets = 0
        c = (-1 if ((p >= len(_hx_str))) else ord(_hx_str[p]))
        buf = StringBuf()
        escapeNext = 1
        attrValQuote = -1
        while (c != -1):
            state1 = state
            if (state1 == 0):
                c1 = c
                if ((((c1 == 32) or ((c1 == 13))) or ((c1 == 10))) or ((c1 == 9))):
                    pass
                else:
                    state = next
                    continue
            elif (state1 == 1):
                if (c == 60):
                    state = 0
                    next = 2
                else:
                    start = p
                    state = 13
                    continue
            elif (state1 == 2):
                c2 = c
                if (c2 == 33):
                    index = (p + 1)
                    if (((-1 if ((index >= len(_hx_str))) else ord(_hx_str[index]))) == 91):
                        p = (p + 2)
                        if (HxString.substr(_hx_str,p,6).upper() != "CDATA["):
                            raise _HxException(haxe_xml_XmlParserException("Expected <![CDATA[",_hx_str,p))
                        p = (p + 5)
                        state = 17
                        start = (p + 1)
                    else:
                        tmp = None
                        index1 = (p + 1)
                        if (((-1 if ((index1 >= len(_hx_str))) else ord(_hx_str[index1]))) != 68):
                            index2 = (p + 1)
                            tmp = (((-1 if ((index2 >= len(_hx_str))) else ord(_hx_str[index2]))) == 100)
                        else:
                            tmp = True
                        if tmp:
                            if (HxString.substr(_hx_str,(p + 2),6).upper() != "OCTYPE"):
                                raise _HxException(haxe_xml_XmlParserException("Expected <!DOCTYPE",_hx_str,p))
                            p = (p + 8)
                            state = 16
                            start = (p + 1)
                        else:
                            tmp1 = None
                            index3 = (p + 1)
                            if (((-1 if ((index3 >= len(_hx_str))) else ord(_hx_str[index3]))) == 45):
                                index4 = (p + 2)
                                tmp1 = (((-1 if ((index4 >= len(_hx_str))) else ord(_hx_str[index4]))) != 45)
                            else:
                                tmp1 = True
                            if tmp1:
                                raise _HxException(haxe_xml_XmlParserException("Expected <!--",_hx_str,p))
                            else:
                                p = (p + 2)
                                state = 15
                                start = (p + 1)
                elif (c2 == 47):
                    if (parent is None):
                        raise _HxException(haxe_xml_XmlParserException("Expected node name",_hx_str,p))
                    start = (p + 1)
                    state = 0
                    next = 10
                elif (c2 == 63):
                    state = 14
                    start = p
                else:
                    state = 3
                    start = p
                    continue
            elif (state1 == 3):
                if (not (((((((((c >= 97) and ((c <= 122))) or (((c >= 65) and ((c <= 90))))) or (((c >= 48) and ((c <= 57))))) or ((c == 58))) or ((c == 46))) or ((c == 95))) or ((c == 45))))):
                    if (p == start):
                        raise _HxException(haxe_xml_XmlParserException("Expected node name",_hx_str,p))
                    xml = Xml.createElement(HxString.substr(_hx_str,start,(p - start)))
                    parent.addChild(xml)
                    nsubs = (nsubs + 1)
                    state = 0
                    next = 4
                    continue
            elif (state1 == 4):
                c3 = c
                if (c3 == 47):
                    state = 11
                elif (c3 == 62):
                    state = 9
                else:
                    state = 5
                    start = p
                    continue
            elif (state1 == 5):
                if (not (((((((((c >= 97) and ((c <= 122))) or (((c >= 65) and ((c <= 90))))) or (((c >= 48) and ((c <= 57))))) or ((c == 58))) or ((c == 46))) or ((c == 95))) or ((c == 45))))):
                    if (start == p):
                        raise _HxException(haxe_xml_XmlParserException("Expected attribute name",_hx_str,p))
                    tmp2 = HxString.substr(_hx_str,start,(p - start))
                    aname = tmp2
                    if xml.exists(aname):
                        raise _HxException(haxe_xml_XmlParserException((("Duplicate attribute [" + ("null" if aname is None else aname)) + "]"),_hx_str,p))
                    state = 0
                    next = 6
                    continue
            elif (state1 == 6):
                if (c == 61):
                    state = 0
                    next = 7
                else:
                    raise _HxException(haxe_xml_XmlParserException("Expected =",_hx_str,p))
            elif (state1 == 7):
                c4 = c
                if ((c4 == 39) or ((c4 == 34))):
                    buf = StringBuf()
                    state = 8
                    start = (p + 1)
                    attrValQuote = c
                else:
                    raise _HxException(haxe_xml_XmlParserException("Expected \"",_hx_str,p))
            elif (state1 == 8):
                c5 = c
                if (c5 == 38):
                    _hx_len = (p - start)
                    s = (HxString.substr(_hx_str,start,None) if ((_hx_len is None)) else HxString.substr(_hx_str,start,_hx_len))
                    buf.b.write(s)
                    state = 18
                    escapeNext = 8
                    start = (p + 1)
                elif ((c5 == 62) or ((c5 == 60))):
                    if strict:
                        raise _HxException(haxe_xml_XmlParserException((("Invalid unescaped " + HxOverrides.stringOrNull("".join(map(chr,[c])))) + " in attribute value"),_hx_str,p))
                    elif (c == attrValQuote):
                        len1 = (p - start)
                        s1 = (HxString.substr(_hx_str,start,None) if ((len1 is None)) else HxString.substr(_hx_str,start,len1))
                        buf.b.write(s1)
                        val = buf.b.getvalue()
                        buf = StringBuf()
                        xml.set(aname,val)
                        state = 0
                        next = 4
                elif (c == attrValQuote):
                    len2 = (p - start)
                    s2 = (HxString.substr(_hx_str,start,None) if ((len2 is None)) else HxString.substr(_hx_str,start,len2))
                    buf.b.write(s2)
                    val1 = buf.b.getvalue()
                    buf = StringBuf()
                    xml.set(aname,val1)
                    state = 0
                    next = 4
            elif (state1 == 9):
                p = haxe_xml_Parser.doParse(_hx_str,strict,p,xml)
                start = p
                state = 1
            elif (state1 == 10):
                if (not (((((((((c >= 97) and ((c <= 122))) or (((c >= 65) and ((c <= 90))))) or (((c >= 48) and ((c <= 57))))) or ((c == 58))) or ((c == 46))) or ((c == 95))) or ((c == 45))))):
                    if (start == p):
                        raise _HxException(haxe_xml_XmlParserException("Expected node name",_hx_str,p))
                    v = HxString.substr(_hx_str,start,(p - start))
                    if ((parent is None) or ((parent.nodeType != 0))):
                        raise _HxException(haxe_xml_XmlParserException((("Unexpected </" + ("null" if v is None else v)) + ">, tag is not open"),_hx_str,p))
                    if (parent.nodeType != Xml.Element):
                        raise _HxException(("Bad node type, expected Element but found " + HxOverrides.stringOrNull(_Xml_XmlType_Impl_.toString(parent.nodeType))))
                    if (v != parent.nodeName):
                        if (parent.nodeType != Xml.Element):
                            raise _HxException(("Bad node type, expected Element but found " + HxOverrides.stringOrNull(_Xml_XmlType_Impl_.toString(parent.nodeType))))
                        raise _HxException(haxe_xml_XmlParserException((("Expected </" + HxOverrides.stringOrNull(parent.nodeName)) + ">"),_hx_str,p))
                    state = 0
                    next = 12
                    continue
            elif (state1 == 11):
                if (c == 62):
                    state = 1
                else:
                    raise _HxException(haxe_xml_XmlParserException("Expected >",_hx_str,p))
            elif (state1 == 12):
                if (c == 62):
                    if (nsubs == 0):
                        parent.addChild(Xml.createPCData(""))
                    return p
                else:
                    raise _HxException(haxe_xml_XmlParserException("Expected >",_hx_str,p))
            elif (state1 == 13):
                if (c == 60):
                    len3 = (p - start)
                    s3 = (HxString.substr(_hx_str,start,None) if ((len3 is None)) else HxString.substr(_hx_str,start,len3))
                    buf.b.write(s3)
                    child = Xml.createPCData(buf.b.getvalue())
                    buf = StringBuf()
                    parent.addChild(child)
                    nsubs = (nsubs + 1)
                    state = 0
                    next = 2
                elif (c == 38):
                    len4 = (p - start)
                    s4 = (HxString.substr(_hx_str,start,None) if ((len4 is None)) else HxString.substr(_hx_str,start,len4))
                    buf.b.write(s4)
                    state = 18
                    escapeNext = 13
                    start = (p + 1)
            elif (state1 == 14):
                tmp3 = None
                if (c == 63):
                    index5 = (p + 1)
                    tmp3 = (((-1 if ((index5 >= len(_hx_str))) else ord(_hx_str[index5]))) == 62)
                else:
                    tmp3 = False
                if tmp3:
                    p = (p + 1)
                    str1 = HxString.substr(_hx_str,(start + 1),((p - start) - 2))
                    parent.addChild(Xml.createProcessingInstruction(str1))
                    nsubs = (nsubs + 1)
                    state = 1
            elif (state1 == 15):
                tmp4 = None
                tmp5 = None
                if (c == 45):
                    index6 = (p + 1)
                    tmp5 = (((-1 if ((index6 >= len(_hx_str))) else ord(_hx_str[index6]))) == 45)
                else:
                    tmp5 = False
                if tmp5:
                    index7 = (p + 2)
                    tmp4 = (((-1 if ((index7 >= len(_hx_str))) else ord(_hx_str[index7]))) == 62)
                else:
                    tmp4 = False
                if tmp4:
                    parent.addChild(Xml.createComment(HxString.substr(_hx_str,start,(p - start))))
                    nsubs = (nsubs + 1)
                    p = (p + 2)
                    state = 1
            elif (state1 == 16):
                if (c == 91):
                    nbrackets = (nbrackets + 1)
                elif (c == 93):
                    nbrackets = (nbrackets - 1)
                elif ((c == 62) and ((nbrackets == 0))):
                    parent.addChild(Xml.createDocType(HxString.substr(_hx_str,start,(p - start))))
                    nsubs = (nsubs + 1)
                    state = 1
            elif (state1 == 17):
                tmp6 = None
                tmp7 = None
                if (c == 93):
                    index8 = (p + 1)
                    tmp7 = (((-1 if ((index8 >= len(_hx_str))) else ord(_hx_str[index8]))) == 93)
                else:
                    tmp7 = False
                if tmp7:
                    index9 = (p + 2)
                    tmp6 = (((-1 if ((index9 >= len(_hx_str))) else ord(_hx_str[index9]))) == 62)
                else:
                    tmp6 = False
                if tmp6:
                    child1 = Xml.createCData(HxString.substr(_hx_str,start,(p - start)))
                    parent.addChild(child1)
                    nsubs = (nsubs + 1)
                    p = (p + 2)
                    state = 1
            elif (state1 == 18):
                if (c == 59):
                    s5 = HxString.substr(_hx_str,start,(p - start))
                    if (((-1 if ((0 >= len(s5))) else ord(s5[0]))) == 35):
                        c6 = (Std.parseInt(("0" + HxOverrides.stringOrNull(HxString.substr(s5,1,(len(s5) - 1))))) if ((((-1 if ((1 >= len(s5))) else ord(s5[1]))) == 120)) else Std.parseInt(HxString.substr(s5,1,(len(s5) - 1))))
                        s6 = "".join(map(chr,[c6]))
                        buf.b.write(s6)
                    elif (not (s5 in haxe_xml_Parser.escapes.h)):
                        if strict:
                            raise _HxException(haxe_xml_XmlParserException(("Undefined entity: " + ("null" if s5 is None else s5)),_hx_str,p))
                        s7 = Std.string((("&" + ("null" if s5 is None else s5)) + ";"))
                        buf.b.write(s7)
                    else:
                        s8 = Std.string(haxe_xml_Parser.escapes.h.get(s5,None))
                        buf.b.write(s8)
                    start = (p + 1)
                    state = escapeNext
                elif ((not (((((((((c >= 97) and ((c <= 122))) or (((c >= 65) and ((c <= 90))))) or (((c >= 48) and ((c <= 57))))) or ((c == 58))) or ((c == 46))) or ((c == 95))) or ((c == 45))))) and ((c != 35))):
                    if strict:
                        raise _HxException(haxe_xml_XmlParserException(("Invalid character in entity: " + HxOverrides.stringOrNull("".join(map(chr,[c])))),_hx_str,p))
                    s9 = "".join(map(chr,[38]))
                    buf.b.write(s9)
                    len5 = (p - start)
                    s10 = (HxString.substr(_hx_str,start,None) if ((len5 is None)) else HxString.substr(_hx_str,start,len5))
                    buf.b.write(s10)
                    p = (p - 1)
                    start = (p + 1)
                    state = escapeNext
            else:
                pass
            p = (p + 1)
            index10 = p
            c = (-1 if ((index10 >= len(_hx_str))) else ord(_hx_str[index10]))
        if (state == 1):
            start = p
            state = 13
        if (state == 13):
            if (parent.nodeType == 0):
                if (parent.nodeType != Xml.Element):
                    raise _HxException(("Bad node type, expected Element but found " + HxOverrides.stringOrNull(_Xml_XmlType_Impl_.toString(parent.nodeType))))
                raise _HxException(haxe_xml_XmlParserException((("Unclosed node <" + HxOverrides.stringOrNull(parent.nodeName)) + ">"),_hx_str,p))
            if ((p != start) or ((nsubs == 0))):
                len6 = (p - start)
                s11 = (HxString.substr(_hx_str,start,None) if ((len6 is None)) else HxString.substr(_hx_str,start,len6))
                buf.b.write(s11)
                parent.addChild(Xml.createPCData(buf.b.getvalue()))
                nsubs = (nsubs + 1)
            return p
        if (((not strict) and ((state == 18))) and ((escapeNext == 13))):
            s12 = "".join(map(chr,[38]))
            buf.b.write(s12)
            len7 = (p - start)
            s13 = (HxString.substr(_hx_str,start,None) if ((len7 is None)) else HxString.substr(_hx_str,start,len7))
            buf.b.write(s13)
            parent.addChild(Xml.createPCData(buf.b.getvalue()))
            nsubs = (nsubs + 1)
            return p
        raise _HxException(haxe_xml_XmlParserException("Unexpected end",_hx_str,p))
haxe_xml_Parser._hx_class = haxe_xml_Parser
_hx_classes["haxe.xml.Parser"] = haxe_xml_Parser


class haxe_xml_Printer:
    _hx_class_name = "haxe.xml.Printer"
    _hx_is_interface = "False"
    __slots__ = ("output", "pretty")
    _hx_fields = ["output", "pretty"]
    _hx_methods = ["writeNode", "hasChildren"]
    _hx_statics = ["print"]

    def __init__(self,pretty):
        self.output = StringBuf()
        self.pretty = pretty

    def writeNode(self,value,tabs):
        _g = value.nodeType
        if (_g == 0):
            _this = self.output
            s = Std.string((("null" if tabs is None else tabs) + "<"))
            _this.b.write(s)
            if (value.nodeType != Xml.Element):
                raise _HxException(("Bad node type, expected Element but found " + HxOverrides.stringOrNull(_Xml_XmlType_Impl_.toString(value.nodeType))))
            _this1 = self.output
            s1 = Std.string(value.nodeName)
            _this1.b.write(s1)
            attribute = value.attributes()
            while attribute.hasNext():
                attribute1 = attribute.next()
                _this2 = self.output
                s2 = Std.string(((" " + ("null" if attribute1 is None else attribute1)) + "=\""))
                _this2.b.write(s2)
                input = StringTools.htmlEscape(value.get(attribute1),True)
                _this3 = self.output
                s3 = Std.string(input)
                _this3.b.write(s3)
                self.output.b.write("\"")
            if self.hasChildren(value):
                self.output.b.write(">")
                if self.pretty:
                    self.output.b.write("\n")
                if ((value.nodeType != Xml.Document) and ((value.nodeType != Xml.Element))):
                    raise _HxException(("Bad node type, expected Element or Document but found " + HxOverrides.stringOrNull(_Xml_XmlType_Impl_.toString(value.nodeType))))
                child = python_HaxeIterator(value.children.__iter__())
                while child.hasNext():
                    child1 = child.next()
                    self.writeNode(child1,((("null" if tabs is None else tabs) + "\t") if (self.pretty) else tabs))
                _this4 = self.output
                s4 = Std.string((("null" if tabs is None else tabs) + "</"))
                _this4.b.write(s4)
                if (value.nodeType != Xml.Element):
                    raise _HxException(("Bad node type, expected Element but found " + HxOverrides.stringOrNull(_Xml_XmlType_Impl_.toString(value.nodeType))))
                _this5 = self.output
                s5 = Std.string(value.nodeName)
                _this5.b.write(s5)
                self.output.b.write(">")
                if self.pretty:
                    self.output.b.write("\n")
            else:
                self.output.b.write("/>")
                if self.pretty:
                    self.output.b.write("\n")
        elif (_g == 1):
            if ((value.nodeType == Xml.Document) or ((value.nodeType == Xml.Element))):
                raise _HxException(("Bad node type, unexpected " + HxOverrides.stringOrNull(_Xml_XmlType_Impl_.toString(value.nodeType))))
            nodeValue = value.nodeValue
            if (len(nodeValue) != 0):
                input1 = (("null" if tabs is None else tabs) + HxOverrides.stringOrNull(StringTools.htmlEscape(nodeValue)))
                _this6 = self.output
                s6 = Std.string(input1)
                _this6.b.write(s6)
                if self.pretty:
                    self.output.b.write("\n")
        elif (_g == 2):
            _this7 = self.output
            s7 = Std.string((("null" if tabs is None else tabs) + "<![CDATA["))
            _this7.b.write(s7)
            if ((value.nodeType == Xml.Document) or ((value.nodeType == Xml.Element))):
                raise _HxException(("Bad node type, unexpected " + HxOverrides.stringOrNull(_Xml_XmlType_Impl_.toString(value.nodeType))))
            _this8 = self.output
            s8 = Std.string(value.nodeValue)
            _this8.b.write(s8)
            self.output.b.write("]]>")
            if self.pretty:
                self.output.b.write("\n")
        elif (_g == 3):
            if ((value.nodeType == Xml.Document) or ((value.nodeType == Xml.Element))):
                raise _HxException(("Bad node type, unexpected " + HxOverrides.stringOrNull(_Xml_XmlType_Impl_.toString(value.nodeType))))
            commentContent = value.nodeValue
            commentContent = EReg("[\n\r\t]+","g").replace(commentContent,"")
            commentContent = (("<!--" + ("null" if commentContent is None else commentContent)) + "-->")
            _this9 = self.output
            s9 = Std.string(tabs)
            _this9.b.write(s9)
            input2 = StringTools.trim(commentContent)
            _this10 = self.output
            s10 = Std.string(input2)
            _this10.b.write(s10)
            if self.pretty:
                self.output.b.write("\n")
        elif (_g == 4):
            if ((value.nodeType == Xml.Document) or ((value.nodeType == Xml.Element))):
                raise _HxException(("Bad node type, unexpected " + HxOverrides.stringOrNull(_Xml_XmlType_Impl_.toString(value.nodeType))))
            _this11 = self.output
            s11 = Std.string((("<!DOCTYPE " + HxOverrides.stringOrNull(value.nodeValue)) + ">"))
            _this11.b.write(s11)
            if self.pretty:
                self.output.b.write("\n")
        elif (_g == 5):
            if ((value.nodeType == Xml.Document) or ((value.nodeType == Xml.Element))):
                raise _HxException(("Bad node type, unexpected " + HxOverrides.stringOrNull(_Xml_XmlType_Impl_.toString(value.nodeType))))
            _this12 = self.output
            s12 = Std.string((("<?" + HxOverrides.stringOrNull(value.nodeValue)) + "?>"))
            _this12.b.write(s12)
            if self.pretty:
                self.output.b.write("\n")
        elif (_g == 6):
            if ((value.nodeType != Xml.Document) and ((value.nodeType != Xml.Element))):
                raise _HxException(("Bad node type, expected Element or Document but found " + HxOverrides.stringOrNull(_Xml_XmlType_Impl_.toString(value.nodeType))))
            child2 = python_HaxeIterator(value.children.__iter__())
            while child2.hasNext():
                child3 = child2.next()
                self.writeNode(child3,tabs)
        else:
            pass

    def hasChildren(self,value):
        if ((value.nodeType != Xml.Document) and ((value.nodeType != Xml.Element))):
            raise _HxException(("Bad node type, expected Element or Document but found " + HxOverrides.stringOrNull(_Xml_XmlType_Impl_.toString(value.nodeType))))
        child = python_HaxeIterator(value.children.__iter__())
        while child.hasNext():
            child1 = child.next()
            _g = child1.nodeType
            if ((_g == 1) or ((_g == 0))):
                return True
            elif ((_g == 3) or ((_g == 2))):
                if ((child1.nodeType == Xml.Document) or ((child1.nodeType == Xml.Element))):
                    raise _HxException(("Bad node type, unexpected " + HxOverrides.stringOrNull(_Xml_XmlType_Impl_.toString(child1.nodeType))))
                if (len(StringTools.ltrim(child1.nodeValue)) != 0):
                    return True
            else:
                pass
        return False

    @staticmethod
    def print(xml,pretty = None):
        if (pretty is None):
            pretty = False
        printer = haxe_xml_Printer(pretty)
        printer.writeNode(xml,"")
        return printer.output.b.getvalue()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.output = None
        _hx_o.pretty = None
haxe_xml_Printer._hx_class = haxe_xml_Printer
_hx_classes["haxe.xml.Printer"] = haxe_xml_Printer


class haxe_zip_Compress:
    _hx_class_name = "haxe.zip.Compress"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["run"]

    @staticmethod
    def run(s,level):
        raise _HxException("Not implemented for this platform")
haxe_zip_Compress._hx_class = haxe_zip_Compress
_hx_classes["haxe.zip.Compress"] = haxe_zip_Compress

class haxe_zip_Huffman(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.zip.Huffman"
    _hx_constructs = ["Found", "NeedBit", "NeedBits"]

    @staticmethod
    def Found(i):
        return haxe_zip_Huffman("Found", 0, (i,))

    @staticmethod
    def NeedBit(left,right):
        return haxe_zip_Huffman("NeedBit", 1, (left,right))

    @staticmethod
    def NeedBits(n,table):
        return haxe_zip_Huffman("NeedBits", 2, (n,table))
haxe_zip_Huffman._hx_class = haxe_zip_Huffman
_hx_classes["haxe.zip.Huffman"] = haxe_zip_Huffman


class haxe_zip_HuffTools:
    _hx_class_name = "haxe.zip.HuffTools"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_methods = ["treeDepth", "treeCompress", "treeWalk", "treeMake", "make"]

    def __init__(self):
        pass

    def treeDepth(self,t):
        tmp = t.index
        if (tmp == 0):
            _g = t.params[0]
            return 0
        elif (tmp == 1):
            b = t.params[1]
            a = t.params[0]
            da = self.treeDepth(a)
            db = self.treeDepth(b)
            return (1 + ((da if ((da < db)) else db)))
        elif (tmp == 2):
            _g2 = t.params[1]
            _g1 = t.params[0]
            raise _HxException("assert")
        else:
            pass

    def treeCompress(self,t):
        d = self.treeDepth(t)
        if (d == 0):
            return t
        if (d == 1):
            if (t.index == 1):
                b = t.params[1]
                a = t.params[0]
                return haxe_zip_Huffman.NeedBit(self.treeCompress(a),self.treeCompress(b))
            else:
                raise _HxException("assert")
        size = (1 << d)
        table = list()
        _g = 0
        _g1 = size
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            table.append(haxe_zip_Huffman.Found(-1))
        self.treeWalk(table,0,0,d,t)
        return haxe_zip_Huffman.NeedBits(d,table)

    def treeWalk(self,table,p,cd,d,t):
        if (t.index == 1):
            b = t.params[1]
            a = t.params[0]
            if (d > 0):
                self.treeWalk(table,p,(cd + 1),(d - 1),a)
                self.treeWalk(table,(p | ((1 << cd))),(cd + 1),(d - 1),b)
            else:
                python_internal_ArrayImpl._set(table, p, self.treeCompress(t))
        else:
            python_internal_ArrayImpl._set(table, p, self.treeCompress(t))

    def treeMake(self,bits,maxbits,v,_hx_len):
        if (_hx_len > maxbits):
            raise _HxException("Invalid huffman")
        idx = ((v << 5) | _hx_len)
        if (idx in bits.h):
            return haxe_zip_Huffman.Found(bits.h.get(idx,None))
        v = (v << 1)
        _hx_len = (_hx_len + 1)
        return haxe_zip_Huffman.NeedBit(self.treeMake(bits,maxbits,v,_hx_len),self.treeMake(bits,maxbits,(v | 1),_hx_len))

    def make(self,lengths,pos,nlengths,maxbits):
        if (nlengths == 1):
            return haxe_zip_Huffman.NeedBit(haxe_zip_Huffman.Found(0),haxe_zip_Huffman.Found(0))
        counts = list()
        tmp = list()
        if (maxbits > 32):
            raise _HxException("Invalid huffman")
        _g = 0
        _g1 = maxbits
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            counts.append(0)
            tmp.append(0)
        _g2 = 0
        _g3 = nlengths
        while (_g2 < _g3):
            i1 = _g2
            _g2 = (_g2 + 1)
            p = python_internal_ArrayImpl._get(lengths, (i1 + pos))
            if (p >= maxbits):
                raise _HxException("Invalid huffman")
            python_internal_ArrayImpl._set(counts, p, ((counts[p] if p >= 0 and p < len(counts) else None) + 1))
        code = 0
        _g4 = 1
        _g5 = (maxbits - 1)
        while (_g4 < _g5):
            i2 = _g4
            _g4 = (_g4 + 1)
            code = ((code + (counts[i2] if i2 >= 0 and i2 < len(counts) else None)) << 1)
            python_internal_ArrayImpl._set(tmp, i2, code)
        bits = haxe_ds_IntMap()
        _g6 = 0
        _g7 = nlengths
        while (_g6 < _g7):
            i3 = _g6
            _g6 = (_g6 + 1)
            l = python_internal_ArrayImpl._get(lengths, (i3 + pos))
            if (l != 0):
                n = python_internal_ArrayImpl._get(tmp, (l - 1))
                python_internal_ArrayImpl._set(tmp, (l - 1), (n + 1))
                bits.set(((n << 5) | l),i3)
        return self.treeCompress(haxe_zip_Huffman.NeedBit(self.treeMake(bits,maxbits,0,1),self.treeMake(bits,maxbits,1,1)))

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
haxe_zip_HuffTools._hx_class = haxe_zip_HuffTools
_hx_classes["haxe.zip.HuffTools"] = haxe_zip_HuffTools


class haxe_zip__InflateImpl_Window:
    _hx_class_name = "haxe.zip._InflateImpl.Window"
    _hx_is_interface = "False"
    __slots__ = ("buffer", "pos", "crc")
    _hx_fields = ["buffer", "pos", "crc"]
    _hx_methods = ["slide", "addBytes", "addByte", "getLastChar", "available", "checksum"]

    def __init__(self,hasCrc):
        self.crc = None
        self.buffer = haxe_io_Bytes.alloc(65536)
        self.pos = 0
        if hasCrc:
            self.crc = haxe_crypto_Adler32()

    def slide(self):
        if (self.crc is not None):
            self.crc.update(self.buffer,0,32768)
        b = haxe_io_Bytes.alloc(65536)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 - 32768)
        _hx_local_0.pos
        b.blit(0,self.buffer,32768,self.pos)
        self.buffer = b

    def addBytes(self,b,p,_hx_len):
        if ((self.pos + _hx_len) > 65536):
            self.slide()
        self.buffer.blit(self.pos,b,p,_hx_len)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + _hx_len)
        _hx_local_0.pos

    def addByte(self,c):
        if (self.pos == 65536):
            self.slide()
        self.buffer.b[self.pos] = (c & 255)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + 1)
        _hx_local_1

    def getLastChar(self):
        return self.buffer.b[(self.pos - 1)]

    def available(self):
        return self.pos

    def checksum(self):
        if (self.crc is not None):
            self.crc.update(self.buffer,0,self.pos)
        return self.crc

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.buffer = None
        _hx_o.pos = None
        _hx_o.crc = None
haxe_zip__InflateImpl_Window._hx_class = haxe_zip__InflateImpl_Window
_hx_classes["haxe.zip._InflateImpl.Window"] = haxe_zip__InflateImpl_Window

class haxe_zip__InflateImpl_State(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.zip._InflateImpl.State"
    _hx_constructs = ["Head", "Block", "CData", "Flat", "Crc", "Dist", "DistOne", "Done"]
haxe_zip__InflateImpl_State.Head = haxe_zip__InflateImpl_State("Head", 0, ())
haxe_zip__InflateImpl_State.Block = haxe_zip__InflateImpl_State("Block", 1, ())
haxe_zip__InflateImpl_State.CData = haxe_zip__InflateImpl_State("CData", 2, ())
haxe_zip__InflateImpl_State.Flat = haxe_zip__InflateImpl_State("Flat", 3, ())
haxe_zip__InflateImpl_State.Crc = haxe_zip__InflateImpl_State("Crc", 4, ())
haxe_zip__InflateImpl_State.Dist = haxe_zip__InflateImpl_State("Dist", 5, ())
haxe_zip__InflateImpl_State.DistOne = haxe_zip__InflateImpl_State("DistOne", 6, ())
haxe_zip__InflateImpl_State.Done = haxe_zip__InflateImpl_State("Done", 7, ())
haxe_zip__InflateImpl_State._hx_class = haxe_zip__InflateImpl_State
_hx_classes["haxe.zip._InflateImpl.State"] = haxe_zip__InflateImpl_State


class haxe_zip_InflateImpl:
    _hx_class_name = "haxe.zip.InflateImpl"
    _hx_is_interface = "False"
    __slots__ = ("nbits", "bits", "state", "isFinal", "huffman", "huffdist", "htools", "len", "dist", "needed", "output", "outpos", "input", "lengths", "window")
    _hx_fields = ["nbits", "bits", "state", "isFinal", "huffman", "huffdist", "htools", "len", "dist", "needed", "output", "outpos", "input", "lengths", "window"]
    _hx_methods = ["buildFixedHuffman", "readBytes", "getBits", "getBit", "getRevBits", "resetBits", "addBytes", "addByte", "addDistOne", "addDist", "applyHuffman", "inflateLengths", "inflateLoop"]
    _hx_statics = ["LEN_EXTRA_BITS_TBL", "LEN_BASE_VAL_TBL", "DIST_EXTRA_BITS_TBL", "DIST_BASE_VAL_TBL", "CODE_LENGTHS_POS", "FIXED_HUFFMAN", "run"]

    def __init__(self,i,header = None,crc = None):
        if (header is None):
            header = True
        if (crc is None):
            crc = True
        self.window = None
        self.lengths = None
        self.input = None
        self.outpos = None
        self.output = None
        self.needed = None
        self.dist = None
        self.len = None
        self.huffdist = None
        self.huffman = None
        self.state = None
        self.bits = None
        self.nbits = None
        self.isFinal = False
        self.htools = haxe_zip_HuffTools()
        self.huffman = self.buildFixedHuffman()
        self.huffdist = None
        self.len = 0
        self.dist = 0
        self.state = (haxe_zip__InflateImpl_State.Head if header else haxe_zip__InflateImpl_State.Block)
        self.input = i
        self.bits = 0
        self.nbits = 0
        self.needed = 0
        self.output = None
        self.outpos = 0
        self.lengths = list()
        _this = self.lengths
        _this.append(-1)
        _this1 = self.lengths
        _this1.append(-1)
        _this2 = self.lengths
        _this2.append(-1)
        _this3 = self.lengths
        _this3.append(-1)
        _this4 = self.lengths
        _this4.append(-1)
        _this5 = self.lengths
        _this5.append(-1)
        _this6 = self.lengths
        _this6.append(-1)
        _this7 = self.lengths
        _this7.append(-1)
        _this8 = self.lengths
        _this8.append(-1)
        _this9 = self.lengths
        _this9.append(-1)
        _this10 = self.lengths
        _this10.append(-1)
        _this11 = self.lengths
        _this11.append(-1)
        _this12 = self.lengths
        _this12.append(-1)
        _this13 = self.lengths
        _this13.append(-1)
        _this14 = self.lengths
        _this14.append(-1)
        _this15 = self.lengths
        _this15.append(-1)
        _this16 = self.lengths
        _this16.append(-1)
        _this17 = self.lengths
        _this17.append(-1)
        _this18 = self.lengths
        _this18.append(-1)
        self.window = haxe_zip__InflateImpl_Window(crc)

    def buildFixedHuffman(self):
        if (haxe_zip_InflateImpl.FIXED_HUFFMAN is not None):
            return haxe_zip_InflateImpl.FIXED_HUFFMAN
        a = list()
        _g = 0
        while (_g < 288):
            n = _g
            _g = (_g + 1)
            a.append((8 if ((n <= 143)) else (9 if ((n <= 255)) else (7 if ((n <= 279)) else 8))))
        haxe_zip_InflateImpl.FIXED_HUFFMAN = self.htools.make(a,0,288,10)
        return haxe_zip_InflateImpl.FIXED_HUFFMAN

    def readBytes(self,b,pos,_hx_len):
        self.needed = _hx_len
        self.outpos = pos
        self.output = b
        if (_hx_len > 0):
            while self.inflateLoop():
                pass
        return (_hx_len - self.needed)

    def getBits(self,n):
        while (self.nbits < n):
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.bits
            _hx_local_0.bits = (_hx_local_1 | ((self.input.readByte() << self.nbits)))
            _hx_local_0.bits
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.nbits
            _hx_local_2.nbits = (_hx_local_3 + 8)
            _hx_local_2.nbits
        b = (self.bits & ((((1 << n)) - 1)))
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.nbits
        _hx_local_4.nbits = (_hx_local_5 - n)
        _hx_local_4.nbits
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6.bits
        _hx_local_6.bits = (_hx_local_7 >> n)
        _hx_local_6.bits
        return b

    def getBit(self):
        if (self.nbits == 0):
            self.nbits = 8
            self.bits = self.input.readByte()
        b = (((self.bits & 1)) == 1)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.nbits
        _hx_local_0.nbits = (_hx_local_1 - 1)
        _hx_local_1
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.bits
        _hx_local_2.bits = (_hx_local_3 >> 1)
        _hx_local_2.bits
        return b

    def getRevBits(self,n):
        if (n == 0):
            return 0
        elif self.getBit():
            return ((1 << ((n - 1))) | self.getRevBits((n - 1)))
        else:
            return self.getRevBits((n - 1))

    def resetBits(self):
        self.bits = 0
        self.nbits = 0

    def addBytes(self,b,p,_hx_len):
        self.window.addBytes(b,p,_hx_len)
        self.output.blit(self.outpos,b,p,_hx_len)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.needed
        _hx_local_0.needed = (_hx_local_1 - _hx_len)
        _hx_local_0.needed
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.outpos
        _hx_local_2.outpos = (_hx_local_3 + _hx_len)
        _hx_local_2.outpos

    def addByte(self,b):
        self.window.addByte(b)
        self.output.b[self.outpos] = (b & 255)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.needed
        _hx_local_0.needed = (_hx_local_1 - 1)
        _hx_local_1
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.outpos
        _hx_local_2.outpos = (_hx_local_3 + 1)
        _hx_local_3

    def addDistOne(self,n):
        c = self.window.getLastChar()
        _g = 0
        _g1 = n
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            self.addByte(c)

    def addDist(self,d,_hx_len):
        self.addBytes(self.window.buffer,(self.window.pos - d),_hx_len)

    def applyHuffman(self,h):
        tmp = h.index
        if (tmp == 0):
            n = h.params[0]
            return n
        elif (tmp == 1):
            b = h.params[1]
            a = h.params[0]
            return self.applyHuffman((b if (self.getBit()) else a))
        elif (tmp == 2):
            tbl = h.params[1]
            n1 = h.params[0]
            return self.applyHuffman(python_internal_ArrayImpl._get(tbl, self.getBits(n1)))
        else:
            pass

    def inflateLengths(self,a,_hx_max):
        i = 0
        prev = 0
        while (i < _hx_max):
            n = self.applyHuffman(self.huffman)
            n1 = n
            if ((((((((((((((((n1 == 15) or ((n1 == 14))) or ((n1 == 13))) or ((n1 == 12))) or ((n1 == 11))) or ((n1 == 10))) or ((n1 == 9))) or ((n1 == 8))) or ((n1 == 7))) or ((n1 == 6))) or ((n1 == 5))) or ((n1 == 4))) or ((n1 == 3))) or ((n1 == 2))) or ((n1 == 1))) or ((n1 == 0))):
                prev = n
                python_internal_ArrayImpl._set(a, i, n)
                i = (i + 1)
            elif (n1 == 16):
                end = ((i + 3) + self.getBits(2))
                if (end > _hx_max):
                    raise _HxException("Invalid data")
                while (i < end):
                    python_internal_ArrayImpl._set(a, i, prev)
                    i = (i + 1)
            elif (n1 == 17):
                i = (i + ((3 + self.getBits(3))))
                if (i > _hx_max):
                    raise _HxException("Invalid data")
            elif (n1 == 18):
                i = (i + ((11 + self.getBits(7))))
                if (i > _hx_max):
                    raise _HxException("Invalid data")
            else:
                raise _HxException("Invalid data")

    def inflateLoop(self):
        tmp = self.state.index
        if (tmp == 0):
            cmf = self.input.readByte()
            cm = (cmf & 15)
            cinfo = (cmf >> 4)
            if (cm != 8):
                raise _HxException("Invalid data")
            flg = self.input.readByte()
            fdict = (((flg & 32)) != 0)
            if (HxOverrides.mod(((((cmf << 8)) + flg)), 31) != 0):
                raise _HxException("Invalid data")
            if fdict:
                raise _HxException("Unsupported dictionary")
            self.state = haxe_zip__InflateImpl_State.Block
            return True
        elif (tmp == 1):
            self.isFinal = self.getBit()
            _g = self.getBits(2)
            if (_g == 0):
                self.len = self.input.readUInt16()
                nlen = self.input.readUInt16()
                if (nlen != ((65535 - self.len))):
                    raise _HxException("Invalid data")
                self.state = haxe_zip__InflateImpl_State.Flat
                r = self.inflateLoop()
                self.resetBits()
                return r
            elif (_g == 1):
                self.huffman = self.buildFixedHuffman()
                self.huffdist = None
                self.state = haxe_zip__InflateImpl_State.CData
                return True
            elif (_g == 2):
                hlit = (self.getBits(5) + 257)
                hdist = (self.getBits(5) + 1)
                hclen = (self.getBits(4) + 4)
                _g1 = 0
                _g11 = hclen
                while (_g1 < _g11):
                    i = _g1
                    _g1 = (_g1 + 1)
                    python_internal_ArrayImpl._set(self.lengths, python_internal_ArrayImpl._get(haxe_zip_InflateImpl.CODE_LENGTHS_POS, i), self.getBits(3))
                _g2 = hclen
                _g3 = 19
                while (_g2 < _g3):
                    i1 = _g2
                    _g2 = (_g2 + 1)
                    python_internal_ArrayImpl._set(self.lengths, python_internal_ArrayImpl._get(haxe_zip_InflateImpl.CODE_LENGTHS_POS, i1), 0)
                self.huffman = self.htools.make(self.lengths,0,19,8)
                lengths = list()
                _g4 = 0
                _g5 = (hlit + hdist)
                while (_g4 < _g5):
                    i2 = _g4
                    _g4 = (_g4 + 1)
                    lengths.append(0)
                self.inflateLengths(lengths,(hlit + hdist))
                self.huffdist = self.htools.make(lengths,hlit,hdist,16)
                self.huffman = self.htools.make(lengths,0,hlit,16)
                self.state = haxe_zip__InflateImpl_State.CData
                return True
            else:
                raise _HxException("Invalid data")
        elif (tmp == 2):
            n = self.applyHuffman(self.huffman)
            if (n < 256):
                self.addByte(n)
                return (self.needed > 0)
            elif (n == 256):
                self.state = (haxe_zip__InflateImpl_State.Crc if (self.isFinal) else haxe_zip__InflateImpl_State.Block)
                return True
            else:
                n = (n - 257)
                extra_bits = python_internal_ArrayImpl._get(haxe_zip_InflateImpl.LEN_EXTRA_BITS_TBL, n)
                if (extra_bits == -1):
                    raise _HxException("Invalid data")
                self.len = (python_internal_ArrayImpl._get(haxe_zip_InflateImpl.LEN_BASE_VAL_TBL, n) + self.getBits(extra_bits))
                dist_code = (self.getRevBits(5) if ((self.huffdist is None)) else self.applyHuffman(self.huffdist))
                extra_bits = python_internal_ArrayImpl._get(haxe_zip_InflateImpl.DIST_EXTRA_BITS_TBL, dist_code)
                if (extra_bits == -1):
                    raise _HxException("Invalid data")
                self.dist = (python_internal_ArrayImpl._get(haxe_zip_InflateImpl.DIST_BASE_VAL_TBL, dist_code) + self.getBits(extra_bits))
                if (self.dist > self.window.available()):
                    raise _HxException("Invalid data")
                self.state = (haxe_zip__InflateImpl_State.DistOne if ((self.dist == 1)) else haxe_zip__InflateImpl_State.Dist)
                return True
        elif (tmp == 3):
            rlen = (self.len if ((self.len < self.needed)) else self.needed)
            _hx_bytes = self.input.read(rlen)
            _hx_local_1 = self
            _hx_local_2 = _hx_local_1.len
            _hx_local_1.len = (_hx_local_2 - rlen)
            _hx_local_1.len
            self.addBytes(_hx_bytes,0,rlen)
            if (self.len == 0):
                self.state = (haxe_zip__InflateImpl_State.Crc if (self.isFinal) else haxe_zip__InflateImpl_State.Block)
            return (self.needed > 0)
        elif (tmp == 4):
            calc = self.window.checksum()
            if (calc is None):
                self.state = haxe_zip__InflateImpl_State.Done
                return True
            crc = haxe_crypto_Adler32.read(self.input)
            if (not calc.equals(crc)):
                raise _HxException("Invalid CRC")
            self.state = haxe_zip__InflateImpl_State.Done
            return True
        elif (tmp == 5):
            while ((self.len > 0) and ((self.needed > 0))):
                rdist = (self.len if ((self.len < self.dist)) else self.dist)
                rlen1 = (self.needed if ((self.needed < rdist)) else rdist)
                self.addDist(self.dist,rlen1)
                _hx_local_3 = self
                _hx_local_4 = _hx_local_3.len
                _hx_local_3.len = (_hx_local_4 - rlen1)
                _hx_local_3.len
            if (self.len == 0):
                self.state = haxe_zip__InflateImpl_State.CData
            return (self.needed > 0)
        elif (tmp == 6):
            rlen2 = (self.len if ((self.len < self.needed)) else self.needed)
            self.addDistOne(rlen2)
            _hx_local_5 = self
            _hx_local_6 = _hx_local_5.len
            _hx_local_5.len = (_hx_local_6 - rlen2)
            _hx_local_5.len
            if (self.len == 0):
                self.state = haxe_zip__InflateImpl_State.CData
            return (self.needed > 0)
        elif (tmp == 7):
            return False
        else:
            pass

    @staticmethod
    def run(i,bufsize = None):
        if (bufsize is None):
            bufsize = 65536
        buf = haxe_io_Bytes.alloc(bufsize)
        output = haxe_io_BytesBuffer()
        inflate = haxe_zip_InflateImpl(i)
        while True:
            _hx_len = inflate.readBytes(buf,0,bufsize)
            if ((_hx_len < 0) or ((_hx_len > buf.length))):
                raise _HxException(haxe_io_Error.OutsideBounds)
            output.b.extend(buf.b[0:_hx_len])
            if (_hx_len < bufsize):
                break
        return output.getBytes()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.nbits = None
        _hx_o.bits = None
        _hx_o.state = None
        _hx_o.isFinal = None
        _hx_o.huffman = None
        _hx_o.huffdist = None
        _hx_o.htools = None
        _hx_o.len = None
        _hx_o.dist = None
        _hx_o.needed = None
        _hx_o.output = None
        _hx_o.outpos = None
        _hx_o.input = None
        _hx_o.lengths = None
        _hx_o.window = None
haxe_zip_InflateImpl._hx_class = haxe_zip_InflateImpl
_hx_classes["haxe.zip.InflateImpl"] = haxe_zip_InflateImpl


class haxe_zip_Uncompress:
    _hx_class_name = "haxe.zip.Uncompress"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["run"]

    @staticmethod
    def run(src,bufsize = None):
        return haxe_zip_InflateImpl.run(haxe_io_BytesInput(src),bufsize)
haxe_zip_Uncompress._hx_class = haxe_zip_Uncompress
_hx_classes["haxe.zip.Uncompress"] = haxe_zip_Uncompress


class hxd_BitmapInnerDataImpl:
    _hx_class_name = "hxd.BitmapInnerDataImpl"
    _hx_is_interface = "False"
    __slots__ = ("pixels", "width", "height")
    _hx_fields = ["pixels", "width", "height"]

    def __init__(self):
        self.height = None
        self.width = None
        self.pixels = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.pixels = None
        _hx_o.width = None
        _hx_o.height = None
hxd_BitmapInnerDataImpl._hx_class = hxd_BitmapInnerDataImpl
_hx_classes["hxd.BitmapInnerDataImpl"] = hxd_BitmapInnerDataImpl


class hxd_BitmapData:
    _hx_class_name = "hxd.BitmapData"
    _hx_is_interface = "False"
    __slots__ = ("data",)
    _hx_fields = ["data"]
    _hx_methods = ["clear", "fill", "draw", "drawScaled", "line", "dispose", "clone", "sub", "lock", "unlock", "getPixel", "setPixel", "get_width", "get_height", "getPixels", "setPixels", "toNative", "toPNG"]
    _hx_statics = ["notImplemented", "fromNative"]

    def __init__(self,width,height):
        self.data = None
        if (not (((width == -101) and ((height == -102))))):
            self.data = hxd_BitmapInnerDataImpl()
            this1 = [None]*(width * height)
            self.data.pixels = this1
            self.data.width = width
            self.data.height = height

    def clear(self,color):
        self.fill(0,0,self.data.width,self.data.height,color)

    def fill(self,x,y,width,height,color):
        if (x < 0):
            width = (width + x)
            x = 0
        if (y < 0):
            height = (height + y)
            y = 0
        if ((x + width) > self.data.width):
            width = (self.data.width - x)
        if ((y + height) > self.data.height):
            height = (self.data.height - y)
        _g = 0
        _g1 = height
        while (_g < _g1):
            dy = _g
            _g = (_g + 1)
            p = (x + ((((y + dy)) * self.data.width)))
            _g2 = 0
            _g11 = width
            while (_g2 < _g11):
                dx = _g2
                _g2 = (_g2 + 1)
                index = p
                p = (p + 1)
                self.data.pixels[index] = color

    def draw(self,x,y,src,srcX,srcY,width,height,blendMode = None):
        raise _HxException("Not implemented")

    def drawScaled(self,x,y,width,height,src,srcX,srcY,srcWidth,srcHeight,blendMode = None,smooth = None):
        if (smooth is None):
            smooth = True
        if (blendMode is None):
            blendMode = h2d_BlendMode.Alpha
        raise _HxException("Not implemented")

    def line(self,x0,y0,x1,y1,color):
        dx = (x1 - x0)
        dy = (y1 - y0)
        if (dx == 0):
            if (y1 < y0):
                tmp = y0
                y0 = y1
                y1 = tmp
            if (y0 < 0):
                y0 = 0
            if (y1 > ((self.data.height - 1))):
                y1 = (self.data.height - 1)
            _g = y0
            _g1 = (y1 + 1)
            while (_g < _g1):
                y = _g
                _g = (_g + 1)
                self.setPixel(x0,y,color)
        elif (dy == 0):
            if (x1 < x0):
                tmp1 = x0
                x0 = x1
                x1 = tmp1
            if (x0 < 0):
                x0 = 0
            if (x1 > ((self.data.width - 1))):
                x1 = (self.data.width - 1)
            _g2 = x0
            _g11 = (x1 + 1)
            while (_g2 < _g11):
                x = _g2
                _g2 = (_g2 + 1)
                self.setPixel(x,y0,color)
        else:
            sx = None
            sy = None
            clip_x0 = None
            clip_y0 = None
            clip_x1 = None
            clip_y1 = None
            if (x0 < x1):
                if ((x0 >= self.data.width) or ((x1 < 0))):
                    return
                sx = 1
                clip_x0 = 0
                clip_x1 = (self.data.width - 1)
            else:
                if ((x1 >= self.data.width) or ((x0 < 0))):
                    return
                sx = -1
                x1 = -x1
                x0 = -x0
                clip_x0 = (1 - self.data.width)
                clip_x1 = 0
            if (y0 < y1):
                if ((y0 >= self.data.height) or ((y1 < 0))):
                    return
                sy = 1
                clip_y0 = 0
                clip_y1 = (self.data.height - 1)
            else:
                if ((y1 >= self.data.width) or ((y0 < 0))):
                    return
                sy = -1
                y1 = -y1
                y0 = -y0
                clip_y0 = (1 - self.data.height)
                clip_y1 = 0
            dx = (x1 - x0)
            dy = (y1 - y0)
            d2x = (dx << 1)
            d2y = (dy << 1)
            x2 = x0
            y2 = y0
            if (dx >= dy):
                delta = (d2y - dx)
                tracing_can_start = False
                if (y0 < clip_y0):
                    temp = d2x
                    temp = ((temp * ((clip_y0 - y0))) - dx)
                    xinc = (temp / d2y)
                    x3 = None
                    try:
                        x3 = int(xinc)
                    except Exception as _hx_e:
                        _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                        e = _hx_e1
                        x3 = None
                    x2 = (x2 + x3)
                    if (x2 > clip_x1):
                        return
                    if (x2 >= clip_x0):
                        temp = (temp - ((xinc * d2y)))
                        delta1 = None
                        try:
                            delta1 = int(temp)
                        except Exception as _hx_e:
                            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                            e1 = _hx_e1
                            delta1 = None
                        delta = (delta - ((delta1 + dx)))
                        y2 = clip_y0
                        if (temp > 0):
                            x2 = (x2 + 1)
                            delta = (delta + d2y)
                        tracing_can_start = True
                if ((not tracing_can_start) and ((x0 < clip_x0))):
                    temp1 = d2y
                    temp1 = (temp1 * ((clip_x0 - x0)))
                    yinc = (temp1 / d2x)
                    y3 = None
                    try:
                        y3 = int(yinc)
                    except Exception as _hx_e:
                        _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                        e2 = _hx_e1
                        y3 = None
                    y2 = (y2 + y3)
                    temp1 = HxOverrides.modf(temp1, d2x)
                    if ((y2 > clip_y1) or (((y2 == clip_y1) and ((temp1 > dx))))):
                        return
                    x2 = clip_x0
                    delta2 = None
                    try:
                        delta2 = int(temp1)
                    except Exception as _hx_e:
                        _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                        e3 = _hx_e1
                        delta2 = None
                    delta = (delta + delta2)
                    if (temp1 >= dx):
                        y2 = (y2 + 1)
                        delta = (delta - d2x)
                xend = x1
                if (y1 > clip_y1):
                    temp2 = d2x
                    temp2 = ((temp2 * ((clip_y1 - y1))) + dx)
                    xinc1 = (temp2 / d2y)
                    xend1 = None
                    try:
                        xend1 = int(xinc1)
                    except Exception as _hx_e:
                        _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                        e4 = _hx_e1
                        xend1 = None
                    xend = (xend + xend1)
                    if ((temp2 - ((xinc1 * d2y))) == 0):
                        xend = (xend - 1)
                if (xend > clip_x1):
                    xend = (clip_x1 + 1)
                else:
                    xend = (xend + 1)
                if (sx == -1):
                    x2 = -x2
                    xend = -xend
                if (sy == -1):
                    y2 = -y2
                d2x = (d2x - d2y)
                while (x2 != xend):
                    self.setPixel(x2,y2,color)
                    if (delta >= 0):
                        y2 = (y2 + sy)
                        delta = (delta - d2x)
                    else:
                        delta = (delta + d2y)
                    x2 = (x2 + sx)
            else:
                delta3 = (d2x - dy)
                tracing_can_start1 = False
                if (x0 < clip_x0):
                    temp3 = d2y
                    temp3 = ((temp3 * ((clip_x0 - x0))) - dy)
                    yinc1 = (temp3 / d2x)
                    y4 = None
                    try:
                        y4 = int(yinc1)
                    except Exception as _hx_e:
                        _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                        e5 = _hx_e1
                        y4 = None
                    y2 = (y2 + y4)
                    if (y2 > clip_y1):
                        return
                    if (y2 >= clip_y0):
                        temp3 = (temp3 - ((yinc1 * d2x)))
                        delta4 = None
                        try:
                            delta4 = int(temp3)
                        except Exception as _hx_e:
                            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                            e6 = _hx_e1
                            delta4 = None
                        delta3 = (delta3 - ((delta4 + dy)))
                        x2 = clip_x0
                        if (temp3 > 0):
                            y2 = (y2 + 1)
                            delta3 = (delta3 + d2x)
                        tracing_can_start1 = True
                if ((not tracing_can_start1) and ((y0 < clip_y0))):
                    temp4 = d2x
                    temp4 = (temp4 * ((clip_y0 - y0)))
                    xinc2 = (temp4 / d2y)
                    x4 = None
                    try:
                        x4 = int(xinc2)
                    except Exception as _hx_e:
                        _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                        e7 = _hx_e1
                        x4 = None
                    x2 = (x2 + x4)
                    temp4 = HxOverrides.modf(temp4, d2y)
                    if ((x2 > clip_x1) or (((x2 == clip_x1) and ((temp4 > dy))))):
                        return
                    y2 = clip_y0
                    delta5 = None
                    try:
                        delta5 = int(temp4)
                    except Exception as _hx_e:
                        _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                        e8 = _hx_e1
                        delta5 = None
                    delta3 = (delta3 + delta5)
                    if (temp4 >= dy):
                        x2 = (x2 + 1)
                        delta3 = (delta3 - d2y)
                yend = y1
                if (x1 > clip_x1):
                    temp5 = d2y
                    temp5 = ((temp5 * ((clip_x1 - x1))) + dy)
                    yinc2 = (temp5 / d2x)
                    yend1 = None
                    try:
                        yend1 = int(yinc2)
                    except Exception as _hx_e:
                        _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                        e9 = _hx_e1
                        yend1 = None
                    yend = (yend + yend1)
                    if ((temp5 - ((yinc2 * d2x))) == 0):
                        yend = (yend - 1)
                if (yend > clip_y1):
                    yend = (clip_y1 + 1)
                else:
                    yend = (yend + 1)
                if (sx == -1):
                    x2 = -x2
                if (sy == -1):
                    y2 = -y2
                    yend = -yend
                d2y = (d2y - d2x)
                while (y2 != yend):
                    self.setPixel(x2,y2,color)
                    if (delta3 >= 0):
                        x2 = (x2 + sx)
                        delta3 = (delta3 - d2y)
                    else:
                        delta3 = (delta3 + d2x)
                    y2 = (y2 + sy)

    def dispose(self):
        self.data = None

    def clone(self):
        return self.sub(0,0,self.data.width,self.data.height)

    def sub(self,x,y,w,h):
        if ((((((x < 0) or ((y < 0))) or ((w < 0))) or ((h < 0))) or (((x + w) > self.data.width))) or (((y + h) > self.data.height))):
            raise _HxException("Outside bounds")
        b = hxd_BitmapInnerDataImpl()
        b.width = w
        b.height = h
        this1 = [None]*(w * h)
        b.pixels = this1
        _g = 0
        _g1 = h
        while (_g < _g1):
            dy = _g
            _g = (_g + 1)
            haxe_ds__Vector_Vector_Impl_.blit(self.data.pixels,(x + ((((y + dy)) * self.data.width))),b.pixels,(dy * w),w)
        return hxd_BitmapData.fromNative(b)

    def lock(self):
        pass

    def unlock(self):
        pass

    def getPixel(self,x,y):
        if ((((x >= 0) and ((y >= 0))) and ((x < self.data.width))) and ((y < self.data.height))):
            return self.data.pixels[(x + ((y * self.data.width)))]
        else:
            return 0

    def setPixel(self,x,y,c):
        if ((((x >= 0) and ((y >= 0))) and ((x < self.data.width))) and ((y < self.data.height))):
            self.data.pixels[(x + ((y * self.data.width)))] = c

    def get_width(self):
        return self.data.width

    def get_height(self):
        return self.data.height

    def getPixels(self):
        out = haxe_io_Bytes.alloc(((self.data.width * self.data.height) * 4))
        _g = 0
        _g1 = (self.data.width * self.data.height)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            pos = (i << 2)
            v = self.data.pixels[i]
            out.b[pos] = (v & 255)
            out.b[(pos + 1)] = ((v >> 8) & 255)
            out.b[(pos + 2)] = ((v >> 16) & 255)
            out.b[(pos + 3)] = (HxOverrides.rshift(v, 24) & 255)
        return hxd_Pixels(self.data.width,self.data.height,out,hxd_PixelFormat.BGRA)

    def setPixels(self,pixels):
        if ((pixels.width != self.data.width) or ((pixels.height != self.data.height))):
            raise _HxException("Invalid pixels size")
        pixels.setFlip(False)
        pixels.convert(hxd_PixelFormat.BGRA)
        src = pixels.bytes
        _g = 0
        _g1 = (self.data.width * self.data.height)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            this1 = self.data.pixels
            pos = (i << 2)
            v = (((src.b[pos] | ((src.b[(pos + 1)] << 8))) | ((src.b[(pos + 2)] << 16))) | ((src.b[(pos + 3)] << 24)))
            val = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
            this1[i] = val

    def toNative(self):
        return self.data

    def toPNG(self):
        pixels = self.getPixels()
        png = pixels.toPNG()
        pixels.dispose()
        return png

    @staticmethod
    def notImplemented():
        raise _HxException("Not implemented")

    @staticmethod
    def fromNative(data):
        b = hxd_BitmapData(-101,-102)
        b.data = data
        return b

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.data = None
hxd_BitmapData._hx_class = hxd_BitmapData
_hx_classes["hxd.BitmapData"] = hxd_BitmapData


class hxd_Charset:
    _hx_class_name = "hxd.Charset"
    _hx_is_interface = "False"
    __slots__ = ("map",)
    _hx_fields = ["map"]
    _hx_methods = ["resolveChar", "isCJK", "isSpace", "isBreakChar"]
    _hx_statics = ["ASCII", "LATIN1", "CYRILLIC", "POLISH", "TURKISH", "JP_KANA", "UNICODE_SPECIALS", "DEFAULT_CHARS", "inst", "getDefault"]

    def __init__(self):
        self.map = None
        _gthis = self
        self.map = haxe_ds_IntMap()
        _g = 0
        while (_g < 94):
            i = _g
            _g = (_g + 1)
            _gthis.map.set((65281 + i),(33 + i))
        _g1 = 192
        _g2 = 199
        while (_g1 < _g2):
            i1 = _g1
            _g1 = (_g1 + 1)
            _gthis.map.set(i1,65)
        _g3 = 224
        _g4 = 231
        while (_g3 < _g4):
            i2 = _g3
            _g3 = (_g3 + 1)
            _gthis.map.set(i2,97)
        _g5 = 200
        _g6 = 204
        while (_g5 < _g6):
            i3 = _g5
            _g5 = (_g5 + 1)
            _gthis.map.set(i3,69)
        _g7 = 232
        _g8 = 236
        while (_g7 < _g8):
            i4 = _g7
            _g7 = (_g7 + 1)
            _gthis.map.set(i4,101)
        _g9 = 204
        _g10 = 208
        while (_g9 < _g10):
            i5 = _g9
            _g9 = (_g9 + 1)
            _gthis.map.set(i5,73)
        _g11 = 236
        _g12 = 240
        while (_g11 < _g12):
            i6 = _g11
            _g11 = (_g11 + 1)
            _gthis.map.set(i6,105)
        _g13 = 210
        _g14 = 215
        while (_g13 < _g14):
            i7 = _g13
            _g13 = (_g13 + 1)
            _gthis.map.set(i7,79)
        _g15 = 242
        _g16 = 247
        while (_g15 < _g16):
            i8 = _g15
            _g15 = (_g15 + 1)
            _gthis.map.set(i8,111)
        _g17 = 217
        _g18 = 221
        while (_g17 < _g18):
            i9 = _g17
            _g17 = (_g17 + 1)
            _gthis.map.set(i9,85)
        _g19 = 249
        _g20 = 253
        while (_g19 < _g20):
            i10 = _g19
            _g19 = (_g19 + 1)
            _gthis.map.set(i10,117)
        _gthis.map.set(199,67)
        _gthis.map.set(231,67)
        _gthis.map.set(208,68)
        _gthis.map.set(222,100)
        _gthis.map.set(209,78)
        _gthis.map.set(241,110)
        _gthis.map.set(221,89)
        _gthis.map.set(253,121)
        _gthis.map.set(255,121)
        _gthis.map.set(8364,69)
        _gthis.map.set(12288,32)
        _gthis.map.set(160,32)
        _gthis.map.set(171,34)
        _gthis.map.set(187,34)
        _gthis.map.set(8220,34)
        _gthis.map.set(8221,34)
        _gthis.map.set(8216,39)
        _gthis.map.set(8217,39)
        _gthis.map.set(180,39)
        _gthis.map.set(8216,39)
        _gthis.map.set(8249,60)
        _gthis.map.set(8250,62)
        _gthis.map.set(8211,45)

    def resolveChar(self,code,glyphs):
        c = code
        while (c is not None):
            g = glyphs.h.get(c,None)
            if (g is not None):
                return g
            c = self.map.h.get(c,None)
        return None

    def isCJK(self,code):
        if (not ((((code >= 11904) and ((code <= 42191))) or (((code >= 63744) and ((code <= 64255))))))):
            if (code >= 131072):
                return (code <= 262141)
            else:
                return False
        else:
            return True

    def isSpace(self,code):
        if (code != 32):
            return (code == 12288)
        else:
            return True

    def isBreakChar(self,code):
        if (not self.isSpace(code)):
            return self.isCJK(code)
        else:
            return True
    inst = None

    @staticmethod
    def getDefault():
        if (hxd_Charset.inst is None):
            hxd_Charset.inst = hxd_Charset()
        return hxd_Charset.inst

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.map = None
hxd_Charset._hx_class = hxd_Charset
_hx_classes["hxd.Charset"] = hxd_Charset

class hxd_Cursor(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.Cursor"
    _hx_constructs = ["Default", "Button", "Move", "TextInput", "Hide", "Custom", "Callback"]

    @staticmethod
    def Custom(custom):
        return hxd_Cursor("Custom", 5, (custom,))

    @staticmethod
    def Callback(f):
        return hxd_Cursor("Callback", 6, (f,))
hxd_Cursor.Default = hxd_Cursor("Default", 0, ())
hxd_Cursor.Button = hxd_Cursor("Button", 1, ())
hxd_Cursor.Move = hxd_Cursor("Move", 2, ())
hxd_Cursor.TextInput = hxd_Cursor("TextInput", 3, ())
hxd_Cursor.Hide = hxd_Cursor("Hide", 4, ())
hxd_Cursor._hx_class = hxd_Cursor
_hx_classes["hxd.Cursor"] = hxd_Cursor


class hxd_CustomCursor:
    _hx_class_name = "hxd.CustomCursor"
    _hx_is_interface = "False"
    __slots__ = ("frames", "speed", "offsetX", "offsetY", "alloc")
    _hx_fields = ["frames", "speed", "offsetX", "offsetY", "alloc"]
    _hx_methods = ["dispose"]

    def __init__(self,frames,speed,offsetX,offsetY):
        self.alloc = None
        self.frames = frames
        self.speed = speed
        self.offsetX = offsetX
        self.offsetY = offsetY

    def dispose(self):
        _g = 0
        _g1 = self.frames
        while (_g < len(_g1)):
            f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            f.data = None
        self.frames = []
        if (self.alloc is not None):
            raise _HxException("TODO")

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.frames = None
        _hx_o.speed = None
        _hx_o.offsetX = None
        _hx_o.offsetY = None
        _hx_o.alloc = None
hxd_CustomCursor._hx_class = hxd_CustomCursor
_hx_classes["hxd.CustomCursor"] = hxd_CustomCursor

class hxd_EventKind(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.EventKind"
    _hx_constructs = ["EPush", "ERelease", "EMove", "EOver", "EOut", "EWheel", "EFocus", "EFocusLost", "EKeyDown", "EKeyUp", "EReleaseOutside", "ETextInput", "ECheck"]
hxd_EventKind.EPush = hxd_EventKind("EPush", 0, ())
hxd_EventKind.ERelease = hxd_EventKind("ERelease", 1, ())
hxd_EventKind.EMove = hxd_EventKind("EMove", 2, ())
hxd_EventKind.EOver = hxd_EventKind("EOver", 3, ())
hxd_EventKind.EOut = hxd_EventKind("EOut", 4, ())
hxd_EventKind.EWheel = hxd_EventKind("EWheel", 5, ())
hxd_EventKind.EFocus = hxd_EventKind("EFocus", 6, ())
hxd_EventKind.EFocusLost = hxd_EventKind("EFocusLost", 7, ())
hxd_EventKind.EKeyDown = hxd_EventKind("EKeyDown", 8, ())
hxd_EventKind.EKeyUp = hxd_EventKind("EKeyUp", 9, ())
hxd_EventKind.EReleaseOutside = hxd_EventKind("EReleaseOutside", 10, ())
hxd_EventKind.ETextInput = hxd_EventKind("ETextInput", 11, ())
hxd_EventKind.ECheck = hxd_EventKind("ECheck", 12, ())
hxd_EventKind._hx_class = hxd_EventKind
_hx_classes["hxd.EventKind"] = hxd_EventKind


class hxd_Event:
    _hx_class_name = "hxd.Event"
    _hx_is_interface = "False"
    __slots__ = ("kind", "relX", "relY", "relZ", "propagate", "cancel", "button", "touchId", "keyCode", "charCode", "wheelDelta")
    _hx_fields = ["kind", "relX", "relY", "relZ", "propagate", "cancel", "button", "touchId", "keyCode", "charCode", "wheelDelta"]
    _hx_methods = ["toString"]

    def __init__(self,k,x = None,y = None):
        if (x is None):
            x = 0.
        if (y is None):
            y = 0.
        self.wheelDelta = None
        self.charCode = None
        self.keyCode = None
        self.touchId = None
        self.cancel = None
        self.propagate = None
        self.relZ = None
        self.button = 0
        self.kind = k
        self.relX = x
        self.relY = y

    def toString(self):
        tmp = (Std.string(self.kind) + "[")
        x = self.relX
        tmp1 = None
        try:
            tmp1 = int(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            tmp1 = None
        tmp2 = ((("null" if tmp is None else tmp) + Std.string(tmp1)) + ",")
        x1 = self.relY
        tmp3 = None
        try:
            tmp3 = int(x1)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e1 = _hx_e1
            tmp3 = None
        tmp4 = ((("null" if tmp2 is None else tmp2) + Std.string(tmp3)) + "]")
        tmp5 = None
        tmp6 = self.kind.index
        if (((tmp6 == 10) or ((tmp6 == 1))) or ((tmp6 == 0))):
            tmp5 = (",button=" + Std.string(self.button))
        elif ((((((tmp6 == 12) or ((tmp6 == 7))) or ((tmp6 == 6))) or ((tmp6 == 4))) or ((tmp6 == 3))) or ((tmp6 == 2))):
            tmp5 = ""
        elif (tmp6 == 5):
            tmp5 = (",wheelDelta=" + Std.string(self.wheelDelta))
        elif ((tmp6 == 9) or ((tmp6 == 8))):
            tmp5 = (",keyCode=" + Std.string(self.keyCode))
        elif (tmp6 == 11):
            tmp5 = (",charCode=" + Std.string(self.charCode))
        else:
            pass
        return (("null" if tmp4 is None else tmp4) + ("null" if tmp5 is None else tmp5))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.kind = None
        _hx_o.relX = None
        _hx_o.relY = None
        _hx_o.relZ = None
        _hx_o.propagate = None
        _hx_o.cancel = None
        _hx_o.button = None
        _hx_o.touchId = None
        _hx_o.keyCode = None
        _hx_o.charCode = None
        _hx_o.wheelDelta = None
hxd_Event._hx_class = hxd_Event
_hx_classes["hxd.Event"] = hxd_Event


class hxd_File:
    _hx_class_name = "hxd.File"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["browse", "saveAs", "exists", "delete", "listDirectory", "getBytes", "saveBytes", "load", "createDirectory", "applicationPath"]

    @staticmethod
    def browse(onSelect,options = None):
        if (options is None):
            options = _hx_AnonObject({})
        raise _HxException("Not supported")

    @staticmethod
    def saveAs(dataContent,options = None):
        if (options is None):
            options = _hx_AnonObject({})
        raise _HxException("Not supported")

    @staticmethod
    def exists(path):
        return sys_FileSystem.exists(path)

    @staticmethod
    def delete(path):
        try:
            sys_FileSystem.deleteFile(path)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            pass

    @staticmethod
    def listDirectory(path):
        return sys_FileSystem.readDirectory(path)

    @staticmethod
    def getBytes(path):
        return sys_io_File.getBytes(path)

    @staticmethod
    def saveBytes(path,data):
        sys_io_File.saveBytes(path,data)

    @staticmethod
    def load(path,onLoad,onError = None):
        if (onError is None):
            def _hx_local_0(_):
                pass
            onError = _hx_local_0
        content = None
        try:
            content = sys_io_File.getBytes(path)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            if (onError is not None):
                onError(("" + Std.string(e)))
            return
        onLoad(content)

    @staticmethod
    def createDirectory(path):
        sys_FileSystem.createDirectory(path)

    @staticmethod
    def applicationPath():
        raise _HxException("Not supported")
hxd_File._hx_class = hxd_File
_hx_classes["hxd.File"] = hxd_File


class hxd__FloatBuffer_InnerIterator:
    _hx_class_name = "hxd._FloatBuffer.InnerIterator"
    _hx_is_interface = "False"
    __slots__ = ("b", "len", "pos")
    _hx_fields = ["b", "len", "pos"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,b):
        self.pos = None
        self.len = None
        self.b = b
        self.len = len(self.b)
        self.pos = 0

    def hasNext(self):
        return (self.pos < self.len)

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.pos
                _hx_local_0.pos = (_hx_local_1 + 1)
                return _hx_local_1
            return python_internal_ArrayImpl._get(self.b, _hx_local_2())
        return _hx_local_3()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.b = None
        _hx_o.len = None
        _hx_o.pos = None
hxd__FloatBuffer_InnerIterator._hx_class = hxd__FloatBuffer_InnerIterator
_hx_classes["hxd._FloatBuffer.InnerIterator"] = hxd__FloatBuffer_InnerIterator


class hxd__FloatBuffer_FloatBuffer_Impl_:
    _hx_class_name = "hxd._FloatBuffer.FloatBuffer_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "push", "grow", "resize", "arrayRead", "arrayWrite", "getNative", "iterator", "get_length"]
    length = None

    @staticmethod
    def _new(length = None):
        if (length is None):
            length = 0
        this1 = list()
        if (length > 0):
            if (length > len(this1)):
                python_internal_ArrayImpl._set(this1, (length - 1), 0.)
        return this1

    @staticmethod
    def push(this1,v):
        this1.append(v)

    @staticmethod
    def grow(this1,v):
        if (v > len(this1)):
            python_internal_ArrayImpl._set(this1, (v - 1), 0.)

    @staticmethod
    def resize(this1,v):
        if (len(this1) > v):
            _hx_len = (len(this1) - v)
            pos = v
            if (pos < 0):
                pos = (len(this1) + pos)
            if (pos < 0):
                pos = 0
            res = this1[pos:(pos + _hx_len)]
            del this1[pos:(pos + _hx_len)]
        elif (v > len(this1)):
            python_internal_ArrayImpl._set(this1, (v - 1), 0.)

    @staticmethod
    def arrayRead(this1,key):
        return (this1[key] if key >= 0 and key < len(this1) else None)

    @staticmethod
    def arrayWrite(this1,key,value):
        def _hx_local_1():
            def _hx_local_0():
                python_internal_ArrayImpl._set(this1, key, value)
                return (this1[key] if key >= 0 and key < len(this1) else None)
            return _hx_local_0()
        return _hx_local_1()

    @staticmethod
    def getNative(this1):
        return this1

    @staticmethod
    def iterator(this1):
        return hxd__FloatBuffer_InnerIterator(this1)

    @staticmethod
    def get_length(this1):
        return len(this1)
hxd__FloatBuffer_FloatBuffer_Impl_._hx_class = hxd__FloatBuffer_FloatBuffer_Impl_
_hx_classes["hxd._FloatBuffer.FloatBuffer_Impl_"] = hxd__FloatBuffer_FloatBuffer_Impl_


class hxd__IndexBuffer_InnerIterator:
    _hx_class_name = "hxd._IndexBuffer.InnerIterator"
    _hx_is_interface = "False"
    __slots__ = ("b", "len", "pos")
    _hx_fields = ["b", "len", "pos"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,b):
        self.pos = None
        self.len = None
        self.b = b
        self.len = len(self.b)
        self.pos = 0

    def hasNext(self):
        return (self.pos < self.len)

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.pos
                _hx_local_0.pos = (_hx_local_1 + 1)
                return _hx_local_1
            return python_internal_ArrayImpl._get(self.b, _hx_local_2())
        return _hx_local_3()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.b = None
        _hx_o.len = None
        _hx_o.pos = None
hxd__IndexBuffer_InnerIterator._hx_class = hxd__IndexBuffer_InnerIterator
_hx_classes["hxd._IndexBuffer.InnerIterator"] = hxd__IndexBuffer_InnerIterator


class hxd__IndexBuffer_IndexBuffer_Impl_:
    _hx_class_name = "hxd._IndexBuffer.IndexBuffer_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "push", "grow", "arrayRead", "arrayWrite", "getNative", "iterator", "get_length"]
    length = None

    @staticmethod
    def _new(length = None):
        if (length is None):
            length = 0
        this1 = list()
        if (length > 0):
            if (length > len(this1)):
                python_internal_ArrayImpl._set(this1, (length - 1), 0)
        return this1

    @staticmethod
    def push(this1,v):
        this1.append(v)

    @staticmethod
    def grow(this1,v):
        if (v > len(this1)):
            python_internal_ArrayImpl._set(this1, (v - 1), 0)

    @staticmethod
    def arrayRead(this1,key):
        return (this1[key] if key >= 0 and key < len(this1) else None)

    @staticmethod
    def arrayWrite(this1,key,value):
        def _hx_local_1():
            def _hx_local_0():
                python_internal_ArrayImpl._set(this1, key, value)
                return (this1[key] if key >= 0 and key < len(this1) else None)
            return _hx_local_0()
        return _hx_local_1()

    @staticmethod
    def getNative(this1):
        return this1

    @staticmethod
    def iterator(this1):
        return hxd__IndexBuffer_InnerIterator(this1)

    @staticmethod
    def get_length(this1):
        return len(this1)
hxd__IndexBuffer_IndexBuffer_Impl_._hx_class = hxd__IndexBuffer_IndexBuffer_Impl_
_hx_classes["hxd._IndexBuffer.IndexBuffer_Impl_"] = hxd__IndexBuffer_IndexBuffer_Impl_


class hxd_Key:
    _hx_class_name = "hxd.Key"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["BACKSPACE", "TAB", "ENTER", "SHIFT", "CTRL", "ALT", "ESCAPE", "SPACE", "PGUP", "PGDOWN", "END", "HOME", "LEFT", "UP", "RIGHT", "DOWN", "INSERT", "DELETE", "QWERTY_EQUALS", "QWERTY_MINUS", "QWERTY_TILDE", "QWERTY_BRACKET_LEFT", "QWERTY_BRACKET_RIGHT", "QWERTY_SEMICOLON", "QWERTY_QUOTE", "QWERTY_BACKSLASH", "QWERTY_COMMA", "QWERTY_PERIOD", "QWERTY_SLASH", "INTL_BACKSLASH", "LEFT_WINDOW_KEY", "RIGHT_WINDOW_KEY", "CONTEXT_MENU", "PAUSE_BREAK", "CAPS_LOCK", "NUM_LOCK", "SCROLL_LOCK", "NUMBER_0", "NUMBER_1", "NUMBER_2", "NUMBER_3", "NUMBER_4", "NUMBER_5", "NUMBER_6", "NUMBER_7", "NUMBER_8", "NUMBER_9", "NUMPAD_0", "NUMPAD_1", "NUMPAD_2", "NUMPAD_3", "NUMPAD_4", "NUMPAD_5", "NUMPAD_6", "NUMPAD_7", "NUMPAD_8", "NUMPAD_9", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "F1", "F2", "F3", "F4", "F5", "F6", "F7", "F8", "F9", "F10", "F11", "F12", "F13", "F14", "F15", "F16", "F17", "F18", "F19", "F20", "F21", "F22", "F23", "F24", "NUMPAD_MULT", "NUMPAD_ADD", "NUMPAD_ENTER", "NUMPAD_SUB", "NUMPAD_DOT", "NUMPAD_DIV", "MOUSE_LEFT", "MOUSE_RIGHT", "MOUSE_MIDDLE", "MOUSE_BACK", "MOUSE_FORWARD", "MOUSE_WHEEL_UP", "MOUSE_WHEEL_DOWN", "LOC_LEFT", "LOC_RIGHT", "LSHIFT", "RSHIFT", "LCTRL", "RCTRL", "LALT", "RALT", "initDone", "keyPressed", "ALLOW_KEY_REPEAT", "isDown", "getFrame", "isPressed", "isReleased", "initialize", "dispose", "onEvent", "getKeyName"]

    @staticmethod
    def isDown(code):
        return (python_internal_ArrayImpl._get(hxd_Key.keyPressed, code) > 0)

    @staticmethod
    def getFrame():
        return (hxd_Timer.frameCount + 1)

    @staticmethod
    def isPressed(code):
        return (python_internal_ArrayImpl._get(hxd_Key.keyPressed, code) == (((hxd_Timer.frameCount + 1) - 1)))

    @staticmethod
    def isReleased(code):
        return (python_internal_ArrayImpl._get(hxd_Key.keyPressed, code) == ((-((hxd_Timer.frameCount + 1)) + 1)))

    @staticmethod
    def initialize():
        if hxd_Key.initDone:
            hxd_Key.dispose()
        hxd_Key.initDone = True
        hxd_Key.keyPressed = []
        hxd_Window.getInstance().addEventTarget(hxd_Key.onEvent)

    @staticmethod
    def dispose():
        if hxd_Key.initDone:
            hxd_Window.getInstance().removeEventTarget(hxd_Key.onEvent)
            hxd_Key.initDone = False
            hxd_Key.keyPressed = []

    @staticmethod
    def onEvent(e):
        tmp = e.kind.index
        if (tmp == 0):
            if (e.button < 5):
                python_internal_ArrayImpl._set(hxd_Key.keyPressed, e.button, (hxd_Timer.frameCount + 1))
        elif (tmp == 1):
            if (e.button < 5):
                python_internal_ArrayImpl._set(hxd_Key.keyPressed, e.button, -((hxd_Timer.frameCount + 1)))
        elif (tmp == 5):
            python_internal_ArrayImpl._set(hxd_Key.keyPressed, (6 if ((e.wheelDelta > 0)) else 5), (hxd_Timer.frameCount + 1))
        elif (tmp == 8):
            if ((not hxd_Key.ALLOW_KEY_REPEAT) and ((python_internal_ArrayImpl._get(hxd_Key.keyPressed, e.keyCode) > 0))):
                return
            python_internal_ArrayImpl._set(hxd_Key.keyPressed, e.keyCode, (hxd_Timer.frameCount + 1))
        elif (tmp == 9):
            python_internal_ArrayImpl._set(hxd_Key.keyPressed, e.keyCode, -((hxd_Timer.frameCount + 1)))
        else:
            pass

    @staticmethod
    def getKeyName(keyCode):
        c = keyCode
        c1 = c
        if (c1 == 0):
            return "MouseLeft"
        elif (c1 == 1):
            return "MouseRight"
        elif (c1 == 2):
            return "MouseMiddle"
        elif (c1 == 3):
            return "Mouse3"
        elif (c1 == 4):
            return "Mouse4"
        elif (c1 == 8):
            return "Backspace"
        elif (c1 == 9):
            return "Tab"
        elif (c1 == 13):
            return "Enter"
        elif (c1 == 16):
            return "Shift"
        elif (c1 == 17):
            return "Ctrl"
        elif (c1 == 18):
            return "Alt"
        elif (c1 == 19):
            return "PauseBreak"
        elif (c1 == 20):
            return "CapsLock"
        elif (c1 == 27):
            return "Escape"
        elif (c1 == 32):
            return "Space"
        elif (c1 == 33):
            return "PageUp"
        elif (c1 == 34):
            return "PageDown"
        elif (c1 == 35):
            return "End"
        elif (c1 == 36):
            return "Home"
        elif (c1 == 37):
            return "Left"
        elif (c1 == 38):
            return "Up"
        elif (c1 == 39):
            return "Right"
        elif (c1 == 40):
            return "Down"
        elif (c1 == 45):
            return "Insert"
        elif (c1 == 46):
            return "Delete"
        elif (c1 == 91):
            return "LeftWindowKey"
        elif (c1 == 92):
            return "RightWindowKey"
        elif (c1 == 93):
            return "ContextMenu"
        elif (c1 == 106):
            return "NumPad*"
        elif (c1 == 107):
            return "NumPad+"
        elif (c1 == 108):
            return "NumPadEnter"
        elif (c1 == 109):
            return "NumPad-"
        elif (c1 == 110):
            return "NumPad."
        elif (c1 == 111):
            return "NumPad/"
        elif (c1 == 144):
            return "NumLock"
        elif (c1 == 145):
            return "ScrollLock"
        elif (c1 == 186):
            return "Semicolon"
        elif (c1 == 187):
            return "Equals"
        elif (c1 == 188):
            return "Comma"
        elif (c1 == 189):
            return "Minus"
        elif (c1 == 190):
            return "Period"
        elif (c1 == 191):
            return "Slash"
        elif (c1 == 192):
            return "Tilde"
        elif (c1 == 219):
            return "BracketLeft"
        elif (c1 == 220):
            return "Backslash"
        elif (c1 == 221):
            return "BacketRight"
        elif (c1 == 222):
            return "Quote"
        elif (c1 == 226):
            return "IntlBackslash"
        elif (c1 == 272):
            return "LShift"
        elif (c1 == 273):
            return "LCtrl"
        elif (c1 == 274):
            return "LAlt"
        elif (c1 == 528):
            return "RShift"
        elif (c1 == 529):
            return "RCtrl"
        elif (c1 == 530):
            return "RAlt"
        elif ((c >= 48) and ((c <= 57))):
            return ("" + Std.string(((c - 48))))
        elif ((c >= 96) and ((c <= 105))):
            return ("NumPad" + Std.string(((c - 96))))
        elif ((c >= 65) and ((c <= 90))):
            return "".join(map(chr,[((65 + c) - 65)]))
        elif ((c >= 112) and ((c <= 135))):
            return ("F" + Std.string((((c - 112) + 1))))
        else:
            return None
hxd_Key._hx_class = hxd_Key
_hx_classes["hxd.Key"] = hxd_Key


class hxd_Math:
    _hx_class_name = "hxd.Math"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["PI", "EPSILON", "get_POSITIVE_INFINITY", "get_NEGATIVE_INFINITY", "get_NaN", "isNaN", "fmt", "floor", "ceil", "round", "clamp", "pow", "scaleTime", "cos", "sin", "tan", "acos", "asin", "atan", "sqrt", "invSqrt", "atan2", "abs", "max", "min", "iabs", "imax", "imin", "iclamp", "lerp", "bitCount", "isPOT", "nextPOT", "distanceSq", "distance", "colorLerp", "angle", "angleLerp", "angleMove", "shuffle", "random", "srand", "b2f", "f2b", "umod", "ufmod", "degToRad", "radToDeg"]
    POSITIVE_INFINITY = None
    NEGATIVE_INFINITY = None
    NaN = None

    @staticmethod
    def get_POSITIVE_INFINITY():
        return Math.POSITIVE_INFINITY

    @staticmethod
    def get_NEGATIVE_INFINITY():
        return Math.NEGATIVE_INFINITY

    @staticmethod
    def get_NaN():
        return Math.NaN

    @staticmethod
    def isNaN(v):
        return python_lib_Math.isnan(v)

    @staticmethod
    def fmt(v):
        neg = None
        if (v < 0):
            neg = -1.0
            v = -v
        else:
            neg = 1.0
        if (python_lib_Math.isnan(v) or (not ((((v != Math.POSITIVE_INFINITY) and ((v != Math.NEGATIVE_INFINITY))) and (not python_lib_Math.isnan(v)))))):
            return v
        x = (4 - ((((Math.NEGATIVE_INFINITY if ((v == 0.0)) else (Math.NaN if ((v < 0.0)) else python_lib_Math.log(v)))) / python_lib_Math.log(10))))
        digits = None
        try:
            digits = int(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            digits = None
        if (digits < 1):
            digits = 1
        elif (digits >= 10):
            return 0.
        exp = Math.pow(10,digits)
        v1 = ((v * exp) + .49999)
        return ((((v1 if (((v1 == Math.POSITIVE_INFINITY) or ((v1 == Math.NEGATIVE_INFINITY)))) else (Math.NaN if (python_lib_Math.isnan(v1)) else Math.floor(v1)))) * neg) / exp)

    @staticmethod
    def floor(f):
        return Math.floor(f)

    @staticmethod
    def ceil(f):
        return Math.ceil(f)

    @staticmethod
    def round(f):
        return Math.floor((f + 0.5))

    @staticmethod
    def clamp(f,_hx_min = None,_hx_max = None):
        if (_hx_min is None):
            _hx_min = 0.
        if (_hx_max is None):
            _hx_max = 1.
        if (f < _hx_min):
            return _hx_min
        elif (f > _hx_max):
            return _hx_max
        else:
            return f

    @staticmethod
    def pow(v,p):
        return Math.pow(v,p)

    @staticmethod
    def scaleTime(v,et):
        return Math.pow(v,(et * hxd_Timer.wantedFPS))

    @staticmethod
    def cos(f):
        if ((f == Math.POSITIVE_INFINITY) or ((f == Math.NEGATIVE_INFINITY))):
            return Math.NaN
        else:
            return python_lib_Math.cos(f)

    @staticmethod
    def sin(f):
        if ((f == Math.POSITIVE_INFINITY) or ((f == Math.NEGATIVE_INFINITY))):
            return Math.NaN
        else:
            return python_lib_Math.sin(f)

    @staticmethod
    def tan(f):
        return Math.tan(f)

    @staticmethod
    def acos(f):
        return Math.acos(f)

    @staticmethod
    def asin(f):
        return Math.asin(f)

    @staticmethod
    def atan(f):
        return Math.atan(f)

    @staticmethod
    def sqrt(f):
        if (f < 0):
            return Math.NaN
        else:
            return python_lib_Math.sqrt(f)

    @staticmethod
    def invSqrt(f):
        return (1. / ((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))))

    @staticmethod
    def atan2(dy,dx):
        return Math.atan2(dy,dx)

    @staticmethod
    def abs(f):
        if (f < 0):
            return -f
        else:
            return f

    @staticmethod
    def max(a,b):
        if (a < b):
            return b
        else:
            return a

    @staticmethod
    def min(a,b):
        if (a > b):
            return b
        else:
            return a

    @staticmethod
    def iabs(i):
        if (i < 0):
            return -i
        else:
            return i

    @staticmethod
    def imax(a,b):
        if (a < b):
            return b
        else:
            return a

    @staticmethod
    def imin(a,b):
        if (a > b):
            return b
        else:
            return a

    @staticmethod
    def iclamp(v,_hx_min,_hx_max):
        if (v < _hx_min):
            return _hx_min
        elif (v > _hx_max):
            return _hx_max
        else:
            return v

    @staticmethod
    def lerp(a,b,k):
        return (a + ((k * ((b - a)))))

    @staticmethod
    def bitCount(v):
        v = (v - (((v >> 1) & 1431655765)))
        v = (((v & 858993459)) + (((v >> 2) & 858993459)))
        return (((((v + ((v >> 4))) & 252645135)) * 16843009) >> 24)

    @staticmethod
    def isPOT(v):
        return (((v & ((v - 1)))) == 0)

    @staticmethod
    def nextPOT(v):
        v = (v - 1)
        v = (v | ((v >> 1)))
        v = (v | ((v >> 2)))
        v = (v | ((v >> 4)))
        v = (v | ((v >> 8)))
        v = (v | ((v >> 16)))
        def _hx_local_8():
            def _hx_local_7():
                nonlocal v
                v = (v + 1)
                return v
            return _hx_local_7()
        return _hx_local_8()

    @staticmethod
    def distanceSq(dx,dy,dz = None):
        if (dz is None):
            dz = 0.
        return (((dx * dx) + ((dy * dy))) + ((dz * dz)))

    @staticmethod
    def distance(dx,dy,dz = None):
        if (dz is None):
            dz = 0.
        dz1 = dz
        if (dz1 is None):
            dz1 = 0.
        f = (((dx * dx) + ((dy * dy))) + ((dz1 * dz1)))
        if (f < 0):
            return Math.NaN
        else:
            return python_lib_Math.sqrt(f)

    @staticmethod
    def colorLerp(c1,c2,k):
        a1 = HxOverrides.rshift(c1, 24)
        r1 = ((c1 >> 16) & 255)
        g1 = ((c1 >> 8) & 255)
        b1 = (c1 & 255)
        a2 = HxOverrides.rshift(c2, 24)
        r2 = ((c2 >> 16) & 255)
        g2 = ((c2 >> 8) & 255)
        b2 = (c2 & 255)
        a = None
        try:
            a = int(((a1 * ((1 - k))) + ((a2 * k))))
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            a = None
        a3 = a
        r = None
        try:
            r = int(((r1 * ((1 - k))) + ((r2 * k))))
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e1 = _hx_e1
            r = None
        r3 = r
        g = None
        try:
            g = int(((g1 * ((1 - k))) + ((g2 * k))))
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e2 = _hx_e1
            g = None
        g3 = g
        b = None
        try:
            b = int(((b1 * ((1 - k))) + ((b2 * k))))
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e3 = _hx_e1
            b = None
        b3 = b
        return ((((a3 << 24) | ((r3 << 16))) | ((g3 << 8))) | b3)

    @staticmethod
    def angle(da):
        da = HxOverrides.modf(da, 6.28318530717958623)
        if (da > 3.14159265358979323):
            da = (da - 6.28318530717958623)
        elif (da <= -3.14159265358979312):
            da = (da + 6.28318530717958623)
        return da

    @staticmethod
    def angleLerp(a,b,k):
        da = (b - a)
        da = HxOverrides.modf(da, 6.28318530717958623)
        if (da > 3.14159265358979323):
            da = (da - 6.28318530717958623)
        elif (da <= -3.14159265358979312):
            da = (da + 6.28318530717958623)
        return (a + ((da * k)))

    @staticmethod
    def angleMove(a,b,_hx_max):
        da = (b - a)
        da = HxOverrides.modf(da, 6.28318530717958623)
        if (da > 3.14159265358979323):
            da = (da - 6.28318530717958623)
        elif (da <= -3.14159265358979312):
            da = (da + 6.28318530717958623)
        da1 = da
        if ((da1 > -_hx_max) and ((da1 < _hx_max))):
            return b
        else:
            return (a + ((-_hx_max if ((da1 < 0)) else _hx_max)))

    @staticmethod
    def shuffle(a):
        _hx_len = len(a)
        _g = 0
        _g1 = _hx_len
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            x = (0 if ((_hx_len <= 0)) else int((python_lib_Random.random() * _hx_len)))
            y = (0 if ((_hx_len <= 0)) else int((python_lib_Random.random() * _hx_len)))
            tmp = (a[x] if x >= 0 and x < len(a) else None)
            python_internal_ArrayImpl._set(a, x, (a[y] if y >= 0 and y < len(a) else None))
            python_internal_ArrayImpl._set(a, y, tmp)

    @staticmethod
    def random(_hx_max = None):
        if (_hx_max is None):
            _hx_max = 1.0
        return (python_lib_Random.random() * _hx_max)

    @staticmethod
    def srand(_hx_max = None):
        if (_hx_max is None):
            _hx_max = 1.0
        return (((python_lib_Random.random() - 0.5)) * ((_hx_max * 2)))

    @staticmethod
    def b2f(v):
        return (((v & 255)) * 0.0039215686274509803921568627451)

    @staticmethod
    def f2b(v):
        tmp = None
        try:
            tmp = int((((0. if ((v < 0.)) else (1. if ((v > 1.)) else v))) * 255.0))
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            tmp = None
        return tmp

    @staticmethod
    def umod(value,modulo):
        r = HxOverrides.mod(value, modulo)
        if (r >= 0):
            return r
        else:
            return (r + modulo)

    @staticmethod
    def ufmod(value,modulo):
        r = HxOverrides.modf(value, modulo)
        if (r >= 0):
            return r
        else:
            return (r + modulo)

    @staticmethod
    def degToRad(deg):
        return ((deg * 3.14159265358979323) / 180.0)

    @staticmethod
    def radToDeg(rad):
        return ((rad * 180.0) / 3.14159265358979323)
hxd_Math._hx_class = hxd_Math
_hx_classes["hxd.Math"] = hxd_Math

class hxd_Flags(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.Flags"
    _hx_constructs = ["ReadOnly", "AlphaPremultiplied", "FlipY"]
hxd_Flags.ReadOnly = hxd_Flags("ReadOnly", 0, ())
hxd_Flags.AlphaPremultiplied = hxd_Flags("AlphaPremultiplied", 1, ())
hxd_Flags.FlipY = hxd_Flags("FlipY", 2, ())
hxd_Flags._hx_class = hxd_Flags
_hx_classes["hxd.Flags"] = hxd_Flags


class hxd__Pixels_PixelsARGB_Impl_:
    _hx_class_name = "hxd._Pixels.PixelsARGB_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["getPixel", "setPixel", "fromPixels"]

    @staticmethod
    def getPixel(this1,x,y):
        _this = this1.bytes
        pos = ((((x + ((y * this1.width))) << 2)) + this1.offset)
        v = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
        v1 = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
        return (((HxOverrides.rshift(v1, 24) | (((v1 >> 8) & 65280))) | (((v1 << 8) & 16711680))) | ((v1 << 24)))

    @staticmethod
    def setPixel(this1,x,y,v):
        _this = this1.bytes
        pos = ((((x + ((y * this1.width))) << 2)) + this1.offset)
        v1 = (((HxOverrides.rshift(v, 24) | (((v >> 8) & 65280))) | (((v << 8) & 16711680))) | ((v << 24)))
        _this.b[pos] = (v1 & 255)
        _this.b[(pos + 1)] = ((v1 >> 8) & 255)
        _this.b[(pos + 2)] = ((v1 >> 16) & 255)
        _this.b[(pos + 3)] = (HxOverrides.rshift(v1, 24) & 255)

    @staticmethod
    def fromPixels(p):
        p.convert(hxd_PixelFormat.ARGB)
        p.setFlip(False)
        return p
hxd__Pixels_PixelsARGB_Impl_._hx_class = hxd__Pixels_PixelsARGB_Impl_
_hx_classes["hxd._Pixels.PixelsARGB_Impl_"] = hxd__Pixels_PixelsARGB_Impl_


class hxd__Pixels_PixelsFloat_Impl_:
    _hx_class_name = "hxd._Pixels.PixelsFloat_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["getPixelF", "setPixelF", "fromPixels", "invalidFormat"]

    @staticmethod
    def getPixelF(this1,x,y):
        tmp = this1.innerFormat.index
        if (tmp == 4):
            pix = ((((x + ((y * this1.width))) << 4)) + this1.offset)
            return h3d_Vector(this1.bytes.getFloat(pix),this1.bytes.getFloat((pix + 4)),this1.bytes.getFloat((pix + 8)),this1.bytes.getFloat((pix + 12)))
        elif (tmp == 7):
            pix1 = ((((x + ((y * this1.width))) << 1)) + this1.offset)
            return h3d_Vector(this1.bytes.getFloat(pix1))
        else:
            hxd__Pixels_PixelsFloat_Impl_.invalidFormat(this1)
            return None

    @staticmethod
    def setPixelF(this1,x,y,v):
        tmp = this1.innerFormat.index
        if (tmp == 4):
            pix = ((((x + ((y * this1.width))) << 4)) + this1.offset)
            this1.bytes.setFloat(pix,v.x)
            this1.bytes.setFloat((pix + 4),v.y)
            this1.bytes.setFloat((pix + 8),v.z)
            this1.bytes.setFloat((pix + 12),v.w)
        elif (tmp == 7):
            pix1 = ((((x + ((y * this1.width))) << 1)) + this1.offset)
            this1.bytes.setFloat(pix1,v.x)
        else:
            hxd__Pixels_PixelsFloat_Impl_.invalidFormat(this1)

    @staticmethod
    def fromPixels(p):
        p.setFlip(False)
        return p

    @staticmethod
    def invalidFormat(this1):
        raise _HxException(("Unsupported format for this operation : " + Std.string(this1.innerFormat)))
hxd__Pixels_PixelsFloat_Impl_._hx_class = hxd__Pixels_PixelsFloat_Impl_
_hx_classes["hxd._Pixels.PixelsFloat_Impl_"] = hxd__Pixels_PixelsFloat_Impl_


class hxd__Pixels_Channel_Impl_:
    _hx_class_name = "hxd._Pixels.Channel_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["R", "G", "B", "A", "toInt", "fromInt"]

    @staticmethod
    def toInt(this1):
        return this1

    @staticmethod
    def fromInt(v):
        return v
hxd__Pixels_Channel_Impl_._hx_class = hxd__Pixels_Channel_Impl_
_hx_classes["hxd._Pixels.Channel_Impl_"] = hxd__Pixels_Channel_Impl_


class hxd_Pixels:
    _hx_class_name = "hxd.Pixels"
    _hx_is_interface = "False"
    __slots__ = ("bytes", "width", "height", "stride", "offset", "flags", "bytesPerPixel", "innerFormat")
    _hx_fields = ["bytes", "width", "height", "stride", "offset", "flags", "bytesPerPixel", "innerFormat"]
    _hx_methods = ["get_format", "set_innerFormat", "invalidFormat", "sub", "yflip", "blit", "clear", "toVector", "makeSquare", "copyInner", "willChange", "setFlip", "convert", "getPixel", "setPixel", "dispose", "toPNG", "clone"]
    _hx_statics = ["switchEndian", "switchBR", "calcStride", "S3TC_SIZES", "getChannelOffset", "alloc"]

    def __init__(self,width,height,_hx_bytes,format,offset = None):
        if (offset is None):
            offset = 0
        self.innerFormat = None
        self.bytesPerPixel = None
        self.flags = None
        self.offset = None
        self.stride = None
        self.width = width
        self.height = height
        self.bytes = _hx_bytes
        self.set_innerFormat(format)
        self.offset = offset
        i = 0
        if (i is None):
            i = 0
        this1 = i
        self.flags = this1

    def get_format(self):
        return self.innerFormat

    def set_innerFormat(self,fmt):
        self.innerFormat = fmt
        self.stride = hxd_Pixels.calcStride(self.width,fmt)
        self.bytesPerPixel = hxd_Pixels.calcStride(1,fmt)
        return fmt

    def invalidFormat(self):
        raise _HxException(("Unsupported format for this operation : " + Std.string(self.innerFormat)))

    def sub(self,x,y,width,height):
        if ((((x < 0) or ((y < 0))) or (((x + width) > self.width))) or (((y + height) > self.height))):
            raise _HxException("Pixels.sub() outside bounds")
        out = haxe_io_Bytes.alloc((height * self.stride))
        stride = hxd_Pixels.calcStride(width,self.innerFormat)
        outP = 0
        _g = 0
        _g1 = height
        while (_g < _g1):
            dy = _g
            _g = (_g + 1)
            y1 = (y + dy)
            p = ((((x + ((((((self.height - 1) - y1) if ((((self.flags & ((1 << hxd_Flags.FlipY.index)))) != 0)) else y1)) * self.width)))) * self.bytesPerPixel) + self.offset)
            out.blit(outP,self.bytes,p,stride)
            outP = (outP + stride)
        return hxd_Pixels(width,height,out,self.innerFormat)

    def yflip(self,y):
        if (((self.flags & ((1 << hxd_Flags.FlipY.index)))) != 0):
            return ((self.height - 1) - y)
        else:
            return y

    def blit(self,x,y,src,srcX,srcY,width,height):
        if ((((x < 0) or ((y < 0))) or (((x + width) > self.width))) or (((y + height) > self.height))):
            raise _HxException("Pixels.blit() outside bounds")
        if ((((srcX < 0) or ((srcX < 0))) or (((srcX + width) > src.width))) or (((srcY + height) > src.height))):
            raise _HxException("Pixels.blit() outside src bounds")
        if (((self.flags & ((1 << hxd_Flags.ReadOnly.index)))) != 0):
            self.copyInner()
        src.convert(self.innerFormat)
        bpp = self.bytesPerPixel
        if (bpp == 0):
            raise _HxException("assert")
        stride = hxd_Pixels.calcStride(width,self.innerFormat)
        _g = 0
        _g1 = height
        while (_g < _g1):
            dy = _g
            _g = (_g + 1)
            y1 = (dy + srcY)
            srcP = ((((srcX + ((((((src.height - 1) - y1) if ((((src.flags & ((1 << hxd_Flags.FlipY.index)))) != 0)) else y1)) * src.width)))) * bpp) + src.offset)
            y2 = (dy + y)
            dstP = ((((x + ((((((self.height - 1) - y2) if ((((self.flags & ((1 << hxd_Flags.FlipY.index)))) != 0)) else y2)) * self.width)))) * bpp) + self.offset)
            self.bytes.blit(dstP,src.bytes,srcP,stride)

    def clear(self,color,preserveMask = None):
        if (preserveMask is None):
            preserveMask = 0
        mask = preserveMask
        if (((self.flags & ((1 << hxd_Flags.ReadOnly.index)))) != 0):
            self.copyInner()
        if (((((color & 255)) == (((color >> 8) & 255))) and ((((color & 65535)) == (HxOverrides.rshift(color, 16))))) and ((mask == 0))):
            self.bytes.fill(self.offset,((self.width * self.height) * self.bytesPerPixel),(color & 255))
            return
        tmp = self.innerFormat.index
        if (tmp == 0):
            color = (((HxOverrides.rshift(color, 24) | (((color >> 8) & 65280))) | (((color << 8) & 16711680))) | ((color << 24)))
            mask = (((HxOverrides.rshift(mask, 24) | (((mask >> 8) & 65280))) | (((mask << 8) & 16711680))) | ((mask << 24)))
        elif (tmp == 1):
            pass
        elif (tmp == 2):
            color = (((color & -16711936) | (((color << 16) & 16711680))) | (((color >> 16) & 255)))
            mask = (((mask & -16711936) | (((mask << 16) & 16711680))) | (((mask >> 16) & 255)))
        else:
            self.invalidFormat()
        p = self.offset
        if (mask == 0):
            _g1 = 0
            _g2 = (self.width * self.height)
            while (_g1 < _g2):
                i = _g1
                _g1 = (_g1 + 1)
                _this = self.bytes
                _this.b[p] = (color & 255)
                _this.b[(p + 1)] = ((color >> 8) & 255)
                _this.b[(p + 2)] = ((color >> 16) & 255)
                _this.b[(p + 3)] = (HxOverrides.rshift(color, 24) & 255)
                p = (p + 4)
        else:
            _g11 = 0
            _g21 = (self.width * self.height)
            while (_g11 < _g21):
                i1 = _g11
                _g11 = (_g11 + 1)
                _this1 = self.bytes
                _this2 = self.bytes
                v = (((_this2.b[p] | ((_this2.b[(p + 1)] << 8))) | ((_this2.b[(p + 2)] << 16))) | ((_this2.b[(p + 3)] << 24)))
                v1 = (color | (((((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)) & mask)))
                _this1.b[p] = (v1 & 255)
                _this1.b[(p + 1)] = ((v1 >> 8) & 255)
                _this1.b[(p + 2)] = ((v1 >> 16) & 255)
                _this1.b[(p + 3)] = (HxOverrides.rshift(v1, 24) & 255)
                p = (p + 4)

    def toVector(self):
        this1 = [None]*(self.width * self.height)
        vec = this1
        idx = 0
        p = self.offset
        dl = 0
        if (((self.flags & ((1 << hxd_Flags.FlipY.index)))) != 0):
            p = (p + (((((self.height - 1)) * self.width) * self.bytesPerPixel)))
            dl = ((-self.width * 2) * self.bytesPerPixel)
        tmp = self.innerFormat.index
        if (tmp == 0):
            _g = 0
            _g1 = self.height
            while (_g < _g1):
                y = _g
                _g = (_g + 1)
                _g2 = 0
                _g11 = self.width
                while (_g2 < _g11):
                    x = _g2
                    _g2 = (_g2 + 1)
                    _this = self.bytes
                    v = (((_this.b[p] | ((_this.b[(p + 1)] << 8))) | ((_this.b[(p + 2)] << 16))) | ((_this.b[(p + 3)] << 24)))
                    v1 = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
                    index = idx
                    idx = (idx + 1)
                    val = (((HxOverrides.rshift(v1, 24) | (((v1 >> 8) & 65280))) | (((v1 << 8) & 16711680))) | ((v1 << 24)))
                    vec[index] = val
                    p = (p + 4)
                p = (p + dl)
        elif (tmp == 1):
            _g3 = 0
            _g12 = self.height
            while (_g3 < _g12):
                y1 = _g3
                _g3 = (_g3 + 1)
                _g4 = 0
                _g13 = self.width
                while (_g4 < _g13):
                    x1 = _g4
                    _g4 = (_g4 + 1)
                    index1 = idx
                    idx = (idx + 1)
                    _this1 = self.bytes
                    v2 = (((_this1.b[p] | ((_this1.b[(p + 1)] << 8))) | ((_this1.b[(p + 2)] << 16))) | ((_this1.b[(p + 3)] << 24)))
                    val1 = ((v2 | -2147483648) if ((((v2 & -2147483648)) != 0)) else v2)
                    vec[index1] = val1
                    p = (p + 4)
                p = (p + dl)
        elif (tmp == 2):
            _g5 = 0
            _g14 = self.height
            while (_g5 < _g14):
                y2 = _g5
                _g5 = (_g5 + 1)
                _g6 = 0
                _g15 = self.width
                while (_g6 < _g15):
                    x2 = _g6
                    _g6 = (_g6 + 1)
                    _this2 = self.bytes
                    v3 = (((_this2.b[p] | ((_this2.b[(p + 1)] << 8))) | ((_this2.b[(p + 2)] << 16))) | ((_this2.b[(p + 3)] << 24)))
                    v4 = ((v3 | -2147483648) if ((((v3 & -2147483648)) != 0)) else v3)
                    index2 = idx
                    idx = (idx + 1)
                    val2 = (((v4 & -16711936) | (((v4 << 16) & 16711680))) | (((v4 >> 16) & 255)))
                    vec[index2] = val2
                    p = (p + 4)
                p = (p + dl)
        else:
            self.invalidFormat()
        return vec

    def makeSquare(self,copy = None):
        w = self.width
        h = self.height
        tw = (0 if ((w == 0)) else 1)
        th = (0 if ((h == 0)) else 1)
        while (tw < w):
            tw = (tw << 1)
        while (th < h):
            th = (th << 1)
        if ((w == tw) and ((h == th))):
            return self
        bpp = self.bytesPerPixel
        out = haxe_io_Bytes.alloc(((tw * th) * bpp))
        p = 0
        b = self.offset
        _g = 0
        _g1 = h
        while (_g < _g1):
            y = _g
            _g = (_g + 1)
            out.blit(p,self.bytes,b,(w * bpp))
            p = (p + ((w * bpp)))
            b = (b + ((w * bpp)))
            _g2 = 0
            _g11 = ((((tw - w)) * bpp) >> 2)
            while (_g2 < _g11):
                i = _g2
                _g2 = (_g2 + 1)
                out.b[p] = 0
                out.b[(p + 1)] = 0
                out.b[(p + 2)] = 0
                out.b[(p + 3)] = 0
                p = (p + 4)
        _g21 = 0
        _g3 = (((((th - h)) * tw) * bpp) >> 2)
        while (_g21 < _g3):
            i1 = _g21
            _g21 = (_g21 + 1)
            out.b[p] = 0
            out.b[(p + 1)] = 0
            out.b[(p + 2)] = 0
            out.b[(p + 3)] = 0
            p = (p + 4)
        if copy:
            return hxd_Pixels(tw,th,out,self.innerFormat)
        self.bytes = out
        self.width = tw
        self.height = th
        return self

    def copyInner(self):
        old = self.bytes
        self.bytes = haxe_io_Bytes.alloc((self.height * self.stride))
        self.bytes.blit(0,old,self.offset,(self.height * self.stride))
        self.offset = 0
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.flags
        _hx_local_0.flags = (_hx_local_1 & ((-1 - ((1 << hxd_Flags.ReadOnly.index)))))
        _hx_local_0.flags

    def willChange(self):
        if (((self.flags & ((1 << hxd_Flags.ReadOnly.index)))) != 0):
            self.copyInner()

    def setFlip(self,b):
        if ((((self.flags & ((1 << hxd_Flags.FlipY.index)))) != 0) == b):
            return
        if (((self.flags & ((1 << hxd_Flags.ReadOnly.index)))) != 0):
            self.copyInner()
        if b:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.flags
            _hx_local_0.flags = (_hx_local_1 | ((1 << hxd_Flags.FlipY.index)))
            _hx_local_0.flags
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.flags
            _hx_local_2.flags = (_hx_local_3 & ((-1 - ((1 << hxd_Flags.FlipY.index)))))
            _hx_local_2.flags
        if (HxOverrides.mod(self.stride, 4) != 0):
            self.invalidFormat()
        _g = 0
        _g1 = (self.height >> 1)
        while (_g < _g1):
            y = _g
            _g = (_g + 1)
            p1 = ((y * self.stride) + self.offset)
            p2 = (((((self.height - 1) - y)) * self.stride) + self.offset)
            _g2 = 0
            _g11 = (self.stride >> 2)
            while (_g2 < _g11):
                x = _g2
                _g2 = (_g2 + 1)
                _this = self.bytes
                v = (((_this.b[p1] | ((_this.b[(p1 + 1)] << 8))) | ((_this.b[(p1 + 2)] << 16))) | ((_this.b[(p1 + 3)] << 24)))
                a = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
                _this1 = self.bytes
                v1 = (((_this1.b[p2] | ((_this1.b[(p2 + 1)] << 8))) | ((_this1.b[(p2 + 2)] << 16))) | ((_this1.b[(p2 + 3)] << 24)))
                b1 = ((v1 | -2147483648) if ((((v1 & -2147483648)) != 0)) else v1)
                _this2 = self.bytes
                _this2.b[p1] = (b1 & 255)
                _this2.b[(p1 + 1)] = ((b1 >> 8) & 255)
                _this2.b[(p1 + 2)] = ((b1 >> 16) & 255)
                _this2.b[(p1 + 3)] = (HxOverrides.rshift(b1, 24) & 255)
                _this3 = self.bytes
                _this3.b[p2] = (a & 255)
                _this3.b[(p2 + 1)] = ((a >> 8) & 255)
                _this3.b[(p2 + 2)] = ((a >> 16) & 255)
                _this3.b[(p2 + 3)] = (HxOverrides.rshift(a, 24) & 255)
                p1 = (p1 + 4)
                p2 = (p2 + 4)

    def convert(self,target):
        if (self.innerFormat == target):
            return
        if (((self.flags & ((1 << hxd_Flags.ReadOnly.index)))) != 0):
            self.copyInner()
        this1 = self.bytes.b
        _hx_bytes = this1
        _g = self.innerFormat
        tmp = _g.index
        if (tmp == 0):
            tmp1 = target.index
            if (tmp1 == 1):
                _g1 = 0
                _g11 = (self.width * self.height)
                while (_g1 < _g11):
                    i = _g1
                    _g1 = (_g1 + 1)
                    p = (((i << 2)) + self.offset)
                    a = _hx_bytes[p]
                    r = _hx_bytes[(p + 1)]
                    g = _hx_bytes[(p + 2)]
                    b = _hx_bytes[(p + 3)]
                    i1 = p
                    p = (p + 1)
                    _hx_bytes[i1] = b
                    i2 = p
                    p = (p + 1)
                    _hx_bytes[i2] = g
                    i3 = p
                    p = (p + 1)
                    _hx_bytes[i3] = r
                    _hx_bytes[p] = a
            elif (tmp1 == 2):
                _g2 = 0
                _g12 = (self.width * self.height)
                while (_g2 < _g12):
                    i4 = _g2
                    _g2 = (_g2 + 1)
                    p1 = (((i4 << 2)) + self.offset)
                    a1 = _hx_bytes[p1]
                    v = _hx_bytes[(p1 + 1)]
                    _hx_bytes[p1] = v
                    v1 = _hx_bytes[(p1 + 2)]
                    _hx_bytes[(p1 + 1)] = v1
                    v2 = _hx_bytes[(p1 + 3)]
                    _hx_bytes[(p1 + 2)] = v2
                    _hx_bytes[(p1 + 3)] = a1
            else:
                raise _HxException(((("Cannot convert from " + Std.string(self.innerFormat)) + " to ") + Std.string(target)))
        elif (tmp == 1):
            tmp2 = target.index
            if (tmp2 == 0):
                _g3 = 0
                _g13 = (self.width * self.height)
                while (_g3 < _g13):
                    i5 = _g3
                    _g3 = (_g3 + 1)
                    p2 = (((i5 << 2)) + self.offset)
                    a2 = _hx_bytes[p2]
                    r1 = _hx_bytes[(p2 + 1)]
                    g1 = _hx_bytes[(p2 + 2)]
                    b1 = _hx_bytes[(p2 + 3)]
                    i6 = p2
                    p2 = (p2 + 1)
                    _hx_bytes[i6] = b1
                    i7 = p2
                    p2 = (p2 + 1)
                    _hx_bytes[i7] = g1
                    i8 = p2
                    p2 = (p2 + 1)
                    _hx_bytes[i8] = r1
                    _hx_bytes[p2] = a2
            elif (tmp2 == 2):
                _g4 = 0
                _g14 = (self.width * self.height)
                while (_g4 < _g14):
                    i9 = _g4
                    _g4 = (_g4 + 1)
                    p3 = (((i9 << 2)) + self.offset)
                    b2 = _hx_bytes[p3]
                    r2 = _hx_bytes[(p3 + 2)]
                    _hx_bytes[p3] = r2
                    _hx_bytes[(p3 + 2)] = b2
            else:
                raise _HxException(((("Cannot convert from " + Std.string(self.innerFormat)) + " to ") + Std.string(target)))
        elif (tmp == 2):
            tmp3 = target.index
            if (tmp3 == 0):
                _g5 = 0
                _g15 = (self.width * self.height)
                while (_g5 < _g15):
                    i10 = _g5
                    _g5 = (_g5 + 1)
                    p4 = (((i10 << 2)) + self.offset)
                    a3 = _hx_bytes[(p4 + 3)]
                    v3 = _hx_bytes[(p4 + 2)]
                    _hx_bytes[(p4 + 3)] = v3
                    v4 = _hx_bytes[(p4 + 1)]
                    _hx_bytes[(p4 + 2)] = v4
                    v5 = _hx_bytes[p4]
                    _hx_bytes[(p4 + 1)] = v5
                    _hx_bytes[p4] = a3
            elif (tmp3 == 1):
                _g6 = 0
                _g16 = (self.width * self.height)
                while (_g6 < _g16):
                    i11 = _g6
                    _g6 = (_g6 + 1)
                    p5 = (((i11 << 2)) + self.offset)
                    b3 = _hx_bytes[p5]
                    r3 = _hx_bytes[(p5 + 2)]
                    _hx_bytes[p5] = r3
                    _hx_bytes[(p5 + 2)] = b3
            else:
                raise _HxException(((("Cannot convert from " + Std.string(self.innerFormat)) + " to ") + Std.string(target)))
        elif (tmp == 18):
            if (target.index == 18):
                a4 = _g.params[0]
                b4 = target.params[0]
                if (a4 != b4):
                    raise _HxException(((("Cannot convert from " + Std.string(self.innerFormat)) + " to ") + Std.string(target)))
            else:
                raise _HxException(((("Cannot convert from " + Std.string(self.innerFormat)) + " to ") + Std.string(target)))
        else:
            raise _HxException(((("Cannot convert from " + Std.string(self.innerFormat)) + " to ") + Std.string(target)))
        self.set_innerFormat(target)

    def getPixel(self,x,y):
        p = ((((x + ((((((self.height - 1) - y) if ((((self.flags & ((1 << hxd_Flags.FlipY.index)))) != 0)) else y)) * self.width)))) * self.bytesPerPixel) + self.offset)
        tmp = self.innerFormat.index
        if (tmp == 0):
            _this = self.bytes
            v = (((_this.b[p] | ((_this.b[(p + 1)] << 8))) | ((_this.b[(p + 2)] << 16))) | ((_this.b[(p + 3)] << 24)))
            v1 = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
            return (((HxOverrides.rshift(v1, 24) | (((v1 >> 8) & 65280))) | (((v1 << 8) & 16711680))) | ((v1 << 24)))
        elif (tmp == 1):
            _this1 = self.bytes
            v2 = (((_this1.b[p] | ((_this1.b[(p + 1)] << 8))) | ((_this1.b[(p + 2)] << 16))) | ((_this1.b[(p + 3)] << 24)))
            if (((v2 & -2147483648)) != 0):
                return (v2 | -2147483648)
            else:
                return v2
        elif (tmp == 2):
            _this2 = self.bytes
            v3 = (((_this2.b[p] | ((_this2.b[(p + 1)] << 8))) | ((_this2.b[(p + 2)] << 16))) | ((_this2.b[(p + 3)] << 24)))
            v4 = ((v3 | -2147483648) if ((((v3 & -2147483648)) != 0)) else v3)
            return (((v4 & -16711936) | (((v4 << 16) & 16711680))) | (((v4 >> 16) & 255)))
        else:
            self.invalidFormat()
            return 0

    def setPixel(self,x,y,color):
        p = ((((x + ((((((self.height - 1) - y) if ((((self.flags & ((1 << hxd_Flags.FlipY.index)))) != 0)) else y)) * self.width)))) * self.bytesPerPixel) + self.offset)
        if (((self.flags & ((1 << hxd_Flags.ReadOnly.index)))) != 0):
            self.copyInner()
        tmp = self.innerFormat.index
        if (tmp == 0):
            _this = self.bytes
            v = (((HxOverrides.rshift(color, 24) | (((color >> 8) & 65280))) | (((color << 8) & 16711680))) | ((color << 24)))
            _this.b[p] = (v & 255)
            _this.b[(p + 1)] = ((v >> 8) & 255)
            _this.b[(p + 2)] = ((v >> 16) & 255)
            _this.b[(p + 3)] = (HxOverrides.rshift(v, 24) & 255)
        elif (tmp == 1):
            _this1 = self.bytes
            _this1.b[p] = (color & 255)
            _this1.b[(p + 1)] = ((color >> 8) & 255)
            _this1.b[(p + 2)] = ((color >> 16) & 255)
            _this1.b[(p + 3)] = (HxOverrides.rshift(color, 24) & 255)
        elif (tmp == 2):
            _this2 = self.bytes
            v1 = (((color & -16711936) | (((color << 16) & 16711680))) | (((color >> 16) & 255)))
            _this2.b[p] = (v1 & 255)
            _this2.b[(p + 1)] = ((v1 >> 8) & 255)
            _this2.b[(p + 2)] = ((v1 >> 16) & 255)
            _this2.b[(p + 3)] = (HxOverrides.rshift(v1, 24) & 255)
        else:
            self.invalidFormat()

    def dispose(self):
        self.bytes = None

    def toPNG(self,level = None):
        if (level is None):
            level = 9
        png = None
        self.setFlip(False)
        if (self.innerFormat.index == 0):
            png = format_png_Tools.build32ARGB(self.width,self.height,self.bytes,level)
        else:
            self.convert(hxd_PixelFormat.BGRA)
            png = format_png_Tools.build32BGRA(self.width,self.height,self.bytes,level)
        o = haxe_io_BytesOutput()
        format_png_Writer(o).write(png)
        return o.getBytes()

    def clone(self):
        p = hxd_Pixels(self.width,self.height,None,self.innerFormat)
        p.flags = self.flags
        p.flags = (p.flags & ((-1 - ((1 << hxd_Flags.ReadOnly.index)))))
        if (self.bytes is not None):
            size = (self.height * self.stride)
            p.bytes = haxe_io_Bytes.alloc(size)
            p.bytes.blit(0,self.bytes,self.offset,size)
        return p

    @staticmethod
    def switchEndian(v):
        return (((HxOverrides.rshift(v, 24) | (((v >> 8) & 65280))) | (((v << 8) & 16711680))) | ((v << 24)))

    @staticmethod
    def switchBR(v):
        return (((v & -16711936) | (((v << 16) & 16711680))) | (((v >> 16) & 255)))

    @staticmethod
    def calcStride(width,format):
        tmp = None
        tmp1 = format.index
        if (tmp1 == 3):
            tmp = 8
        elif (tmp1 == 4):
            tmp = 16
        elif (tmp1 == 5):
            tmp = 1
        elif (tmp1 == 6):
            tmp = 2
        elif (tmp1 == 7):
            tmp = 4
        elif (tmp1 == 8):
            tmp = 2
        elif (tmp1 == 9):
            tmp = 4
        elif (tmp1 == 10):
            tmp = 8
        elif (tmp1 == 11):
            tmp = 3
        elif (tmp1 == 12):
            tmp = 6
        elif (tmp1 == 13):
            tmp = 12
        elif (((((tmp1 == 15) or ((tmp1 == 14))) or ((tmp1 == 2))) or ((tmp1 == 1))) or ((tmp1 == 0))):
            tmp = 4
        elif (tmp1 == 16):
            tmp = 4
        elif (tmp1 == 17):
            tmp = 4
        elif (tmp1 == 18):
            n = format.params[0]
            if ((n == 1) or ((n == 4))):
                return (width >> 1)
            tmp = 1
        else:
            pass
        return (width * tmp)

    @staticmethod
    def getChannelOffset(format,channel):
        tmp = format.index
        if (tmp == 0):
            return python_internal_ArrayImpl._get([1, 2, 3, 0], channel)
        elif (tmp == 1):
            return python_internal_ArrayImpl._get([2, 1, 0, 3], channel)
        elif (tmp == 3):
            return (channel * 2)
        elif (tmp == 4):
            return (channel * 4)
        elif (((tmp == 7) or ((tmp == 6))) or ((tmp == 5))):
            if (channel == 0):
                return 0
            else:
                return -1
        elif (((tmp == 10) or ((tmp == 9))) or ((tmp == 8))):
            p = hxd_Pixels.calcStride(1,format)
            return python_internal_ArrayImpl._get([0, p, -1, -1], channel)
        elif (((tmp == 13) or ((tmp == 12))) or ((tmp == 11))):
            p1 = hxd_Pixels.calcStride(1,format)
            return python_internal_ArrayImpl._get([0, p1, (p1 << 1), -1], channel)
        elif (((tmp == 15) or ((tmp == 14))) or ((tmp == 2))):
            return channel
        elif ((tmp == 17) or ((tmp == 16))):
            raise _HxException("Bit packed format")
        elif (tmp == 18):
            _g = format.params[0]
            raise _HxException("Not supported")
        else:
            pass

    @staticmethod
    def alloc(width,height,format):
        return hxd_Pixels(width,height,haxe_io_Bytes.alloc((height * hxd_Pixels.calcStride(width,format))),format)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.bytes = None
        _hx_o.width = None
        _hx_o.height = None
        _hx_o.stride = None
        _hx_o.offset = None
        _hx_o.flags = None
        _hx_o.bytesPerPixel = None
        _hx_o.innerFormat = None
hxd_Pixels._hx_class = hxd_Pixels
_hx_classes["hxd.Pixels"] = hxd_Pixels


class hxd_Res:
    _hx_class_name = "hxd.Res"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["load", "get_loader", "set_loader"]
    loader = None

    @staticmethod
    def load(name):
        return hxd_Res.get_loader().load(name)

    @staticmethod
    def get_loader():
        l = hxd_res_Loader.currentInstance
        if (l is None):
            raise _HxException("Resource loader not initialized: call to hxd.Res.initXXX() required")
        return l

    @staticmethod
    def set_loader(l):
        def _hx_local_1():
            def _hx_local_0():
                hxd_res_Loader.currentInstance = l
                return hxd_res_Loader.currentInstance
            return _hx_local_0()
        return _hx_local_1()
hxd_Res._hx_class = hxd_Res
_hx_classes["hxd.Res"] = hxd_Res


class hxd_SceneEvents:
    _hx_class_name = "hxd.SceneEvents"
    _hx_is_interface = "False"
    __slots__ = ("window", "scenes", "overList", "overCandidates", "overIndex", "currentFocus", "pendingEvents", "pushList", "currentDrag", "mouseX", "mouseY", "lastTouch", "focusLost", "checkPos", "onOut", "onOver", "isOut", "enablePhysicalMouse", "mouseCheckMove", "defaultCursor")
    _hx_fields = ["window", "scenes", "overList", "overCandidates", "overIndex", "currentFocus", "pendingEvents", "pushList", "currentDrag", "mouseX", "mouseY", "lastTouch", "focusLost", "checkPos", "onOut", "onOver", "isOut", "enablePhysicalMouse", "mouseCheckMove", "defaultCursor"]
    _hx_methods = ["setMousePos", "onRemove", "addScene", "removeScene", "dispose", "focus", "blur", "checkFocus", "emitEvent", "checkEvents", "startDrag", "stopDrag", "getFocus", "updateCursor", "set_defaultCursor", "selectCursor", "onEvent", "dispatchListeners"]

    def __init__(self,window = None):
        self.currentDrag = None
        self.currentFocus = None
        self.defaultCursor = hxd_Cursor.Default
        self.mouseCheckMove = True
        self.enablePhysicalMouse = True
        self.isOut = False
        self.onOver = hxd_Event(hxd_EventKind.EOver)
        self.onOut = hxd_Event(hxd_EventKind.EOut)
        self.checkPos = hxd_Event(hxd_EventKind.ECheck)
        self.focusLost = hxd_Event(hxd_EventKind.EFocusLost)
        self.lastTouch = 0
        self.mouseY = -1.
        self.mouseX = -1.
        self.overIndex = -1
        self.scenes = []
        self.pendingEvents = []
        self.pushList = []
        self.overList = []
        self.overCandidates = []
        if (window is None):
            window = hxd_Window.getInstance()
        self.window = window
        window.addEventTarget(self.onEvent)

    def setMousePos(self,xPos,yPos):
        self.mouseX = xPos
        self.mouseY = yPos

    def onRemove(self,i):
        if (i == self.currentFocus):
            self.currentFocus = None
        if (self.overIndex >= 0):
            index = python_internal_ArrayImpl.indexOf(self.overList,i,None)
            if (index >= 0):
                python_internal_ArrayImpl.remove(self.overList,i)
                if (index < self.overIndex):
                    _hx_local_0 = self
                    _hx_local_1 = _hx_local_0.overIndex
                    _hx_local_0.overIndex = (_hx_local_1 - 1)
                    _hx_local_1
        else:
            python_internal_ArrayImpl.remove(self.overList,i)
            self.selectCursor()
        python_internal_ArrayImpl.remove(self.pushList,i)

    def addScene(self,s,index = None):
        s.setEvents(self)
        if (index is None):
            _this = self.scenes
            _this.append(s)
        else:
            self.scenes.insert(index, s)

    def removeScene(self,s):
        if python_internal_ArrayImpl.remove(self.scenes,s):
            s.setEvents(None)

    def dispose(self):
        self.window.removeEventTarget(self.onEvent)

    def focus(self,i):
        if (self.currentFocus == i):
            return
        if (i is None):
            self.blur()
            return
        if (self.currentFocus is not None):
            self.blur()
            if (self.currentFocus is not None):
                return
        e = hxd_Event(hxd_EventKind.EFocus)
        i.handleEvent(e)
        if (not e.cancel):
            self.currentFocus = i

    def blur(self):
        if (self.currentFocus is None):
            return
        self.focusLost.cancel = False
        self.currentFocus.handleEvent(self.focusLost)
        if (not self.focusLost.cancel):
            self.currentFocus = None

    def checkFocus(self):
        if (self.currentFocus is None):
            return
        s = self.currentFocus.getInteractiveScene()
        if (s is None):
            self.currentFocus = None
            return
        if (not s.isInteractiveVisible(self.currentFocus)):
            self.blur()

    def emitEvent(self,event):
        oldX = event.relX
        oldY = event.relY
        overCandidateCount = 0
        handled = False
        checkOver = False
        fillOver = False
        checkPush = False
        cancelFocus = False
        updateCursor = False
        self.overIndex = 0
        tmp = event.kind.index
        if (tmp == 0):
            cancelFocus = True
            checkPush = True
        elif (tmp == 1):
            checkPush = True
        elif ((((tmp == 11) or ((tmp == 9))) or ((tmp == 8))) or ((tmp == 5))):
            if (self.currentFocus is not None):
                def _hx_local_0():
                    event.relY = 0
                    return event.relY
                event.relX = _hx_local_0()
                self.currentFocus.handleEvent(event)
                event.relX = oldX
                event.relY = oldY
                if (not event.propagate):
                    return
        elif ((tmp == 12) or ((tmp == 2))):
            checkOver = True
            fillOver = True
        else:
            pass
        _g1 = 0
        _g2 = self.scenes
        while (_g1 < len(_g2)):
            s = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
            _g1 = (_g1 + 1)
            last = None
            while True:
                i = s.handleEvent(event,last)
                if (i is None):
                    event.relX = oldX
                    event.relY = oldY
                    break
                if checkOver:
                    if fillOver:
                        idx = python_internal_ArrayImpl.indexOf(self.overList,i,None)
                        if (idx == -1):
                            if (len(self.overCandidates) == overCandidateCount):
                                python_internal_ArrayImpl._set(self.overCandidates, overCandidateCount, _hx_AnonObject({'i': i, 's': s, 'x': event.relX, 'y': event.relY, 'z': event.relZ}))
                            else:
                                info = (self.overCandidates[overCandidateCount] if overCandidateCount >= 0 and overCandidateCount < len(self.overCandidates) else None)
                                info.i = i
                                info.s = s
                                info.x = event.relX
                                info.y = event.relY
                                info.z = event.relZ
                            overCandidateCount = (overCandidateCount + 1)
                            pos = self.overIndex
                            self.overIndex = (self.overIndex + 1)
                            self.overList.insert(pos, i)
                            updateCursor = True
                        else:
                            if (idx < self.overIndex):
                                while True:
                                    python_internal_ArrayImpl._set(self.overList, idx, python_internal_ArrayImpl._get(self.overList, (idx + 1)))
                                    idx = (idx + 1)
                                    if (not ((idx < self.overIndex))):
                                        break
                                python_internal_ArrayImpl._set(self.overList, self.overIndex, i)
                                updateCursor = True
                            elif (idx > self.overIndex):
                                while True:
                                    python_internal_ArrayImpl._set(self.overList, idx, python_internal_ArrayImpl._get(self.overList, (idx - 1)))
                                    idx = (idx - 1)
                                    if (not ((idx > self.overIndex))):
                                        break
                                python_internal_ArrayImpl._set(self.overList, self.overIndex, i)
                                updateCursor = True
                            _hx_local_5 = self
                            _hx_local_6 = _hx_local_5.overIndex
                            _hx_local_5.overIndex = (_hx_local_6 + 1)
                            _hx_local_6
                        fillOver = event.propagate
                else:
                    if checkPush:
                        if (event.kind == hxd_EventKind.EPush):
                            _this = self.pushList
                            _this.append(i)
                        else:
                            python_internal_ArrayImpl.remove(self.pushList,i)
                    if (cancelFocus and ((i == self.currentFocus))):
                        cancelFocus = False
                event.relX = oldX
                event.relY = oldY
                if (not event.propagate):
                    handled = True
                    break
                last = i
                event.propagate = False
            if handled:
                break
        if (cancelFocus and ((self.currentFocus is not None))):
            self.blur()
        if checkOver:
            if (self.overIndex < len(self.overList)):
                while (self.overIndex < len(self.overList)):
                    _this1 = self.overList
                    e = (None if ((len(_this1) == 0)) else _this1.pop())
                    e.handleEvent(self.onOut)
                updateCursor = True
            if (overCandidateCount != 0):
                i1 = 0
                ev = self.onOver
                while True:
                    info1 = i1
                    i1 = (i1 + 1)
                    info2 = (self.overCandidates[info1] if info1 >= 0 and info1 < len(self.overCandidates) else None)
                    ev.relX = info2.x
                    ev.relY = info2.y
                    ev.relZ = info2.z
                    if info2.s.isInteractiveVisible(info2.i):
                        info2.i.handleEvent(ev)
                    else:
                        python_internal_ArrayImpl.remove(self.overList,info2.i)
                    info2.i = None
                    info2.s = None
                    if (not ((i1 < overCandidateCount))):
                        break
        self.overIndex = -1
        if updateCursor:
            self.selectCursor()
        if ((not handled) and ((event != self.checkPos))):
            if (event.kind == hxd_EventKind.EPush):
                _this2 = self.pushList
                _this2.append(None)
            elif (event.kind == hxd_EventKind.ERelease):
                python_internal_ArrayImpl.remove(self.pushList,None)
            self.dispatchListeners(event)
        if ((event.kind == hxd_EventKind.ERelease) and ((len(self.pushList) > 0))):
            _g3 = 0
            _g4 = self.pushList
            while (_g3 < len(_g4)):
                i2 = (_g4[_g3] if _g3 >= 0 and _g3 < len(_g4) else None)
                _g3 = (_g3 + 1)
                if (i2 is None):
                    event.kind = hxd_EventKind.EReleaseOutside
                    self.dispatchListeners(event)
                    event.kind = hxd_EventKind.ERelease
                else:
                    s1 = i2.getInteractiveScene()
                    if (s1 is None):
                        continue
                    event.kind = hxd_EventKind.EReleaseOutside
                    s1.dispatchEvent(event,i2)
                    event.kind = hxd_EventKind.ERelease
                    event.relX = oldX
                    event.relY = oldY
            self.pushList = list()

    def checkEvents(self):
        old = self.pendingEvents
        checkMoved = (not self.mouseCheckMove)
        checkFocused = (self.currentFocus is None)
        if (len(old) > 0):
            self.pendingEvents = []
            _g = 0
            while (_g < len(old)):
                e = (old[_g] if _g >= 0 and _g < len(old) else None)
                _g = (_g + 1)
                ox = e.relX
                oy = e.relY
                tmp = e.kind.index
                if ((tmp == 1) or ((tmp == 0))):
                    self.mouseX = e.relX
                    self.mouseY = e.relY
                    self.lastTouch = e.touchId
                elif (tmp == 2):
                    checkMoved = True
                    self.mouseX = e.relX
                    self.mouseY = e.relY
                    self.lastTouch = e.touchId
                elif (tmp == 3):
                    self.isOut = False
                    self.selectCursor()
                    continue
                elif (tmp == 4):
                    self.isOut = True
                    if (len(self.overList) > 0):
                        i = (len(self.overList) - 1)
                        while (i >= 0):
                            self.onOut.cancel = False
                            (self.overList[i] if i >= 0 and i < len(self.overList) else None).handleEvent(self.onOut)
                            python_internal_ArrayImpl.remove(self.overList,(self.overList[i] if i >= 0 and i < len(self.overList) else None))
                            i = (i - 1)
                        self.selectCursor()
                    continue
                elif ((((tmp == 11) or ((tmp == 9))) or ((tmp == 8))) or ((tmp == 5))):
                    if (not checkFocused):
                        checkFocused = True
                        self.checkFocus()
                else:
                    pass
                if ((self.currentDrag is not None) and (((self.currentDrag.ref is None) or ((self.currentDrag.ref == e.touchId))))):
                    e.propagate = True
                    e.cancel = False
                    self.currentDrag.f(e)
                    e.relX = ox
                    e.relY = oy
                    if (not e.propagate):
                        continue
                self.emitEvent(e)
        if (not checkFocused):
            self.checkFocus()
        if (((not checkMoved) and (not self.isOut)) and ((self.currentDrag is None))):
            self.checkPos.relX = self.mouseX
            self.checkPos.relY = self.mouseY
            self.checkPos.touchId = self.lastTouch
            self.checkPos.cancel = False
            self.checkPos.propagate = False
            self.emitEvent(self.checkPos)

    def startDrag(self,f,onCancel = None,refEvent = None):
        if ((self.currentDrag is not None) and ((self.currentDrag.onCancel is not None))):
            self.currentDrag.onCancel()
        self.currentDrag = _hx_AnonObject({'f': f, 'ref': (None if ((refEvent is None)) else refEvent.touchId), 'onCancel': onCancel})

    def stopDrag(self):
        if ((self.currentDrag is not None) and ((self.currentDrag.onCancel is not None))):
            self.currentDrag.onCancel()
        self.currentDrag = None

    def getFocus(self):
        return self.currentFocus

    def updateCursor(self,i):
        if (python_internal_ArrayImpl.indexOf(self.overList,i,None) != -1):
            self.selectCursor()

    def set_defaultCursor(self,c):
        if Type.enumEq(c,self.defaultCursor):
            return c
        self.defaultCursor = c
        self.selectCursor()
        return c

    def selectCursor(self):
        cur = self.defaultCursor
        _g = 0
        _g1 = self.overList
        while (_g < len(_g1)):
            o = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (o.cursor is not None):
                cur = o.cursor
                break
        if (cur.index == 6):
            f = cur.params[0]
            f()
        else:
            hxd_System.setCursor(cur)

    def onEvent(self,e):
        if ((not self.enablePhysicalMouse) and ((e.kind == hxd_EventKind.EMove))):
            return
        _this = self.pendingEvents
        _this.append(e)

    def dispatchListeners(self,event):
        ox = event.relX
        oy = event.relY
        event.propagate = True
        _g = 0
        _g1 = self.scenes
        while (_g < len(_g1)):
            s = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            event.cancel = False
            s.dispatchListeners(event)
            event.relX = ox
            event.relY = oy
            if (not event.propagate):
                break

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.window = None
        _hx_o.scenes = None
        _hx_o.overList = None
        _hx_o.overCandidates = None
        _hx_o.overIndex = None
        _hx_o.currentFocus = None
        _hx_o.pendingEvents = None
        _hx_o.pushList = None
        _hx_o.currentDrag = None
        _hx_o.mouseX = None
        _hx_o.mouseY = None
        _hx_o.lastTouch = None
        _hx_o.focusLost = None
        _hx_o.checkPos = None
        _hx_o.onOut = None
        _hx_o.onOver = None
        _hx_o.isOut = None
        _hx_o.enablePhysicalMouse = None
        _hx_o.mouseCheckMove = None
        _hx_o.defaultCursor = None
hxd_SceneEvents._hx_class = hxd_SceneEvents
_hx_classes["hxd.SceneEvents"] = hxd_SceneEvents

class hxd_Platform(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.Platform"
    _hx_constructs = ["IOS", "Android", "WebGL", "PC", "Console", "FlashPlayer"]
hxd_Platform.IOS = hxd_Platform("IOS", 0, ())
hxd_Platform.Android = hxd_Platform("Android", 1, ())
hxd_Platform.WebGL = hxd_Platform("WebGL", 2, ())
hxd_Platform.PC = hxd_Platform("PC", 3, ())
hxd_Platform.Console = hxd_Platform("Console", 4, ())
hxd_Platform.FlashPlayer = hxd_Platform("FlashPlayer", 5, ())
hxd_Platform._hx_class = hxd_Platform
_hx_classes["hxd.Platform"] = hxd_Platform

class hxd_SystemValue(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.SystemValue"
    _hx_constructs = ["IsTouch", "IsWindowed", "IsMobile"]
hxd_SystemValue.IsTouch = hxd_SystemValue("IsTouch", 0, ())
hxd_SystemValue.IsWindowed = hxd_SystemValue("IsWindowed", 1, ())
hxd_SystemValue.IsMobile = hxd_SystemValue("IsMobile", 2, ())
hxd_SystemValue._hx_class = hxd_SystemValue
_hx_classes["hxd.SystemValue"] = hxd_SystemValue


class hxd_System:
    _hx_class_name = "hxd.System"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["setCursor", "timeoutTick", "loopFunc", "getCurrentLoop", "setLoop", "start", "setNativeCursor", "getDeviceName", "getDefaultFrameRate", "getValue", "exit", "openURL", "get_width", "get_height", "get_lang", "get_platform", "get_screenDPI", "get_allowTimeout", "set_allowTimeout"]
    width = None
    height = None
    lang = None
    platform = None
    screenDPI = None
    allowTimeout = None
    loopFunc = None

    @staticmethod
    def timeoutTick():
        pass

    @staticmethod
    def getCurrentLoop():
        return hxd_System.loopFunc

    @staticmethod
    def setLoop(f):
        hxd_System.loopFunc = f

    @staticmethod
    def start(callb):
        pass

    @staticmethod
    def setNativeCursor(c):
        pass

    @staticmethod
    def getDeviceName():
        return "Unknown"

    @staticmethod
    def getDefaultFrameRate():
        return 60.

    @staticmethod
    def getValue(s):
        return False

    @staticmethod
    def exit():
        pass

    @staticmethod
    def openURL(url):
        pass

    @staticmethod
    def get_width():
        return 0

    @staticmethod
    def get_height():
        return 0

    @staticmethod
    def get_lang():
        return "en"

    @staticmethod
    def get_platform():
        return hxd_Platform.PC

    @staticmethod
    def get_screenDPI():
        return 72

    @staticmethod
    def get_allowTimeout():
        return False

    @staticmethod
    def set_allowTimeout(b):
        return False
hxd_System._hx_class = hxd_System
_hx_classes["hxd.System"] = hxd_System


class hxd_Timer:
    _hx_class_name = "hxd.Timer"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["wantedFPS", "maxDeltaTime", "smoothFactor", "lastTimeStamp", "elapsedTime", "frameCount", "dt", "currentDT", "update", "get_tmod", "set_tmod", "fps", "skip", "reset"]
    tmod = None

    @staticmethod
    def update():
        _hx_local_0 = hxd_Timer
        _hx_local_1 = _hx_local_0.frameCount
        _hx_local_0.frameCount = (_hx_local_1 + 1)
        _hx_local_1
        newTime = python_lib_Timeit.default_timer()
        hxd_Timer.elapsedTime = (newTime - hxd_Timer.lastTimeStamp)
        hxd_Timer.lastTimeStamp = newTime
        if (hxd_Timer.elapsedTime < hxd_Timer.maxDeltaTime):
            a = hxd_Timer.elapsedTime
            hxd_Timer.currentDT = (a + ((hxd_Timer.smoothFactor * ((hxd_Timer.currentDT - a)))))
        else:
            hxd_Timer.elapsedTime = (1 / hxd_Timer.wantedFPS)
        hxd_Timer.dt = hxd_Timer.currentDT

    @staticmethod
    def get_tmod():
        return (hxd_Timer.dt * hxd_Timer.wantedFPS)

    @staticmethod
    def set_tmod(v):
        hxd_Timer.dt = (v / hxd_Timer.wantedFPS)
        return v

    @staticmethod
    def fps():
        return (1. / hxd_Timer.currentDT)

    @staticmethod
    def skip():
        hxd_Timer.lastTimeStamp = python_lib_Timeit.default_timer()

    @staticmethod
    def reset():
        hxd_Timer.lastTimeStamp = python_lib_Timeit.default_timer()
        def _hx_local_0():
            hxd_Timer.currentDT = (1. / hxd_Timer.wantedFPS)
            return hxd_Timer.currentDT
        hxd_Timer.dt = _hx_local_0()
hxd_Timer._hx_class = hxd_Timer
_hx_classes["hxd.Timer"] = hxd_Timer

class hxd_DisplayMode(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.DisplayMode"
    _hx_constructs = ["Windowed", "Borderless", "Fullscreen", "FullscreenResize"]
hxd_DisplayMode.Windowed = hxd_DisplayMode("Windowed", 0, ())
hxd_DisplayMode.Borderless = hxd_DisplayMode("Borderless", 1, ())
hxd_DisplayMode.Fullscreen = hxd_DisplayMode("Fullscreen", 2, ())
hxd_DisplayMode.FullscreenResize = hxd_DisplayMode("FullscreenResize", 3, ())
hxd_DisplayMode._hx_class = hxd_DisplayMode
_hx_classes["hxd.DisplayMode"] = hxd_DisplayMode


class hxd_Window:
    _hx_class_name = "hxd.Window"
    _hx_is_interface = "False"
    _hx_fields = ["resizeEvents", "eventTargets"]
    _hx_methods = ["onClose", "event", "addEventTarget", "removeEventTarget", "addResizeEvent", "removeResizeEvent", "onResize", "resize", "setFullScreen", "get_mouseX", "get_mouseY", "get_width", "get_height", "get_mouseLock", "set_mouseLock", "get_vsync", "set_vsync", "get_isFocused", "get_displayMode", "set_displayMode", "get_title", "set_title"]
    _hx_statics = ["inst", "getInstance"]

    def __init__(self):
        self.eventTargets = haxe_ds_List()
        self.resizeEvents = haxe_ds_List()

    def onClose(self):
        return True

    def event(self,e):
        _g_head = self.eventTargets.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            et = val
            et(e)

    def addEventTarget(self,et):
        self.eventTargets.add(et)

    def removeEventTarget(self,et):
        _g_head = self.eventTargets.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            e = val
            if Reflect.compareMethods(e,et):
                self.eventTargets.remove(e)
                break

    def addResizeEvent(self,f):
        self.resizeEvents.push(f)

    def removeResizeEvent(self,f):
        _g_head = self.resizeEvents.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            e = val
            if Reflect.compareMethods(e,f):
                self.resizeEvents.remove(f)
                break

    def onResize(self,e):
        _g_head = self.resizeEvents.h
        while (_g_head is not None):
            val = _g_head.item
            _g_head = _g_head.next
            r = val
            r()

    def resize(self,width,height):
        pass

    def setFullScreen(self,v):
        pass

    def get_mouseX(self):
        return 0

    def get_mouseY(self):
        return 0

    def get_width(self):
        return 0

    def get_height(self):
        return 0

    def get_mouseLock(self):
        return False

    def set_mouseLock(self,v):
        if v:
            raise _HxException("Not implemented")
        return False

    def get_vsync(self):
        return True

    def set_vsync(self,b):
        if (not b):
            raise _HxException("Can't disable vsync on this platform")
        return True

    def get_isFocused(self):
        return True

    def get_displayMode(self):
        return hxd_DisplayMode.Windowed

    def set_displayMode(self,m):
        return m

    def get_title(self):
        return ""

    def set_title(self,t):
        return t

    @staticmethod
    def getInstance():
        if (hxd_Window.inst is None):
            hxd_Window.inst = hxd_Window()
        return hxd_Window.inst

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.resizeEvents = None
        _hx_o.eventTargets = None
hxd_Window._hx_class = hxd_Window
_hx_classes["hxd.Window"] = hxd_Window


class hxd_fmt_bfnt_FontParser:
    _hx_class_name = "hxd.fmt.bfnt.FontParser"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["parse"]

    @staticmethod
    def parse(_hx_bytes,path,resolveTile):
        tile = None
        font = h2d_Font(None,0)
        glyphs = font.glyphs
        font.baseLine = 0
        v = (((_hx_bytes.b[0] | ((_hx_bytes.b[1] << 8))) | ((_hx_bytes.b[2] << 16))) | ((_hx_bytes.b[3] << 24)))
        _g = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
        _g1 = _g
        if (_g1 == 54938946):
            bytes1 = haxe_io_BytesInput(_hx_bytes)
            _g2 = bytes1
            _g2.set_position((_g2.pos + 4))
            pageCount = 0
            while (bytes1.pos < bytes1.totlen):
                id = bytes1.readByte()
                length = bytes1.readInt32()
                pos = bytes1.pos
                id1 = id
                if (id1 == 1):
                    def _hx_local_0():
                        font.initSize = bytes1.readInt16()
                        return font.initSize
                    font.size = _hx_local_0()
                    _g3 = bytes1
                    _g3.set_position((_g3.pos + 12))
                    font.name = bytes1.readUntil(0)
                elif (id1 == 2):
                    font.lineHeight = bytes1.readUInt16()
                    font.baseLine = bytes1.readUInt16()
                    _g4 = bytes1
                    _g4.set_position((_g4.pos + 4))
                    pageCount = bytes1.readUInt16()
                    if (pageCount != 1):
                        haxe_Log.trace("Warning: BMF format only supports one page at the moment.",_hx_AnonObject({'fileName': "hxd/fmt/bfnt/FontParser.hx", 'lineNumber': 224, 'className': "hxd.fmt.bfnt.FontParser", 'methodName': "parse"}))
                elif (id1 == 3):
                    name = bytes1.readUntil(0)
                    try:
                        font.tilePath = name
                        tile1 = haxe_io_Path.join([haxe_io_Path.directory(path), name])
                        tile = resolveTile(tile1)
                    except Exception as _hx_e:
                        _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                        e = _hx_e1
                        haxe_Log.trace((("Warning: Could not find referenced font texture at \"" + ("null" if name is None else name)) + "\", trying to resolve same name as fnt!"),_hx_AnonObject({'fileName': "hxd/fmt/bfnt/FontParser.hx", 'lineNumber': 30, 'className': "hxd.fmt.bfnt.FontParser", 'methodName': "parse"}))
                        font.tilePath = (HxOverrides.stringOrNull(haxe_io_Path(path).file) + ".png")
                        tile2 = haxe_io_Path.withExtension(path,"png")
                        tile = resolveTile(tile2)
                elif (id1 == 4):
                    count = None
                    try:
                        count = int((length / 20))
                    except Exception as _hx_e:
                        _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                        e1 = _hx_e1
                        count = None
                    count1 = count
                    while (count1 > 0):
                        cid = bytes1.readInt32()
                        t = bytes1.readUInt16()
                        t1 = bytes1.readUInt16()
                        t2 = bytes1.readUInt16()
                        t3 = bytes1.readUInt16()
                        t4 = bytes1.readInt16()
                        t5 = bytes1.readInt16()
                        t6 = tile.sub(t,t1,t2,t3,t4,t5)
                        fc = h2d_FontChar(t6,bytes1.readInt16())
                        glyphs.set(cid,fc)
                        _g5 = bytes1
                        _g5.set_position((_g5.pos + 2))
                        count1 = (count1 - 1)
                elif (id1 == 5):
                    count2 = None
                    try:
                        count2 = int((length / 10))
                    except Exception as _hx_e:
                        _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                        e2 = _hx_e1
                        count2 = None
                    count3 = count2
                    while (count3 > 0):
                        first = bytes1.readInt32()
                        key = bytes1.readInt32()
                        fc1 = glyphs.h.get(key,None)
                        if (fc1 is not None):
                            fc1.addKerning(first,bytes1.readInt16())
                        else:
                            _g6 = bytes1
                            _g6.set_position((_g6.pos + 2))
                        count3 = (count3 - 1)
                else:
                    pass
                bytes1.set_position((pos + length))
        elif (_g1 == 1414415938):
            def _hx_local_4():
                def _hx_local_3(tp):
                    nonlocal tile
                    nonlocal tile
                    try:
                        font.tilePath = tp
                        tile3 = haxe_io_Path.join([haxe_io_Path.directory(path), tp])
                        tile = resolveTile(tile3)
                    except Exception as _hx_e:
                        _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                        e3 = _hx_e1
                        haxe_Log.trace((("Warning: Could not find referenced font texture at \"" + ("null" if tp is None else tp)) + "\", trying to resolve same name as fnt!"),_hx_AnonObject({'fileName': "hxd/fmt/bfnt/FontParser.hx", 'lineNumber': 30, 'className': "hxd.fmt.bfnt.FontParser", 'methodName': "parse"}))
                        font.tilePath = (HxOverrides.stringOrNull(haxe_io_Path(path).file) + ".png")
                        tile4 = haxe_io_Path.withExtension(path,"png")
                        tile = resolveTile(tile4)
                    return tile
                return hxd_fmt_bfnt_Reader(haxe_io_BytesInput(_hx_bytes)).read(_hx_local_3)
            return _hx_local_4()
        elif ((_g1 == 1852794428) or ((_g1 == 1836597052))):
            xml = Xml.parse(_hx_bytes.toString())
            x = xml.firstElement()
            if ((x.nodeType != Xml.Document) and ((x.nodeType != Xml.Element))):
                raise _HxException(("Invalid nodeType " + HxOverrides.stringOrNull(_Xml_XmlType_Impl_.toString(x.nodeType))))
            this1 = x
            xml1 = this1
            if haxe_xml__Access_HasNodeAccess_Impl_.resolve(xml1,"info"):
                tmp = haxe_xml__Access_NodeAccess_Impl_.resolve(xml1,"info")
                font.name = haxe_xml__Access_AttribAccess_Impl_.resolve(tmp,"face")
                tmp1 = haxe_xml__Access_AttribAccess_Impl_.resolve(haxe_xml__Access_NodeAccess_Impl_.resolve(xml1,"info"),"size")
                def _hx_local_5():
                    font.initSize = Std.parseInt(tmp1)
                    return font.initSize
                font.size = _hx_local_5()
                tmp2 = haxe_xml__Access_AttribAccess_Impl_.resolve(haxe_xml__Access_NodeAccess_Impl_.resolve(xml1,"common"),"lineHeight")
                font.lineHeight = Std.parseInt(tmp2)
                tmp3 = haxe_xml__Access_AttribAccess_Impl_.resolve(haxe_xml__Access_NodeAccess_Impl_.resolve(xml1,"common"),"base")
                font.baseLine = Std.parseInt(tmp3)
                p = haxe_xml__Access_NodeAccess_Impl_.resolve(xml1,"pages").elements()
                while p.hasNext():
                    p1 = p.next()
                    if (haxe_xml__Access_AttribAccess_Impl_.resolve(p1,"id") == "0"):
                        tilePath = haxe_xml__Access_AttribAccess_Impl_.resolve(p1,"file")
                        try:
                            font.tilePath = tilePath
                            tile5 = haxe_io_Path.join([haxe_io_Path.directory(path), tilePath])
                            tile = resolveTile(tile5)
                        except Exception as _hx_e:
                            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                            e4 = _hx_e1
                            haxe_Log.trace((("Warning: Could not find referenced font texture at \"" + ("null" if tilePath is None else tilePath)) + "\", trying to resolve same name as fnt!"),_hx_AnonObject({'fileName': "hxd/fmt/bfnt/FontParser.hx", 'lineNumber': 30, 'className': "hxd.fmt.bfnt.FontParser", 'methodName': "parse"}))
                            font.tilePath = (HxOverrides.stringOrNull(haxe_io_Path(path).file) + ".png")
                            tile6 = haxe_io_Path.withExtension(path,"png")
                            tile = resolveTile(tile6)
                    else:
                        haxe_Log.trace("Warning: BMF format only supports one page at the moment.",_hx_AnonObject({'fileName': "hxd/fmt/bfnt/FontParser.hx", 'lineNumber': 66, 'className': "hxd.fmt.bfnt.FontParser", 'methodName': "parse"}))
                chars = haxe_xml__Access_NodeAccess_Impl_.resolve(xml1,"chars").elements()
                c = chars
                while c.hasNext():
                    c1 = c.next()
                    t7 = Std.parseInt(haxe_xml__Access_AttribAccess_Impl_.resolve(c1,"x"))
                    t8 = Std.parseInt(haxe_xml__Access_AttribAccess_Impl_.resolve(c1,"y"))
                    t9 = Std.parseInt(haxe_xml__Access_AttribAccess_Impl_.resolve(c1,"width"))
                    t10 = Std.parseInt(haxe_xml__Access_AttribAccess_Impl_.resolve(c1,"height"))
                    t11 = Std.parseInt(haxe_xml__Access_AttribAccess_Impl_.resolve(c1,"xoffset"))
                    t12 = Std.parseInt(haxe_xml__Access_AttribAccess_Impl_.resolve(c1,"yoffset"))
                    t13 = tile.sub(t7,t8,t9,t10,t11,t12)
                    fc2 = h2d_FontChar(t13,Std.parseInt(haxe_xml__Access_AttribAccess_Impl_.resolve(c1,"xadvance")))
                    kerns = haxe_xml__Access_NodeAccess_Impl_.resolve(xml1,"kernings").elements()
                    k = kerns
                    while k.hasNext():
                        k1 = k.next()
                        if (haxe_xml__Access_AttribAccess_Impl_.resolve(k1,"second") == haxe_xml__Access_AttribAccess_Impl_.resolve(c1,"id")):
                            fc2.addKerning(Std.parseInt(haxe_xml__Access_AttribAccess_Impl_.resolve(k1,"first")),Std.parseInt(haxe_xml__Access_AttribAccess_Impl_.resolve(k1,"amount")))
                    glyphs.set(Std.parseInt(haxe_xml__Access_AttribAccess_Impl_.resolve(c1,"id")),fc2)
            else:
                font.tilePath = (HxOverrides.stringOrNull(haxe_io_Path(path).file) + ".png")
                tile7 = haxe_io_Path.withExtension(path,"png")
                tile = resolveTile(tile7)
                font.name = haxe_xml__Access_AttribAccess_Impl_.resolve(xml1,"family")
                tmp4 = haxe_xml__Access_AttribAccess_Impl_.resolve(xml1,"size")
                def _hx_local_6():
                    font.initSize = Std.parseInt(tmp4)
                    return font.initSize
                font.size = _hx_local_6()
                tmp5 = haxe_xml__Access_AttribAccess_Impl_.resolve(xml1,"height")
                font.lineHeight = Std.parseInt(tmp5)
                kernings = []
                c2 = xml1.elements()
                while c2.hasNext():
                    c3 = c2.next()
                    _this = haxe_xml__Access_AttribAccess_Impl_.resolve(c3,"rect")
                    r = _this.split(" ")
                    _this1 = haxe_xml__Access_AttribAccess_Impl_.resolve(c3,"offset")
                    o = _this1.split(" ")
                    t14 = Std.parseInt((r[0] if 0 < len(r) else None))
                    t15 = Std.parseInt((r[1] if 1 < len(r) else None))
                    t16 = Std.parseInt((r[2] if 2 < len(r) else None))
                    t17 = Std.parseInt((r[3] if 3 < len(r) else None))
                    t18 = Std.parseInt((o[0] if 0 < len(o) else None))
                    t19 = Std.parseInt((o[1] if 1 < len(o) else None))
                    t20 = tile.sub(t14,t15,t16,t17,t18,t19)
                    fc3 = h2d_FontChar(t20,(Std.parseInt(haxe_xml__Access_AttribAccess_Impl_.resolve(c3,"width")) - 1))
                    code = haxe_xml__Access_AttribAccess_Impl_.resolve(c3,"code")
                    code1 = (Std.parseInt(HxString.substr(code,2,(len(code) - 3))) if (code.startswith("&#")) else HxString.charCodeAt(code,0))
                    k2 = c3.elements()
                    while k2.hasNext():
                        k3 = k2.next()
                        code2 = haxe_xml__Access_AttribAccess_Impl_.resolve(k3,"id")
                        next = (Std.parseInt(HxString.substr(code2,2,(len(code2) - 3))) if (code2.startswith("&#")) else HxString.charCodeAt(code2,0))
                        adv = Std.parseInt(haxe_xml__Access_AttribAccess_Impl_.resolve(k3,"advance"))
                        if (next in glyphs.h):
                            glyphs.h.get(next,None).addKerning(code1,adv)
                        else:
                            kernings.append(_hx_AnonObject({'prev': code1, 'next': next, 'adv': adv}))
                    glyphs.set(code1,fc3)
                _g7 = 0
                while (_g7 < len(kernings)):
                    k4 = (kernings[_g7] if _g7 >= 0 and _g7 < len(kernings) else None)
                    _g7 = (_g7 + 1)
                    g = glyphs.h.get(k4.next,None)
                    if (g is None):
                        continue
                    g.addKerning(k4.prev,k4.adv)
        elif (_g1 == 1868983913):
            _this2 = _hx_bytes.toString()
            lines = _this2.split("\n")
            reg = EReg(" *?([0-9a-zA-Z]+)=(\"[^\"]+\"|.+?)(?:[ \r]|$)","")
            idx = None
            pageCount1 = 0
            _g8 = 0
            while (_g8 < len(lines)):
                line = (lines[_g8] if _g8 >= 0 and _g8 < len(lines) else None)
                _g8 = (_g8 + 1)
                startIndex = None
                idx = (line.find(" ") if ((startIndex is None)) else line.find(" ", startIndex))
                _g9 = HxString.substr(line,0,idx)
                _hx_local_9 = len(_g9)
                if (_hx_local_9 == 4):
                    if (_g9 == "char"):
                        id2 = 0
                        x1 = 0
                        y = 0
                        width = 0
                        height = 0
                        xoffset = 0
                        yoffset = 0
                        xadvance = 0
                        while ((idx < len(line)) and reg.matchSub(line,idx)):
                            _g10 = reg.matchObj.group(1)
                            _hx_local_10 = len(_g10)
                            if (_hx_local_10 == 1):
                                if (_g10 == "x"):
                                    v4 = reg.matchObj.group(2)
                                    x1 = Std.parseInt((HxString.substring(v4,1,(len(v4) - 1)) if ((HxString.charCodeAt(v4,0) == 34)) else v4))
                                elif (_g10 == "y"):
                                    v7 = reg.matchObj.group(2)
                                    y = Std.parseInt((HxString.substring(v7,1,(len(v7) - 1)) if ((HxString.charCodeAt(v7,0) == 34)) else v7))
                            elif (_hx_local_10 == 5):
                                if (_g10 == "width"):
                                    v3 = reg.matchObj.group(2)
                                    width = Std.parseInt((HxString.substring(v3,1,(len(v3) - 1)) if ((HxString.charCodeAt(v3,0) == 34)) else v3))
                            elif (_hx_local_10 == 7):
                                if (_g10 == "xoffset"):
                                    v6 = reg.matchObj.group(2)
                                    xoffset = Std.parseInt((HxString.substring(v6,1,(len(v6) - 1)) if ((HxString.charCodeAt(v6,0) == 34)) else v6))
                                elif (_g10 == "yoffset"):
                                    v8 = reg.matchObj.group(2)
                                    yoffset = Std.parseInt((HxString.substring(v8,1,(len(v8) - 1)) if ((HxString.charCodeAt(v8,0) == 34)) else v8))
                            elif (_hx_local_10 == 8):
                                if (_g10 == "xadvance"):
                                    v5 = reg.matchObj.group(2)
                                    xadvance = Std.parseInt((HxString.substring(v5,1,(len(v5) - 1)) if ((HxString.charCodeAt(v5,0) == 34)) else v5))
                            elif (_hx_local_10 == 6):
                                if (_g10 == "height"):
                                    v1 = reg.matchObj.group(2)
                                    height = Std.parseInt((HxString.substring(v1,1,(len(v1) - 1)) if ((HxString.charCodeAt(v1,0) == 34)) else v1))
                            elif (_hx_local_10 == 2):
                                if (_g10 == "id"):
                                    v2 = reg.matchObj.group(2)
                                    id2 = Std.parseInt((HxString.substring(v2,1,(len(v2) - 1)) if ((HxString.charCodeAt(v2,0) == 34)) else v2))
                            else:
                                pass
                            pos_pos = reg.matchObj.start()
                            pos_len = (reg.matchObj.end() - reg.matchObj.start())
                            idx = (pos_pos + pos_len)
                        t21 = tile.sub(x1,y,width,height,xoffset,yoffset)
                        fc4 = h2d_FontChar(t21,xadvance)
                        glyphs.set(id2,fc4)
                    elif (_g9 == "info"):
                        while ((idx < len(line)) and reg.matchSub(line,idx)):
                            _g12 = reg.matchObj.group(1)
                            if (_g12 == "face"):
                                v12 = reg.matchObj.group(2)
                                tmp8 = (HxString.substring(v12,1,(len(v12) - 1)) if ((HxString.charCodeAt(v12,0) == 34)) else v12)
                                font.name = tmp8
                            elif (_g12 == "size"):
                                v13 = reg.matchObj.group(2)
                                tmp9 = (HxString.substring(v13,1,(len(v13) - 1)) if ((HxString.charCodeAt(v13,0) == 34)) else v13)
                                def _hx_local_11():
                                    font.initSize = Std.parseInt(tmp9)
                                    return font.initSize
                                font.size = _hx_local_11()
                            else:
                                pass
                            pos_pos2 = reg.matchObj.start()
                            pos_len2 = (reg.matchObj.end() - reg.matchObj.start())
                            idx = (pos_pos2 + pos_len2)
                    elif (_g9 == "page"):
                        while ((idx < len(line)) and reg.matchSub(line,idx)):
                            if (reg.matchObj.group(1) == "file"):
                                v17 = reg.matchObj.group(2)
                                tilePath1 = (HxString.substring(v17,1,(len(v17) - 1)) if ((HxString.charCodeAt(v17,0) == 34)) else v17)
                                try:
                                    font.tilePath = tilePath1
                                    tile8 = haxe_io_Path.join([haxe_io_Path.directory(path), tilePath1])
                                    tile = resolveTile(tile8)
                                except Exception as _hx_e:
                                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                                    e5 = _hx_e1
                                    haxe_Log.trace((("Warning: Could not find referenced font texture at \"" + ("null" if tilePath1 is None else tilePath1)) + "\", trying to resolve same name as fnt!"),_hx_AnonObject({'fileName': "hxd/fmt/bfnt/FontParser.hx", 'lineNumber': 30, 'className': "hxd.fmt.bfnt.FontParser", 'methodName': "parse"}))
                                    font.tilePath = (HxOverrides.stringOrNull(haxe_io_Path(path).file) + ".png")
                                    tile9 = haxe_io_Path.withExtension(path,"png")
                                    tile = resolveTile(tile9)
                            pos_pos4 = reg.matchObj.start()
                            pos_len4 = (reg.matchObj.end() - reg.matchObj.start())
                            idx = (pos_pos4 + pos_len4)
                elif (_hx_local_9 == 7):
                    if (_g9 == "kerning"):
                        first1 = 0
                        second = 0
                        advance = 0
                        while ((idx < len(line)) and reg.matchSub(line,idx)):
                            _g13 = reg.matchObj.group(1)
                            _hx_local_12 = len(_g13)
                            if (_hx_local_12 == 5):
                                if (_g13 == "first"):
                                    v15 = reg.matchObj.group(2)
                                    first1 = Std.parseInt((HxString.substring(v15,1,(len(v15) - 1)) if ((HxString.charCodeAt(v15,0) == 34)) else v15))
                            elif (_hx_local_12 == 6):
                                if (_g13 == "amount"):
                                    v14 = reg.matchObj.group(2)
                                    advance = Std.parseInt((HxString.substring(v14,1,(len(v14) - 1)) if ((HxString.charCodeAt(v14,0) == 34)) else v14))
                                elif (_g13 == "second"):
                                    v16 = reg.matchObj.group(2)
                                    second = Std.parseInt((HxString.substring(v16,1,(len(v16) - 1)) if ((HxString.charCodeAt(v16,0) == 34)) else v16))
                            else:
                                pass
                            pos_pos3 = reg.matchObj.start()
                            pos_len3 = (reg.matchObj.end() - reg.matchObj.start())
                            idx = (pos_pos3 + pos_len3)
                        fc5 = glyphs.h.get(second,None)
                        if (fc5 is not None):
                            fc5.addKerning(first1,advance)
                elif (_hx_local_9 == 6):
                    if (_g9 == "common"):
                        while ((idx < len(line)) and reg.matchSub(line,idx)):
                            _g11 = reg.matchObj.group(1)
                            _hx_local_13 = len(_g11)
                            if (_hx_local_13 == 10):
                                if (_g11 == "lineHeight"):
                                    v10 = reg.matchObj.group(2)
                                    tmp7 = (HxString.substring(v10,1,(len(v10) - 1)) if ((HxString.charCodeAt(v10,0) == 34)) else v10)
                                    font.lineHeight = Std.parseInt(tmp7)
                            elif (_hx_local_13 == 4):
                                if (_g11 == "base"):
                                    v9 = reg.matchObj.group(2)
                                    tmp6 = (HxString.substring(v9,1,(len(v9) - 1)) if ((HxString.charCodeAt(v9,0) == 34)) else v9)
                                    font.baseLine = Std.parseInt(tmp6)
                            elif (_hx_local_13 == 5):
                                if (_g11 == "pages"):
                                    v11 = reg.matchObj.group(2)
                                    pageCount1 = Std.parseInt((HxString.substring(v11,1,(len(v11) - 1)) if ((HxString.charCodeAt(v11,0) == 34)) else v11))
                                    if (pageCount1 != 1):
                                        haxe_Log.trace("Warning: BMF format only supports one page at the moment.",_hx_AnonObject({'fileName': "hxd/fmt/bfnt/FontParser.hx", 'lineNumber': 157, 'className': "hxd.fmt.bfnt.FontParser", 'methodName': "parse"}))
                            else:
                                pass
                            pos_pos1 = reg.matchObj.start()
                            pos_len1 = (reg.matchObj.end() - reg.matchObj.start())
                            idx = (pos_pos1 + pos_len1)
                else:
                    pass
        else:
            sign = _g
            raise _HxException(("Unknown font signature " + HxOverrides.stringOrNull(StringTools.hex(sign,8))))
        if (glyphs.h.get(32,None) is None):
            glyphs.set(32,h2d_FontChar(tile.sub(0,0,0,0),(font.size >> 1)))
        font.tile = tile
        if (font.baseLine == 0):
            padding = 0
            space = glyphs.h.get(32,None)
            if (space is not None):
                padding = (space.t.height * .5)
            a = glyphs.h.get(65,None)
            if (a is None):
                a = glyphs.h.get(97,None)
            if (a is None):
                a = glyphs.h.get(48,None)
            if (a is None):
                font.baseLine = ((font.lineHeight - 2) - padding)
            else:
                font.baseLine = ((a.t.dy + a.t.height) - padding)
        fallback = glyphs.h.get(65533,None)
        if (fallback is None):
            fallback = glyphs.h.get(9633,None)
        if (fallback is None):
            fallback = glyphs.h.get(63,None)
        if (fallback is not None):
            font.defaultChar = fallback
        return font
hxd_fmt_bfnt_FontParser._hx_class = hxd_fmt_bfnt_FontParser
_hx_classes["hxd.fmt.bfnt.FontParser"] = hxd_fmt_bfnt_FontParser


class hxd_fmt_bfnt_Reader:
    _hx_class_name = "hxd.fmt.bfnt.Reader"
    _hx_is_interface = "False"
    __slots__ = ("i",)
    _hx_fields = ["i"]
    _hx_methods = ["read"]
    _hx_statics = ["parse"]

    def __init__(self,i):
        self.i = i

    def read(self,resolveTile):
        if ((self.i.readString(4) != "BFNT") or ((self.i.readByte() != 0))):
            raise _HxException("Not a BFNT file!")
        font = None
        _g = self.i.readByte()
        if (_g == 1):
            font = h2d_Font(self.i.readString(self.i.readUInt16()),self.i.readInt16())
            font.tilePath = self.i.readString(self.i.readUInt16())
            def _hx_local_0():
                font.tile = resolveTile(font.tilePath)
                return font.tile
            tile = _hx_local_0()
            font.lineHeight = self.i.readInt16()
            font.baseLine = self.i.readInt16()
            defaultChar = self.i.readInt32()
            id = None
            while True:
                id = self.i.readInt32()
                if (not ((id != 0))):
                    break
                t = tile.sub(self.i.readUInt16(),self.i.readUInt16(),self.i.readUInt16(),self.i.readUInt16(),self.i.readInt16(),self.i.readInt16())
                glyph = h2d_FontChar(t,self.i.readInt16())
                font.glyphs.set(id,glyph)
                if (id == defaultChar):
                    font.defaultChar = glyph
                prevChar = None
                while True:
                    prevChar = self.i.readInt32()
                    if (not ((prevChar != 0))):
                        break
                    glyph.addKerning(prevChar,self.i.readInt16())
        else:
            ver = _g
            raise _HxException(("Unknown BFNT version: " + Std.string(ver)))
        return font

    @staticmethod
    def parse(_hx_bytes,resolveTile):
        return hxd_fmt_bfnt_Reader(haxe_io_BytesInput(_hx_bytes)).read(resolveTile)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.i = None
hxd_fmt_bfnt_Reader._hx_class = hxd_fmt_bfnt_Reader
_hx_classes["hxd.fmt.bfnt.Reader"] = hxd_fmt_bfnt_Reader


class hxd_fmt_bfnt_Writer:
    _hx_class_name = "hxd.fmt.bfnt.Writer"
    _hx_is_interface = "False"
    __slots__ = ("out",)
    _hx_fields = ["out"]
    _hx_methods = ["write", "writeString"]
    _hx_statics = ["VERSION"]

    def __init__(self,out):
        self.out = out

    def write(self,font):
        self.out.writeString("BFNT")
        self.out.writeByte(0)
        self.out.writeByte(1)
        s = font.name
        if (s is None):
            s = ""
        _hx_bytes = haxe_io_Bytes.ofString(s)
        if (_hx_bytes.length > 65535):
            raise _HxException("Invalid string: Size over 0xFFFF")
        self.out.writeUInt16(_hx_bytes.length)
        self.out.write(_hx_bytes)
        self.out.writeInt16(font.size)
        s1 = font.tilePath
        if (s1 is None):
            s1 = ""
        bytes1 = haxe_io_Bytes.ofString(s1)
        if (bytes1.length > 65535):
            raise _HxException("Invalid string: Size over 0xFFFF")
        self.out.writeUInt16(bytes1.length)
        self.out.write(bytes1)
        tmp = self.out
        x = font.lineHeight
        tmp1 = None
        try:
            tmp1 = int(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            tmp1 = None
        tmp.writeInt16(tmp1)
        tmp2 = self.out
        x1 = font.baseLine
        tmp3 = None
        try:
            tmp3 = int(x1)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e1 = _hx_e1
            tmp3 = None
        tmp2.writeInt16(tmp3)
        if (font.defaultChar != font.nullChar):
            found = False
            k = font.glyphs.keys()
            while k.hasNext():
                k1 = k.next()
                if (font.glyphs.h.get(k1,None) == font.defaultChar):
                    self.out.writeInt32(k1)
                    found = True
                    break
            if (not found):
                self.out.writeInt32(0)
        else:
            self.out.writeInt32(0)
        id = font.glyphs.keys()
        while id.hasNext():
            id1 = id.next()
            if (id1 == 0):
                continue
            glyph = font.glyphs.h.get(id1,None)
            t = glyph.t
            self.out.writeInt32(id1)
            tmp4 = self.out
            x2 = t.x
            tmp5 = None
            try:
                tmp5 = int(x2)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e2 = _hx_e1
                tmp5 = None
            tmp4.writeUInt16(tmp5)
            tmp6 = self.out
            x3 = t.y
            tmp7 = None
            try:
                tmp7 = int(x3)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e3 = _hx_e1
                tmp7 = None
            tmp6.writeUInt16(tmp7)
            tmp8 = self.out
            x4 = t.width
            tmp9 = None
            try:
                tmp9 = int(x4)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e4 = _hx_e1
                tmp9 = None
            tmp8.writeUInt16(tmp9)
            tmp10 = self.out
            x5 = t.height
            tmp11 = None
            try:
                tmp11 = int(x5)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e5 = _hx_e1
                tmp11 = None
            tmp10.writeUInt16(tmp11)
            tmp12 = self.out
            x6 = t.dx
            tmp13 = None
            try:
                tmp13 = int(x6)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e6 = _hx_e1
                tmp13 = None
            tmp12.writeInt16(tmp13)
            tmp14 = self.out
            x7 = t.dy
            tmp15 = None
            try:
                tmp15 = int(x7)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e7 = _hx_e1
                tmp15 = None
            tmp14.writeInt16(tmp15)
            tmp16 = self.out
            x8 = glyph.width
            tmp17 = None
            try:
                tmp17 = int(x8)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e8 = _hx_e1
                tmp17 = None
            tmp16.writeInt16(tmp17)
            kern = glyph.kerning
            while (kern is not None):
                if (kern.prevChar != 0):
                    self.out.writeInt32(kern.prevChar)
                    tmp18 = self.out
                    x9 = kern.offset
                    tmp19 = None
                    try:
                        tmp19 = int(x9)
                    except Exception as _hx_e:
                        _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                        e9 = _hx_e1
                        tmp19 = None
                    tmp18.writeInt16(tmp19)
                kern = kern.next
            self.out.writeInt32(0)
        self.out.writeInt32(0)

    def writeString(self,s):
        if (s is None):
            s = ""
        _hx_bytes = haxe_io_Bytes.ofString(s)
        if (_hx_bytes.length > 65535):
            raise _HxException("Invalid string: Size over 0xFFFF")
        self.out.writeUInt16(_hx_bytes.length)
        self.out.write(_hx_bytes)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.out = None
hxd_fmt_bfnt_Writer._hx_class = hxd_fmt_bfnt_Writer
_hx_classes["hxd.fmt.bfnt.Writer"] = hxd_fmt_bfnt_Writer


class hxd_fmt_fbx_TmpObject:
    _hx_class_name = "hxd.fmt.fbx.TmpObject"
    _hx_is_interface = "False"
    __slots__ = ("index", "model", "parent", "isJoint", "isMesh", "childs", "obj", "joint", "skin")
    _hx_fields = ["index", "model", "parent", "isJoint", "isMesh", "childs", "obj", "joint", "skin"]

    def __init__(self):
        self.skin = None
        self.joint = None
        self.obj = None
        self.isMesh = None
        self.isJoint = None
        self.parent = None
        self.model = None
        self.index = None
        self.childs = []

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.index = None
        _hx_o.model = None
        _hx_o.parent = None
        _hx_o.isJoint = None
        _hx_o.isMesh = None
        _hx_o.childs = None
        _hx_o.obj = None
        _hx_o.joint = None
        _hx_o.skin = None
hxd_fmt_fbx_TmpObject._hx_class = hxd_fmt_fbx_TmpObject
_hx_classes["hxd.fmt.fbx.TmpObject"] = hxd_fmt_fbx_TmpObject


class hxd_fmt_fbx__BaseLibrary_AnimCurve:
    _hx_class_name = "hxd.fmt.fbx._BaseLibrary.AnimCurve"
    _hx_is_interface = "False"
    __slots__ = ("_hx_def", "object", "t", "r", "s", "a", "fov", "roll", "uv")
    _hx_fields = ["def", "object", "t", "r", "s", "a", "fov", "roll", "uv"]

    def __init__(self,_hx_def,object):
        self.uv = None
        self.roll = None
        self.fov = None
        self.a = None
        self.s = None
        self.r = None
        self.t = None
        self._hx_def = _hx_def
        self.object = object

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o._hx_def = None
        _hx_o.object = None
        _hx_o.t = None
        _hx_o.r = None
        _hx_o.s = None
        _hx_o.a = None
        _hx_o.fov = None
        _hx_o.roll = None
        _hx_o.uv = None
hxd_fmt_fbx__BaseLibrary_AnimCurve._hx_class = hxd_fmt_fbx__BaseLibrary_AnimCurve
_hx_classes["hxd.fmt.fbx._BaseLibrary.AnimCurve"] = hxd_fmt_fbx__BaseLibrary_AnimCurve


class hxd_fmt_fbx_DefaultMatrixes:
    _hx_class_name = "hxd.fmt.fbx.DefaultMatrixes"
    _hx_is_interface = "False"
    __slots__ = ("trans", "scale", "rotate", "preRot", "wasRemoved", "transPos")
    _hx_fields = ["trans", "scale", "rotate", "preRot", "wasRemoved", "transPos"]
    _hx_methods = ["toMatrix", "toQuaternion"]
    _hx_statics = ["rightHandToLeft"]

    def __init__(self):
        self.transPos = None
        self.wasRemoved = None
        self.preRot = None
        self.rotate = None
        self.scale = None
        self.trans = None

    def toMatrix(self,leftHand):
        m = h3d_Matrix()
        m.identity()
        if (self.scale is not None):
            m.scale(self.scale.x,self.scale.y,self.scale.z)
        if (self.rotate is not None):
            m.rotate(self.rotate.x,self.rotate.y,self.rotate.z)
        if (self.preRot is not None):
            m.rotate(self.preRot.x,self.preRot.y,self.preRot.z)
        if (self.trans is not None):
            m.translate(self.trans.x,self.trans.y,self.trans.z)
        if leftHand:
            m._12 = -m._12
            m._13 = -m._13
            m._21 = -m._21
            m._31 = -m._31
            m._41 = -m._41
        return m

    def toQuaternion(self,leftHand):
        m = h3d_Matrix()
        m.identity()
        if (self.rotate is not None):
            m.rotate(self.rotate.x,self.rotate.y,self.rotate.z)
        if (self.preRot is not None):
            m.rotate(self.preRot.x,self.preRot.y,self.preRot.z)
        if leftHand:
            m._12 = -m._12
            m._13 = -m._13
            m._21 = -m._21
            m._31 = -m._31
            m._41 = -m._41
        q = h3d_Quat()
        q.initRotateMatrix(m)
        return q

    @staticmethod
    def rightHandToLeft(m):
        m._12 = -m._12
        m._13 = -m._13
        m._21 = -m._21
        m._31 = -m._31
        m._41 = -m._41

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.trans = None
        _hx_o.scale = None
        _hx_o.rotate = None
        _hx_o.preRot = None
        _hx_o.wasRemoved = None
        _hx_o.transPos = None
hxd_fmt_fbx_DefaultMatrixes._hx_class = hxd_fmt_fbx_DefaultMatrixes
_hx_classes["hxd.fmt.fbx.DefaultMatrixes"] = hxd_fmt_fbx_DefaultMatrixes


class hxd_fmt_fbx_BaseLibrary:
    _hx_class_name = "hxd.fmt.fbx.BaseLibrary"
    _hx_is_interface = "False"
    __slots__ = ("root", "ids", "connect", "namedConnect", "invConnect", "leftHand", "defaultModelMatrixes", "uvAnims", "animationEvents", "isMaya", "fileName", "version", "keepJoints", "skipObjects", "bonesPerVertex", "maxBonesPerSkin", "unskinnedJointsAsObjects", "allowVertexColor", "normalizeScaleOrient")
    _hx_fields = ["root", "ids", "connect", "namedConnect", "invConnect", "leftHand", "defaultModelMatrixes", "uvAnims", "animationEvents", "isMaya", "fileName", "version", "keepJoints", "skipObjects", "bonesPerVertex", "maxBonesPerSkin", "unskinnedJointsAsObjects", "allowVertexColor", "normalizeScaleOrient"]
    _hx_methods = ["reset", "loadFile", "load", "updateModelScale", "convertPoints", "leftHandConvert", "init", "getGeometry", "getParent", "getChild", "getSpecChild", "getChilds", "getParents", "getRoot", "ignoreMissingObject", "buildHierarchy", "getObjectCurve", "mergeModels", "addLink", "removeLink", "checkData", "roundValues", "getAnimationNames", "loadAnimation", "sortDistinctFloats", "isNullJoint", "getModelPath", "autoMerge", "keepJoint", "createSkin", "round", "updateDefaultMatrix", "getDefaultMatrixes"]

    def __init__(self,fileName):
        self.unskinnedJointsAsObjects = None
        self.isMaya = None
        self.animationEvents = None
        self.uvAnims = None
        self.defaultModelMatrixes = None
        self.leftHand = None
        self.invConnect = None
        self.namedConnect = None
        self.connect = None
        self.ids = None
        self.normalizeScaleOrient = True
        self.allowVertexColor = True
        self.maxBonesPerSkin = 34
        self.bonesPerVertex = 3
        self.version = 0.
        self.fileName = fileName
        self.root = _hx_AnonObject({'name': "Root", 'props': [], 'childs': []})
        self.keepJoints = haxe_ds_StringMap()
        self.skipObjects = haxe_ds_StringMap()
        self.reset()

    def reset(self):
        self.ids = haxe_ds_IntMap()
        self.connect = haxe_ds_IntMap()
        self.namedConnect = haxe_ds_IntMap()
        self.invConnect = haxe_ds_IntMap()
        self.defaultModelMatrixes = haxe_ds_StringMap()

    def loadFile(self,data):
        self.load(hxd_fmt_fbx_Parser.parse(data))

    def load(self,root):
        self.reset()
        self.root = root
        self.version = (hxd_fmt_fbx_FbxTools.toInt(python_internal_ArrayImpl._get(hxd_fmt_fbx_FbxTools.get(root,"FBXHeaderExtension.FBXVersion").props, 0)) / 1000)
        x = self.version
        tmp = None
        try:
            tmp = int(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            tmp = None
        if (tmp != 7):
            raise _HxException("FBX Version 7.x required : use FBX 2010 export")
        _g = 0
        _g1 = hxd_fmt_fbx_FbxTools.getAll(root,"FBXHeaderExtension.SceneInfo.Properties70.P")
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (hxd_fmt_fbx_FbxTools.toString((p.props[0] if 0 < len(p.props) else None)) == "Original|ApplicationName"):
                _this = hxd_fmt_fbx_FbxTools.toString((p.props[4] if 4 < len(p.props) else None)).lower()
                startIndex = None
                self.isMaya = (((_this.find("maya") if ((startIndex is None)) else _this.find("maya", startIndex))) >= 0)
                break
        _g2 = 0
        _g3 = root.childs
        while (_g2 < len(_g3)):
            c = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
            _g2 = (_g2 + 1)
            self.init(c)
        if self.normalizeScaleOrient:
            self.updateModelScale()
        _g4 = 0
        _g5 = hxd_fmt_fbx_FbxTools.getAll(self.root,"Objects.Model")
        while (_g4 < len(_g5)):
            m = (_g5[_g4] if _g4 >= 0 and _g4 < len(_g5) else None)
            _g4 = (_g4 + 1)
            _g41 = 0
            _g51 = hxd_fmt_fbx_FbxTools.getAll(m,"Properties70.P")
            while (_g41 < len(_g51)):
                p1 = (_g51[_g41] if _g41 >= 0 and _g41 < len(_g51) else None)
                _g41 = (_g41 + 1)
                _g42 = hxd_fmt_fbx_FbxTools.toString((p1.props[0] if 0 < len(p1.props) else None))
                _hx_local_4 = len(_g42)
                if (_hx_local_4 == 9):
                    if (_g42 == "UDP3DSMAX"):
                        _this1 = hxd_fmt_fbx_FbxTools.toString((p1.props[4] if 4 < len(p1.props) else None))
                        userProps = _this1.split("&cr;&lf;")
                        _g43 = 0
                        while (_g43 < len(userProps)):
                            p2 = (userProps[_g43] if _g43 >= 0 and _g43 < len(userProps) else None)
                            _g43 = (_g43 + 1)
                            pl = p2.split("=")
                            pname = StringTools.trim((None if ((len(pl) == 0)) else pl.pop(0)))
                            pval = StringTools.trim("=".join([python_Boot.toString1(x1,'') for x1 in pl]))
                            pname1 = pname
                            _hx_local_6 = len(pname1)
                            if (_hx_local_6 == 6):
                                if (pname1 == "Events"):
                                    xml = None
                                    try:
                                        xml = Xml.parse(pval)
                                    except Exception as _hx_e:
                                        _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                                        e1 = _hx_e1
                                        raise _HxException(("Invalid Events data in " + HxOverrides.stringOrNull(hxd_fmt_fbx_FbxTools.getName(m))))
                                    _g44 = []
                                    x1 = xml.firstElement()
                                    if ((x1.nodeType != Xml.Document) and ((x1.nodeType != Xml.Element))):
                                        raise _HxException(("Invalid nodeType " + HxOverrides.stringOrNull(_Xml_XmlType_Impl_.toString(x1.nodeType))))
                                    this1 = x1
                                    f = this1.elements()
                                    while f.hasNext():
                                        f1 = f.next()
                                        _this2 = haxe_xml__Access_Access_Impl_.get_innerData(f1)
                                        f2 = _this2.split(" ")
                                        x2 = _hx_AnonObject({'frame': Std.parseInt((None if ((len(f2) == 0)) else f2.pop(0))), 'data': StringTools.trim(" ".join([python_Boot.toString1(x1,'') for x1 in f2]))})
                                        _g44.append(x2)
                                    self.animationEvents = _g44
                                else:
                                    pass
                            elif (_hx_local_6 == 2):
                                if (pname1 == "UV"):
                                    if (pval != ""):
                                        xml1 = None
                                        try:
                                            xml1 = Xml.parse(pval)
                                        except Exception as _hx_e:
                                            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                                            e2 = _hx_e1
                                            raise _HxException(("Invalid UV data in " + HxOverrides.stringOrNull(hxd_fmt_fbx_FbxTools.getName(m))))
                                        _g45 = []
                                        x3 = xml1.firstElement()
                                        if ((x3.nodeType != Xml.Document) and ((x3.nodeType != Xml.Element))):
                                            raise _HxException(("Invalid nodeType " + HxOverrides.stringOrNull(_Xml_XmlType_Impl_.toString(x3.nodeType))))
                                        this2 = x3
                                        f3 = this2.elements()
                                        while f3.hasNext():
                                            f4 = f3.next()
                                            _this3 = haxe_xml__Access_Access_Impl_.get_innerData(f4)
                                            f5 = _this3.split(" ")
                                            x4 = _hx_AnonObject({'t': (Std.parseFloat((f5[0] if 0 < len(f5) else None)) * 9622116.25), 'u': Std.parseFloat((f5[1] if 1 < len(f5) else None)), 'v': Std.parseFloat((f5[2] if 2 < len(f5) else None))})
                                            _g45.append(x4)
                                        frames = _g45
                                        if (self.uvAnims is None):
                                            self.uvAnims = haxe_ds_StringMap()
                                        this3 = self.uvAnims
                                        key = hxd_fmt_fbx_FbxTools.getName(m)
                                        this3.h[key] = frames
                                else:
                                    pass
                            else:
                                pass
                    else:
                        pass
                elif (_hx_local_4 == 6):
                    if (_g42 == "Events"):
                        _this1 = hxd_fmt_fbx_FbxTools.toString((p1.props[4] if 4 < len(p1.props) else None))
                        userProps = _this1.split("&cr;&lf;")
                        _g43 = 0
                        while (_g43 < len(userProps)):
                            p2 = (userProps[_g43] if _g43 >= 0 and _g43 < len(userProps) else None)
                            _g43 = (_g43 + 1)
                            pl = p2.split("=")
                            pname = StringTools.trim((None if ((len(pl) == 0)) else pl.pop(0)))
                            pval = StringTools.trim("=".join([python_Boot.toString1(x1,'') for x1 in pl]))
                            pname1 = pname
                            _hx_local_8 = len(pname1)
                            if (_hx_local_8 == 6):
                                if (pname1 == "Events"):
                                    xml = None
                                    try:
                                        xml = Xml.parse(pval)
                                    except Exception as _hx_e:
                                        _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                                        e1 = _hx_e1
                                        raise _HxException(("Invalid Events data in " + HxOverrides.stringOrNull(hxd_fmt_fbx_FbxTools.getName(m))))
                                    _g44 = []
                                    x1 = xml.firstElement()
                                    if ((x1.nodeType != Xml.Document) and ((x1.nodeType != Xml.Element))):
                                        raise _HxException(("Invalid nodeType " + HxOverrides.stringOrNull(_Xml_XmlType_Impl_.toString(x1.nodeType))))
                                    this1 = x1
                                    f = this1.elements()
                                    while f.hasNext():
                                        f1 = f.next()
                                        _this2 = haxe_xml__Access_Access_Impl_.get_innerData(f1)
                                        f2 = _this2.split(" ")
                                        x2 = _hx_AnonObject({'frame': Std.parseInt((None if ((len(f2) == 0)) else f2.pop(0))), 'data': StringTools.trim(" ".join([python_Boot.toString1(x1,'') for x1 in f2]))})
                                        _g44.append(x2)
                                    self.animationEvents = _g44
                                else:
                                    pass
                            elif (_hx_local_8 == 2):
                                if (pname1 == "UV"):
                                    if (pval != ""):
                                        xml1 = None
                                        try:
                                            xml1 = Xml.parse(pval)
                                        except Exception as _hx_e:
                                            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                                            e2 = _hx_e1
                                            raise _HxException(("Invalid UV data in " + HxOverrides.stringOrNull(hxd_fmt_fbx_FbxTools.getName(m))))
                                        _g45 = []
                                        x3 = xml1.firstElement()
                                        if ((x3.nodeType != Xml.Document) and ((x3.nodeType != Xml.Element))):
                                            raise _HxException(("Invalid nodeType " + HxOverrides.stringOrNull(_Xml_XmlType_Impl_.toString(x3.nodeType))))
                                        this2 = x3
                                        f3 = this2.elements()
                                        while f3.hasNext():
                                            f4 = f3.next()
                                            _this3 = haxe_xml__Access_Access_Impl_.get_innerData(f4)
                                            f5 = _this3.split(" ")
                                            x4 = _hx_AnonObject({'t': (Std.parseFloat((f5[0] if 0 < len(f5) else None)) * 9622116.25), 'u': Std.parseFloat((f5[1] if 1 < len(f5) else None)), 'v': Std.parseFloat((f5[2] if 2 < len(f5) else None))})
                                            _g45.append(x4)
                                        frames = _g45
                                        if (self.uvAnims is None):
                                            self.uvAnims = haxe_ds_StringMap()
                                        this3 = self.uvAnims
                                        key = hxd_fmt_fbx_FbxTools.getName(m)
                                        this3.h[key] = frames
                                else:
                                    pass
                            else:
                                pass
                    else:
                        pass
                else:
                    pass

    def updateModelScale(self):
        unitScale = 1
        originScale = 1
        upAxis = 1
        originAxis = 2
        _g = 0
        _g1 = hxd_fmt_fbx_FbxTools.getAll(self.root,"GlobalSettings.Properties70.P")
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            _g2 = hxd_fmt_fbx_FbxTools.toString((p.props[0] if 0 < len(p.props) else None))
            _hx_local_1 = len(_g2)
            if (_hx_local_1 == 15):
                if (_g2 == "UnitScaleFactor"):
                    unitScale = hxd_fmt_fbx_FbxTools.toInt((p.props[4] if 4 < len(p.props) else None))
                else:
                    pass
            elif (_hx_local_1 == 23):
                if (_g2 == "OriginalUnitScaleFactor"):
                    originScale = hxd_fmt_fbx_FbxTools.toInt((p.props[4] if 4 < len(p.props) else None))
                else:
                    pass
            elif (_hx_local_1 == 14):
                if (_g2 == "OriginalUpAxis"):
                    originAxis = hxd_fmt_fbx_FbxTools.toInt((p.props[4] if 4 < len(p.props) else None))
                else:
                    pass
            elif (_hx_local_1 == 6):
                if (_g2 == "UpAxis"):
                    upAxis = hxd_fmt_fbx_FbxTools.toInt((p.props[4] if 4 < len(p.props) else None))
                else:
                    pass
            else:
                pass
        scaleFactor = (100 if (((unitScale == 100) and ((originScale == 1)))) else 1)
        axisFlip = ((upAxis == 2) and ((originAxis == 1)))
        geometryScaleFactor = scaleFactor
        app = ""
        _g21 = 0
        _g3 = hxd_fmt_fbx_FbxTools.getAll(self.root,"FBXHeaderExtension.SceneInfo.Properties70.P")
        while (_g21 < len(_g3)):
            p1 = (_g3[_g21] if _g21 >= 0 and _g21 < len(_g3) else None)
            _g21 = (_g21 + 1)
            if (hxd_fmt_fbx_FbxTools.toString((p1.props[0] if 0 < len(p1.props) else None)) == "LastSaved|ApplicationName"):
                app = hxd_fmt_fbx_FbxTools.toString((p1.props[4] if 4 < len(p1.props) else None))
        startIndex = None
        if (((((app.find("Blender") if ((startIndex is None)) else app.find("Blender", startIndex))) >= 0) and ((unitScale == 1))) and ((originScale == 1))):
            scaleFactor = (scaleFactor * 0.01)
        if ((scaleFactor == 1) and ((geometryScaleFactor == 1))):
            return
        def _hx_local_5(n):
            _g4 = (n.props[0] if 0 < len(n.props) else None)
            toFloats1 = _g4.index
            if (toFloats1 == 4):
                vl = _g4.params[0]
                _g41 = []
                _g5 = 0
                while (_g5 < len(vl)):
                    v = (vl[_g5] if _g5 >= 0 and _g5 < len(vl) else None)
                    _g5 = (_g5 + 1)
                    _g41.append(v)
                vl1 = _g41
                python_internal_ArrayImpl._set(n.props, 0, hxd_fmt_fbx_FbxProp.PFloats(vl1))
                return vl1
            elif (toFloats1 == 5):
                vl2 = _g4.params[0]
                return vl2
            else:
                raise _HxException((Std.string((n.props[0] if 0 < len(n.props) else None)) + " should be floats "))
        toFloats = _hx_local_5
        if (geometryScaleFactor != 1):
            _g42 = 0
            _g51 = hxd_fmt_fbx_FbxTools.getAll(self.root,"Objects.Geometry.Vertices")
            while (_g42 < len(_g51)):
                g = (_g51[_g42] if _g42 >= 0 and _g42 < len(_g51) else None)
                _g42 = (_g42 + 1)
                v1 = toFloats(g)
                _g43 = 0
                _g52 = len(v1)
                while (_g43 < _g52):
                    i = _g43
                    _g43 = (_g43 + 1)
                    python_internal_ArrayImpl._set(v1, i, ((v1[i] if i >= 0 and i < len(v1) else None) / geometryScaleFactor))
        if (scaleFactor == 1):
            return
        _g44 = 0
        _g53 = hxd_fmt_fbx_FbxTools.getAll(self.root,"Objects.Model")
        while (_g44 < len(_g53)):
            m = (_g53[_g44] if _g44 >= 0 and _g44 < len(_g53) else None)
            _g44 = (_g44 + 1)
            isRoot = (self.getParent(m,"Model",True) is None)
            _g45 = 0
            _g54 = hxd_fmt_fbx_FbxTools.getAll(m,"Properties70.P")
            while (_g45 < len(_g54)):
                p2 = (_g54[_g45] if _g45 >= 0 and _g45 < len(_g54) else None)
                _g45 = (_g45 + 1)
                _g46 = hxd_fmt_fbx_FbxTools.toString((p2.props[0] if 0 < len(p2.props) else None))
                _hx_local_10 = len(_g46)
                if (_hx_local_10 == 15):
                    if (_g46 == "Lcl Translation"):
                        if (not isRoot):
                            idx = 4
                            v2 = hxd_fmt_fbx_FbxTools.toFloat((p2.props[idx] if idx >= 0 and idx < len(p2.props) else None))
                            python_internal_ArrayImpl._set(p2.props, idx, hxd_fmt_fbx_FbxProp.PFloat((v2 / scaleFactor)))
                            idx1 = 5
                            v3 = hxd_fmt_fbx_FbxTools.toFloat((p2.props[idx1] if idx1 >= 0 and idx1 < len(p2.props) else None))
                            python_internal_ArrayImpl._set(p2.props, idx1, hxd_fmt_fbx_FbxProp.PFloat((v3 / scaleFactor)))
                            idx2 = 6
                            v4 = hxd_fmt_fbx_FbxTools.toFloat((p2.props[idx2] if idx2 >= 0 and idx2 < len(p2.props) else None))
                            python_internal_ArrayImpl._set(p2.props, idx2, hxd_fmt_fbx_FbxProp.PFloat((v4 / scaleFactor)))
                    else:
                        pass
                elif (_hx_local_10 == 11):
                    if (_g46 == "Lcl Scaling"):
                        if isRoot:
                            idx3 = 4
                            v5 = hxd_fmt_fbx_FbxTools.toFloat((p2.props[idx3] if idx3 >= 0 and idx3 < len(p2.props) else None))
                            python_internal_ArrayImpl._set(p2.props, idx3, hxd_fmt_fbx_FbxProp.PFloat((v5 * scaleFactor)))
                            idx4 = 5
                            v6 = hxd_fmt_fbx_FbxTools.toFloat((p2.props[idx4] if idx4 >= 0 and idx4 < len(p2.props) else None))
                            python_internal_ArrayImpl._set(p2.props, idx4, hxd_fmt_fbx_FbxProp.PFloat((v6 * scaleFactor)))
                            idx5 = 6
                            v7 = hxd_fmt_fbx_FbxTools.toFloat((p2.props[idx5] if idx5 >= 0 and idx5 < len(p2.props) else None))
                            python_internal_ArrayImpl._set(p2.props, idx5, hxd_fmt_fbx_FbxProp.PFloat((v7 * scaleFactor)))
                    else:
                        pass
                elif (_hx_local_10 == 20):
                    if (_g46 == "GeometricTranslation"):
                        if (not isRoot):
                            idx = 4
                            v2 = hxd_fmt_fbx_FbxTools.toFloat((p2.props[idx] if idx >= 0 and idx < len(p2.props) else None))
                            python_internal_ArrayImpl._set(p2.props, idx, hxd_fmt_fbx_FbxProp.PFloat((v2 / scaleFactor)))
                            idx1 = 5
                            v3 = hxd_fmt_fbx_FbxTools.toFloat((p2.props[idx1] if idx1 >= 0 and idx1 < len(p2.props) else None))
                            python_internal_ArrayImpl._set(p2.props, idx1, hxd_fmt_fbx_FbxProp.PFloat((v3 / scaleFactor)))
                            idx2 = 6
                            v4 = hxd_fmt_fbx_FbxTools.toFloat((p2.props[idx2] if idx2 >= 0 and idx2 < len(p2.props) else None))
                            python_internal_ArrayImpl._set(p2.props, idx2, hxd_fmt_fbx_FbxProp.PFloat((v4 / scaleFactor)))
                    else:
                        pass
                else:
                    pass
        _g6 = 0
        _g7 = hxd_fmt_fbx_FbxTools.getAll(self.root,"Objects.Deformer.Transform")
        while (_g6 < len(_g7)):
            t = (_g7[_g6] if _g6 >= 0 and _g6 < len(_g7) else None)
            _g6 = (_g6 + 1)
            m1 = toFloats(t)
            _hx_local_12 = m1
            _hx_local_13 = 12
            _hx_local_14 = (_hx_local_12[_hx_local_13] if _hx_local_13 >= 0 and _hx_local_13 < len(_hx_local_12) else None)
            python_internal_ArrayImpl._set(_hx_local_12, _hx_local_13, (_hx_local_14 / scaleFactor))
            (_hx_local_12[_hx_local_13] if _hx_local_13 >= 0 and _hx_local_13 < len(_hx_local_12) else None)
            _hx_local_15 = m1
            _hx_local_16 = 13
            _hx_local_17 = (_hx_local_15[_hx_local_16] if _hx_local_16 >= 0 and _hx_local_16 < len(_hx_local_15) else None)
            python_internal_ArrayImpl._set(_hx_local_15, _hx_local_16, (_hx_local_17 / scaleFactor))
            (_hx_local_15[_hx_local_16] if _hx_local_16 >= 0 and _hx_local_16 < len(_hx_local_15) else None)
            _hx_local_18 = m1
            _hx_local_19 = 14
            _hx_local_20 = (_hx_local_18[_hx_local_19] if _hx_local_19 >= 0 and _hx_local_19 < len(_hx_local_18) else None)
            python_internal_ArrayImpl._set(_hx_local_18, _hx_local_19, (_hx_local_20 / scaleFactor))
            (_hx_local_18[_hx_local_19] if _hx_local_19 >= 0 and _hx_local_19 < len(_hx_local_18) else None)
        _g8 = 0
        _g9 = hxd_fmt_fbx_FbxTools.getAll(self.root,"Objects.AnimationCurveNode")
        while (_g8 < len(_g9)):
            n1 = (_g9[_g8] if _g8 >= 0 and _g8 < len(_g9) else None)
            _g8 = (_g8 + 1)
            name = hxd_fmt_fbx_FbxTools.getName(n1)
            model = self.getParent(n1,"Model",True)
            isRoot1 = ((model is not None) and ((self.getParent(model,"Model",True) is None)))
            _g81 = 0
            _g91 = hxd_fmt_fbx_FbxTools.getAll(n1,"Properties70.P")
            while (_g81 < len(_g91)):
                p3 = (_g91[_g81] if _g81 >= 0 and _g81 < len(_g91) else None)
                _g81 = (_g81 + 1)
                _g82 = hxd_fmt_fbx_FbxTools.toString((p3.props[0] if 0 < len(p3.props) else None))
                if (((_g82 == "d|Z") or ((_g82 == "d|Y"))) or ((_g82 == "d|X"))):
                    if ((name == "T") and (not isRoot1)):
                        python_internal_ArrayImpl._set(p3.props, 4, hxd_fmt_fbx_FbxProp.PFloat((hxd_fmt_fbx_FbxTools.toFloat((p3.props[4] if 4 < len(p3.props) else None)) / scaleFactor)))
                    elif ((name == "S") and isRoot1):
                        python_internal_ArrayImpl._set(p3.props, 4, hxd_fmt_fbx_FbxProp.PFloat((hxd_fmt_fbx_FbxTools.toFloat((p3.props[4] if 4 < len(p3.props) else None)) * scaleFactor)))
                else:
                    pass
            _g10 = 0
            _g11 = self.getChilds(n1,"AnimationCurve")
            while (_g10 < len(_g11)):
                c = (_g11[_g10] if _g10 >= 0 and _g10 < len(_g11) else None)
                _g10 = (_g10 + 1)
                vl3 = toFloats(hxd_fmt_fbx_FbxTools.get(c,"KeyValueFloat"))
                if (name is not None):
                    name1 = name
                    if (name1 == "S"):
                        if isRoot1:
                            _g101 = 0
                            _g111 = len(vl3)
                            while (_g101 < _g111):
                                i1 = _g101
                                _g101 = (_g101 + 1)
                                python_internal_ArrayImpl._set(vl3, i1, ((vl3[i1] if i1 >= 0 and i1 < len(vl3) else None) * scaleFactor))
                    elif (name1 == "T"):
                        if (not isRoot1):
                            _g102 = 0
                            _g112 = len(vl3)
                            while (_g102 < _g112):
                                i2 = _g102
                                _g102 = (_g102 + 1)
                                python_internal_ArrayImpl._set(vl3, i2, ((vl3[i2] if i2 >= 0 and i2 < len(vl3) else None) / scaleFactor))
                    else:
                        pass

    def convertPoints(self,a):
        p = 0
        _g = 0
        x = (len(a) / 3)
        _g1 = None
        try:
            _g1 = int(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            _g1 = None
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            python_internal_ArrayImpl._set(a, p, -(a[p] if p >= 0 and p < len(a) else None))
            p = (p + 3)

    def leftHandConvert(self):
        if self.leftHand:
            return
        self.leftHand = True
        _g = 0
        _g1 = hxd_fmt_fbx_FbxTools.getAll(self.root,"Objects.Geometry")
        while (_g < len(_g1)):
            g = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            _g2 = 0
            _g11 = hxd_fmt_fbx_FbxTools.getAll(g,"Vertices")
            while (_g2 < len(_g11)):
                v = (_g11[_g2] if _g2 >= 0 and _g2 < len(_g11) else None)
                _g2 = (_g2 + 1)
                self.convertPoints(hxd_fmt_fbx_FbxTools.getFloats(v))
            _g21 = 0
            _g3 = hxd_fmt_fbx_FbxTools.getAll(g,"LayerElementNormal.Normals")
            while (_g21 < len(_g3)):
                v1 = (_g3[_g21] if _g21 >= 0 and _g21 < len(_g3) else None)
                _g21 = (_g21 + 1)
                self.convertPoints(hxd_fmt_fbx_FbxTools.getFloats(v1))
            _g4 = 0
            _g5 = hxd_fmt_fbx_FbxTools.getAll(g,"LayerElementTangent.Tangents")
            while (_g4 < len(_g5)):
                v2 = (_g5[_g4] if _g4 >= 0 and _g4 < len(_g5) else None)
                _g4 = (_g4 + 1)
                self.convertPoints(hxd_fmt_fbx_FbxTools.getFloats(v2))
            _g6 = 0
            _g7 = hxd_fmt_fbx_FbxTools.getAll(g,"LayerElementBinormal.Binormals")
            while (_g6 < len(_g7)):
                v3 = (_g7[_g6] if _g6 >= 0 and _g6 < len(_g7) else None)
                _g6 = (_g6 + 1)
                self.convertPoints(hxd_fmt_fbx_FbxTools.getFloats(v3))

    def init(self,n):
        _g = n.name
        _hx_local_0 = len(_g)
        if (_hx_local_0 == 11):
            if (_g == "Connections"):
                _g1 = 0
                _g11 = n.childs
                while (_g1 < len(_g11)):
                    c = (_g11[_g1] if _g1 >= 0 and _g1 < len(_g11) else None)
                    _g1 = (_g1 + 1)
                    if (c.name != "C"):
                        continue
                    child = hxd_fmt_fbx_FbxTools.toInt((c.props[1] if 1 < len(c.props) else None))
                    parent = hxd_fmt_fbx_FbxTools.toInt((c.props[2] if 2 < len(c.props) else None))
                    if ((self.ids.h.get(child,None) is None) or ((self.ids.h.get(parent,None) is None))):
                        continue
                    name = (c.props[3] if 3 < len(c.props) else None)
                    if (name is not None):
                        name1 = hxd_fmt_fbx_FbxTools.toString(name)
                        nc = self.namedConnect.h.get(parent,None)
                        if (nc is None):
                            nc = haxe_ds_StringMap()
                            self.namedConnect.set(parent,nc)
                        nc.h[name1] = child
                        if (name1 == "LookAtProperty"):
                            continue
                    c1 = self.connect.h.get(parent,None)
                    if (c1 is None):
                        c1 = []
                        self.connect.set(parent,c1)
                    c1.append(child)
                    if (parent == 0):
                        continue
                    c2 = self.invConnect.h.get(child,None)
                    if (c2 is None):
                        c2 = []
                        self.invConnect.set(child,c2)
                    c2.append(parent)
            else:
                pass
        elif (_hx_local_0 == 7):
            if (_g == "Objects"):
                _g2 = 0
                _g12 = n.childs
                while (_g2 < len(_g12)):
                    c3 = (_g12[_g2] if _g2 >= 0 and _g2 < len(_g12) else None)
                    _g2 = (_g2 + 1)
                    self.ids.set(hxd_fmt_fbx_FbxTools.getId(c3),c3)
            else:
                pass
        else:
            pass

    def getGeometry(self,name = None):
        if (name is None):
            name = ""
        geom = None
        _g = 0
        _g1 = hxd_fmt_fbx_FbxTools.getAll(self.root,"Objects.Geometry")
        while (_g < len(_g1)):
            g = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if hxd_fmt_fbx_FbxTools.hasProp(g,hxd_fmt_fbx_FbxProp.PString(("Geometry::" + ("null" if name is None else name)))):
                geom = g
                break
        if (geom is None):
            raise _HxException((("Geometry " + ("null" if name is None else name)) + " not found"))
        return hxd_fmt_fbx_Geometry(self,geom)

    def getParent(self,node,nodeName,opt = None):
        p = self.getParents(node,nodeName)
        if (len(p) > 1):
            tmp = (((((HxOverrides.stringOrNull(hxd_fmt_fbx_FbxTools.getName(node)) + " has ") + Std.string(len(p))) + " ") + ("null" if nodeName is None else nodeName)) + " parents ")
            _g = []
            _g1 = 0
            while (_g1 < len(p)):
                o = (p[_g1] if _g1 >= 0 and _g1 < len(p) else None)
                _g1 = (_g1 + 1)
                x = hxd_fmt_fbx_FbxTools.getName(o)
                _g.append(x)
            raise _HxException((("null" if tmp is None else tmp) + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in _g]))))
        if ((len(p) == 0) and (not opt)):
            raise _HxException((((("Missing " + HxOverrides.stringOrNull(hxd_fmt_fbx_FbxTools.getName(node))) + " ") + ("null" if nodeName is None else nodeName)) + " parent"))
        return (p[0] if 0 < len(p) else None)

    def getChild(self,node,nodeName,opt = None):
        c = self.getChilds(node,nodeName)
        if (len(c) > 1):
            tmp = (((((HxOverrides.stringOrNull(hxd_fmt_fbx_FbxTools.getName(node)) + " has ") + Std.string(len(c))) + " ") + ("null" if nodeName is None else nodeName)) + " childs ")
            _g = []
            _g1 = 0
            while (_g1 < len(c)):
                o = (c[_g1] if _g1 >= 0 and _g1 < len(c) else None)
                _g1 = (_g1 + 1)
                x = hxd_fmt_fbx_FbxTools.getName(o)
                _g.append(x)
            raise _HxException((("null" if tmp is None else tmp) + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in _g]))))
        if ((len(c) == 0) and (not opt)):
            raise _HxException((((("Missing " + HxOverrides.stringOrNull(hxd_fmt_fbx_FbxTools.getName(node))) + " ") + ("null" if nodeName is None else nodeName)) + " child"))
        return (c[0] if 0 < len(c) else None)

    def getSpecChild(self,node,name):
        this1 = self.namedConnect
        key = hxd_fmt_fbx_FbxTools.getId(node)
        nc = this1.h.get(key,None)
        if (nc is None):
            return None
        id = nc.h.get(name,None)
        if (id is None):
            return None
        return self.ids.h.get(id,None)

    def getChilds(self,node,nodeName = None):
        this1 = self.connect
        key = hxd_fmt_fbx_FbxTools.getId(node)
        c = this1.h.get(key,None)
        subs = []
        if (c is not None):
            _g = 0
            while (_g < len(c)):
                id = (c[_g] if _g >= 0 and _g < len(c) else None)
                _g = (_g + 1)
                n = self.ids.h.get(id,None)
                if (n is None):
                    raise _HxException((Std.string(id) + " not found"))
                if ((nodeName is not None) and ((n.name != nodeName))):
                    continue
                subs.append(n)
        return subs

    def getParents(self,node,nodeName = None):
        this1 = self.invConnect
        key = hxd_fmt_fbx_FbxTools.getId(node)
        c = this1.h.get(key,None)
        pl = []
        if (c is not None):
            _g = 0
            while (_g < len(c)):
                id = (c[_g] if _g >= 0 and _g < len(c) else None)
                _g = (_g + 1)
                n = self.ids.h.get(id,None)
                if (n is None):
                    raise _HxException((Std.string(id) + " not found"))
                if ((nodeName is not None) and ((n.name != nodeName))):
                    continue
                pl.append(n)
        return pl

    def getRoot(self):
        return self.root

    def ignoreMissingObject(self,name):
        _hx_def = self.defaultModelMatrixes.h.get(name,None)
        if (_hx_def is None):
            _hx_def = hxd_fmt_fbx_DefaultMatrixes()
            _hx_def.wasRemoved = -2
            self.defaultModelMatrixes.h[name] = _hx_def

    def buildHierarchy(self):
        oroot = hxd_fmt_fbx_TmpObject()
        objects = list()
        hobjects = haxe_ds_IntMap()
        hobjects.set(0,oroot)
        _g = 0
        _g1 = hxd_fmt_fbx_FbxTools.getAll(self.root,"Objects.Model")
        while (_g < len(_g1)):
            model = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            this1 = self.skipObjects
            key = hxd_fmt_fbx_FbxTools.getName(model)
            if this1.h.get(key,None):
                continue
            mtype = hxd_fmt_fbx_FbxTools.getType(model)
            isJoint = ((mtype == "LimbNode") and (((not self.unskinnedJointsAsObjects) or (not self.isNullJoint(model)))))
            o = hxd_fmt_fbx_TmpObject()
            o.model = model
            o.isJoint = isJoint
            o.isMesh = (mtype == "Mesh")
            hobjects.set(hxd_fmt_fbx_FbxTools.getId(model),o)
            objects.append(o)
        _g2 = 0
        while (_g2 < len(objects)):
            o1 = (objects[_g2] if _g2 >= 0 and _g2 < len(objects) else None)
            _g2 = (_g2 + 1)
            p = self.getParent(o1.model,"Model",True)
            pid = (0 if ((p is None)) else hxd_fmt_fbx_FbxTools.getId(p))
            op = hobjects.h.get(pid,None)
            if (op is None):
                op = oroot
            _this = op.childs
            _this.append(o1)
            o1.parent = op
        _g3 = 0
        while (_g3 < len(objects)):
            o2 = (objects[_g3] if _g3 >= 0 and _g3 < len(objects) else None)
            _g3 = (_g3 + 1)
            if (not o2.isMesh):
                continue
            g = self.getChild(o2.model,"Geometry")
            _hx_def = self.getChild(g,"Deformer",True)
            if (_hx_def is None):
                continue
            _g31 = []
            _g4 = 0
            _g5 = self.getChilds(_hx_def,"Deformer")
            while (_g4 < len(_g5)):
                d = (_g5[_g4] if _g4 >= 0 and _g4 < len(_g5) else None)
                _g4 = (_g4 + 1)
                key1 = hxd_fmt_fbx_FbxTools.getId(self.getChild(d,"Model"))
                x = hobjects.h.get(key1,None)
                _g31.append(x)
            bones = _g31
            if (len(bones) == 0):
                continue
            o3 = (bones[0] if 0 < len(bones) else None)
            k = 0
            while (o3 != oroot):
                o3 = o3.parent
                k = (k + 1)
            minDepth = k
            _g6 = 1
            _g7 = len(bones)
            while (_g6 < _g7):
                i = _g6
                _g6 = (_g6 + 1)
                o4 = (bones[i] if i >= 0 and i < len(bones) else None)
                k1 = 0
                while (o4 != oroot):
                    o4 = o4.parent
                    k1 = (k1 + 1)
                d1 = k1
                if (d1 < minDepth):
                    minDepth = d1
            out = []
            _g8 = 0
            _g9 = len(bones)
            while (_g8 < _g9):
                i1 = _g8
                _g8 = (_g8 + 1)
                b = (bones[i1] if i1 >= 0 and i1 < len(bones) else None)
                o5 = b
                k2 = 0
                while (o5 != oroot):
                    o5 = o5.parent
                    k2 = (k2 + 1)
                n = (k2 - minDepth)
                _g81 = 0
                _g91 = n
                while (_g81 < _g91):
                    i2 = _g81
                    _g81 = (_g81 + 1)
                    b.isJoint = True
                    b = b.parent
                python_internal_ArrayImpl.remove(out,b)
                out.append(b)
            bones = out
            while (len(bones) > 1):
                _g10 = 0
                while (_g10 < len(bones)):
                    b1 = (bones[_g10] if _g10 >= 0 and _g10 < len(bones) else None)
                    _g10 = (_g10 + 1)
                    b1.isJoint = True
                parents = []
                _g11 = 0
                while (_g11 < len(bones)):
                    b2 = (bones[_g11] if _g11 >= 0 and _g11 < len(bones) else None)
                    _g11 = (_g11 + 1)
                    if ((b2.parent == oroot) or b2.parent.isMesh):
                        continue
                    python_internal_ArrayImpl.remove(parents,b2.parent)
                    x1 = b2.parent
                    parents.append(x1)
                bones = parents
        changed = True
        while changed:
            changed = False
            _g41 = 0
            while (_g41 < len(objects)):
                o6 = (objects[_g41] if _g41 >= 0 and _g41 < len(objects) else None)
                _g41 = (_g41 + 1)
                if (o6.isJoint or o6.isMesh):
                    continue
                if o6.parent.isJoint:
                    o6.isJoint = True
                    changed = True
                    continue
                hasJoint = False
                _g42 = 0
                _g51 = o6.childs
                while (_g42 < len(_g51)):
                    c = (_g51[_g42] if _g42 >= 0 and _g42 < len(_g51) else None)
                    _g42 = (_g42 + 1)
                    if c.isJoint:
                        hasJoint = True
                        break
                if hasJoint:
                    _g61 = 0
                    _g71 = o6.parent.childs
                    while (_g61 < len(_g71)):
                        c1 = (_g71[_g61] if _g61 >= 0 and _g61 < len(_g71) else None)
                        _g61 = (_g61 + 1)
                        if c1.isJoint:
                            o6.isJoint = True
                            changed = True
                            break
        return _hx_AnonObject({'root': oroot, 'objects': objects})

    def getObjectCurve(self,curves,model,curveName,animName):
        key = hxd_fmt_fbx_FbxTools.getId(model)
        c = curves.h.get(key,None)
        if (c is not None):
            return c
        name = hxd_fmt_fbx_FbxTools.getName(model)
        if self.skipObjects.h.get(name,None):
            return None
        _hx_def = self.getDefaultMatrixes(model)
        if (_hx_def is None):
            return None
        isMove = ((curveName != "Visibility") and ((curveName != "UV")))
        if ((_hx_def.wasRemoved is not None) and ((isMove or ((_hx_def.wasRemoved == -1))))):
            return None
        if ((_hx_def.wasRemoved is not None) and ((_hx_def.wasRemoved != -2))):
            model = self.ids.h.get(_hx_def.wasRemoved,None)
            name = hxd_fmt_fbx_FbxTools.getName(model)
            c = curves.h.get(_hx_def.wasRemoved,None)
            _hx_def = self.getDefaultMatrixes(model)
            if (_hx_def is None):
                raise _HxException("assert")
        if (c is None):
            c = hxd_fmt_fbx__BaseLibrary_AnimCurve(_hx_def,name)
            curves.set(hxd_fmt_fbx_FbxTools.getId(model),c)
        return c

    def mergeModels(self,modelNames):
        if (len(modelNames) <= 1):
            return
        models = hxd_fmt_fbx_FbxTools.getAll(self.root,"Objects.Model")
        def _hx_local_1(name):
            _g = 0
            while (_g < len(models)):
                m = (models[_g] if _g >= 0 and _g < len(models) else None)
                _g = (_g + 1)
                if (hxd_fmt_fbx_FbxTools.getName(m) == name):
                    return m
            raise _HxException(("Model not found " + ("null" if name is None else name)))
        getModel = _hx_local_1
        m1 = getModel((modelNames[0] if 0 < len(modelNames) else None))
        geom = hxd_fmt_fbx_Geometry(self,self.getChild(m1,"Geometry"))
        _hx_def = self.getChild(geom.getRoot(),"Deformer",True)
        subDefs = self.getChilds(_hx_def,"Deformer")
        _g1 = 1
        _g11 = len(modelNames)
        while (_g1 < _g11):
            i = _g1
            _g1 = (_g1 + 1)
            name1 = (modelNames[i] if i >= 0 and i < len(modelNames) else None)
            m2 = getModel(name1)
            geom2 = hxd_fmt_fbx_Geometry(self,self.getChild(m2,"Geometry"))
            x = (len(geom.getVertices()) / 3)
            vcount = None
            try:
                vcount = int(x)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                vcount = None
            self.skipObjects.h[name1] = True
            mindex = []
            materials = self.getChilds(m1,"Material")
            _g2 = 0
            _g12 = self.getChilds(m2,"Material")
            while (_g2 < len(_g12)):
                mat = (_g12[_g2] if _g2 >= 0 and _g2 < len(_g12) else None)
                _g2 = (_g2 + 1)
                idx = python_internal_ArrayImpl.indexOf(materials,mat,None)
                if (idx < 0):
                    idx = len(materials)
                    materials.append(mat)
                    self.addLink(m1,mat)
                mindex.append(idx)
            geom.merge(geom2,mindex)
            def2 = self.getChild(geom2.getRoot(),"Deformer",True)
            if (def2 is not None):
                if (_hx_def is None):
                    raise _HxException((((HxOverrides.stringOrNull(hxd_fmt_fbx_FbxTools.getName(m1)) + " does not have a deformer but ") + ("null" if name1 is None else name1)) + " has one"))
                _g21 = 0
                _g3 = self.getChilds(def2,"Deformer")
                while (_g21 < len(_g3)):
                    subDef = (_g3[_g21] if _g21 >= 0 and _g21 < len(_g3) else None)
                    _g21 = (_g21 + 1)
                    subModel = self.getChild(subDef,"Model")
                    prevDef = None
                    _g22 = 0
                    while (_g22 < len(subDefs)):
                        s = (subDefs[_g22] if _g22 >= 0 and _g22 < len(subDefs) else None)
                        _g22 = (_g22 + 1)
                        if (self.getChild(s,"Model") == subModel):
                            prevDef = s
                            break
                    if (prevDef is not None):
                        self.removeLink(subDef,subModel)
                    idx1 = hxd_fmt_fbx_FbxTools.get(subDef,"Indexes",True)
                    if (idx1 is None):
                        continue
                    if (prevDef is None):
                        self.addLink(_hx_def,subDef)
                        self.removeLink(def2,subDef)
                        subDefs.append(subDef)
                        idx2 = hxd_fmt_fbx_FbxTools.getInts(idx1)
                        _g31 = 0
                        _g4 = len(idx2)
                        while (_g31 < _g4):
                            i1 = _g31
                            _g31 = (_g31 + 1)
                            python_internal_ArrayImpl._set(idx2, i1, ((idx2[i1] if i1 >= 0 and i1 < len(idx2) else None) + vcount))
                    else:
                        pidx = hxd_fmt_fbx_FbxTools.getInts(hxd_fmt_fbx_FbxTools.get(prevDef,"Indexes"))
                        _g32 = 0
                        _g41 = hxd_fmt_fbx_FbxTools.getInts(idx1)
                        while (_g32 < len(_g41)):
                            i2 = (_g41[_g32] if _g32 >= 0 and _g32 < len(_g41) else None)
                            _g32 = (_g32 + 1)
                            pidx.append((i2 + vcount))
                        weights = hxd_fmt_fbx_FbxTools.getFloats(hxd_fmt_fbx_FbxTools.get(prevDef,"Weights"))
                        _g5 = 0
                        _g6 = hxd_fmt_fbx_FbxTools.getFloats(hxd_fmt_fbx_FbxTools.get(subDef,"Weights"))
                        while (_g5 < len(_g6)):
                            w = (_g6[_g5] if _g5 >= 0 and _g5 < len(_g6) else None)
                            _g5 = (_g5 + 1)
                            weights.append(w)

    def addLink(self,parent,child):
        pid = hxd_fmt_fbx_FbxTools.getId(parent)
        nid = hxd_fmt_fbx_FbxTools.getId(child)
        _this = self.connect.h.get(pid,None)
        _this.append(nid)
        _this1 = self.invConnect.h.get(nid,None)
        _this1.append(pid)

    def removeLink(self,parent,child):
        pid = hxd_fmt_fbx_FbxTools.getId(parent)
        nid = hxd_fmt_fbx_FbxTools.getId(child)
        python_internal_ArrayImpl.remove(self.connect.h.get(pid,None),nid)
        python_internal_ArrayImpl.remove(self.invConnect.h.get(nid,None),pid)

    def checkData(self,t):
        if (t is None):
            return True
        if (t.x is not None):
            v = (t.x[0] if 0 < len(t.x) else None)
            _g = 0
            _g1 = t.x
            while (_g < len(_g1)):
                v2 = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (v != v2):
                    return False
        if (t.y is not None):
            v1 = (t.y[0] if 0 < len(t.y) else None)
            _g2 = 0
            _g11 = t.y
            while (_g2 < len(_g11)):
                v21 = (_g11[_g2] if _g2 >= 0 and _g2 < len(_g11) else None)
                _g2 = (_g2 + 1)
                if (v1 != v21):
                    return False
        if (t.z is not None):
            v3 = (t.z[0] if 0 < len(t.z) else None)
            _g3 = 0
            _g12 = t.z
            while (_g3 < len(_g12)):
                v22 = (_g12[_g3] if _g3 >= 0 and _g3 < len(_g12) else None)
                _g3 = (_g3 + 1)
                if (v3 != v22):
                    return False
        return True

    def roundValues(self,data,_hx_def,mult = None):
        if (mult is None):
            mult = 1.
        hasValue = False
        _g = 0
        _g1 = len(data)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            v = ((data[i] if i >= 0 and i < len(data) else None) * mult)
            f = (v - _hx_def)
            if (((-f if ((f < 0)) else f)) > 1e-3):
                hasValue = True
            else:
                v = _hx_def
            python_internal_ArrayImpl._set(data, i, self.round(v))
        return hasValue

    def getAnimationNames(self):
        names = []
        _g = 0
        _g1 = hxd_fmt_fbx_FbxTools.getAll(self.root,"Objects.AnimationStack")
        while (_g < len(_g1)):
            a = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (len(self.getChilds(a,"AnimationLayer")) > 0):
                x = hxd_fmt_fbx_FbxTools.getName(a)
                names.append(x)
        return names

    def loadAnimation(self,animName = None,root = None,lib = None):
        if (lib is not None):
            lib.defaultModelMatrixes = self.defaultModelMatrixes
            return lib.loadAnimation(animName)
        if (root is not None):
            l = hxd_fmt_fbx_BaseLibrary(self.fileName)
            l.normalizeScaleOrient = self.normalizeScaleOrient
            l.load(root)
            if self.leftHand:
                l.leftHandConvert()
            l.defaultModelMatrixes = self.defaultModelMatrixes
            return l.loadAnimation(animName)
        defNode = None
        animNodes = []
        _g = 0
        _g1 = hxd_fmt_fbx_FbxTools.getAll(self.root,"Objects.AnimationStack")
        while (_g < len(_g1)):
            a = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if ((animName is None) or ((hxd_fmt_fbx_FbxTools.getName(a) == animName))):
                _g2 = 0
                _g11 = self.getChilds(a,"AnimationLayer")
                while (_g2 < len(_g11)):
                    n = (_g11[_g2] if _g2 >= 0 and _g2 < len(_g11) else None)
                    _g2 = (_g2 + 1)
                    defNode = n
                    if (len(self.getChilds(n,"AnimationCurveNode")) > 0):
                        animNodes.append(n)
        animNode = None
        _g21 = len(animNodes)
        if (_g21 == 0):
            animNode = defNode
        elif (_g21 == 1):
            animNode = (animNodes[0] if 0 < len(animNodes) else None)
        else:
            haxe_Log.trace("Multiple animation layers curves are currently not supported",_hx_AnonObject({'fileName': "hxd/fmt/fbx/BaseLibrary.hx", 'lineNumber': 783, 'className': "hxd.fmt.fbx.BaseLibrary", 'methodName': "loadAnimation"}))
            animNode = (animNodes[0] if 0 < len(animNodes) else None)
        if (animNode is None):
            if (animName is not None):
                raise _HxException(("Animation not found " + ("null" if animName is None else animName)))
            if (self.uvAnims is None):
                return None
        if (animName is None):
            animName = hxd_fmt_fbx_FbxTools.getName(self.getParent(animNode,"AnimationStack"))
        curves = haxe_ds_IntMap()
        P0 = h3d_col_Point()
        P1 = h3d_col_Point(1,1,1)
        F = 0.0174532925199432955
        allTimes = haxe_ds_IntMap()
        if (animNode is not None):
            _g3 = 0
            _g4 = self.getChilds(animNode,"AnimationCurveNode")
            while (_g3 < len(_g4)):
                cn = (_g4[_g3] if _g3 >= 0 and _g3 < len(_g4) else None)
                _g3 = (_g3 + 1)
                model = self.getParent(cn,"Model",True)
                if (model is None):
                    _g31 = hxd_fmt_fbx_FbxTools.getName(cn)
                    if (_g31 is None):
                        continue
                    else:
                        _g32 = _g31
                        _hx_local_3 = len(_g32)
                        if (_hx_local_3 == 11):
                            if (_g32 == "FieldOfView"):
                                nattr = self.getParent(cn,"NodeAttribute",True)
                                model = (None if ((nattr is None)) else self.getParent(nattr,"Model",True))
                                if (model is None):
                                    continue
                            else:
                                continue
                        elif (_hx_local_3 == 4):
                            if (_g32 == "Roll"):
                                nattr = self.getParent(cn,"NodeAttribute",True)
                                model = (None if ((nattr is None)) else self.getParent(nattr,"Model",True))
                                if (model is None):
                                    continue
                            else:
                                continue
                        else:
                            continue
                c = self.getObjectCurve(curves,model,hxd_fmt_fbx_FbxTools.getName(cn),animName)
                if (c is None):
                    continue
                dataCurves = self.getChilds(cn,"AnimationCurve")
                if (len(dataCurves) == 0):
                    continue
                cname = hxd_fmt_fbx_FbxTools.getName(cn)
                times = hxd_fmt_fbx_FbxTools.getFloats(hxd_fmt_fbx_FbxTools.get((dataCurves[0] if 0 < len(dataCurves) else None),"KeyTime"))
                _g33 = 0
                _g41 = len(times)
                while (_g33 < _g41):
                    i = _g33
                    _g33 = (_g33 + 1)
                    t = (times[i] if i >= 0 and i < len(times) else None)
                    if (HxOverrides.modf(t, 100) != 0):
                        t = (t + ((100 - (HxOverrides.modf(t, 100)))))
                        python_internal_ArrayImpl._set(times, i, t)
                    it = None
                    try:
                        it = int((t / 200000))
                    except Exception as _hx_e:
                        _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                        e = _hx_e1
                        it = None
                    it1 = it
                    allTimes.set(it1,t)
                if (len(dataCurves) != 3):
                    values = hxd_fmt_fbx_FbxTools.getFloats(hxd_fmt_fbx_FbxTools.get((dataCurves[0] if 0 < len(dataCurves) else None),"KeyValueFloat"))
                    if (cname is not None):
                        cname1 = cname
                        _hx_local_5 = len(cname1)
                        if (_hx_local_5 == 10):
                            if (cname1 == "Visibility"):
                                if (not self.roundValues(values,1)):
                                    continue
                                c.a = _hx_AnonObject({'v': values, 't': times})
                                continue
                            else:
                                pass
                        elif (_hx_local_5 == 11):
                            if (cname1 == "FieldOfView"):
                                ratio = 1.77777777777777768
                                fov = 45.
                                _g5 = 0
                                _g6 = hxd_fmt_fbx_FbxTools.getAll(self.getChild(model,"NodeAttribute"),"Properties70.P")
                                while (_g5 < len(_g6)):
                                    p = (_g6[_g5] if _g5 >= 0 and _g5 < len(_g6) else None)
                                    _g5 = (_g5 + 1)
                                    _g51 = hxd_fmt_fbx_FbxTools.toString((p.props[0] if 0 < len(p.props) else None))
                                    _hx_local_7 = len(_g51)
                                    if (_hx_local_7 == 15):
                                        if (_g51 == "FilmAspectRatio"):
                                            ratio = hxd_fmt_fbx_FbxTools.toFloat((p.props[4] if 4 < len(p.props) else None))
                                        else:
                                            pass
                                    elif (_hx_local_7 == 11):
                                        if (_g51 == "FieldOfView"):
                                            fov = hxd_fmt_fbx_FbxTools.toFloat((p.props[4] if 4 < len(p.props) else None))
                                        else:
                                            pass
                                    else:
                                        pass
                                _g7 = 0
                                _g8 = len(values)
                                while (_g7 < _g8):
                                    i1 = _g7
                                    _g7 = (_g7 + 1)
                                    python_internal_ArrayImpl._set(values, i1, (((2 * Math.atan((Math.tan(((((values[i1] if i1 >= 0 and i1 < len(values) else None) * 0.5) * 3.14159265358979323) / 180)) / ratio))) * 180) / 3.14159265358979323))
                                if (not self.roundValues(values,(((2 * Math.atan((Math.tan((((fov * 0.5) * 3.14159265358979323) / 180)) / ratio))) * 180) / 3.14159265358979323))):
                                    continue
                                c.fov = _hx_AnonObject({'v': values, 't': times})
                                continue
                            else:
                                pass
                        elif (_hx_local_5 == 4):
                            if (cname1 == "Roll"):
                                if (not self.roundValues(values,0)):
                                    continue
                                c.roll = _hx_AnonObject({'v': values, 't': times})
                                continue
                            else:
                                pass
                        else:
                            pass
                data = _hx_AnonObject({'x': None, 'y': None, 'z': None, 't': times})
                this1 = self.namedConnect
                key = hxd_fmt_fbx_FbxTools.getId(cn)
                curves1 = this1.h.get(key,None)
                cname2 = curves1.keys()
                while cname2.hasNext():
                    cname3 = cname2.next()
                    this2 = self.ids
                    key1 = curves1.h.get(cname3,None)
                    values1 = hxd_fmt_fbx_FbxTools.getFloats(hxd_fmt_fbx_FbxTools.get(this2.h.get(key1,None),"KeyValueFloat"))
                    cname4 = cname3
                    if (cname4 == "d|X"):
                        data.x = values1
                    elif (cname4 == "d|Y"):
                        data.y = values1
                    elif (cname4 == "d|Z"):
                        data.z = values1
                    else:
                        haxe_Log.trace(("Unsupported key name " + ("null" if cname3 is None else cname3)),_hx_AnonObject({'fileName': "hxd/fmt/fbx/BaseLibrary.hx", 'lineNumber': 898, 'className': "hxd.fmt.fbx.BaseLibrary", 'methodName': "loadAnimation"}))
                M = 1.0
                _hx_def = None
                if (cname is None):
                    haxe_Log.trace(((("Unknown curve " + HxOverrides.stringOrNull(hxd_fmt_fbx_FbxTools.getName(model))) + ".") + ("null" if cname is None else cname)),_hx_AnonObject({'fileName': "hxd/fmt/fbx/BaseLibrary.hx", 'lineNumber': 925, 'className': "hxd.fmt.fbx.BaseLibrary", 'methodName': "loadAnimation"}))
                    continue
                else:
                    cname5 = cname
                    if (cname5 == "R"):
                        M = F
                        if ((c._hx_def.rotate is None) and ((c._hx_def.preRot is None))):
                            _hx_def = P0
                        elif (c._hx_def.rotate is None):
                            _hx_def = c._hx_def.preRot
                        elif (c._hx_def.preRot is None):
                            _hx_def = c._hx_def.rotate
                        else:
                            q = h3d_Quat()
                            q2 = h3d_Quat()
                            q2.initRotation(c._hx_def.preRot.x,c._hx_def.preRot.y,c._hx_def.preRot.z)
                            q.initRotation(c._hx_def.rotate.x,c._hx_def.rotate.y,c._hx_def.rotate.z)
                            q.multiply(q2,q)
                            _this = q.toEuler()
                            _hx_def = h3d_col_Point(_this.x,_this.y,_this.z)
                    elif (cname5 == "S"):
                        _hx_def = (P1 if ((c._hx_def.scale is None)) else c._hx_def.scale)
                    elif (cname5 == "T"):
                        _hx_def = (P0 if ((c._hx_def.trans is None)) else c._hx_def.trans)
                    else:
                        haxe_Log.trace(((("Unknown curve " + HxOverrides.stringOrNull(hxd_fmt_fbx_FbxTools.getName(model))) + ".") + ("null" if cname is None else cname)),_hx_AnonObject({'fileName': "hxd/fmt/fbx/BaseLibrary.hx", 'lineNumber': 925, 'className': "hxd.fmt.fbx.BaseLibrary", 'methodName': "loadAnimation"}))
                        continue
                hasValue = False
                if ((data.x is not None) and self.roundValues(data.x,_hx_def.x,M)):
                    hasValue = True
                if ((data.y is not None) and self.roundValues(data.y,_hx_def.y,M)):
                    hasValue = True
                if ((data.z is not None) and self.roundValues(data.z,_hx_def.z,M)):
                    hasValue = True
                if (not hasValue):
                    continue
                keyCount = 0
                if (data.x is not None):
                    keyCount = len(data.x)
                if (data.y is not None):
                    keyCount = len(data.y)
                if (data.z is not None):
                    keyCount = len(data.z)
                if (data.x is None):
                    _g52 = []
                    _g61 = 0
                    _g71 = keyCount
                    while (_g61 < _g71):
                        i2 = _g61
                        _g61 = (_g61 + 1)
                        x = _hx_def.x
                        _g52.append(x)
                    data.x = _g52
                if (data.y is None):
                    _g53 = []
                    _g62 = 0
                    _g72 = keyCount
                    while (_g62 < _g72):
                        i3 = _g62
                        _g62 = (_g62 + 1)
                        x1 = _hx_def.y
                        _g53.append(x1)
                    data.y = _g53
                if (data.z is None):
                    _g54 = []
                    _g63 = 0
                    _g73 = keyCount
                    while (_g63 < _g73):
                        i4 = _g63
                        _g63 = (_g63 + 1)
                        x2 = _hx_def.z
                        _g54.append(x2)
                    data.z = _g54
                if (cname is None):
                    raise _HxException("assert")
                else:
                    cname6 = cname
                    if (cname6 == "R"):
                        c.r = data
                    elif (cname6 == "S"):
                        c.s = data
                    elif (cname6 == "T"):
                        c.t = data
                    else:
                        raise _HxException("assert")
        if (self.uvAnims is not None):
            modelByName = haxe_ds_StringMap()
            _g34 = 0
            _g42 = hxd_fmt_fbx_FbxTools.getAll(self.root,"Objects.Model")
            while (_g34 < len(_g42)):
                obj = (_g42[_g34] if _g34 >= 0 and _g34 < len(_g42) else None)
                _g34 = (_g34 + 1)
                key2 = hxd_fmt_fbx_FbxTools.getName(obj)
                modelByName.h[key2] = obj
            obj1 = self.uvAnims.keys()
            while obj1.hasNext():
                obj2 = obj1.next()
                frames = self.uvAnims.h.get(obj2,None)
                model1 = modelByName.h.get(obj2,None)
                if (model1 is None):
                    raise _HxException((("Missing model '" + ("null" if obj2 is None else obj2)) + "' required by UV animation"))
                c1 = self.getObjectCurve(curves,model1,"UV",animName)
                if (c1 is None):
                    continue
                c1.uv = frames
                _g55 = 0
                while (_g55 < len(frames)):
                    f = (frames[_g55] if _g55 >= 0 and _g55 < len(frames) else None)
                    _g55 = (_g55 + 1)
                    x3 = (f.t / 200000)
                    key3 = None
                    try:
                        key3 = int(x3)
                    except Exception as _hx_e:
                        _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                        e1 = _hx_e1
                        key3 = None
                    allTimes.set(key3,f.t)
        _g35 = []
        a1 = allTimes.iterator()
        while a1.hasNext():
            a2 = a1.next()
            _g35.append(a2)
        allTimes1 = _g35
        if (len(allTimes1) == 0):
            return None
        allTimes1.sort(key= python_lib_Functools.cmp_to_key(self.sortDistinctFloats))
        maxTime = python_internal_ArrayImpl._get(allTimes1, (len(allTimes1) - 1))
        minDT = maxTime
        curT = (allTimes1[0] if 0 < len(allTimes1) else None)
        _g43 = 1
        _g56 = len(allTimes1)
        while (_g43 < _g56):
            i5 = _g43
            _g43 = (_g43 + 1)
            t1 = (allTimes1[i5] if i5 >= 0 and i5 < len(allTimes1) else None)
            dt = (t1 - curT)
            if (dt < minDT):
                minDT = dt
            curT = t1
        numFrames = None
        if (maxTime == 0):
            numFrames = 1
        else:
            numFrames1 = None
            try:
                numFrames1 = int((((maxTime - (allTimes1[0] if 0 < len(allTimes1) else None))) / minDT))
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e2 = _hx_e1
                numFrames1 = None
            numFrames = (1 + numFrames1)
        sampling = (15.0 / ((minDT / 3079077200)))
        if (len(allTimes1) < numFrames):
            t2 = (allTimes1[0] if 0 < len(allTimes1) else None)
            while (t2 < maxTime):
                if (python_internal_ArrayImpl.indexOf(allTimes1,t2,None) < 0):
                    allTimes1.append(t2)
                t2 = (t2 + minDT)
            allTimes1.sort(key= python_lib_Functools.cmp_to_key(Reflect.compare))
            if (len(allTimes1) > numFrames):
                tmp = (((("Animation " + ("null" if animName is None else animName)) + "(") + HxOverrides.stringOrNull(self.fileName)) + ") is not baked on a fixed framerate (detected ")
                tmp1 = None
                try:
                    tmp1 = int(sampling)
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e3 = _hx_e1
                    tmp1 = None
                raise _HxException(((("null" if tmp is None else tmp) + Std.string(tmp1)) + ")"))
            if (len(allTimes1) < numFrames):
                raise _HxException("assert")
        anim = h3d_anim_LinearAnimation(animName,numFrames,sampling)
        q1 = h3d_Quat()
        q21 = h3d_Quat()
        _g64 = []
        c2 = curves.iterator()
        while c2.hasNext():
            c3 = c2.next()
            _g64.append(c3)
        sortedCurves = _g64
        def _hx_local_11(c4):
            if (c4.roll is not None):
                return "roll"
            elif (c4.fov is not None):
                return "fov"
            elif (c4.uv is not None):
                return "uv"
            else:
                return "position"
        curveName = _hx_local_11
        def _hx_local_12(c11,c21):
            r = Reflect.compare(c11.object,c21.object)
            if (r != 0):
                return r
            return Reflect.compare(curveName(c11),curveName(c21))
        sortedCurves.sort(key= python_lib_Functools.cmp_to_key(_hx_local_12))
        _g74 = 0
        while (_g74 < len(sortedCurves)):
            c5 = (sortedCurves[_g74] if _g74 >= 0 and _g74 < len(sortedCurves) else None)
            _g74 = (_g74 + 1)
            numFrames2 = numFrames
            sameData = True
            if (((((((c5.t is None) and ((c5.r is None))) and ((c5.s is None))) and ((c5.a is None))) and ((c5.uv is None))) and ((c5.roll is None))) and ((c5.fov is None))):
                numFrames2 = 1
            else:
                if sameData:
                    sameData = self.checkData(c5.t)
                if sameData:
                    sameData = self.checkData(c5.r)
                if sameData:
                    sameData = self.checkData(c5.s)
            this3 = [None]*(1 if sameData else numFrames2)
            frames1 = this3
            alpha = None
            if (c5.a is None):
                alpha = None
            else:
                this4 = [None]*numFrames2
                alpha = this4
            uvs = None
            if (c5.uv is None):
                uvs = None
            else:
                this5 = [None]*(numFrames2 * 2)
                uvs = this5
            roll = None
            if (c5.roll is None):
                roll = None
            else:
                this6 = [None]*numFrames2
                roll = this6
            fov1 = None
            if (c5.fov is None):
                fov1 = None
            else:
                this7 = [None]*numFrames2
                fov1 = this7
            if (((((frames1 is None) and ((alpha is None))) and ((uvs is None))) and ((roll is None))) and ((fov1 is None))):
                continue
            ctx = (None if ((c5.t is None)) else c5.t.x)
            cty = (None if ((c5.t is None)) else c5.t.y)
            ctz = (None if ((c5.t is None)) else c5.t.z)
            ctt = ([-1.] if ((c5.t is None)) else c5.t.t)
            crx = (None if ((c5.r is None)) else c5.r.x)
            cry = (None if ((c5.r is None)) else c5.r.y)
            crz = (None if ((c5.r is None)) else c5.r.z)
            crt = ([-1.] if ((c5.r is None)) else c5.r.t)
            csx = (None if ((c5.s is None)) else c5.s.x)
            csy = (None if ((c5.s is None)) else c5.s.y)
            csz = (None if ((c5.s is None)) else c5.s.z)
            cst = ([-1.] if ((c5.s is None)) else c5.s.t)
            cav = (None if ((c5.a is None)) else c5.a.v)
            cat = (None if ((c5.a is None)) else c5.a.t)
            cuv = c5.uv
            def1 = c5._hx_def
            tp = 0
            rp = 0
            sp = 0
            ap = 0
            uvp = 0
            fovp = 0
            rollp = 0
            curFrame = None
            _g75 = 0
            _g81 = numFrames2
            while (_g75 < _g81):
                f1 = _g75
                _g75 = (_g75 + 1)
                changed = (curFrame is None)
                if ((allTimes1[f1] if f1 >= 0 and f1 < len(allTimes1) else None) == (ctt[tp] if tp >= 0 and tp < len(ctt) else None)):
                    changed = True
                    tp = (tp + 1)
                if ((allTimes1[f1] if f1 >= 0 and f1 < len(allTimes1) else None) == (crt[rp] if rp >= 0 and rp < len(crt) else None)):
                    changed = True
                    rp = (rp + 1)
                if ((allTimes1[f1] if f1 >= 0 and f1 < len(allTimes1) else None) == (cst[sp] if sp >= 0 and sp < len(cst) else None)):
                    changed = True
                    sp = (sp + 1)
                if changed:
                    f2 = h3d_anim_LinearFrame()
                    if ((c5.s is None) or ((sp == 0))):
                        if (def1.scale is not None):
                            f2.sx = def1.scale.x
                            f2.sy = def1.scale.y
                            f2.sz = def1.scale.z
                        else:
                            f2.sx = 1
                            f2.sy = 1
                            f2.sz = 1
                    else:
                        f2.sx = python_internal_ArrayImpl._get(csx, (sp - 1))
                        f2.sy = python_internal_ArrayImpl._get(csy, (sp - 1))
                        f2.sz = python_internal_ArrayImpl._get(csz, (sp - 1))
                    if ((c5.r is None) or ((rp == 0))):
                        if (def1.rotate is not None):
                            q1.initRotation(def1.rotate.x,def1.rotate.y,def1.rotate.z)
                        else:
                            def _hx_local_18():
                                def _hx_local_17():
                                    q1.z = 0
                                    return q1.z
                                q1.y = _hx_local_17()
                                return q1.y
                            q1.x = _hx_local_18()
                            q1.w = 1
                    else:
                        q1.initRotation(python_internal_ArrayImpl._get(crx, (rp - 1)),python_internal_ArrayImpl._get(cry, (rp - 1)),python_internal_ArrayImpl._get(crz, (rp - 1)))
                    if (def1.preRot is not None):
                        q21.initRotation(def1.preRot.x,def1.preRot.y,def1.preRot.z)
                        q1.multiply(q21,q1)
                    f2.qx = q1.x
                    f2.qy = q1.y
                    f2.qz = q1.z
                    f2.qw = q1.w
                    if ((c5.t is None) or ((tp == 0))):
                        if (def1.trans is not None):
                            f2.tx = def1.trans.x
                            f2.ty = def1.trans.y
                            f2.tz = def1.trans.z
                        else:
                            f2.tx = 0
                            f2.ty = 0
                            f2.tz = 0
                    else:
                        f2.tx = python_internal_ArrayImpl._get(ctx, (tp - 1))
                        f2.ty = python_internal_ArrayImpl._get(cty, (tp - 1))
                        f2.tz = python_internal_ArrayImpl._get(ctz, (tp - 1))
                    if self.leftHand:
                        f2.tx = -f2.tx
                        f2.qy = -f2.qy
                        f2.qz = -f2.qz
                    curFrame = f2
                if ((frames1 is not None) and ((f1 < len(frames1)))):
                    frames1[f1] = curFrame
                if (alpha is not None):
                    if ((allTimes1[f1] if f1 >= 0 and f1 < len(allTimes1) else None) == (cat[ap] if ap >= 0 and ap < len(cat) else None)):
                        ap = (ap + 1)
                    val = python_internal_ArrayImpl._get(cav, (ap - 1))
                    alpha[f1] = val
                if (uvs is not None):
                    if ((uvp < len(cuv)) and (((allTimes1[f1] if f1 >= 0 and f1 < len(allTimes1) else None) == (cuv[uvp] if uvp >= 0 and uvp < len(cuv) else None).t))):
                        uvp = (uvp + 1)
                    val1 = python_internal_ArrayImpl._get(cuv, (uvp - 1)).u
                    uvs[(f1 << 1)] = val1
                    val2 = python_internal_ArrayImpl._get(cuv, (uvp - 1)).v
                    uvs[((f1 << 1) | 1)] = val2
                if (roll is not None):
                    if ((allTimes1[f1] if f1 >= 0 and f1 < len(allTimes1) else None) == python_internal_ArrayImpl._get(c5.roll.t, rollp)):
                        rollp = (rollp + 1)
                    val3 = python_internal_ArrayImpl._get(c5.roll.v, (rollp - 1))
                    roll[f1] = val3
                if (fov1 is not None):
                    if ((allTimes1[f1] if f1 >= 0 and f1 < len(allTimes1) else None) == python_internal_ArrayImpl._get(c5.fov.t, fovp)):
                        fovp = (fovp + 1)
                    val4 = python_internal_ArrayImpl._get(c5.fov.v, (fovp - 1))
                    fov1[f1] = val4
            if (frames1 is not None):
                hasTrans = (c5.t is not None)
                hasRot = (((c5.r is not None) or ((def1.rotate is not None))) or ((def1.preRot is not None)))
                hasScale = ((c5.s is not None) or ((def1.scale is not None)))
                if ((not hasTrans) and ((def1.transPos is None))):
                    hasTrans = True
                anim.addCurve(c5.object,frames1,hasTrans,hasRot,hasScale)
            if (alpha is not None):
                anim.addAlphaCurve(c5.object,alpha)
            if (uvs is not None):
                anim.addUVCurve(c5.object,uvs)
            if (roll is not None):
                anim.addPropCurve(c5.object,"Roll",roll)
            if (fov1 is not None):
                anim.addPropCurve(c5.object,"FOVY",fov1)
        return anim

    def sortDistinctFloats(self,a,b):
        if (a > b):
            return 1
        else:
            return -1

    def isNullJoint(self,model):
        if (len(self.getParents(model,"Deformer")) > 0):
            return False
        parent = self.getParent(model,"Model",True)
        if (parent is None):
            return True
        t = hxd_fmt_fbx_FbxTools.getType(parent)
        if ((t == "LimbNode") or ((t == "Root"))):
            return False
        return True

    def getModelPath(self,model):
        parent = self.getParent(model,"Model",True)
        name = hxd_fmt_fbx_FbxTools.getName(model)
        if (parent is None):
            return name
        return ((HxOverrides.stringOrNull(self.getModelPath(parent)) + ".") + ("null" if name is None else name))

    def autoMerge(self):
        toMerge = []
        mergeGroups = haxe_ds_IntMap()
        _g = 0
        _g1 = hxd_fmt_fbx_FbxTools.getAll(self.root,"Objects.Model")
        while (_g < len(_g1)):
            model = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            this1 = self.skipObjects
            key = hxd_fmt_fbx_FbxTools.getName(model)
            if this1.h.get(key,None):
                continue
            mtype = hxd_fmt_fbx_FbxTools.getType(model)
            isJoint = ((mtype == "LimbNode") and (((not self.unskinnedJointsAsObjects) or (not self.isNullJoint(model)))))
            if (not isJoint):
                continue
            deformers = self.getParents(model,"Deformer")
            if (len(deformers) <= 1):
                continue
            group = []
            _g2 = 0
            while (_g2 < len(deformers)):
                d = (deformers[_g2] if _g2 >= 0 and _g2 < len(deformers) else None)
                _g2 = (_g2 + 1)
                _hx_def = self.getParent(d,"Deformer")
                if (_hx_def is None):
                    continue
                geom = self.getParent(_hx_def,"Geometry")
                if (geom is None):
                    continue
                model2 = self.getParent(geom,"Model")
                if (model2 is None):
                    continue
                id = hxd_fmt_fbx_FbxTools.getId(model2)
                g = mergeGroups.h.get(id,None)
                if (g is not None):
                    _g3 = 0
                    while (_g3 < len(g)):
                        g1 = (g[_g3] if _g3 >= 0 and _g3 < len(g) else None)
                        _g3 = (_g3 + 1)
                        python_internal_ArrayImpl.remove(group,g1)
                        group.append(g1)
                    python_internal_ArrayImpl.remove(toMerge,g)
                python_internal_ArrayImpl.remove(group,model2)
                group.append(model2)
                mergeGroups.set(id,group)
            toMerge.append(group)
        _g21 = 0
        while (_g21 < len(toMerge)):
            group1 = (toMerge[_g21] if _g21 >= 0 and _g21 < len(toMerge) else None)
            _g21 = (_g21 + 1)
            def _hx_local_4(m1,m2):
                return Reflect.compare(hxd_fmt_fbx_FbxTools.getName(m1),hxd_fmt_fbx_FbxTools.getName(m2))
            group1.sort(key= python_lib_Functools.cmp_to_key(_hx_local_4))
            _g22 = 0
            while (_g22 < len(toMerge)):
                g2 = (toMerge[_g22] if _g22 >= 0 and _g22 < len(toMerge) else None)
                _g22 = (_g22 + 1)
                if (g2 is not group1):
                    found = False
                    _g23 = 0
                    while (_g23 < len(group1)):
                        m = (group1[_g23] if _g23 >= 0 and _g23 < len(group1) else None)
                        _g23 = (_g23 + 1)
                        if python_internal_ArrayImpl.remove(g2,m):
                            found = True
                    if found:
                        g2.append((group1[0] if 0 < len(group1) else None))
            _g31 = []
            _g4 = 0
            while (_g4 < len(group1)):
                g3 = (group1[_g4] if _g4 >= 0 and _g4 < len(group1) else None)
                _g4 = (_g4 + 1)
                x = hxd_fmt_fbx_FbxTools.getName(g3)
                _g31.append(x)
            self.mergeModels(_g31)

    def keepJoint(self,j):
        return self.keepJoints.h.get(j.name,None)

    def createSkin(self,hskins,hgeom,rootJoints,bonesPerVertex):
        allJoints = []
        collectJoints = None
        def _hx_local_1(j):
            _g = 0
            _g1 = j.subs
            while (_g < len(_g1)):
                j1 = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                collectJoints(j1)
            allJoints.append(j)
        collectJoints = _hx_local_1
        _g2 = 0
        while (_g2 < len(rootJoints)):
            j2 = (rootJoints[_g2] if _g2 >= 0 and _g2 < len(rootJoints) else None)
            _g2 = (_g2 + 1)
            collectJoints(j2)
        skin = None
        geomTrans = None
        iterJoints = list(allJoints)
        _g11 = 0
        while (_g11 < len(iterJoints)):
            j3 = (iterJoints[_g11] if _g11 >= 0 and _g11 < len(iterJoints) else None)
            _g11 = (_g11 + 1)
            jModel = self.ids.h.get(j3.index,None)
            subDef = self.getParent(jModel,"Deformer",True)
            this1 = self.defaultModelMatrixes
            key = hxd_fmt_fbx_FbxTools.getName(jModel)
            defMat = this1.h.get(key,None)
            j3.defMat = defMat.toMatrix(self.leftHand)
            if (subDef is None):
                if ((len(j3.subs) > 0) or self.keepJoint(j3)):
                    continue
                if (j3.parent is None):
                    python_internal_ArrayImpl.remove(rootJoints,j3)
                else:
                    python_internal_ArrayImpl.remove(j3.parent.subs,j3)
                python_internal_ArrayImpl.remove(allJoints,j3)
                defMat.wasRemoved = -1
                continue
            if (skin is None):
                _hx_def = self.getParent(subDef,"Deformer")
                key1 = hxd_fmt_fbx_FbxTools.getId(_hx_def)
                skin = hskins.h.get(key1,None)
                if (skin is not None):
                    return skin
                key2 = hxd_fmt_fbx_FbxTools.getId(self.getParent(_hx_def,"Geometry"))
                geom = hgeom.h.get(key2,None)
                skin = h3d_anim_Skin(None,geom.vertexCount(),bonesPerVertex)
                geom.setSkin(skin)
                hskins.set(hxd_fmt_fbx_FbxTools.getId(_hx_def),skin)
            j3.transPos = defMat.transPos
            weights = hxd_fmt_fbx_FbxTools.getAll(subDef,"Weights")
            if (len(weights) > 0):
                weights1 = hxd_fmt_fbx_FbxTools.getFloats((weights[0] if 0 < len(weights) else None))
                vertex = hxd_fmt_fbx_FbxTools.getInts(hxd_fmt_fbx_FbxTools.get(subDef,"Indexes"))
                _g12 = 0
                _g21 = len(vertex)
                while (_g12 < _g21):
                    i = _g12
                    _g12 = (_g12 + 1)
                    w = (weights1[i] if i >= 0 and i < len(weights1) else None)
                    if (w < 0.01):
                        continue
                    vid = (vertex[i] if i >= 0 and i < len(vertex) else None)
                    il = (skin.envelop[vid] if vid >= 0 and vid < len(skin.envelop) else None)
                    if (il is None):
                        def _hx_local_4():
                            python_internal_ArrayImpl._set(skin.envelop, vid, [])
                            return (skin.envelop[vid] if vid >= 0 and vid < len(skin.envelop) else None)
                        il = _hx_local_4()
                    x = h3d_anim__Skin_Influence(j3,w)
                    il.append(x)
        if (skin is None):
            _g22 = []
            _g3 = 0
            while (_g3 < len(iterJoints)):
                j4 = (iterJoints[_g3] if _g3 >= 0 and _g3 < len(iterJoints) else None)
                _g3 = (_g3 + 1)
                x1 = j4.name
                _g22.append(x1)
            raise _HxException((("No joint is skinned (" + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in _g22]))) + ")"))
        allJoints.reverse()
        _g23 = 0
        _g31 = len(allJoints)
        while (_g23 < _g31):
            i1 = _g23
            _g23 = (_g23 + 1)
            (allJoints[i1] if i1 >= 0 and i1 < len(allJoints) else None).index = i1
        skin.setJoints(allJoints,rootJoints)
        skin.initWeights()
        return skin

    def round(self,v):
        if (v != v):
            raise _HxException("NaN found")
        v1 = (v * 131072)
        return (((v1 if (((v1 == Math.POSITIVE_INFINITY) or ((v1 == Math.NEGATIVE_INFINITY)))) else (Math.NaN if (python_lib_Math.isnan(v1)) else Math.floor((v1 + 0.5))))) / 131072)

    def updateDefaultMatrix(self,model,d):
        subDef = self.getParent(model,"Deformer",True)
        if (subDef is None):
            return
        transPos = h3d_Matrix.L(hxd_fmt_fbx_FbxTools.getFloats(hxd_fmt_fbx_FbxTools.get(subDef,"Transform")))
        if self.leftHand:
            transPos._12 = -transPos._12
            transPos._13 = -transPos._13
            transPos._21 = -transPos._21
            transPos._31 = -transPos._31
            transPos._41 = -transPos._41
        d.transPos = transPos

    def getDefaultMatrixes(self,model):
        name = hxd_fmt_fbx_FbxTools.getName(model)
        d = self.defaultModelMatrixes.h.get(name,None)
        if (d is not None):
            return d
        d = hxd_fmt_fbx_DefaultMatrixes()
        F = 0.0174532925199432955
        _g = 0
        _g1 = hxd_fmt_fbx_FbxTools.getAll(model,"Properties70.P")
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            _g2 = hxd_fmt_fbx_FbxTools.toString((p.props[0] if 0 < len(p.props) else None))
            _hx_local_1 = len(_g2)
            if (_hx_local_1 == 15):
                if (_g2 == "Lcl Translation"):
                    d.trans = h3d_col_Point(self.round(hxd_fmt_fbx_FbxTools.toFloat((p.props[4] if 4 < len(p.props) else None))),self.round(hxd_fmt_fbx_FbxTools.toFloat((p.props[5] if 5 < len(p.props) else None))),self.round(hxd_fmt_fbx_FbxTools.toFloat((p.props[6] if 6 < len(p.props) else None))))
                    if (((d.trans.x == 0) and ((d.trans.y == 0))) and ((d.trans.z == 0))):
                        d.trans = None
                else:
                    pass
            elif (_hx_local_1 == 11):
                if (_g2 == "Lcl Scaling"):
                    d.scale = h3d_col_Point(self.round(hxd_fmt_fbx_FbxTools.toFloat((p.props[4] if 4 < len(p.props) else None))),self.round(hxd_fmt_fbx_FbxTools.toFloat((p.props[5] if 5 < len(p.props) else None))),self.round(hxd_fmt_fbx_FbxTools.toFloat((p.props[6] if 6 < len(p.props) else None))))
                    if (((d.scale.x == 1) and ((d.scale.y == 1))) and ((d.scale.z == 1))):
                        d.scale = None
                elif (_g2 == "PreRotation"):
                    d.preRot = h3d_col_Point(self.round((hxd_fmt_fbx_FbxTools.toFloat((p.props[4] if 4 < len(p.props) else None)) * F)),self.round((hxd_fmt_fbx_FbxTools.toFloat((p.props[5] if 5 < len(p.props) else None)) * F)),self.round((hxd_fmt_fbx_FbxTools.toFloat((p.props[6] if 6 < len(p.props) else None)) * F)))
                    if (((d.preRot.x == 0) and ((d.preRot.y == 0))) and ((d.preRot.z == 0))):
                        d.preRot = None
                else:
                    pass
            elif (_hx_local_1 == 12):
                if (_g2 == "Lcl Rotation"):
                    d.rotate = h3d_col_Point(self.round((hxd_fmt_fbx_FbxTools.toFloat((p.props[4] if 4 < len(p.props) else None)) * F)),self.round((hxd_fmt_fbx_FbxTools.toFloat((p.props[5] if 5 < len(p.props) else None)) * F)),self.round((hxd_fmt_fbx_FbxTools.toFloat((p.props[6] if 6 < len(p.props) else None)) * F)))
                    if (((d.rotate.x == 0) and ((d.rotate.y == 0))) and ((d.rotate.z == 0))):
                        d.rotate = None
                else:
                    pass
            elif (_hx_local_1 == 20):
                if (_g2 == "GeometricTranslation"):
                    pass
                else:
                    pass
            else:
                pass
        if (hxd_fmt_fbx_FbxTools.getType(model) == "LimbNode"):
            self.updateDefaultMatrix(model,d)
        self.defaultModelMatrixes.h[name] = d
        return d

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.root = None
        _hx_o.ids = None
        _hx_o.connect = None
        _hx_o.namedConnect = None
        _hx_o.invConnect = None
        _hx_o.leftHand = None
        _hx_o.defaultModelMatrixes = None
        _hx_o.uvAnims = None
        _hx_o.animationEvents = None
        _hx_o.isMaya = None
        _hx_o.fileName = None
        _hx_o.version = None
        _hx_o.keepJoints = None
        _hx_o.skipObjects = None
        _hx_o.bonesPerVertex = None
        _hx_o.maxBonesPerSkin = None
        _hx_o.unskinnedJointsAsObjects = None
        _hx_o.allowVertexColor = None
        _hx_o.normalizeScaleOrient = None
hxd_fmt_fbx_BaseLibrary._hx_class = hxd_fmt_fbx_BaseLibrary
_hx_classes["hxd.fmt.fbx.BaseLibrary"] = hxd_fmt_fbx_BaseLibrary

class hxd_fmt_fbx_FbxProp(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.fmt.fbx.FbxProp"
    _hx_constructs = ["PInt", "PFloat", "PString", "PIdent", "PInts", "PFloats", "PBinary"]

    @staticmethod
    def PInt(v):
        return hxd_fmt_fbx_FbxProp("PInt", 0, (v,))

    @staticmethod
    def PFloat(v):
        return hxd_fmt_fbx_FbxProp("PFloat", 1, (v,))

    @staticmethod
    def PString(v):
        return hxd_fmt_fbx_FbxProp("PString", 2, (v,))

    @staticmethod
    def PIdent(i):
        return hxd_fmt_fbx_FbxProp("PIdent", 3, (i,))

    @staticmethod
    def PInts(v):
        return hxd_fmt_fbx_FbxProp("PInts", 4, (v,))

    @staticmethod
    def PFloats(v):
        return hxd_fmt_fbx_FbxProp("PFloats", 5, (v,))

    @staticmethod
    def PBinary(v):
        return hxd_fmt_fbx_FbxProp("PBinary", 6, (v,))
hxd_fmt_fbx_FbxProp._hx_class = hxd_fmt_fbx_FbxProp
_hx_classes["hxd.fmt.fbx.FbxProp"] = hxd_fmt_fbx_FbxProp


class hxd_fmt_fbx_FbxTools:
    _hx_class_name = "hxd.fmt.fbx.FbxTools"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["get", "getAll", "getInts", "getFloats", "hasProp", "idToInt", "toInt", "toFloat", "toString", "toBinary", "getId", "getName", "getType"]

    @staticmethod
    def get(n,path,opt = None):
        if (opt is None):
            opt = False
        parts = path.split(".")
        cur = n
        _g = 0
        while (_g < len(parts)):
            p = (parts[_g] if _g >= 0 and _g < len(parts) else None)
            _g = (_g + 1)
            found = False
            _g1 = 0
            _g11 = cur.childs
            while (_g1 < len(_g11)):
                c = (_g11[_g1] if _g1 >= 0 and _g1 < len(_g11) else None)
                _g1 = (_g1 + 1)
                if (c.name == p):
                    cur = c
                    found = True
                    break
            if (not found):
                if opt:
                    return None
                raise _HxException((((((HxOverrides.stringOrNull(n.name) + " does not have ") + ("null" if path is None else path)) + " (") + ("null" if p is None else p)) + " not found)"))
        return cur

    @staticmethod
    def getAll(n,path):
        parts = path.split(".")
        cur = [n]
        _g = 0
        while (_g < len(parts)):
            p = (parts[_g] if _g >= 0 and _g < len(parts) else None)
            _g = (_g + 1)
            out = []
            _g1 = 0
            while (_g1 < len(cur)):
                n1 = (cur[_g1] if _g1 >= 0 and _g1 < len(cur) else None)
                _g1 = (_g1 + 1)
                _g2 = 0
                _g11 = n1.childs
                while (_g2 < len(_g11)):
                    c = (_g11[_g2] if _g2 >= 0 and _g2 < len(_g11) else None)
                    _g2 = (_g2 + 1)
                    if (c.name == p):
                        out.append(c)
            cur = out
            if (len(cur) == 0):
                return cur
        return cur

    @staticmethod
    def getInts(n):
        if (len(n.props) != 1):
            raise _HxException((((HxOverrides.stringOrNull(n.name) + " has ") + Std.string(n.props)) + " props"))
        _g = (n.props[0] if 0 < len(n.props) else None)
        if (_g.index == 4):
            v = _g.params[0]
            return v
        else:
            raise _HxException((((HxOverrides.stringOrNull(n.name) + " has ") + Std.string(n.props)) + " props"))

    @staticmethod
    def getFloats(n):
        if (len(n.props) != 1):
            raise _HxException((((HxOverrides.stringOrNull(n.name) + " has ") + Std.string(n.props)) + " props"))
        _g = (n.props[0] if 0 < len(n.props) else None)
        tmp = _g.index
        if (tmp == 4):
            i = _g.params[0]
            fl = list()
            _g1 = 0
            while (_g1 < len(i)):
                x = (i[_g1] if _g1 >= 0 and _g1 < len(i) else None)
                _g1 = (_g1 + 1)
                fl.append(x)
            python_internal_ArrayImpl._set(n.props, 0, hxd_fmt_fbx_FbxProp.PFloats(fl))
            return fl
        elif (tmp == 5):
            v = _g.params[0]
            return v
        else:
            raise _HxException((((HxOverrides.stringOrNull(n.name) + " has ") + Std.string(n.props)) + " props"))

    @staticmethod
    def hasProp(n,p):
        _g = 0
        _g1 = n.props
        while (_g < len(_g1)):
            p2 = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if Type.enumEq(p,p2):
                return True
        return False

    @staticmethod
    def idToInt(f):
        f = HxOverrides.modf(f, 4294967296.)
        if (f >= 2147483648.):
            f = (f - 4294967296.)
        elif (f < -2147483648.):
            f = (f + 4294967296.)
        tmp = None
        try:
            tmp = int(f)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            tmp = None
        return tmp

    @staticmethod
    def toInt(n):
        if (n is None):
            raise _HxException("null prop")
        tmp = n.index
        if (tmp == 0):
            v = n.params[0]
            return v
        elif (tmp == 1):
            f = n.params[0]
            return hxd_fmt_fbx_FbxTools.idToInt(f)
        else:
            raise _HxException(("Invalid prop " + Std.string(n)))

    @staticmethod
    def toFloat(n):
        if (n is None):
            raise _HxException("null prop")
        tmp = n.index
        if (tmp == 0):
            v = n.params[0]
            return (v * 1.0)
        elif (tmp == 1):
            v1 = n.params[0]
            return v1
        else:
            raise _HxException(("Invalid prop " + Std.string(n)))

    @staticmethod
    def toString(n):
        if (n is None):
            raise _HxException("null prop")
        if (n.index == 2):
            v = n.params[0]
            return v
        else:
            raise _HxException(("Invalid prop " + Std.string(n)))

    @staticmethod
    def toBinary(n):
        if (n is None):
            raise _HxException("null prop")
        if (n.index == 6):
            v = n.params[0]
            return v
        else:
            raise _HxException(("Invalid prop " + Std.string(n)))

    @staticmethod
    def getId(n):
        if (len(n.props) != 3):
            raise _HxException((HxOverrides.stringOrNull(n.name) + " is not an object"))
        _g = (n.props[0] if 0 < len(n.props) else None)
        tmp = _g.index
        if (tmp == 0):
            id = _g.params[0]
            return id
        elif (tmp == 1):
            id1 = _g.params[0]
            return hxd_fmt_fbx_FbxTools.idToInt(id1)
        else:
            raise _HxException(((HxOverrides.stringOrNull(n.name) + " is not an object ") + Std.string(n.props)))

    @staticmethod
    def getName(n):
        if (len(n.props) != 3):
            raise _HxException((HxOverrides.stringOrNull(n.name) + " is not an object"))
        _g = (n.props[1] if 1 < len(n.props) else None)
        if (_g.index == 2):
            n1 = _g.params[0]
            _this = n1.split("::")
            return (None if ((len(_this) == 0)) else _this.pop())
        else:
            raise _HxException((HxOverrides.stringOrNull(n.name) + " is not an object"))

    @staticmethod
    def getType(n):
        if (len(n.props) != 3):
            raise _HxException((HxOverrides.stringOrNull(n.name) + " is not an object"))
        _g = (n.props[2] if 2 < len(n.props) else None)
        if (_g.index == 2):
            n1 = _g.params[0]
            return n1
        else:
            raise _HxException((HxOverrides.stringOrNull(n.name) + " is not an object"))
hxd_fmt_fbx_FbxTools._hx_class = hxd_fmt_fbx_FbxTools
_hx_classes["hxd.fmt.fbx.FbxTools"] = hxd_fmt_fbx_FbxTools


class hxd_fmt_fbx_Geometry:
    _hx_class_name = "hxd.fmt.fbx.Geometry"
    _hx_is_interface = "False"
    __slots__ = ("lib", "root")
    _hx_fields = ["lib", "root"]
    _hx_methods = ["getRoot", "getVertices", "getPolygons", "getMaterials", "getMaterialByTriangle", "merge", "getIndexes", "getNormals", "getTangents", "getBinormals", "processVectors", "getColors", "getUVs", "getGeomMatrix"]

    def __init__(self,l,root):
        self.lib = l
        self.root = root

    def getRoot(self):
        return self.root

    def getVertices(self):
        return hxd_fmt_fbx_FbxTools.getFloats(hxd_fmt_fbx_FbxTools.get(self.root,"Vertices"))

    def getPolygons(self):
        return hxd_fmt_fbx_FbxTools.getInts(hxd_fmt_fbx_FbxTools.get(self.root,"PolygonVertexIndex"))

    def getMaterials(self):
        mats = hxd_fmt_fbx_FbxTools.get(self.root,"LayerElementMaterial",True)
        if (mats is None):
            return None
        else:
            return hxd_fmt_fbx_FbxTools.getInts(hxd_fmt_fbx_FbxTools.get(mats,"Materials"))

    def getMaterialByTriangle(self):
        mids = self.getMaterials()
        pos = 0
        count = 0
        mats = []
        _g = 0
        _g1 = self.getPolygons()
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            count = (count + 1)
            if (p >= 0):
                continue
            m = pos
            pos = (pos + 1)
            m1 = (mids[m] if m >= 0 and m < len(mids) else None)
            _g2 = 0
            _g11 = (count - 2)
            while (_g2 < _g11):
                i = _g2
                _g2 = (_g2 + 1)
                mats.append(m1)
            count = 0
        return mats

    def merge(self,g,materials):
        vl = self.getVertices()
        x = (len(vl) / 3)
        vcount = None
        try:
            vcount = int(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            vcount = None
        if ((g.getGeomMatrix() is not None) or ((self.getGeomMatrix() is not None))):
            raise _HxException("Cannot merge models with geometric transform")
        _g = 0
        _g1 = g.getVertices()
        while (_g < len(_g1)):
            v = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            vl.append(v)
        poly = self.getPolygons()
        mats = self.getMaterials()
        if ((len(mats) == 1) and ((hxd_fmt_fbx_FbxTools.toString(python_internal_ArrayImpl._get(hxd_fmt_fbx_FbxTools.get(self.root,"LayerElementMaterial.MappingInformationType").props, 0)) == "AllSame"))):
            polyCount = 0
            _g2 = 0
            while (_g2 < len(poly)):
                p = (poly[_g2] if _g2 >= 0 and _g2 < len(poly) else None)
                _g2 = (_g2 + 1)
                if (p < 0):
                    polyCount = (polyCount + 1)
            m0 = (mats[0] if 0 < len(mats) else None)
            _g3 = 1
            _g4 = polyCount
            while (_g3 < _g4):
                i = _g3
                _g3 = (_g3 + 1)
                mats.append(m0)
        polyCount1 = 0
        _g21 = 0
        _g31 = g.getPolygons()
        while (_g21 < len(_g31)):
            p1 = (_g31[_g21] if _g21 >= 0 and _g21 < len(_g31) else None)
            _g21 = (_g21 + 1)
            p2 = p1
            if (p2 < 0):
                polyCount1 = (polyCount1 + 1)
                p2 = (p2 - vcount)
            else:
                p2 = (p2 + vcount)
            poly.append(p2)
        normals = self.getNormals()
        _g41 = 0
        _g5 = g.getNormals()
        while (_g41 < len(_g5)):
            n = (_g5[_g41] if _g41 >= 0 and _g41 < len(_g5) else None)
            _g41 = (_g41 + 1)
            normals.append(n)
        uv = self.getUVs()
        uv2 = g.getUVs()
        if (len(uv) != len(uv2)):
            raise _HxException((((("Different UV layer (" + Std.string(len(uv2))) + " should be ") + Std.string(len(uv))) + ")"))
        _g6 = 0
        _g7 = len(uv)
        while (_g6 < _g7):
            i1 = _g6
            _g6 = (_g6 + 1)
            uv1 = (uv[i1] if i1 >= 0 and i1 < len(uv) else None)
            uv21 = (uv2[i1] if i1 >= 0 and i1 < len(uv2) else None)
            count = (len(uv1.values) >> 1)
            _g61 = 0
            _g71 = uv21.values
            while (_g61 < len(_g71)):
                v1 = (_g71[_g61] if _g61 >= 0 and _g61 < len(_g71) else None)
                _g61 = (_g61 + 1)
                _this = uv1.values
                _this.append(v1)
            _g8 = 0
            _g9 = uv21.index
            while (_g8 < len(_g9)):
                i2 = (_g9[_g8] if _g8 >= 0 and _g8 < len(_g9) else None)
                _g8 = (_g8 + 1)
                _this1 = uv1.index
                _this1.append((i2 + count))
        colors = self.getColors()
        colors2 = g.getColors()
        if (colors is not None):
            if (colors2 is not None):
                count1 = (len(colors.values) >> 2)
                _g81 = 0
                _g91 = colors2.values
                while (_g81 < len(_g91)):
                    v2 = (_g91[_g81] if _g81 >= 0 and _g81 < len(_g91) else None)
                    _g81 = (_g81 + 1)
                    _this2 = colors.values
                    _this2.append(v2)
                _g10 = 0
                _g11 = colors2.index
                while (_g10 < len(_g11)):
                    i3 = (_g11[_g10] if _g10 >= 0 and _g10 < len(_g11) else None)
                    _g10 = (_g10 + 1)
                    _this3 = colors.index
                    _this3.append((i3 + count1))
            else:
                count2 = (len(colors.values) >> 2)
                x1 = (len(g.getNormals()) / 3)
                count21 = None
                try:
                    count21 = int(x1)
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e1 = _hx_e1
                    count21 = None
                _this4 = colors.values
                _this4.append(1)
                _this5 = colors.values
                _this5.append(1)
                _this6 = colors.values
                _this6.append(1)
                _this7 = colors.values
                _this7.append(1)
                _g82 = 0
                _g92 = count21
                while (_g82 < _g92):
                    i4 = _g82
                    _g82 = (_g82 + 1)
                    _this8 = colors.index
                    _this8.append(count2)
        else:
            tmp = (colors2 is not None)
        m2 = g.getMaterials()
        if (m2 is None):
            mid = (materials[0] if 0 < len(materials) else None)
            _g83 = 0
            _g93 = polyCount1
            while (_g83 < _g93):
                i5 = _g83
                _g83 = (_g83 + 1)
                mats.append(mid)
        elif ((polyCount1 > 1) and ((len(m2) == 1))):
            m = (m2[0] if 0 < len(m2) else None)
            _g84 = 0
            _g94 = polyCount1
            while (_g84 < _g94):
                i6 = _g84
                _g84 = (_g84 + 1)
                mats.append((materials[m] if m >= 0 and m < len(materials) else None))
        else:
            _g85 = 0
            while (_g85 < len(m2)):
                m1 = (m2[_g85] if _g85 >= 0 and _g85 < len(m2) else None)
                _g85 = (_g85 + 1)
                mats.append((materials[m1] if m1 >= 0 and m1 < len(materials) else None))

    def getIndexes(self):
        count = 0
        pos = 0
        index = self.getPolygons()
        vout = []
        iout = []
        _g = 0
        while (_g < len(index)):
            i = (index[_g] if _g >= 0 and _g < len(index) else None)
            _g = (_g + 1)
            count = (count + 1)
            if (i < 0):
                python_internal_ArrayImpl._set(index, pos, (-i - 1))
                start = ((pos - count) + 1)
                _g1 = 0
                _g11 = count
                while (_g1 < _g11):
                    n = _g1
                    _g1 = (_g1 + 1)
                    vout.append(python_internal_ArrayImpl._get(index, (n + start)))
                _g2 = 0
                _g3 = (count - 2)
                while (_g2 < _g3):
                    n1 = _g2
                    _g2 = (_g2 + 1)
                    iout.append((start + n1))
                    iout.append(((start + count) - 1))
                    iout.append(((start + n1) + 1))
                python_internal_ArrayImpl._set(index, pos, i)
                count = 0
            pos = (pos + 1)
        return _hx_AnonObject({'vidx': vout, 'idx': iout})

    def getNormals(self):
        return self.processVectors("LayerElementNormal","Normals")

    def getTangents(self,opt = None):
        if (opt is None):
            opt = False
        return self.processVectors("LayerElementTangent","Tangents",opt)

    def getBinormals(self,opt = None):
        if (opt is None):
            opt = False
        return self.processVectors("LayerElementBinormal","Binormals",opt)

    def processVectors(self,layer,name,opt = None):
        if (opt is None):
            opt = False
        vect = hxd_fmt_fbx_FbxTools.get(self.root,((("null" if layer is None else layer) + ".") + ("null" if name is None else name)),opt)
        if (vect is None):
            return None
        nrm = hxd_fmt_fbx_FbxTools.getFloats(vect)
        if (hxd_fmt_fbx_FbxTools.toString(python_internal_ArrayImpl._get(hxd_fmt_fbx_FbxTools.get(self.root,(("null" if layer is None else layer) + ".MappingInformationType")).props, 0)) == "ByVertice"):
            nout = []
            _g = 0
            _g1 = self.getPolygons()
            while (_g < len(_g1)):
                i = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                vid = i
                if (vid < 0):
                    vid = (-vid - 1)
                nout.append(python_internal_ArrayImpl._get(nrm, (vid * 3)))
                nout.append(python_internal_ArrayImpl._get(nrm, ((vid * 3) + 1)))
                nout.append(python_internal_ArrayImpl._get(nrm, ((vid * 3) + 2)))
            nrm = nout
        return nrm

    def getColors(self):
        color = hxd_fmt_fbx_FbxTools.get(self.root,"LayerElementColor",True)
        if (color is None):
            return None
        index = hxd_fmt_fbx_FbxTools.get(color,"ColorIndex",True)
        if (index is None):
            return None
        return _hx_AnonObject({'values': hxd_fmt_fbx_FbxTools.getFloats(hxd_fmt_fbx_FbxTools.get(color,"Colors")), 'index': hxd_fmt_fbx_FbxTools.getInts(index)})

    def getUVs(self):
        uvs = []
        _g = 0
        _g1 = hxd_fmt_fbx_FbxTools.getAll(self.root,"LayerElementUV")
        while (_g < len(_g1)):
            v = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            index = hxd_fmt_fbx_FbxTools.get(v,"UVIndex",True)
            values = hxd_fmt_fbx_FbxTools.getFloats(hxd_fmt_fbx_FbxTools.get(v,"UV"))
            index1 = None
            if (index is None):
                _g2 = []
                _g11 = 0
                _g21 = self.getPolygons()
                while (_g11 < len(_g21)):
                    i = (_g21[_g11] if _g11 >= 0 and _g11 < len(_g21) else None)
                    _g11 = (_g11 + 1)
                    _g2.append(((-i - 1) if ((i < 0)) else i))
                index1 = _g2
            else:
                index1 = hxd_fmt_fbx_FbxTools.getInts(index)
            uvs.append(_hx_AnonObject({'values': values, 'index': index1}))
        return uvs

    def getGeomMatrix(self):
        rot = None
        trans = None
        _g = 0
        _g1 = hxd_fmt_fbx_FbxTools.getAll(self.lib.getParent(self.root,"Model"),"Properties70.P")
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            _g2 = hxd_fmt_fbx_FbxTools.toString((p.props[0] if 0 < len(p.props) else None))
            _hx_local_1 = len(_g2)
            if (_hx_local_1 == 17):
                if (_g2 == "GeometricRotation"):
                    rot = h3d_col_Point(((hxd_fmt_fbx_FbxTools.toFloat((p.props[4] if 4 < len(p.props) else None)) * 3.14159265358979323) / 180),((hxd_fmt_fbx_FbxTools.toFloat((p.props[5] if 5 < len(p.props) else None)) * 3.14159265358979323) / 180),((hxd_fmt_fbx_FbxTools.toFloat((p.props[6] if 6 < len(p.props) else None)) * 3.14159265358979323) / 180))
                else:
                    pass
            elif (_hx_local_1 == 20):
                if (_g2 == "GeometricTranslation"):
                    trans = h3d_col_Point((hxd_fmt_fbx_FbxTools.toFloat((p.props[4] if 4 < len(p.props) else None)) * ((-1 if (self.lib.leftHand) else 1))),hxd_fmt_fbx_FbxTools.toFloat((p.props[5] if 5 < len(p.props) else None)),hxd_fmt_fbx_FbxTools.toFloat((p.props[6] if 6 < len(p.props) else None)))
                else:
                    pass
            else:
                pass
        if ((rot is None) and ((trans is None))):
            return None
        m = h3d_Matrix()
        if (rot is None):
            m.identity()
        else:
            m.initRotation(rot.x,rot.y,rot.z)
        if (trans is not None):
            m._41 = (m._41 + trans.x)
            m._42 = (m._42 + trans.y)
            m._43 = (m._43 + trans.z)
        return m

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.lib = None
        _hx_o.root = None
hxd_fmt_fbx_Geometry._hx_class = hxd_fmt_fbx_Geometry
_hx_classes["hxd.fmt.fbx.Geometry"] = hxd_fmt_fbx_Geometry


class hxd_fmt_fbx_HMDOut(hxd_fmt_fbx_BaseLibrary):
    _hx_class_name = "hxd.fmt.fbx.HMDOut"
    _hx_is_interface = "False"
    __slots__ = ("d", "dataOut", "filePath", "tmp", "absoluteTexturePath", "optimizeSkin", "floatSkinIndexes")
    _hx_fields = ["d", "dataOut", "filePath", "tmp", "absoluteTexturePath", "optimizeSkin", "floatSkinIndexes"]
    _hx_methods = ["int32tof", "keepJoint", "buildTangents", "buildGeom", "addModels", "makeTexturePath", "makeSkin", "makePosition", "writeFloat", "writeFrame", "makeAnimation", "toHMD"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = hxd_fmt_fbx_BaseLibrary


    def __init__(self,fileName):
        self.absoluteTexturePath = None
        self.filePath = None
        self.dataOut = None
        self.d = None
        self.floatSkinIndexes = False
        self.optimizeSkin = True
        self.tmp = haxe_io_Bytes.alloc(4)
        super().__init__(fileName)

    def int32tof(self,v):
        self.tmp.b[0] = ((v & 255) & 255)
        self.tmp.b[1] = (((v >> 8) & 255) & 255)
        self.tmp.b[2] = (((v >> 16) & 255) & 255)
        self.tmp.b[3] = (HxOverrides.rshift(v, 24) & 255)
        return self.tmp.getFloat(0)

    def keepJoint(self,j):
        if (not self.optimizeSkin):
            return True
        tmp = None
        _this = EReg("^Bip00[0-9] ","")
        _this.matchObj = python_lib_Re.search(_this.pattern,j.name)
        if (_this.matchObj is None):
            _this1 = EReg("^Bone[0-9][0-9][0-9]$","")
            _this1.matchObj = python_lib_Re.search(_this1.pattern,j.name)
            tmp = (_this1.matchObj is not None)
        else:
            tmp = True
        if tmp:
            return False
        return True

    def buildTangents(self,geom):
        verts = geom.getVertices()
        normals = geom.getNormals()
        uvs = geom.getUVs()
        index = geom.getIndexes()
        tmp = Sys.getEnv("TMPDIR")
        if (tmp is None):
            tmp = Sys.getEnv("TMP")
        if (tmp is None):
            tmp = Sys.getEnv("TEMP")
        if (tmp is None):
            tmp = "."
        fileName = (((((("null" if tmp is None else tmp) + "/mikktspace_data") + Std.string((Date.now().date.timestamp() * 1000))) + "_") + Std.string(int((python_lib_Random.random() * 16777216)))) + ".bin")
        outFile = (("null" if fileName is None else fileName) + ".out")
        outputData = haxe_io_BytesBuffer()
        outputData.addInt32(len(index.vidx))
        outputData.addInt32(8)
        outputData.addInt32(0)
        outputData.addInt32(3)
        outputData.addInt32(6)
        _g = 0
        _g1 = len(index.vidx)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            vidx = (index.vidx[i] if i >= 0 and i < len(index.vidx) else None)
            outputData.addInt32(haxe_io_FPHelper.floatToI32(python_internal_ArrayImpl._get(verts, (vidx * 3))))
            outputData.addInt32(haxe_io_FPHelper.floatToI32(python_internal_ArrayImpl._get(verts, ((vidx * 3) + 1))))
            outputData.addInt32(haxe_io_FPHelper.floatToI32(python_internal_ArrayImpl._get(verts, ((vidx * 3) + 2))))
            outputData.addInt32(haxe_io_FPHelper.floatToI32(python_internal_ArrayImpl._get(normals, (i * 3))))
            outputData.addInt32(haxe_io_FPHelper.floatToI32(python_internal_ArrayImpl._get(normals, ((i * 3) + 1))))
            outputData.addInt32(haxe_io_FPHelper.floatToI32(python_internal_ArrayImpl._get(normals, ((i * 3) + 2))))
            uidx = python_internal_ArrayImpl._get((uvs[0] if 0 < len(uvs) else None).index, i)
            outputData.addInt32(haxe_io_FPHelper.floatToI32(python_internal_ArrayImpl._get((uvs[0] if 0 < len(uvs) else None).values, (uidx * 2))))
            outputData.addInt32(haxe_io_FPHelper.floatToI32(python_internal_ArrayImpl._get((uvs[0] if 0 < len(uvs) else None).values, ((uidx * 2) + 1))))
        outputData.addInt32(len(index.vidx))
        _g2 = 0
        _g3 = len(index.vidx)
        while (_g2 < _g3):
            i1 = _g2
            _g2 = (_g2 + 1)
            outputData.addInt32(i1)
        sys_io_File.saveBytes(fileName,outputData.getBytes())
        ret = None
        try:
            ret = Sys.command("mikktspace",[fileName, outFile])
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            ret = -1
        if (ret != 0):
            sys_FileSystem.deleteFile(fileName)
            raise _HxException("Failed to called 'mikktspace' executable required to generate tangent data. Please ensure it's in your PATH")
        _hx_bytes = sys_io_File.getBytes(outFile)
        arr = []
        _g4 = 0
        _g5 = (len(index.vidx) * 4)
        while (_g4 < _g5):
            i2 = _g4
            _g4 = (_g4 + 1)
            python_internal_ArrayImpl._set(arr, i2, _hx_bytes.getFloat((i2 << 2)))
        sys_FileSystem.deleteFile(fileName)
        sys_FileSystem.deleteFile(outFile)
        return arr

    def buildGeom(self,geom,skin,dataOut,genTangents):
        g = hxd_fmt_hmd_Geometry()
        verts = geom.getVertices()
        normals = geom.getNormals()
        uvs = geom.getUVs()
        colors = geom.getColors()
        mats = geom.getMaterials()
        if (colors is not None):
            hasData = False
            _g = 0
            _g1 = colors.values
            while (_g < len(_g1)):
                v = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (v < 0.99):
                    hasData = True
                    break
            if (not hasData):
                colors = None
        tangents = (self.buildTangents(geom) if genTangents else None)
        g.vertexFormat = [hxd_fmt_hmd_GeometryFormat("position",3)]
        if (normals is not None):
            _this = g.vertexFormat
            x = hxd_fmt_hmd_GeometryFormat("normal",3)
            _this.append(x)
        if (tangents is not None):
            _this1 = g.vertexFormat
            x1 = hxd_fmt_hmd_GeometryFormat("tangent",3)
            _this1.append(x1)
        _g2 = 0
        _g11 = len(uvs)
        while (_g2 < _g11):
            i = _g2
            _g2 = (_g2 + 1)
            _this2 = g.vertexFormat
            x2 = hxd_fmt_hmd_GeometryFormat(("uv" + HxOverrides.stringOrNull((("" if ((i == 0)) else ("" + Std.string(((i + 1)))))))),2)
            _this2.append(x2)
        if (colors is not None):
            _this3 = g.vertexFormat
            x3 = hxd_fmt_hmd_GeometryFormat("color",3)
            _this3.append(x3)
        if (skin is not None):
            if ((self.bonesPerVertex <= 0) or ((self.bonesPerVertex > 4))):
                raise _HxException("assert")
            _this4 = g.vertexFormat
            x4 = hxd_fmt_hmd_GeometryFormat("weights",python_internal_ArrayImpl._get([1, 2, 3, 4], (self.bonesPerVertex - 1)))
            _this4.append(x4)
            _this5 = g.vertexFormat
            x5 = hxd_fmt_hmd_GeometryFormat("indexes",(python_internal_ArrayImpl._get([1, 2, 3, 4], (self.bonesPerVertex - 1)) if (self.floatSkinIndexes) else 9))
            _this5.append(x5)
        stride = 0
        _g21 = 0
        _g3 = g.vertexFormat
        while (_g21 < len(_g3)):
            f = (_g3[_g21] if _g21 >= 0 and _g21 < len(_g3) else None)
            _g21 = (_g21 + 1)
            stride = (stride + ((f.format & 7)))
        g.vertexStride = stride
        g.vertexCount = 0
        gm = geom.getGeomMatrix()
        this1 = list()
        vbuf = this1
        ibufs = []
        if ((skin is not None) and ((skin.splitJoints is not None))):
            _g4 = 0
            _g5 = skin.splitJoints
            while (_g4 < len(_g5)):
                _ = (_g5[_g4] if _g4 >= 0 and _g4 < len(_g5) else None)
                _g4 = (_g4 + 1)
                this2 = list()
                ibufs.append(this2)
        g.bounds = h3d_col_Bounds()
        this3 = [None]*stride
        tmpBuf = this3
        vertexRemap = list()
        index = geom.getPolygons()
        count = 0
        matPos = 0
        stri = 0
        lookup = haxe_ds_IntMap()
        tmp_x = 0.
        tmp_y = 0.
        tmp_z = 0.
        _g41 = 0
        _g51 = len(index)
        while (_g41 < _g51):
            pos = _g41
            _g41 = (_g41 + 1)
            i1 = (index[pos] if pos >= 0 and pos < len(index) else None)
            count = (count + 1)
            if (i1 >= 0):
                continue
            python_internal_ArrayImpl._set(index, pos, (-i1 - 1))
            start = ((pos - count) + 1)
            _g42 = 0
            _g52 = count
            while (_g42 < _g52):
                n = _g42
                _g42 = (_g42 + 1)
                k = (n + start)
                vidx = (index[k] if k >= 0 and k < len(index) else None)
                p = 0
                x6 = python_internal_ArrayImpl._get(verts, (vidx * 3))
                y = python_internal_ArrayImpl._get(verts, ((vidx * 3) + 1))
                z = python_internal_ArrayImpl._get(verts, ((vidx * 3) + 2))
                if (gm is not None):
                    tmp_x = x6
                    tmp_y = y
                    tmp_z = z
                    px = ((((tmp_x * gm._11) + ((tmp_y * gm._21))) + ((tmp_z * gm._31))) + gm._41)
                    py = ((((tmp_x * gm._12) + ((tmp_y * gm._22))) + ((tmp_z * gm._32))) + gm._42)
                    pz = ((((tmp_x * gm._13) + ((tmp_y * gm._23))) + ((tmp_z * gm._33))) + gm._43)
                    tmp_x = px
                    tmp_y = py
                    tmp_z = pz
                    x6 = tmp_x
                    y = tmp_y
                    z = tmp_z
                index1 = p
                p = (p + 1)
                tmpBuf[index1] = x6
                index2 = p
                p = (p + 1)
                tmpBuf[index2] = y
                index3 = p
                p = (p + 1)
                tmpBuf[index3] = z
                _this6 = g.bounds
                if (x6 < _this6.xMin):
                    _this6.xMin = x6
                if (x6 > _this6.xMax):
                    _this6.xMax = x6
                if (y < _this6.yMin):
                    _this6.yMin = y
                if (y > _this6.yMax):
                    _this6.yMax = y
                if (z < _this6.zMin):
                    _this6.zMin = z
                if (z > _this6.zMax):
                    _this6.zMax = z
                if (normals is not None):
                    nx = python_internal_ArrayImpl._get(normals, (k * 3))
                    ny = python_internal_ArrayImpl._get(normals, ((k * 3) + 1))
                    nz = python_internal_ArrayImpl._get(normals, ((k * 3) + 2))
                    index4 = p
                    p = (p + 1)
                    tmpBuf[index4] = nx
                    index5 = p
                    p = (p + 1)
                    tmpBuf[index5] = ny
                    index6 = p
                    p = (p + 1)
                    tmpBuf[index6] = nz
                if (tangents is not None):
                    index7 = p
                    p = (p + 1)
                    val = self.round(python_internal_ArrayImpl._get(tangents, (k * 4)))
                    tmpBuf[index7] = val
                    index8 = p
                    p = (p + 1)
                    val1 = self.round(python_internal_ArrayImpl._get(tangents, ((k * 4) + 1)))
                    tmpBuf[index8] = val1
                    index9 = p
                    p = (p + 1)
                    val2 = self.round(python_internal_ArrayImpl._get(tangents, ((k * 4) + 2)))
                    tmpBuf[index9] = val2
                    if (python_internal_ArrayImpl._get(tangents, ((k * 4) + 3)) < 0):
                        _g43 = (p - 3)
                        _g53 = tmpBuf
                        val3 = (_g53[_g43] * 0.5)
                        _g53[_g43] = val3
                        _g44 = (p - 2)
                        _g54 = tmpBuf
                        val4 = (_g54[_g44] * 0.5)
                        _g54[_g44] = val4
                        _g45 = (p - 1)
                        _g55 = tmpBuf
                        val5 = (_g55[_g45] * 0.5)
                        _g55[_g45] = val5
                _g46 = 0
                while (_g46 < len(uvs)):
                    tuvs = (uvs[_g46] if _g46 >= 0 and _g46 < len(uvs) else None)
                    _g46 = (_g46 + 1)
                    iuv = (tuvs.index[k] if k >= 0 and k < len(tuvs.index) else None)
                    index10 = p
                    p = (p + 1)
                    val6 = python_internal_ArrayImpl._get(tuvs.values, (iuv * 2))
                    tmpBuf[index10] = val6
                    index11 = p
                    p = (p + 1)
                    val7 = (1 - python_internal_ArrayImpl._get(tuvs.values, ((iuv * 2) + 1)))
                    tmpBuf[index11] = val7
                if (colors is not None):
                    icol = (colors.index[k] if k >= 0 and k < len(colors.index) else None)
                    index12 = p
                    p = (p + 1)
                    val8 = python_internal_ArrayImpl._get(colors.values, (icol * 4))
                    tmpBuf[index12] = val8
                    index13 = p
                    p = (p + 1)
                    val9 = python_internal_ArrayImpl._get(colors.values, ((icol * 4) + 1))
                    tmpBuf[index13] = val9
                    index14 = p
                    p = (p + 1)
                    val10 = python_internal_ArrayImpl._get(colors.values, ((icol * 4) + 2))
                    tmpBuf[index14] = val10
                if (skin is not None):
                    k1 = (vidx * skin.bonesPerVertex)
                    idx = 0
                    _g56 = 0
                    _g6 = skin.bonesPerVertex
                    while (_g56 < _g6):
                        i2 = _g56
                        _g56 = (_g56 + 1)
                        index15 = p
                        p = (p + 1)
                        val11 = skin.vertexWeights[(k1 + i2)]
                        tmpBuf[index15] = val11
                        idx = ((skin.vertexJoints[(k1 + i2)] << ((8 * i2))) | idx)
                    if self.floatSkinIndexes:
                        _g7 = 0
                        _g8 = skin.bonesPerVertex
                        while (_g7 < _g8):
                            i3 = _g7
                            _g7 = (_g7 + 1)
                            index16 = p
                            p = (p + 1)
                            val12 = (skin.vertexJoints[(k1 + i3)] * 3)
                            tmpBuf[index16] = val12
                    else:
                        index17 = p
                        p = (p + 1)
                        val13 = self.int32tof(idx)
                        tmpBuf[index17] = val13
                total = 0.
                _g57 = 0
                _g61 = stride
                while (_g57 < _g61):
                    i4 = _g57
                    _g57 = (_g57 + 1)
                    total = (total + tmpBuf[i4])
                itotal = None
                try:
                    itotal = int(HxOverrides.modf((total * 100), 268435455))
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e = _hx_e1
                    itotal = None
                itotal1 = itotal
                found = None
                vids = lookup.h.get(itotal1,None)
                if (vids is None):
                    vids = []
                    lookup.set(itotal1,vids)
                _g71 = 0
                while (_g71 < len(vids)):
                    vid = (vids[_g71] if _g71 >= 0 and _g71 < len(vids) else None)
                    _g71 = (_g71 + 1)
                    same = True
                    p1 = (vid * stride)
                    _g72 = 0
                    _g81 = stride
                    while (_g72 < _g81):
                        i5 = _g72
                        _g72 = (_g72 + 1)
                        key = p1
                        p1 = (p1 + 1)
                        if (python_internal_ArrayImpl._get(vbuf, key) != tmpBuf[i5]):
                            same = False
                            break
                    if same:
                        found = vid
                        break
                if (found is None):
                    found = g.vertexCount
                    g.vertexCount = (g.vertexCount + 1)
                    _g82 = 0
                    _g9 = stride
                    while (_g82 < _g9):
                        i6 = _g82
                        _g82 = (_g82 + 1)
                        v1 = tmpBuf[i6]
                        vbuf.append(v1)
                    vids.append(found)
                vertexRemap.append(found)
            if ((skin is not None) and ((skin.splitJoints is not None))):
                _g62 = 0
                _g73 = (count - 2)
                while (_g62 < _g73):
                    n1 = _g62
                    _g62 = (_g62 + 1)
                    index18 = stri
                    stri = (stri + 1)
                    idx1 = python_internal_ArrayImpl._get(ibufs, skin.triangleGroups[index18])
                    idx1.append(python_internal_ArrayImpl._get(vertexRemap, (start + n1)))
                    idx1.append(python_internal_ArrayImpl._get(vertexRemap, ((start + count) - 1)))
                    idx1.append(python_internal_ArrayImpl._get(vertexRemap, ((start + n1) + 1)))
            else:
                mid = None
                if (mats is None):
                    mid = 0
                else:
                    mid = (mats[matPos] if matPos >= 0 and matPos < len(mats) else None)
                    if (len(mats) > 1):
                        matPos = (matPos + 1)
                idx2 = (ibufs[mid] if mid >= 0 and mid < len(ibufs) else None)
                if (idx2 is None):
                    this4 = list()
                    idx2 = this4
                    python_internal_ArrayImpl._set(ibufs, mid, idx2)
                _g63 = 0
                _g74 = (count - 2)
                while (_g63 < _g74):
                    n2 = _g63
                    _g63 = (_g63 + 1)
                    idx2.append(python_internal_ArrayImpl._get(vertexRemap, (start + n2)))
                    idx2.append(python_internal_ArrayImpl._get(vertexRemap, ((start + count) - 1)))
                    idx2.append(python_internal_ArrayImpl._get(vertexRemap, ((start + n2) + 1)))
            python_internal_ArrayImpl._set(index, pos, i1)
            count = 0
        g.vertexPosition = len(dataOut.b.b)
        _g64 = 0
        _g75 = len(vbuf)
        while (_g64 < _g75):
            i7 = _g64
            _g64 = (_g64 + 1)
            f1 = python_internal_ArrayImpl._get(vbuf, i7)
            self.dataOut.writeFloat((0 if ((f1 == 0)) else f1))
        g.indexPosition = len(dataOut.b.b)
        g.indexCounts = []
        matMap = []
        matCount = 0
        _g83 = 0
        while (_g83 < len(ibufs)):
            idx3 = (ibufs[_g83] if _g83 >= 0 and _g83 < len(ibufs) else None)
            _g83 = (_g83 + 1)
            if (idx3 is None):
                matCount = (matCount + 1)
                continue
            x7 = matCount
            matCount = (matCount + 1)
            matMap.append(x7)
            _this7 = g.indexCounts
            x8 = len(idx3)
            _this7.append(x8)
            _g8_b = idx3
            _g8_len = len(_g8_b)
            _g8_pos = 0
            while (_g8_pos < _g8_len):
                i8 = _g8_pos
                _g8_pos = (_g8_pos + 1)
                i9 = (_g8_b[i8] if i8 >= 0 and i8 < len(_g8_b) else None)
                dataOut.writeUInt16(i9)
        if ((skin is not None) and ((skin.splitJoints is not None))):
            matMap = None
        return _hx_AnonObject({'g': g, 'materials': matMap})

    def addModels(self,includeGeometry):
        _gthis = self
        root = self.buildHierarchy().root
        objects = []
        joints = []
        skins = []
        foundSkin = None
        uid = 0
        indexRec = None
        def _hx_local_2(t):
            if t.isJoint:
                joints.append(t)
            else:
                isSkin = False
                if (foundSkin is None):
                    _g = 0
                    _g1 = t.childs
                    while (_g < len(_g1)):
                        c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                        _g = (_g + 1)
                        if c.isJoint:
                            isSkin = True
                            break
                else:
                    isSkin = (python_internal_ArrayImpl.indexOf(foundSkin,t,None) >= 0)
                if isSkin:
                    skins.append(t)
                else:
                    objects.append(t)
            _g2 = 0
            _g11 = t.childs
            while (_g2 < len(_g11)):
                c1 = (_g11[_g2] if _g2 >= 0 and _g2 < len(_g11) else None)
                _g2 = (_g2 + 1)
                indexRec(c1)
        indexRec = _hx_local_2
        indexRec(root)
        _g3 = 0
        while (_g3 < len(joints)):
            o = (joints[_g3] if _g3 >= 0 and _g3 < len(joints) else None)
            _g3 = (_g3 + 1)
            if o.isMesh:
                raise _HxException("assert")
            j = h3d_anim_Joint()
            self.getDefaultMatrixes(o.model)
            j.index = hxd_fmt_fbx_FbxTools.getId(o.model)
            j.name = hxd_fmt_fbx_FbxTools.getName(o.model)
            o.joint = j
            if (o.parent is not None):
                j.parent = o.parent.joint
                if o.parent.isJoint:
                    _this = o.parent.joint.subs
                    _this.append(j)
        foundSkin = []
        _g12 = 0
        while (_g12 < len(skins)):
            o1 = (skins[_g12] if _g12 >= 0 and _g12 < len(skins) else None)
            _g12 = (_g12 + 1)
            loopRec = [None]
            def _hx_local_7(loopRec1):
                def _hx_local_5(o2):
                    _g13 = 0
                    _g21 = o2.childs
                    while (_g13 < len(_g21)):
                        j1 = (_g21[_g13] if _g13 >= 0 and _g13 < len(_g21) else None)
                        _g13 = (_g13 + 1)
                        if (not j1.isJoint):
                            continue
                        s = _gthis.getParent(j1.model,"Deformer",True)
                        if (s is not None):
                            return s
                        s = (loopRec1[0] if 0 < len(loopRec1) else None)(j1)
                        if (s is not None):
                            return s
                    return None
                return _hx_local_5
            tmp = _hx_local_7(loopRec)
            python_internal_ArrayImpl._set(loopRec, 0, tmp)
            subDef = (loopRec[0] if 0 < len(loopRec) else None)(o1)
            if (subDef is None):
                continue
            _hx_def = self.getParent(subDef,"Deformer")
            geoms = self.getParents(_hx_def,"Geometry")
            if (len(geoms) == 0):
                continue
            if (len(geoms) > 1):
                raise _HxException("Single skin applied to multiple geometries not supported")
            models = self.getParents((geoms[0] if 0 < len(geoms) else None),"Model")
            if (len(models) == 0):
                continue
            if (len(models) > 1):
                raise _HxException("Single skin applied to multiple models not supported")
            m = (models[0] if 0 < len(models) else None)
            _g14 = 0
            while (_g14 < len(objects)):
                o21 = (objects[_g14] if _g14 >= 0 and _g14 < len(objects) else None)
                _g14 = (_g14 + 1)
                if (o21.model == m):
                    foundSkin.append(o1)
                    o21.skin = o1
                    if (o1.model is None):
                        o1.model = m
                    self.ignoreMissingObject(hxd_fmt_fbx_FbxTools.getName(m))
                    p = o1.parent
                    if (p != o21):
                        python_internal_ArrayImpl.remove(o21.parent.childs,o21)
                        o21.parent = p
                        if (p is not None):
                            _this1 = p.childs
                            _this1.append(o21)
                        else:
                            root = o21
                    if (p is not None):
                        python_internal_ArrayImpl.remove(p.childs,o1)
                    _g15 = 0
                    _g22 = list(o1.childs)
                    while (_g15 < len(_g22)):
                        c2 = (_g22[_g15] if _g15 >= 0 and _g15 < len(_g22) else None)
                        _g15 = (_g15 + 1)
                        if (not c2.isJoint):
                            python_internal_ArrayImpl.remove(o1.childs,c2)
                            _this2 = o21.childs
                            _this2.append(c2)
                            c2.parent = o21
                    break
        if (not includeGeometry):
            return
        objects = []
        if ((len(root.childs) <= 1) and ((root.model is None))):
            root = (root.childs[0] if 0 < len(root.childs) else None)
            root.parent = None
        if (root is not None):
            indexRec(root)
        hskins = haxe_ds_IntMap()
        tmpGeom = haxe_ds_IntMap()
        _g23 = 0
        _g31 = hxd_fmt_fbx_FbxTools.getAll(self.root,"Objects.Geometry")
        while (_g23 < len(_g31)):
            g = [(_g31[_g23] if _g23 >= 0 and _g23 < len(_g31) else None)]
            _g23 = (_g23 + 1)
            def _hx_local_12():
                def _hx_local_11(_):
                    pass
                return _hx_local_11
            def _hx_local_14(g1):
                def _hx_local_13():
                    x = (len(hxd_fmt_fbx_Geometry(_gthis,(g1[0] if 0 < len(g1) else None)).getVertices()) / 3)
                    try:
                        return int(x)
                    except Exception as _hx_e:
                        _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                        e = _hx_e1
                        return None
                return _hx_local_13
            tmpGeom.set(hxd_fmt_fbx_FbxTools.getId((g[0] if 0 < len(g) else None)),_hx_AnonObject({'setSkin': _hx_local_12(), 'vertexCount': _hx_local_14(g)}))
        hgeom = haxe_ds_IntMap()
        hmat = haxe_ds_IntMap()
        index = 0
        _g4 = 0
        while (_g4 < len(objects)):
            o3 = (objects[_g4] if _g4 >= 0 and _g4 < len(objects) else None)
            _g4 = (_g4 + 1)
            tmp1 = index
            index = (index + 1)
            o3.index = tmp1
            model = hxd_fmt_hmd_Model()
            ref = (o3 if ((o3.skin is None)) else o3.skin)
            model.name = (None if ((o3.model is None)) else hxd_fmt_fbx_FbxTools.getName(o3.model))
            model.parent = (-1 if (((o3.parent is None) or o3.parent.isJoint)) else o3.parent.index)
            model.follow = (hxd_fmt_fbx_FbxTools.getName(o3.parent.model) if (((o3.parent is not None) and o3.parent.isJoint)) else None)
            m1 = (hxd_fmt_fbx_DefaultMatrixes() if ((ref.model is None)) else self.getDefaultMatrixes(ref.model))
            p1 = hxd_fmt_hmd_Position()
            p1.x = (0 if ((m1.trans is None)) else -m1.trans.x)
            p1.y = (0 if ((m1.trans is None)) else m1.trans.y)
            p1.z = (0 if ((m1.trans is None)) else m1.trans.z)
            p1.sx = (1 if ((m1.scale is None)) else m1.scale.x)
            p1.sy = (1 if ((m1.scale is None)) else m1.scale.y)
            p1.sz = (1 if ((m1.scale is None)) else m1.scale.z)
            if ((o3.model is not None) and ((hxd_fmt_fbx_FbxTools.getType(o3.model) == "Camera"))):
                props = self.getChild(o3.model,"NodeAttribute")
                fov = 45.
                ratio = 1.77777777777777768
                _g41 = 0
                _g5 = hxd_fmt_fbx_FbxTools.getAll(props,"Properties70.P")
                while (_g41 < len(_g5)):
                    p2 = (_g5[_g41] if _g41 >= 0 and _g41 < len(_g5) else None)
                    _g41 = (_g41 + 1)
                    _g42 = hxd_fmt_fbx_FbxTools.toString((p2.props[0] if 0 < len(p2.props) else None))
                    _hx_local_17 = len(_g42)
                    if (_hx_local_17 == 15):
                        if (_g42 == "FilmAspectRatio"):
                            ratio = hxd_fmt_fbx_FbxTools.toFloat((p2.props[4] if 4 < len(p2.props) else None))
                        else:
                            pass
                    elif (_hx_local_17 == 11):
                        if (_g42 == "FieldOfView"):
                            fov = hxd_fmt_fbx_FbxTools.toFloat((p2.props[4] if 4 < len(p2.props) else None))
                        else:
                            pass
                    else:
                        pass
                fovY = (((2 * Math.atan((Math.tan((((fov * 0.5) * 3.14159265358979323) / 180)) / ratio))) * 180) / 3.14159265358979323)
                if (model.props is None):
                    model.props = []
                _this3 = model.props
                _this3.append(hxd_fmt_hmd_Property.CameraFOVY(fovY))
            q = m1.toQuaternion(True)
            q.normalize()
            if (q.w < 0):
                q.x = -q.x
                q.y = -q.y
                q.z = -q.z
                q.w = -q.w
            p1.qx = q.x
            p1.qy = q.y
            p1.qz = q.z
            model.position = p1
            model.geometry = -1
            _this4 = self.d.models
            _this4.append(model)
            if (not o3.isMesh):
                continue
            mids = []
            hasNormalMap = False
            _g43 = 0
            _g51 = self.getChilds(o3.model,"Material")
            while (_g43 < len(_g51)):
                m2 = (_g51[_g43] if _g43 >= 0 and _g43 < len(_g51) else None)
                _g43 = (_g43 + 1)
                key = hxd_fmt_fbx_FbxTools.getId(m2)
                mid = hmat.h.get(key,None)
                if (mid is not None):
                    mids.append(mid)
                    m3 = python_internal_ArrayImpl._get(self.d.materials, mid)
                    hasNormalMap = (m3.normalMap is not None)
                    continue
                mat = hxd_fmt_hmd_Material()
                mid = len(self.d.materials)
                mids.append(mid)
                hmat.set(hxd_fmt_fbx_FbxTools.getId(m2),mid)
                _this5 = self.d.materials
                _this5.append(mat)
                mat.name = hxd_fmt_fbx_FbxTools.getName(m2)
                mat.blendMode = None
                _g44 = 0
                _g52 = hxd_fmt_fbx_FbxTools.getAll(m2,"Properties70.P")
                while (_g44 < len(_g52)):
                    p3 = (_g52[_g44] if _g44 >= 0 and _g44 < len(_g52) else None)
                    _g44 = (_g44 + 1)
                    pval = (p3.props[4] if 4 < len(p3.props) else None)
                    if (hxd_fmt_fbx_FbxTools.toString((p3.props[0] if 0 < len(p3.props) else None)) == "Opacity"):
                        v = hxd_fmt_fbx_FbxTools.toFloat(pval)
                        if (((v < 1) and ((v > 0.98))) and ((mat.blendMode is None))):
                            mat.blendMode = h2d_BlendMode.Add
                texture = self.getSpecChild(m2,"DiffuseColor")
                if (texture is not None):
                    path = self.makeTexturePath(texture)
                    if (path is not None):
                        mat.diffuseTexture = path
                mat.normalMap = self.makeTexturePath(self.getSpecChild(m2,"NormalMap"))
                if (mat.normalMap is not None):
                    hasNormalMap = True
                spec = self.getSpecChild(m2,"SpecularFactor")
                if (spec is None):
                    spec = self.getSpecChild(m2,"SpecularColor")
                mat.specularTexture = self.makeTexturePath(spec)
                if ((mat.normalMap is not None) or ((mat.specularTexture is not None))):
                    if (mat.props is None):
                        mat.props = []
                    _this6 = mat.props
                    _this6.append(hxd_fmt_hmd_Property.HasExtraTextures)
                transp = self.getSpecChild(m2,"TransparentColor")
                if (transp is not None):
                    path1 = hxd_fmt_fbx_FbxTools.toString(python_internal_ArrayImpl._get(hxd_fmt_fbx_FbxTools.get(transp,"FileName").props, 0))
                    if (path1 != ""):
                        path1 = path1.lower()
                        _this7 = path1.split(".")
                        ext = (None if ((len(_this7) == 0)) else _this7.pop())
                        if ((texture is not None) and ((path1 == hxd_fmt_fbx_FbxTools.toString(python_internal_ArrayImpl._get(hxd_fmt_fbx_FbxTools.get(texture,"FileName").props, 0)).lower()))):
                            if (((mat.blendMode is None) and ((ext != "jpg"))) and ((ext != "jpeg"))):
                                mat.blendMode = h2d_BlendMode.Alpha
                        else:
                            raise _HxException("Alpha texture that is different from diffuse is not supported in HMD")
                if (mat.blendMode is None):
                    mat.blendMode = h2d_BlendMode._hx_None
            g2 = self.getChild(o3.model,"Geometry")
            skin = None
            if (o3.skin is not None):
                rootJoints = []
                _g6 = 0
                _g7 = o3.skin.childs
                while (_g6 < len(_g7)):
                    c3 = (_g7[_g6] if _g6 >= 0 and _g6 < len(_g7) else None)
                    _g6 = (_g6 + 1)
                    if c3.isJoint:
                        x1 = c3.joint
                        rootJoints.append(x1)
                skin = self.createSkin(hskins,tmpGeom,rootJoints,self.bonesPerVertex)
                if (len(skin.boundJoints) > self.maxBonesPerSkin):
                    g3 = hxd_fmt_fbx_Geometry(self,g2)
                    idx = g3.getIndexes()
                    tmp2 = self.maxBonesPerSkin
                    _g8 = []
                    _g9 = 0
                    _g10 = idx.idx
                    while (_g9 < len(_g10)):
                        i = (_g10[_g9] if _g9 >= 0 and _g9 < len(_g10) else None)
                        _g9 = (_g9 + 1)
                        x2 = (idx.vidx[i] if i >= 0 and i < len(idx.vidx) else None)
                        _g8.append(x2)
                    skin.split(tmp2,_g8,(g3.getMaterialByTriangle() if ((len(mids) > 1)) else None))
                model.skin = self.makeSkin(skin,o3.skin)
            key1 = hxd_fmt_fbx_FbxTools.getId(g2)
            gdata = hgeom.h.get(key1,None)
            if (gdata is None):
                geom = self.buildGeom(hxd_fmt_fbx_Geometry(self,g2),skin,self.dataOut,hasNormalMap)
                gdata = _hx_AnonObject({'gid': len(self.d.geometries), 'materials': geom.materials})
                _this8 = self.d.geometries
                x3 = geom.g
                _this8.append(x3)
                hgeom.set(hxd_fmt_fbx_FbxTools.getId(g2),gdata)
            model.geometry = gdata.gid
            if (len(mids) == 0):
                mat1 = hxd_fmt_hmd_Material()
                mat1.blendMode = h2d_BlendMode._hx_None
                mat1.name = "default"
                mid1 = len(self.d.materials)
                _this9 = self.d.materials
                _this9.append(mat1)
                mids = [mid1]
            if (gdata.materials is None):
                model.materials = mids
            else:
                _g61 = []
                _g71 = 0
                _g81 = gdata.materials
                while (_g71 < len(_g81)):
                    id = (_g81[_g71] if _g71 >= 0 and _g71 < len(_g81) else None)
                    _g71 = (_g71 + 1)
                    _g61.append((mids[id] if id >= 0 and id < len(mids) else None))
                model.materials = _g61

    def makeTexturePath(self,tex):
        if (tex is None):
            return None
        path = hxd_fmt_fbx_FbxTools.toString(python_internal_ArrayImpl._get(hxd_fmt_fbx_FbxTools.get(tex,"FileName").props, 0))
        if (path == ""):
            return None
        _this = path.split("\\")
        path = "/".join([python_Boot.toString1(x1,'') for x1 in _this])
        if (not self.absoluteTexturePath):
            tmp = None
            if (self.filePath is not None):
                s = path.lower()
                start = self.filePath
                tmp = s.startswith(start)
            else:
                tmp = False
            if tmp:
                path = HxString.substr(path,len(self.filePath),None)
            else:
                k = path.split("/res/")
                if (len(k) > 1):
                    if (len(k) != 0):
                        k.pop(0)
                    path = "/res/".join([python_Boot.toString1(x1,'') for x1 in k])
        return path

    def makeSkin(self,skin,obj):
        s = hxd_fmt_hmd_Skin()
        s.name = hxd_fmt_fbx_FbxTools.getName(obj.model)
        s.joints = []
        _g = 0
        _g1 = skin.allJoints
        while (_g < len(_g1)):
            jo = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            j = hxd_fmt_hmd_SkinJoint()
            j.name = jo.name
            j.parent = (-1 if ((jo.parent is None)) else jo.parent.index)
            j.bind = jo.bindIndex
            j.position = self.makePosition(jo.defMat)
            if (jo.transPos is not None):
                j.transpos = self.makePosition(jo.transPos)
                if (((j.transpos.sx != 1) or ((j.transpos.sy != 1))) or ((j.transpos.sz != 1))):
                    tmp = jo.transPos.clone()
                    tmp.transpose()
                    v = None
                    if (v is None):
                        v = h3d_Vector()
                    f = (((tmp._11 * tmp._11) + ((tmp._12 * tmp._12))) + ((tmp._13 * tmp._13)))
                    v.x = (Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))
                    f1 = (((tmp._21 * tmp._21) + ((tmp._22 * tmp._22))) + ((tmp._23 * tmp._23)))
                    v.y = (Math.NaN if ((f1 < 0)) else python_lib_Math.sqrt(f1))
                    f2 = (((tmp._31 * tmp._31) + ((tmp._32 * tmp._32))) + ((tmp._33 * tmp._33)))
                    v.z = (Math.NaN if ((f2 < 0)) else python_lib_Math.sqrt(f2))
                    if ((((tmp._11 * (((tmp._22 * tmp._33) - ((tmp._23 * tmp._32))))) + ((tmp._12 * (((tmp._23 * tmp._31) - ((tmp._21 * tmp._33))))))) + ((tmp._13 * (((tmp._21 * tmp._32) - ((tmp._22 * tmp._31))))))) < 0):
                        v.x = (v.x * -1)
                        v.y = (v.y * -1)
                        v.z = (v.z * -1)
                    s1 = v
                    tmp.prependScale((1 / s1.x),(1 / s1.y),(1 / s1.z))
                    tmp.transpose()
                    j.transpos = self.makePosition(tmp)
                    j.transpos.sx = self.round(s1.x)
                    j.transpos.sy = self.round(s1.y)
                    j.transpos.sz = self.round(s1.z)
            _this = s.joints
            _this.append(j)
        if (skin.splitJoints is not None):
            s.split = []
            _g2 = 0
            _g3 = skin.splitJoints
            while (_g2 < len(_g3)):
                sp = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                _g2 = (_g2 + 1)
                ss = hxd_fmt_hmd_SkinSplit()
                ss.materialIndex = sp.material
                _g21 = []
                _g31 = 0
                _g4 = sp.joints
                while (_g31 < len(_g4)):
                    j1 = (_g4[_g31] if _g31 >= 0 and _g31 < len(_g4) else None)
                    _g31 = (_g31 + 1)
                    x = j1.index
                    _g21.append(x)
                ss.joints = _g21
                _this1 = s.split
                _this1.append(ss)
        return s

    def makePosition(self,m):
        p = hxd_fmt_hmd_Position()
        v = None
        if (v is None):
            v = h3d_Vector()
        f = (((m._11 * m._11) + ((m._12 * m._12))) + ((m._13 * m._13)))
        v.x = (Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f))
        f1 = (((m._21 * m._21) + ((m._22 * m._22))) + ((m._23 * m._23)))
        v.y = (Math.NaN if ((f1 < 0)) else python_lib_Math.sqrt(f1))
        f2 = (((m._31 * m._31) + ((m._32 * m._32))) + ((m._33 * m._33)))
        v.z = (Math.NaN if ((f2 < 0)) else python_lib_Math.sqrt(f2))
        if ((((m._11 * (((m._22 * m._33) - ((m._23 * m._32))))) + ((m._12 * (((m._23 * m._31) - ((m._21 * m._33))))))) + ((m._13 * (((m._21 * m._32) - ((m._22 * m._31))))))) < 0):
            v.x = (v.x * -1)
            v.y = (v.y * -1)
            v.z = (v.z * -1)
        s = v
        q = h3d_Quat()
        q.initRotateMatrix(m)
        q.normalize()
        if (q.w < 0):
            q.x = -q.x
            q.y = -q.y
            q.z = -q.z
            q.w = -q.w
        p.sx = self.round(s.x)
        p.sy = self.round(s.y)
        p.sz = self.round(s.z)
        p.qx = self.round(q.x)
        p.qy = self.round(q.y)
        p.qz = self.round(q.z)
        p.x = self.round(m._41)
        p.y = self.round(m._42)
        p.z = self.round(m._43)
        return p

    def writeFloat(self,f):
        self.dataOut.writeFloat((0 if ((f == 0)) else f))

    def writeFrame(self,o,fid):
        if (self.d.version < 3):
            return
        if (o.frames is not None):
            f = o.frames[fid]
            if o.hasPosition:
                f1 = f.tx
                self.dataOut.writeFloat((0 if ((f1 == 0)) else f1))
                f2 = f.ty
                self.dataOut.writeFloat((0 if ((f2 == 0)) else f2))
                f3 = f.tz
                self.dataOut.writeFloat((0 if ((f3 == 0)) else f3))
            if o.hasRotation:
                f4 = ((((f.qx * f.qx) + ((f.qy * f.qy))) + ((f.qz * f.qz))) + ((f.qw * f.qw)))
                ql = (Math.NaN if ((f4 < 0)) else python_lib_Math.sqrt(f4))
                if ((ql * f.qw) < 0):
                    ql = -ql
                f5 = self.round((f.qx / ql))
                self.dataOut.writeFloat((0 if ((f5 == 0)) else f5))
                f6 = self.round((f.qy / ql))
                self.dataOut.writeFloat((0 if ((f6 == 0)) else f6))
                f7 = self.round((f.qz / ql))
                self.dataOut.writeFloat((0 if ((f7 == 0)) else f7))
            if o.hasScale:
                f8 = f.sx
                self.dataOut.writeFloat((0 if ((f8 == 0)) else f8))
                f9 = f.sy
                self.dataOut.writeFloat((0 if ((f9 == 0)) else f9))
                f10 = f.sz
                self.dataOut.writeFloat((0 if ((f10 == 0)) else f10))
        if (o.uvs is not None):
            f11 = o.uvs[(fid << 1)]
            self.dataOut.writeFloat((0 if ((f11 == 0)) else f11))
            f12 = o.uvs[(((fid << 1)) + 1)]
            self.dataOut.writeFloat((0 if ((f12 == 0)) else f12))
        if (o.alphas is not None):
            f13 = o.alphas[fid]
            self.dataOut.writeFloat((0 if ((f13 == 0)) else f13))
        if (o.propValues is not None):
            f14 = o.propValues[fid]
            self.dataOut.writeFloat((0 if ((f14 == 0)) else f14))

    def makeAnimation(self,anim):
        a = hxd_fmt_hmd_Animation()
        a.name = anim.name
        a.loop = True
        a.speed = 1
        a.sampling = anim.sampling
        a.frames = anim.frameCount
        a.objects = []
        a.dataPosition = len(self.dataOut.b.b)
        if (self.animationEvents is not None):
            _g = []
            _g1 = 0
            _g2 = self.animationEvents
            while (_g1 < len(_g2)):
                a1 = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
                _g1 = (_g1 + 1)
                e = hxd_fmt_hmd_AnimationEvent()
                e.frame = a1.frame
                e.data = a1.data
                _g.append(e)
            a.events = _g
        objects = anim.objects
        def _hx_local_1(o1,o2):
            return Reflect.compare(o1.objectName,o2.objectName)
        objects.sort(key= python_lib_Functools.cmp_to_key(_hx_local_1))
        animatedObjects = []
        _g3 = 0
        while (_g3 < len(objects)):
            obj = (objects[_g3] if _g3 >= 0 and _g3 < len(objects) else None)
            _g3 = (_g3 + 1)
            o = hxd_fmt_hmd_AnimationObject()
            count = 0
            o.name = obj.objectName
            this1 = 0
            o.flags = this1
            o.props = []
            if (obj.frames is not None):
                count = len(obj.frames)
                if (obj.hasPosition or ((self.d.version < 3))):
                    o.flags = (o.flags | ((1 << hxd_fmt_hmd_AnimationFlag.HasPosition.index)))
                if obj.hasRotation:
                    o.flags = (o.flags | ((1 << hxd_fmt_hmd_AnimationFlag.HasRotation.index)))
                if obj.hasScale:
                    o.flags = (o.flags | ((1 << hxd_fmt_hmd_AnimationFlag.HasScale.index)))
                if (self.d.version < 3):
                    _g4 = 0
                    _g11 = obj.frames
                    while (_g4 < len(_g11)):
                        f = _g11[_g4]
                        _g4 = (_g4 + 1)
                        if (((o.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasPosition.index)))) != 0):
                            f1 = f.tx
                            self.dataOut.writeFloat((0 if ((f1 == 0)) else f1))
                            f2 = f.ty
                            self.dataOut.writeFloat((0 if ((f2 == 0)) else f2))
                            f3 = f.tz
                            self.dataOut.writeFloat((0 if ((f3 == 0)) else f3))
                        if (((o.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasRotation.index)))) != 0):
                            f4 = ((((f.qx * f.qx) + ((f.qy * f.qy))) + ((f.qz * f.qz))) + ((f.qw * f.qw)))
                            ql = (Math.NaN if ((f4 < 0)) else python_lib_Math.sqrt(f4))
                            if (f.qw < 0):
                                ql = -ql
                            f5 = self.round((f.qx / ql))
                            self.dataOut.writeFloat((0 if ((f5 == 0)) else f5))
                            f6 = self.round((f.qy / ql))
                            self.dataOut.writeFloat((0 if ((f6 == 0)) else f6))
                            f7 = self.round((f.qz / ql))
                            self.dataOut.writeFloat((0 if ((f7 == 0)) else f7))
                        if (((o.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasScale.index)))) != 0):
                            f8 = f.sx
                            self.dataOut.writeFloat((0 if ((f8 == 0)) else f8))
                            f9 = f.sy
                            self.dataOut.writeFloat((0 if ((f9 == 0)) else f9))
                            f10 = f.sz
                            self.dataOut.writeFloat((0 if ((f10 == 0)) else f10))
            if (obj.uvs is not None):
                o.flags = (o.flags | ((1 << hxd_fmt_hmd_AnimationFlag.HasUV.index)))
                if (count == 0):
                    count = (len(obj.uvs) >> 1)
                elif (count != ((len(obj.uvs) >> 1))):
                    raise _HxException("assert")
                if (self.d.version < 3):
                    _g5 = 0
                    _g12 = obj.uvs
                    while (_g5 < len(_g12)):
                        f11 = _g12[_g5]
                        _g5 = (_g5 + 1)
                        self.dataOut.writeFloat((0 if ((f11 == 0)) else f11))
            if (obj.alphas is not None):
                o.flags = (o.flags | ((1 << hxd_fmt_hmd_AnimationFlag.HasAlpha.index)))
                if (count == 0):
                    count = len(obj.alphas)
                elif (count != len(obj.alphas)):
                    raise _HxException("assert")
                if (self.d.version < 3):
                    _g6 = 0
                    _g13 = obj.alphas
                    while (_g6 < len(_g13)):
                        f12 = _g13[_g6]
                        _g6 = (_g6 + 1)
                        self.dataOut.writeFloat((0 if ((f12 == 0)) else f12))
            if (obj.propValues is not None):
                o.flags = (o.flags | ((1 << hxd_fmt_hmd_AnimationFlag.HasProps.index)))
                _this = o.props
                x = obj.propName
                _this.append(x)
                if (count == 0):
                    count = len(obj.propValues)
                elif (count != len(obj.propValues)):
                    raise _HxException("assert")
                if (self.d.version < 3):
                    _g7 = 0
                    _g14 = obj.propValues
                    while (_g7 < len(_g14)):
                        f13 = _g14[_g7]
                        _g7 = (_g7 + 1)
                        self.dataOut.writeFloat((0 if ((f13 == 0)) else f13))
            if (count == 0):
                raise _HxException("assert")
            if (count == 1):
                o.flags = (o.flags | ((1 << hxd_fmt_hmd_AnimationFlag.SingleFrame.index)))
                self.writeFrame(obj,0)
            else:
                if (count != anim.frameCount):
                    raise _HxException("assert")
                animatedObjects.append(obj)
            _this1 = a.objects
            _this1.append(o)
        _g15 = 0
        _g21 = anim.frameCount
        while (_g15 < _g21):
            i = _g15
            _g15 = (_g15 + 1)
            _g16 = 0
            while (_g16 < len(animatedObjects)):
                obj1 = (animatedObjects[_g16] if _g16 >= 0 and _g16 < len(animatedObjects) else None)
                _g16 = (_g16 + 1)
                self.writeFrame(obj1,i)
        return a

    def toHMD(self,filePath,includeGeometry):
        if (not includeGeometry):
            self.optimizeSkin = False
        self.leftHandConvert()
        self.autoMerge()
        if (filePath is not None):
            _this = filePath.split("\\")
            filePath = "/".join([python_Boot.toString1(x1,'') for x1 in _this]).lower()
            if (not filePath.endswith("/")):
                filePath = (("null" if filePath is None else filePath) + "/")
        self.filePath = filePath
        self.d = hxd_fmt_hmd_Data()
        self.d.version = 3
        self.d.geometries = []
        self.d.materials = []
        self.d.models = []
        self.d.animations = []
        self.dataOut = haxe_io_BytesOutput()
        self.addModels(includeGeometry)
        names = self.getAnimationNames()
        _g = 0
        while (_g < len(names)):
            animName = (names[_g] if _g >= 0 and _g < len(names) else None)
            _g = (_g + 1)
            anim = self.loadAnimation(animName)
            if (anim is not None):
                _this1 = self.d.animations
                x = self.makeAnimation(anim)
                _this1.append(x)
        self.d.data = self.dataOut.getBytes()
        return self.d

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.d = None
        _hx_o.dataOut = None
        _hx_o.filePath = None
        _hx_o.tmp = None
        _hx_o.absoluteTexturePath = None
        _hx_o.optimizeSkin = None
        _hx_o.floatSkinIndexes = None
hxd_fmt_fbx_HMDOut._hx_class = hxd_fmt_fbx_HMDOut
_hx_classes["hxd.fmt.fbx.HMDOut"] = hxd_fmt_fbx_HMDOut

class hxd_fmt_fbx__Parser_Token(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.fmt.fbx._Parser.Token"
    _hx_constructs = ["TIdent", "TNode", "TInt", "TFloat", "TString", "TLength", "TBraceOpen", "TBraceClose", "TColon", "TEof"]

    @staticmethod
    def TIdent(s):
        return hxd_fmt_fbx__Parser_Token("TIdent", 0, (s,))

    @staticmethod
    def TNode(s):
        return hxd_fmt_fbx__Parser_Token("TNode", 1, (s,))

    @staticmethod
    def TInt(s):
        return hxd_fmt_fbx__Parser_Token("TInt", 2, (s,))

    @staticmethod
    def TFloat(s):
        return hxd_fmt_fbx__Parser_Token("TFloat", 3, (s,))

    @staticmethod
    def TString(s):
        return hxd_fmt_fbx__Parser_Token("TString", 4, (s,))

    @staticmethod
    def TLength(v):
        return hxd_fmt_fbx__Parser_Token("TLength", 5, (v,))
hxd_fmt_fbx__Parser_Token.TBraceOpen = hxd_fmt_fbx__Parser_Token("TBraceOpen", 6, ())
hxd_fmt_fbx__Parser_Token.TBraceClose = hxd_fmt_fbx__Parser_Token("TBraceClose", 7, ())
hxd_fmt_fbx__Parser_Token.TColon = hxd_fmt_fbx__Parser_Token("TColon", 8, ())
hxd_fmt_fbx__Parser_Token.TEof = hxd_fmt_fbx__Parser_Token("TEof", 9, ())
hxd_fmt_fbx__Parser_Token._hx_class = hxd_fmt_fbx__Parser_Token
_hx_classes["hxd.fmt.fbx._Parser.Token"] = hxd_fmt_fbx__Parser_Token


class hxd_fmt_fbx_Parser:
    _hx_class_name = "hxd.fmt.fbx.Parser"
    _hx_is_interface = "False"
    __slots__ = ("line", "buf", "bytes", "pos", "token", "binary", "fbxVersion")
    _hx_fields = ["line", "buf", "bytes", "pos", "token", "binary", "fbxVersion"]
    _hx_methods = ["parseText", "parseBytes", "parseNodes", "parseNode", "parseBinaryNodes", "parseBinaryNode", "readBinaryProperty", "except", "peek", "next", "error", "unexpected", "tokenStr", "nextChar", "getVersionedInt32", "getInt32", "getInt16", "getFloat", "getDouble", "i64ToFloat", "getByte", "getBuf", "isIdentChar", "nextToken"]
    _hx_statics = ["parse"]

    def __init__(self):
        self.fbxVersion = None
        self.binary = None
        self.token = None
        self.pos = None
        self.bytes = None
        self.buf = None
        self.line = None

    def parseText(self,_hx_str):
        self.buf = _hx_str
        self.pos = 0
        self.line = 1
        self.binary = False
        self.token = None
        return _hx_AnonObject({'name': "Root", 'props': [hxd_fmt_fbx_FbxProp.PInt(0), hxd_fmt_fbx_FbxProp.PString("Root"), hxd_fmt_fbx_FbxProp.PString("Root")], 'childs': self.parseNodes()})

    def parseBytes(self,_hx_bytes):
        self.bytes = _hx_bytes
        self.pos = 0
        self.line = 0
        self.binary = ((_hx_bytes.getString(0,20) == "Kaydara FBX Binary  ") and ((_hx_bytes.b[20] == 0)))
        self.token = None
        if self.binary:
            v = (((_hx_bytes.b[23] | ((_hx_bytes.b[24] << 8))) | ((_hx_bytes.b[25] << 16))) | ((_hx_bytes.b[26] << 24)))
            self.fbxVersion = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
            self.pos = 27
            _this = self.bytes
            pos = self.pos
            v1 = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
            i = ((v1 | -2147483648) if ((((v1 & -2147483648)) != 0)) else v1)
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.pos
            _hx_local_0.pos = (_hx_local_1 + (8 if ((self.fbxVersion >= 7500)) else 4))
            _hx_local_0.pos
            firstNode = self.parseBinaryNode(i)
            if (firstNode.name != ""):
                nodes = [firstNode]
                _this1 = self.bytes
                pos1 = self.pos
                v2 = (((_this1.b[pos1] | ((_this1.b[(pos1 + 1)] << 8))) | ((_this1.b[(pos1 + 2)] << 16))) | ((_this1.b[(pos1 + 3)] << 24)))
                i1 = ((v2 | -2147483648) if ((((v2 & -2147483648)) != 0)) else v2)
                _hx_local_2 = self
                _hx_local_3 = _hx_local_2.pos
                _hx_local_2.pos = (_hx_local_3 + (8 if ((self.fbxVersion >= 7500)) else 4))
                _hx_local_2.pos
                size = i1
                while (size != 0):
                    x = self.parseBinaryNode(size)
                    nodes.append(x)
                    _this2 = self.bytes
                    pos2 = self.pos
                    v3 = (((_this2.b[pos2] | ((_this2.b[(pos2 + 1)] << 8))) | ((_this2.b[(pos2 + 2)] << 16))) | ((_this2.b[(pos2 + 3)] << 24)))
                    i2 = ((v3 | -2147483648) if ((((v3 & -2147483648)) != 0)) else v3)
                    _hx_local_4 = self
                    _hx_local_5 = _hx_local_4.pos
                    _hx_local_4.pos = (_hx_local_5 + (8 if ((self.fbxVersion >= 7500)) else 4))
                    _hx_local_4.pos
                    size = i2
                return _hx_AnonObject({'name': "Root", 'props': [hxd_fmt_fbx_FbxProp.PInt(0), hxd_fmt_fbx_FbxProp.PString("Root"), hxd_fmt_fbx_FbxProp.PString("Root")], 'childs': nodes})
            else:
                return firstNode
        return _hx_AnonObject({'name': "Root", 'props': [hxd_fmt_fbx_FbxProp.PInt(0), hxd_fmt_fbx_FbxProp.PString("Root"), hxd_fmt_fbx_FbxProp.PString("Root")], 'childs': self.parseNodes()})

    def parseNodes(self):
        nodes = []
        while True:
            _g = self.peek()
            if (_g is not None):
                tmp = _g.index
                if ((tmp == 9) or ((tmp == 7))):
                    return nodes
                else:
                    pass
            x = self.parseNode()
            nodes.append(x)

    def parseNode(self):
        t = self.next()
        name = None
        if (t.index == 1):
            n = t.params[0]
            name = n
        else:
            name = self.unexpected(t)
        props = []
        childs = None
        while True:
            t = self.next()
            tmp = t.index
            if (tmp == 0):
                s = t.params[0]
                props.append(hxd_fmt_fbx_FbxProp.PIdent(s))
            elif (tmp == 1):
                _g2 = t.params[0]
                self.token = t
            elif (tmp == 2):
                s1 = t.params[0]
                x = hxd_fmt_fbx_FbxProp.PInt(Std.parseInt(s1))
                props.append(x)
            elif (tmp == 3):
                s2 = t.params[0]
                x1 = hxd_fmt_fbx_FbxProp.PFloat(Std.parseFloat(s2))
                props.append(x1)
            elif (tmp == 4):
                s3 = t.params[0]
                props.append(hxd_fmt_fbx_FbxProp.PString(s3))
            elif (tmp == 5):
                v = t.params[0]
                self._hx_except(hxd_fmt_fbx__Parser_Token.TBraceOpen)
                self._hx_except(hxd_fmt_fbx__Parser_Token.TNode("a"))
                ints = []
                floats = None
                i = 0
                while (i < v):
                    t = self.next()
                    tmp1 = t.index
                    if (tmp1 == 2):
                        s4 = t.params[0]
                        i = (i + 1)
                        if (floats is None):
                            x2 = Std.parseInt(s4)
                            ints.append(x2)
                        else:
                            x3 = Std.parseInt(s4)
                            floats.append(x3)
                    elif (tmp1 == 3):
                        s5 = t.params[0]
                        i = (i + 1)
                        if (floats is None):
                            floats = []
                            _g1 = 0
                            while (_g1 < len(ints)):
                                i1 = (ints[_g1] if _g1 >= 0 and _g1 < len(ints) else None)
                                _g1 = (_g1 + 1)
                                floats.append(i1)
                            ints = None
                        x4 = Std.parseFloat(s5)
                        floats.append(x4)
                    elif (tmp1 == 8):
                        continue
                    else:
                        self.unexpected(t)
                props.append((hxd_fmt_fbx_FbxProp.PInts(ints) if ((floats is None)) else hxd_fmt_fbx_FbxProp.PFloats(floats)))
                if (self.peek() == hxd_fmt_fbx__Parser_Token.TColon):
                    self._hx_except(hxd_fmt_fbx__Parser_Token.TColon)
                self._hx_except(hxd_fmt_fbx__Parser_Token.TBraceClose)
                break
            elif ((tmp == 7) or ((tmp == 6))):
                self.token = t
            else:
                self.unexpected(t)
            t = self.next()
            tmp2 = t.index
            if (tmp2 == 1):
                _g7 = t.params[0]
                self.token = t
                break
            elif (tmp2 == 6):
                childs = self.parseNodes()
                self._hx_except(hxd_fmt_fbx__Parser_Token.TBraceClose)
                break
            elif (tmp2 == 7):
                self.token = t
                break
            elif (tmp2 == 8):
                pass
            else:
                self.unexpected(t)
        if (childs is None):
            childs = []
        return _hx_AnonObject({'name': name, 'props': props, 'childs': childs})

    def parseBinaryNodes(self,output):
        _this = self.bytes
        pos = self.pos
        v = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
        i = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + (8 if ((self.fbxVersion >= 7500)) else 4))
        _hx_local_0.pos
        size = i
        while (size != 0):
            x = self.parseBinaryNode(size)
            output.append(x)
            _this1 = self.bytes
            pos1 = self.pos
            v1 = (((_this1.b[pos1] | ((_this1.b[(pos1 + 1)] << 8))) | ((_this1.b[(pos1 + 2)] << 16))) | ((_this1.b[(pos1 + 3)] << 24)))
            i1 = ((v1 | -2147483648) if ((((v1 & -2147483648)) != 0)) else v1)
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.pos
            _hx_local_2.pos = (_hx_local_3 + (8 if ((self.fbxVersion >= 7500)) else 4))
            _hx_local_2.pos
            size = i1

    def parseBinaryNode(self,nextRecord):
        _this = self.bytes
        pos = self.pos
        v = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
        i = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + (8 if ((self.fbxVersion >= 7500)) else 4))
        _hx_local_0.pos
        numProperties = i
        _this1 = self.bytes
        pos1 = self.pos
        v1 = (((_this1.b[pos1] | ((_this1.b[(pos1 + 1)] << 8))) | ((_this1.b[(pos1 + 2)] << 16))) | ((_this1.b[(pos1 + 3)] << 24)))
        i1 = ((v1 | -2147483648) if ((((v1 & -2147483648)) != 0)) else v1)
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.pos
        _hx_local_2.pos = (_hx_local_3 + (8 if ((self.fbxVersion >= 7500)) else 4))
        _hx_local_2.pos
        propertyListLength = i1
        pos2 = self.pos
        self.pos = (self.pos + 1)
        nameLen = self.bytes.b[pos2]
        name = ("" if ((nameLen == 0)) else self.bytes.getString(self.pos,nameLen))
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.pos
        _hx_local_4.pos = (_hx_local_5 + nameLen)
        _hx_local_4.pos
        props = list()
        childs = list()
        propStart = self.pos
        _g = 0
        _g1 = numProperties
        while (_g < _g1):
            i2 = _g
            _g = (_g + 1)
            x = self.readBinaryProperty()
            props.append(x)
        self.pos = (propStart + propertyListLength)
        if (self.pos < nextRecord):
            self.parseBinaryNodes(childs)
        self.pos = nextRecord
        return _hx_AnonObject({'name': name, 'props': props, 'childs': childs})

    def readBinaryProperty(self):
        _gthis = self
        arrayLen = 0
        arrayEncoding = None
        arrayCompressedLen = None
        arrayBytes = None
        arrayBytesPos = 0
        pos = self.pos
        self.pos = (self.pos + 1)
        _hx_type = self.bytes.b[pos]
        type1 = _hx_type
        if (type1 == 67):
            pos1 = self.pos
            self.pos = (self.pos + 1)
            return hxd_fmt_fbx_FbxProp.PInt(self.bytes.b[pos1])
        elif (type1 == 68):
            d = self.bytes.getDouble(self.pos)
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.pos
            _hx_local_0.pos = (_hx_local_1 + 8)
            _hx_local_0.pos
            return hxd_fmt_fbx_FbxProp.PFloat(d)
        elif (type1 == 70):
            f = self.bytes.getFloat(self.pos)
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.pos
            _hx_local_2.pos = (_hx_local_3 + 4)
            _hx_local_2.pos
            return hxd_fmt_fbx_FbxProp.PFloat(f)
        elif (type1 == 73):
            _this = self.bytes
            pos2 = self.pos
            v = (((_this.b[pos2] | ((_this.b[(pos2 + 1)] << 8))) | ((_this.b[(pos2 + 2)] << 16))) | ((_this.b[(pos2 + 3)] << 24)))
            i = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
            _hx_local_4 = self
            _hx_local_5 = _hx_local_4.pos
            _hx_local_4.pos = (_hx_local_5 + 4)
            _hx_local_4.pos
            return hxd_fmt_fbx_FbxProp.PInt(i)
        elif (type1 == 76):
            _this1 = self.bytes
            pos3 = self.pos
            pos4 = (pos3 + 4)
            v1 = (((_this1.b[pos4] | ((_this1.b[(pos4 + 1)] << 8))) | ((_this1.b[(pos4 + 2)] << 16))) | ((_this1.b[(pos4 + 3)] << 24)))
            v2 = (((_this1.b[pos3] | ((_this1.b[(pos3 + 1)] << 8))) | ((_this1.b[(pos3 + 2)] << 16))) | ((_this1.b[(pos3 + 3)] << 24)))
            i64_high = ((v1 | -2147483648) if ((((v1 & -2147483648)) != 0)) else v1)
            i64_low = ((v2 | -2147483648) if ((((v2 & -2147483648)) != 0)) else v2)
            _hx_local_6 = self
            _hx_local_7 = _hx_local_6.pos
            _hx_local_6.pos = (_hx_local_7 + 8)
            _hx_local_6.pos
            return hxd_fmt_fbx_FbxProp.PFloat(((i64_high * 4294967296) + (((((i64_low & 2147483647)) + 2147483648) if ((((i64_low & -2147483648)) != 0)) else i64_low))))
        elif (type1 == 82):
            _this2 = self.bytes
            pos5 = self.pos
            v3 = (((_this2.b[pos5] | ((_this2.b[(pos5 + 1)] << 8))) | ((_this2.b[(pos5 + 2)] << 16))) | ((_this2.b[(pos5 + 3)] << 24)))
            i1 = ((v3 | -2147483648) if ((((v3 & -2147483648)) != 0)) else v3)
            _hx_local_8 = self
            _hx_local_9 = _hx_local_8.pos
            _hx_local_8.pos = (_hx_local_9 + 4)
            _hx_local_8.pos
            _hx_len = i1
            data = haxe_io_Bytes.alloc(_hx_len)
            data.blit(0,self.bytes,self.pos,_hx_len)
            _hx_local_10 = self
            _hx_local_11 = _hx_local_10.pos
            _hx_local_10.pos = (_hx_local_11 + _hx_len)
            _hx_local_10.pos
            return hxd_fmt_fbx_FbxProp.PBinary(data)
        elif (type1 == 83):
            _this3 = self.bytes
            pos6 = self.pos
            v4 = (((_this3.b[pos6] | ((_this3.b[(pos6 + 1)] << 8))) | ((_this3.b[(pos6 + 2)] << 16))) | ((_this3.b[(pos6 + 3)] << 24)))
            i2 = ((v4 | -2147483648) if ((((v4 & -2147483648)) != 0)) else v4)
            _hx_local_12 = self
            _hx_local_13 = _hx_local_12.pos
            _hx_local_12.pos = (_hx_local_13 + 4)
            _hx_local_12.pos
            len1 = i2
            s = self.bytes.getString(self.pos,len1)
            _hx_local_14 = self
            _hx_local_15 = _hx_local_14.pos
            _hx_local_14.pos = (_hx_local_15 + len1)
            _hx_local_14.pos
            return hxd_fmt_fbx_FbxProp.PString(s)
        elif (type1 == 89):
            i3 = (self.bytes.b[self.pos] | ((self.bytes.b[(self.pos + 1)] << 8)))
            _hx_local_16 = self
            _hx_local_17 = _hx_local_16.pos
            _hx_local_16.pos = (_hx_local_17 + 2)
            _hx_local_16.pos
            return hxd_fmt_fbx_FbxProp.PInt(i3)
        elif (type1 == 98):
            _this4 = _gthis.bytes
            pos7 = _gthis.pos
            v5 = (((_this4.b[pos7] | ((_this4.b[(pos7 + 1)] << 8))) | ((_this4.b[(pos7 + 2)] << 16))) | ((_this4.b[(pos7 + 3)] << 24)))
            i4 = ((v5 | -2147483648) if ((((v5 & -2147483648)) != 0)) else v5)
            _gthis.pos = (_gthis.pos + 4)
            arrayLen = i4
            _this5 = _gthis.bytes
            pos8 = _gthis.pos
            v6 = (((_this5.b[pos8] | ((_this5.b[(pos8 + 1)] << 8))) | ((_this5.b[(pos8 + 2)] << 16))) | ((_this5.b[(pos8 + 3)] << 24)))
            i5 = ((v6 | -2147483648) if ((((v6 & -2147483648)) != 0)) else v6)
            _gthis.pos = (_gthis.pos + 4)
            arrayEncoding = i5
            _this6 = _gthis.bytes
            pos9 = _gthis.pos
            v7 = (((_this6.b[pos9] | ((_this6.b[(pos9 + 1)] << 8))) | ((_this6.b[(pos9 + 2)] << 16))) | ((_this6.b[(pos9 + 3)] << 24)))
            i6 = ((v7 | -2147483648) if ((((v7 & -2147483648)) != 0)) else v7)
            _gthis.pos = (_gthis.pos + 4)
            arrayCompressedLen = i6
            arrayEncoding1 = arrayEncoding
            if (arrayEncoding1 == 0):
                arrayBytes = _gthis.bytes
                arrayBytesPos = _gthis.pos
                _gthis.pos = (_gthis.pos + arrayLen)
            elif (arrayEncoding1 == 1):
                arrayBytesPos = 0
                arrayBytes = haxe_zip_Uncompress.run(_gthis.bytes.sub(_gthis.pos,arrayCompressedLen))
                _gthis.pos = (_gthis.pos + arrayCompressedLen)
            else:
                _gthis.error(("Unsupported array encoding: " + Std.string(arrayEncoding)))
            bools = list()
            while (arrayLen > 0):
                pos10 = arrayBytesPos
                arrayBytesPos = (arrayBytesPos + 1)
                x = arrayBytes.b[pos10]
                bools.append(x)
                arrayLen = (arrayLen - 1)
            return hxd_fmt_fbx_FbxProp.PInts(bools)
        elif (type1 == 100):
            _this7 = _gthis.bytes
            pos11 = _gthis.pos
            v8 = (((_this7.b[pos11] | ((_this7.b[(pos11 + 1)] << 8))) | ((_this7.b[(pos11 + 2)] << 16))) | ((_this7.b[(pos11 + 3)] << 24)))
            i7 = ((v8 | -2147483648) if ((((v8 & -2147483648)) != 0)) else v8)
            _gthis.pos = (_gthis.pos + 4)
            arrayLen = i7
            _this8 = _gthis.bytes
            pos12 = _gthis.pos
            v9 = (((_this8.b[pos12] | ((_this8.b[(pos12 + 1)] << 8))) | ((_this8.b[(pos12 + 2)] << 16))) | ((_this8.b[(pos12 + 3)] << 24)))
            i8 = ((v9 | -2147483648) if ((((v9 & -2147483648)) != 0)) else v9)
            _gthis.pos = (_gthis.pos + 4)
            arrayEncoding = i8
            _this9 = _gthis.bytes
            pos13 = _gthis.pos
            v10 = (((_this9.b[pos13] | ((_this9.b[(pos13 + 1)] << 8))) | ((_this9.b[(pos13 + 2)] << 16))) | ((_this9.b[(pos13 + 3)] << 24)))
            i9 = ((v10 | -2147483648) if ((((v10 & -2147483648)) != 0)) else v10)
            _gthis.pos = (_gthis.pos + 4)
            arrayCompressedLen = i9
            arrayEncoding2 = arrayEncoding
            if (arrayEncoding2 == 0):
                arrayBytes = _gthis.bytes
                arrayBytesPos = _gthis.pos
                _gthis.pos = (_gthis.pos + ((arrayLen * 8)))
            elif (arrayEncoding2 == 1):
                arrayBytesPos = 0
                arrayBytes = haxe_zip_Uncompress.run(_gthis.bytes.sub(_gthis.pos,arrayCompressedLen))
                _gthis.pos = (_gthis.pos + arrayCompressedLen)
            else:
                _gthis.error(("Unsupported array encoding: " + Std.string(arrayEncoding)))
            doubles = list()
            while (arrayLen > 0):
                x1 = arrayBytes.getDouble(arrayBytesPos)
                doubles.append(x1)
                arrayBytesPos = (arrayBytesPos + 8)
                arrayLen = (arrayLen - 1)
            return hxd_fmt_fbx_FbxProp.PFloats(doubles)
        elif (type1 == 102):
            _this10 = _gthis.bytes
            pos14 = _gthis.pos
            v11 = (((_this10.b[pos14] | ((_this10.b[(pos14 + 1)] << 8))) | ((_this10.b[(pos14 + 2)] << 16))) | ((_this10.b[(pos14 + 3)] << 24)))
            i10 = ((v11 | -2147483648) if ((((v11 & -2147483648)) != 0)) else v11)
            _gthis.pos = (_gthis.pos + 4)
            arrayLen = i10
            _this11 = _gthis.bytes
            pos15 = _gthis.pos
            v12 = (((_this11.b[pos15] | ((_this11.b[(pos15 + 1)] << 8))) | ((_this11.b[(pos15 + 2)] << 16))) | ((_this11.b[(pos15 + 3)] << 24)))
            i11 = ((v12 | -2147483648) if ((((v12 & -2147483648)) != 0)) else v12)
            _gthis.pos = (_gthis.pos + 4)
            arrayEncoding = i11
            _this12 = _gthis.bytes
            pos16 = _gthis.pos
            v13 = (((_this12.b[pos16] | ((_this12.b[(pos16 + 1)] << 8))) | ((_this12.b[(pos16 + 2)] << 16))) | ((_this12.b[(pos16 + 3)] << 24)))
            i12 = ((v13 | -2147483648) if ((((v13 & -2147483648)) != 0)) else v13)
            _gthis.pos = (_gthis.pos + 4)
            arrayCompressedLen = i12
            arrayEncoding3 = arrayEncoding
            if (arrayEncoding3 == 0):
                arrayBytes = _gthis.bytes
                arrayBytesPos = _gthis.pos
                _gthis.pos = (_gthis.pos + ((arrayLen * 4)))
            elif (arrayEncoding3 == 1):
                arrayBytesPos = 0
                arrayBytes = haxe_zip_Uncompress.run(_gthis.bytes.sub(_gthis.pos,arrayCompressedLen))
                _gthis.pos = (_gthis.pos + arrayCompressedLen)
            else:
                _gthis.error(("Unsupported array encoding: " + Std.string(arrayEncoding)))
            floats = list()
            while (arrayLen > 0):
                x2 = arrayBytes.getFloat(arrayBytesPos)
                floats.append(x2)
                arrayBytesPos = (arrayBytesPos + 4)
                arrayLen = (arrayLen - 1)
            return hxd_fmt_fbx_FbxProp.PFloats(floats)
        elif (type1 == 105):
            _this13 = _gthis.bytes
            pos17 = _gthis.pos
            v14 = (((_this13.b[pos17] | ((_this13.b[(pos17 + 1)] << 8))) | ((_this13.b[(pos17 + 2)] << 16))) | ((_this13.b[(pos17 + 3)] << 24)))
            i13 = ((v14 | -2147483648) if ((((v14 & -2147483648)) != 0)) else v14)
            _gthis.pos = (_gthis.pos + 4)
            arrayLen = i13
            _this14 = _gthis.bytes
            pos18 = _gthis.pos
            v15 = (((_this14.b[pos18] | ((_this14.b[(pos18 + 1)] << 8))) | ((_this14.b[(pos18 + 2)] << 16))) | ((_this14.b[(pos18 + 3)] << 24)))
            i14 = ((v15 | -2147483648) if ((((v15 & -2147483648)) != 0)) else v15)
            _gthis.pos = (_gthis.pos + 4)
            arrayEncoding = i14
            _this15 = _gthis.bytes
            pos19 = _gthis.pos
            v16 = (((_this15.b[pos19] | ((_this15.b[(pos19 + 1)] << 8))) | ((_this15.b[(pos19 + 2)] << 16))) | ((_this15.b[(pos19 + 3)] << 24)))
            i15 = ((v16 | -2147483648) if ((((v16 & -2147483648)) != 0)) else v16)
            _gthis.pos = (_gthis.pos + 4)
            arrayCompressedLen = i15
            arrayEncoding4 = arrayEncoding
            if (arrayEncoding4 == 0):
                arrayBytes = _gthis.bytes
                arrayBytesPos = _gthis.pos
                _gthis.pos = (_gthis.pos + ((arrayLen * 4)))
            elif (arrayEncoding4 == 1):
                arrayBytesPos = 0
                arrayBytes = haxe_zip_Uncompress.run(_gthis.bytes.sub(_gthis.pos,arrayCompressedLen))
                _gthis.pos = (_gthis.pos + arrayCompressedLen)
            else:
                _gthis.error(("Unsupported array encoding: " + Std.string(arrayEncoding)))
            ints = list()
            while (arrayLen > 0):
                v17 = (((arrayBytes.b[arrayBytesPos] | ((arrayBytes.b[(arrayBytesPos + 1)] << 8))) | ((arrayBytes.b[(arrayBytesPos + 2)] << 16))) | ((arrayBytes.b[(arrayBytesPos + 3)] << 24)))
                ints.append(((v17 | -2147483648) if ((((v17 & -2147483648)) != 0)) else v17))
                arrayBytesPos = (arrayBytesPos + 4)
                arrayLen = (arrayLen - 1)
            return hxd_fmt_fbx_FbxProp.PInts(ints)
        elif (type1 == 108):
            _this16 = _gthis.bytes
            pos20 = _gthis.pos
            v18 = (((_this16.b[pos20] | ((_this16.b[(pos20 + 1)] << 8))) | ((_this16.b[(pos20 + 2)] << 16))) | ((_this16.b[(pos20 + 3)] << 24)))
            i16 = ((v18 | -2147483648) if ((((v18 & -2147483648)) != 0)) else v18)
            _gthis.pos = (_gthis.pos + 4)
            arrayLen = i16
            _this17 = _gthis.bytes
            pos21 = _gthis.pos
            v19 = (((_this17.b[pos21] | ((_this17.b[(pos21 + 1)] << 8))) | ((_this17.b[(pos21 + 2)] << 16))) | ((_this17.b[(pos21 + 3)] << 24)))
            i17 = ((v19 | -2147483648) if ((((v19 & -2147483648)) != 0)) else v19)
            _gthis.pos = (_gthis.pos + 4)
            arrayEncoding = i17
            _this18 = _gthis.bytes
            pos22 = _gthis.pos
            v20 = (((_this18.b[pos22] | ((_this18.b[(pos22 + 1)] << 8))) | ((_this18.b[(pos22 + 2)] << 16))) | ((_this18.b[(pos22 + 3)] << 24)))
            i18 = ((v20 | -2147483648) if ((((v20 & -2147483648)) != 0)) else v20)
            _gthis.pos = (_gthis.pos + 4)
            arrayCompressedLen = i18
            arrayEncoding5 = arrayEncoding
            if (arrayEncoding5 == 0):
                arrayBytes = _gthis.bytes
                arrayBytesPos = _gthis.pos
                _gthis.pos = (_gthis.pos + ((arrayLen * 8)))
            elif (arrayEncoding5 == 1):
                arrayBytesPos = 0
                arrayBytes = haxe_zip_Uncompress.run(_gthis.bytes.sub(_gthis.pos,arrayCompressedLen))
                _gthis.pos = (_gthis.pos + arrayCompressedLen)
            else:
                _gthis.error(("Unsupported array encoding: " + Std.string(arrayEncoding)))
            i64s = list()
            while (arrayLen > 0):
                pos23 = (arrayBytesPos + 4)
                v21 = (((arrayBytes.b[pos23] | ((arrayBytes.b[(pos23 + 1)] << 8))) | ((arrayBytes.b[(pos23 + 2)] << 16))) | ((arrayBytes.b[(pos23 + 3)] << 24)))
                v22 = (((arrayBytes.b[arrayBytesPos] | ((arrayBytes.b[(arrayBytesPos + 1)] << 8))) | ((arrayBytes.b[(arrayBytesPos + 2)] << 16))) | ((arrayBytes.b[(arrayBytesPos + 3)] << 24)))
                i64_high1 = ((v21 | -2147483648) if ((((v21 & -2147483648)) != 0)) else v21)
                i64_low1 = ((v22 | -2147483648) if ((((v22 & -2147483648)) != 0)) else v22)
                i64s.append(((i64_high1 * 4294967296) + (((((i64_low1 & 2147483647)) + 2147483648) if ((((i64_low1 & -2147483648)) != 0)) else i64_low1))))
                arrayBytesPos = (arrayBytesPos + 8)
                arrayLen = (arrayLen - 1)
            return hxd_fmt_fbx_FbxProp.PFloats(i64s)
        else:
            return self.error(((("Unknown property type: " + Std.string(_hx_type)) + "/") + HxOverrides.stringOrNull("".join(map(chr,[_hx_type])))))

    def _hx_except(self,_hx_except):
        t = self.next()
        if (not Type.enumEq(t,_hx_except)):
            self.error((((("Unexpected '" + HxOverrides.stringOrNull(self.tokenStr(t))) + "' (") + HxOverrides.stringOrNull(self.tokenStr(_hx_except))) + " expected)"))

    def peek(self):
        if (self.token is None):
            self.token = self.nextToken()
        return self.token

    def next(self):
        if (self.token is None):
            return self.nextToken()
        tmp = self.token
        self.token = None
        return tmp

    def error(self,msg):
        raise _HxException((((("null" if msg is None else msg) + " (line ") + Std.string(self.line)) + ")"))

    def unexpected(self,t):
        return self.error(("Unexpected " + HxOverrides.stringOrNull(self.tokenStr(t))))

    def tokenStr(self,t):
        tmp = t.index
        if (tmp == 0):
            i = t.params[0]
            return i
        elif (tmp == 1):
            i1 = t.params[0]
            return (("null" if i1 is None else i1) + ":")
        elif (tmp == 2):
            i2 = t.params[0]
            return i2
        elif (tmp == 3):
            f = t.params[0]
            return f
        elif (tmp == 4):
            s = t.params[0]
            return (("\"" + ("null" if s is None else s)) + "\"")
        elif (tmp == 5):
            l = t.params[0]
            return ("*" + Std.string(l))
        elif (tmp == 6):
            return "{"
        elif (tmp == 7):
            return "}"
        elif (tmp == 8):
            return ","
        elif (tmp == 9):
            return "<eof>"
        else:
            pass

    def nextChar(self):
        s = self.buf
        index = self.pos
        self.pos = (self.pos + 1)
        if (index >= len(s)):
            return -1
        else:
            return ord(s[index])

    def getVersionedInt32(self):
        _this = self.bytes
        pos = self.pos
        v = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
        i = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + (8 if ((self.fbxVersion >= 7500)) else 4))
        _hx_local_0.pos
        return i

    def getInt32(self):
        _this = self.bytes
        pos = self.pos
        v = (((_this.b[pos] | ((_this.b[(pos + 1)] << 8))) | ((_this.b[(pos + 2)] << 16))) | ((_this.b[(pos + 3)] << 24)))
        i = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + 4)
        _hx_local_0.pos
        return i

    def getInt16(self):
        i = (self.bytes.b[self.pos] | ((self.bytes.b[(self.pos + 1)] << 8)))
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + 2)
        _hx_local_0.pos
        return i

    def getFloat(self):
        f = self.bytes.getFloat(self.pos)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + 4)
        _hx_local_0.pos
        return f

    def getDouble(self):
        d = self.bytes.getDouble(self.pos)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + 8)
        _hx_local_0.pos
        return d

    def i64ToFloat(self,i64):
        return ((i64.high * 4294967296) + (((((i64.low & 2147483647)) + 2147483648) if ((((i64.low & -2147483648)) != 0)) else i64.low)))

    def getByte(self):
        pos = self.pos
        self.pos = (self.pos + 1)
        return self.bytes.b[pos]

    def getBuf(self,pos,_hx_len):
        return HxString.substr(self.buf,pos,_hx_len)

    def isIdentChar(self,c):
        if (not ((((((c >= 97) and ((c <= 122))) or (((c >= 65) and ((c <= 90))))) or (((c >= 48) and ((c <= 57))))) or ((c == 95))))):
            return (c == 45)
        else:
            return True

    def nextToken(self):
        start = self.pos
        while True:
            s = self.buf
            index = self.pos
            self.pos = (self.pos + 1)
            c = (-1 if ((index >= len(s))) else ord(s[index]))
            c1 = c
            if (c1 == 10):
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.line
                _hx_local_0.line = (_hx_local_1 + 1)
                _hx_local_1
                start = (start + 1)
            elif (((c1 == 32) or ((c1 == 13))) or ((c1 == 9))):
                start = (start + 1)
            elif (c1 == 34):
                start = self.pos
                while True:
                    s1 = self.buf
                    index1 = self.pos
                    self.pos = (self.pos + 1)
                    c = (-1 if ((index1 >= len(s1))) else ord(s1[index1]))
                    if (c == 34):
                        break
                    if ((c == -1) or ((c == 10))):
                        self.error("Unclosed string")
                return hxd_fmt_fbx__Parser_Token.TString(HxString.substr(self.buf,start,((self.pos - start) - 1)))
            elif (c1 == 42):
                start = self.pos
                while True:
                    s2 = self.buf
                    index2 = self.pos
                    self.pos = (self.pos + 1)
                    c = (-1 if ((index2 >= len(s2))) else ord(s2[index2]))
                    if (not (((c >= 48) and ((c <= 57))))):
                        break
                _hx_local_4 = self
                _hx_local_5 = _hx_local_4.pos
                _hx_local_4.pos = (_hx_local_5 - 1)
                _hx_local_5
                return hxd_fmt_fbx__Parser_Token.TLength(Std.parseInt(HxString.substr(self.buf,start,(self.pos - start))))
            elif (c1 == 44):
                return hxd_fmt_fbx__Parser_Token.TColon
            elif (c1 == 59):
                while True:
                    s3 = self.buf
                    index3 = self.pos
                    self.pos = (self.pos + 1)
                    c2 = (-1 if ((index3 >= len(s3))) else ord(s3[index3]))
                    if ((c2 == -1) or ((c2 == 10))):
                        _hx_local_6 = self
                        _hx_local_7 = _hx_local_6.pos
                        _hx_local_6.pos = (_hx_local_7 - 1)
                        _hx_local_7
                        break
                start = self.pos
            elif (c1 == 123):
                return hxd_fmt_fbx__Parser_Token.TBraceOpen
            elif (c1 == 125):
                return hxd_fmt_fbx__Parser_Token.TBraceClose
            else:
                if ((((c >= 97) and ((c <= 122))) or (((c >= 65) and ((c <= 90))))) or ((c == 95))):
                    while True:
                        s4 = self.buf
                        index4 = self.pos
                        self.pos = (self.pos + 1)
                        c = (-1 if ((index4 >= len(s4))) else ord(s4[index4]))
                        if (not (((((((c >= 97) and ((c <= 122))) or (((c >= 65) and ((c <= 90))))) or (((c >= 48) and ((c <= 57))))) or ((c == 95))) or ((c == 45))))):
                            break
                    if (c == 58):
                        return hxd_fmt_fbx__Parser_Token.TNode(HxString.substr(self.buf,start,((self.pos - start) - 1)))
                    _hx_local_8 = self
                    _hx_local_9 = _hx_local_8.pos
                    _hx_local_8.pos = (_hx_local_9 - 1)
                    _hx_local_9
                    return hxd_fmt_fbx__Parser_Token.TIdent(HxString.substr(self.buf,start,(self.pos - start)))
                if (((c >= 48) and ((c <= 57))) or ((c == 45))):
                    while True:
                        s5 = self.buf
                        index5 = self.pos
                        self.pos = (self.pos + 1)
                        c = (-1 if ((index5 >= len(s5))) else ord(s5[index5]))
                        if (not (((c >= 48) and ((c <= 57))))):
                            break
                    if ((((c != 46) and ((c != 69))) and ((c != 101))) and (((self.pos - start) < 10))):
                        _hx_local_10 = self
                        _hx_local_11 = _hx_local_10.pos
                        _hx_local_10.pos = (_hx_local_11 - 1)
                        _hx_local_11
                        return hxd_fmt_fbx__Parser_Token.TInt(HxString.substr(self.buf,start,(self.pos - start)))
                    if (c == 46):
                        while True:
                            s6 = self.buf
                            index6 = self.pos
                            self.pos = (self.pos + 1)
                            c = (-1 if ((index6 >= len(s6))) else ord(s6[index6]))
                            if (not (((c >= 48) and ((c <= 57))))):
                                break
                    if ((c == 101) or ((c == 69))):
                        s7 = self.buf
                        index7 = self.pos
                        self.pos = (self.pos + 1)
                        c = (-1 if ((index7 >= len(s7))) else ord(s7[index7]))
                        if ((c != 45) and ((c != 43))):
                            _hx_local_12 = self
                            _hx_local_13 = _hx_local_12.pos
                            _hx_local_12.pos = (_hx_local_13 - 1)
                            _hx_local_13
                        while True:
                            s8 = self.buf
                            index8 = self.pos
                            self.pos = (self.pos + 1)
                            c = (-1 if ((index8 >= len(s8))) else ord(s8[index8]))
                            if (not (((c >= 48) and ((c <= 57))))):
                                break
                    _hx_local_14 = self
                    _hx_local_15 = _hx_local_14.pos
                    _hx_local_14.pos = (_hx_local_15 - 1)
                    _hx_local_15
                    return hxd_fmt_fbx__Parser_Token.TFloat(HxString.substr(self.buf,start,(self.pos - start)))
                if (c == -1):
                    _hx_local_16 = self
                    _hx_local_17 = _hx_local_16.pos
                    _hx_local_16.pos = (_hx_local_17 - 1)
                    _hx_local_17
                    return hxd_fmt_fbx__Parser_Token.TEof
                self.error((("Unexpected char '" + HxOverrides.stringOrNull("".join(map(chr,[c])))) + "'"))

    @staticmethod
    def parse(data):
        if ((data.length > 20) and ((data.getString(0,20) == "Kaydara FBX Binary  "))):
            return hxd_fmt_fbx_Parser().parseBytes(data)
        return hxd_fmt_fbx_Parser().parseText(data.toString())

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.line = None
        _hx_o.buf = None
        _hx_o.bytes = None
        _hx_o.pos = None
        _hx_o.token = None
        _hx_o.binary = None
        _hx_o.fbxVersion = None
hxd_fmt_fbx_Parser._hx_class = hxd_fmt_fbx_Parser
_hx_classes["hxd.fmt.fbx.Parser"] = hxd_fmt_fbx_Parser


class hxd_fmt_hmd__Data_GeometryDataFormat_Impl_:
    _hx_class_name = "hxd.fmt.hmd._Data.GeometryDataFormat_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["DFloat", "DVec2", "DVec3", "DVec4", "DBytes4", "_new", "getSize", "toInt", "toString", "fromInt"]

    @staticmethod
    def _new(v):
        this1 = v
        return this1

    @staticmethod
    def getSize(this1):
        return (this1 & 7)

    @staticmethod
    def toInt(this1):
        return this1

    @staticmethod
    def toString(this1):
        this2 = this1
        _g = this2
        if (_g == 1):
            return "DFloat"
        elif (_g == 2):
            return "DVec2"
        elif (_g == 3):
            return "DVec3"
        elif (_g == 4):
            return "DVec4"
        elif (_g == 9):
            return "DBytes4"
        else:
            pass

    @staticmethod
    def fromInt(v):
        this1 = v
        return this1
hxd_fmt_hmd__Data_GeometryDataFormat_Impl_._hx_class = hxd_fmt_hmd__Data_GeometryDataFormat_Impl_
_hx_classes["hxd.fmt.hmd._Data.GeometryDataFormat_Impl_"] = hxd_fmt_hmd__Data_GeometryDataFormat_Impl_

class hxd_fmt_hmd_Property(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.fmt.hmd.Property"
    _hx_constructs = ["CameraFOVY", "Unused_HasMaterialFlags", "HasExtraTextures"]

    @staticmethod
    def CameraFOVY(v):
        return hxd_fmt_hmd_Property("CameraFOVY", 0, (v,))
hxd_fmt_hmd_Property.Unused_HasMaterialFlags = hxd_fmt_hmd_Property("Unused_HasMaterialFlags", 1, ())
hxd_fmt_hmd_Property.HasExtraTextures = hxd_fmt_hmd_Property("HasExtraTextures", 2, ())
hxd_fmt_hmd_Property._hx_class = hxd_fmt_hmd_Property
_hx_classes["hxd.fmt.hmd.Property"] = hxd_fmt_hmd_Property


class hxd_fmt_hmd_Position:
    _hx_class_name = "hxd.fmt.hmd.Position"
    _hx_is_interface = "False"
    __slots__ = ("x", "y", "z", "qx", "qy", "qz", "sx", "sy", "sz")
    _hx_fields = ["x", "y", "z", "qx", "qy", "qz", "sx", "sy", "sz"]
    _hx_methods = ["loadQuaternion", "get_qw", "toMatrix"]
    _hx_statics = ["QTMP"]

    def __init__(self):
        self.sz = None
        self.sy = None
        self.sx = None
        self.qz = None
        self.qy = None
        self.qx = None
        self.z = None
        self.y = None
        self.x = None

    def loadQuaternion(self,q):
        q.x = self.qx
        q.y = self.qy
        q.z = self.qz
        q.w = self.get_qw()

    def get_qw(self):
        qw = (1 - ((((self.qx * self.qx) + ((self.qy * self.qy))) + ((self.qz * self.qz)))))
        if (qw < 0):
            f = -qw
            return -((Math.NaN if ((f < 0)) else python_lib_Math.sqrt(f)))
        elif (qw < 0):
            return Math.NaN
        else:
            return python_lib_Math.sqrt(qw)

    def toMatrix(self,postScale = None):
        if (postScale is None):
            postScale = False
        m = h3d_Matrix()
        q = hxd_fmt_hmd_Position.QTMP
        q.x = self.qx
        q.y = self.qy
        q.z = self.qz
        q.w = self.get_qw()
        q.toMatrix(m)
        if postScale:
            m.translate(self.x,self.y,self.z)
            m.scale(self.sx,self.sy,self.sz)
        else:
            m._11 = (m._11 * self.sx)
            m._12 = (m._12 * self.sx)
            m._13 = (m._13 * self.sx)
            m._21 = (m._21 * self.sy)
            m._22 = (m._22 * self.sy)
            m._23 = (m._23 * self.sy)
            m._31 = (m._31 * self.sz)
            m._32 = (m._32 * self.sz)
            m._33 = (m._33 * self.sz)
            m.translate(self.x,self.y,self.z)
        return m

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.x = None
        _hx_o.y = None
        _hx_o.z = None
        _hx_o.qx = None
        _hx_o.qy = None
        _hx_o.qz = None
        _hx_o.sx = None
        _hx_o.sy = None
        _hx_o.sz = None
hxd_fmt_hmd_Position._hx_class = hxd_fmt_hmd_Position
_hx_classes["hxd.fmt.hmd.Position"] = hxd_fmt_hmd_Position


class hxd_fmt_hmd_GeometryFormat:
    _hx_class_name = "hxd.fmt.hmd.GeometryFormat"
    _hx_is_interface = "False"
    __slots__ = ("name", "format")
    _hx_fields = ["name", "format"]

    def __init__(self,name,format):
        self.name = name
        self.format = format

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.name = None
        _hx_o.format = None
hxd_fmt_hmd_GeometryFormat._hx_class = hxd_fmt_hmd_GeometryFormat
_hx_classes["hxd.fmt.hmd.GeometryFormat"] = hxd_fmt_hmd_GeometryFormat


class hxd_fmt_hmd_Geometry:
    _hx_class_name = "hxd.fmt.hmd.Geometry"
    _hx_is_interface = "False"
    __slots__ = ("props", "vertexCount", "vertexStride", "vertexFormat", "vertexPosition", "indexCounts", "indexPosition", "bounds")
    _hx_fields = ["props", "vertexCount", "vertexStride", "vertexFormat", "vertexPosition", "indexCounts", "indexPosition", "bounds"]
    _hx_methods = ["get_indexCount"]

    def __init__(self):
        self.bounds = None
        self.indexPosition = None
        self.indexCounts = None
        self.vertexPosition = None
        self.vertexFormat = None
        self.vertexStride = None
        self.vertexCount = None
        self.props = None

    def get_indexCount(self):
        k = 0
        _g = 0
        _g1 = self.indexCounts
        while (_g < len(_g1)):
            i = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            k = (k + i)
        return k

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.props = None
        _hx_o.vertexCount = None
        _hx_o.vertexStride = None
        _hx_o.vertexFormat = None
        _hx_o.vertexPosition = None
        _hx_o.indexCounts = None
        _hx_o.indexPosition = None
        _hx_o.bounds = None
hxd_fmt_hmd_Geometry._hx_class = hxd_fmt_hmd_Geometry
_hx_classes["hxd.fmt.hmd.Geometry"] = hxd_fmt_hmd_Geometry


class hxd_fmt_hmd_Material:
    _hx_class_name = "hxd.fmt.hmd.Material"
    _hx_is_interface = "False"
    __slots__ = ("name", "props", "diffuseTexture", "specularTexture", "normalMap", "blendMode")
    _hx_fields = ["name", "props", "diffuseTexture", "specularTexture", "normalMap", "blendMode"]

    def __init__(self):
        self.blendMode = None
        self.normalMap = None
        self.specularTexture = None
        self.diffuseTexture = None
        self.props = None
        self.name = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.name = None
        _hx_o.props = None
        _hx_o.diffuseTexture = None
        _hx_o.specularTexture = None
        _hx_o.normalMap = None
        _hx_o.blendMode = None
hxd_fmt_hmd_Material._hx_class = hxd_fmt_hmd_Material
_hx_classes["hxd.fmt.hmd.Material"] = hxd_fmt_hmd_Material


class hxd_fmt_hmd_SkinJoint:
    _hx_class_name = "hxd.fmt.hmd.SkinJoint"
    _hx_is_interface = "False"
    __slots__ = ("name", "props", "parent", "position", "bind", "transpos")
    _hx_fields = ["name", "props", "parent", "position", "bind", "transpos"]

    def __init__(self):
        self.transpos = None
        self.bind = None
        self.position = None
        self.parent = None
        self.props = None
        self.name = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.name = None
        _hx_o.props = None
        _hx_o.parent = None
        _hx_o.position = None
        _hx_o.bind = None
        _hx_o.transpos = None
hxd_fmt_hmd_SkinJoint._hx_class = hxd_fmt_hmd_SkinJoint
_hx_classes["hxd.fmt.hmd.SkinJoint"] = hxd_fmt_hmd_SkinJoint


class hxd_fmt_hmd_SkinSplit:
    _hx_class_name = "hxd.fmt.hmd.SkinSplit"
    _hx_is_interface = "False"
    __slots__ = ("materialIndex", "joints")
    _hx_fields = ["materialIndex", "joints"]

    def __init__(self):
        self.joints = None
        self.materialIndex = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.materialIndex = None
        _hx_o.joints = None
hxd_fmt_hmd_SkinSplit._hx_class = hxd_fmt_hmd_SkinSplit
_hx_classes["hxd.fmt.hmd.SkinSplit"] = hxd_fmt_hmd_SkinSplit


class hxd_fmt_hmd_Skin:
    _hx_class_name = "hxd.fmt.hmd.Skin"
    _hx_is_interface = "False"
    __slots__ = ("name", "props", "joints", "split")
    _hx_fields = ["name", "props", "joints", "split"]

    def __init__(self):
        self.split = None
        self.joints = None
        self.props = None
        self.name = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.name = None
        _hx_o.props = None
        _hx_o.joints = None
        _hx_o.split = None
hxd_fmt_hmd_Skin._hx_class = hxd_fmt_hmd_Skin
_hx_classes["hxd.fmt.hmd.Skin"] = hxd_fmt_hmd_Skin


class hxd_fmt_hmd_Model:
    _hx_class_name = "hxd.fmt.hmd.Model"
    _hx_is_interface = "False"
    __slots__ = ("name", "props", "parent", "follow", "position", "geometry", "materials", "skin")
    _hx_fields = ["name", "props", "parent", "follow", "position", "geometry", "materials", "skin"]

    def __init__(self):
        self.skin = None
        self.materials = None
        self.geometry = None
        self.position = None
        self.follow = None
        self.parent = None
        self.props = None
        self.name = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.name = None
        _hx_o.props = None
        _hx_o.parent = None
        _hx_o.follow = None
        _hx_o.position = None
        _hx_o.geometry = None
        _hx_o.materials = None
        _hx_o.skin = None
hxd_fmt_hmd_Model._hx_class = hxd_fmt_hmd_Model
_hx_classes["hxd.fmt.hmd.Model"] = hxd_fmt_hmd_Model

class hxd_fmt_hmd_AnimationFlag(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.fmt.hmd.AnimationFlag"
    _hx_constructs = ["HasPosition", "HasRotation", "HasScale", "HasUV", "HasAlpha", "SingleFrame", "HasProps", "Reserved"]
hxd_fmt_hmd_AnimationFlag.HasPosition = hxd_fmt_hmd_AnimationFlag("HasPosition", 0, ())
hxd_fmt_hmd_AnimationFlag.HasRotation = hxd_fmt_hmd_AnimationFlag("HasRotation", 1, ())
hxd_fmt_hmd_AnimationFlag.HasScale = hxd_fmt_hmd_AnimationFlag("HasScale", 2, ())
hxd_fmt_hmd_AnimationFlag.HasUV = hxd_fmt_hmd_AnimationFlag("HasUV", 3, ())
hxd_fmt_hmd_AnimationFlag.HasAlpha = hxd_fmt_hmd_AnimationFlag("HasAlpha", 4, ())
hxd_fmt_hmd_AnimationFlag.SingleFrame = hxd_fmt_hmd_AnimationFlag("SingleFrame", 5, ())
hxd_fmt_hmd_AnimationFlag.HasProps = hxd_fmt_hmd_AnimationFlag("HasProps", 6, ())
hxd_fmt_hmd_AnimationFlag.Reserved = hxd_fmt_hmd_AnimationFlag("Reserved", 7, ())
hxd_fmt_hmd_AnimationFlag._hx_class = hxd_fmt_hmd_AnimationFlag
_hx_classes["hxd.fmt.hmd.AnimationFlag"] = hxd_fmt_hmd_AnimationFlag


class hxd_fmt_hmd_AnimationObject:
    _hx_class_name = "hxd.fmt.hmd.AnimationObject"
    _hx_is_interface = "False"
    __slots__ = ("name", "flags", "props")
    _hx_fields = ["name", "flags", "props"]
    _hx_methods = ["getStride"]

    def __init__(self):
        self.props = None
        self.flags = None
        self.name = None

    def getStride(self):
        stride = 0
        if (((self.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasPosition.index)))) != 0):
            stride = (stride + 3)
        if (((self.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasRotation.index)))) != 0):
            stride = (stride + 3)
        if (((self.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasScale.index)))) != 0):
            stride = (stride + 3)
        if (((self.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasUV.index)))) != 0):
            stride = (stride + 2)
        if (((self.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasAlpha.index)))) != 0):
            stride = (stride + 1)
        if (((self.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasProps.index)))) != 0):
            stride = (stride + len(self.props))
        return stride

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.name = None
        _hx_o.flags = None
        _hx_o.props = None
hxd_fmt_hmd_AnimationObject._hx_class = hxd_fmt_hmd_AnimationObject
_hx_classes["hxd.fmt.hmd.AnimationObject"] = hxd_fmt_hmd_AnimationObject


class hxd_fmt_hmd_AnimationEvent:
    _hx_class_name = "hxd.fmt.hmd.AnimationEvent"
    _hx_is_interface = "False"
    __slots__ = ("frame", "data")
    _hx_fields = ["frame", "data"]

    def __init__(self):
        self.data = None
        self.frame = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.frame = None
        _hx_o.data = None
hxd_fmt_hmd_AnimationEvent._hx_class = hxd_fmt_hmd_AnimationEvent
_hx_classes["hxd.fmt.hmd.AnimationEvent"] = hxd_fmt_hmd_AnimationEvent


class hxd_fmt_hmd_Animation:
    _hx_class_name = "hxd.fmt.hmd.Animation"
    _hx_is_interface = "False"
    __slots__ = ("name", "props", "frames", "sampling", "speed", "loop", "objects", "events", "dataPosition")
    _hx_fields = ["name", "props", "frames", "sampling", "speed", "loop", "objects", "events", "dataPosition"]

    def __init__(self):
        self.dataPosition = None
        self.events = None
        self.objects = None
        self.loop = None
        self.speed = None
        self.sampling = None
        self.frames = None
        self.props = None
        self.name = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.name = None
        _hx_o.props = None
        _hx_o.frames = None
        _hx_o.sampling = None
        _hx_o.speed = None
        _hx_o.loop = None
        _hx_o.objects = None
        _hx_o.events = None
        _hx_o.dataPosition = None
hxd_fmt_hmd_Animation._hx_class = hxd_fmt_hmd_Animation
_hx_classes["hxd.fmt.hmd.Animation"] = hxd_fmt_hmd_Animation


class hxd_fmt_hmd_Data:
    _hx_class_name = "hxd.fmt.hmd.Data"
    _hx_is_interface = "False"
    __slots__ = ("version", "props", "geometries", "materials", "models", "animations", "dataPosition", "data")
    _hx_fields = ["version", "props", "geometries", "materials", "models", "animations", "dataPosition", "data"]
    _hx_statics = ["CURRENT_VERSION"]

    def __init__(self):
        self.data = None
        self.dataPosition = None
        self.animations = None
        self.models = None
        self.materials = None
        self.geometries = None
        self.props = None
        self.version = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.version = None
        _hx_o.props = None
        _hx_o.geometries = None
        _hx_o.materials = None
        _hx_o.models = None
        _hx_o.animations = None
        _hx_o.dataPosition = None
        _hx_o.data = None
hxd_fmt_hmd_Data._hx_class = hxd_fmt_hmd_Data
_hx_classes["hxd.fmt.hmd.Data"] = hxd_fmt_hmd_Data


class hxd_fmt_hmd__Library_FormatMap:
    _hx_class_name = "hxd.fmt.hmd._Library.FormatMap"
    _hx_is_interface = "False"
    __slots__ = ("size", "offset", "_hx_def", "next")
    _hx_fields = ["size", "offset", "def", "next"]

    def __init__(self,size,offset,_hx_def,next):
        self.size = size
        self.offset = offset
        self._hx_def = _hx_def
        self.next = next

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.size = None
        _hx_o.offset = None
        _hx_o._hx_def = None
        _hx_o.next = None
hxd_fmt_hmd__Library_FormatMap._hx_class = hxd_fmt_hmd__Library_FormatMap
_hx_classes["hxd.fmt.hmd._Library.FormatMap"] = hxd_fmt_hmd__Library_FormatMap


class hxd_fmt_hmd_GeometryBuffer:
    _hx_class_name = "hxd.fmt.hmd.GeometryBuffer"
    _hx_is_interface = "False"
    __slots__ = ("vertexes", "indexes")
    _hx_fields = ["vertexes", "indexes"]

    def __init__(self):
        self.indexes = None
        self.vertexes = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.vertexes = None
        _hx_o.indexes = None
hxd_fmt_hmd_GeometryBuffer._hx_class = hxd_fmt_hmd_GeometryBuffer
_hx_classes["hxd.fmt.hmd.GeometryBuffer"] = hxd_fmt_hmd_GeometryBuffer


class hxd_fmt_hmd_Library:
    _hx_class_name = "hxd.fmt.hmd.Library"
    _hx_is_interface = "False"
    __slots__ = ("resource", "header", "cachedPrimitives", "cachedAnimations", "cachedSkin", "tmp")
    _hx_fields = ["resource", "header", "cachedPrimitives", "cachedAnimations", "cachedSkin", "tmp"]
    _hx_methods = ["getData", "getDefaultFormat", "load", "getBuffers", "makePrimitive", "makeMaterial", "makeSkin", "getModelProperty", "makeObject", "loadAnimation", "makeAnimation", "makeLinearAnimation", "loadSkin", "ftoint32"]

    def __init__(self,res,header):
        self.tmp = haxe_io_Bytes.alloc(4)
        self.resource = res
        self.header = header
        self.cachedPrimitives = []
        self.cachedAnimations = haxe_ds_StringMap()
        self.cachedSkin = haxe_ds_StringMap()

    def getData(self):
        entry = self.resource.entry
        b = haxe_io_Bytes.alloc((entry.get_size() - self.header.dataPosition))
        entry.open()
        entry.skip(self.header.dataPosition)
        entry.read(b,0,b.length)
        entry.close()
        return b

    def getDefaultFormat(self,stride):
        format = [hxd_fmt_hmd_GeometryFormat("position",3)]
        defs = [None]
        if (stride > 3):
            x = hxd_fmt_hmd_GeometryFormat("normal",3)
            format.append(x)
            defs.append(None)
        if (stride > 6):
            x1 = hxd_fmt_hmd_GeometryFormat("uv",2)
            format.append(x1)
            defs.append(None)
        if (stride > 8):
            x2 = hxd_fmt_hmd_GeometryFormat("color",3)
            format.append(x2)
            x3 = h3d_Vector(1,1,1)
            defs.append(x3)
        if (stride > 11):
            raise _HxException("Unsupported stride")
        return _hx_AnonObject({'format': format, 'defs': defs})

    def load(self,format,defaults = None,modelIndex = None):
        if (modelIndex is None):
            modelIndex = -1
        vtmp_x = 0.
        vtmp_y = 0.
        vtmp_z = 0.
        vtmp_w = 1.
        models = (self.header.models if ((modelIndex < 0)) else [python_internal_ArrayImpl._get(self.header.models, modelIndex)])
        this1 = list()
        outVertex = this1
        this2 = list()
        outIndex = this2
        stride = 0
        mid = -1
        _g = 0
        while (_g < len(format)):
            f = (format[_g] if _g >= 0 and _g < len(format) else None)
            _g = (_g + 1)
            stride = (stride + ((f.format & 7)))
        _g1 = 0
        while (_g1 < len(models)):
            m = (models[_g1] if _g1 >= 0 and _g1 < len(models) else None)
            _g1 = (_g1 + 1)
            geom = python_internal_ArrayImpl._get(self.header.geometries, m.geometry)
            if (geom is None):
                continue
            _g11 = 0
            _g2 = m.materials
            while (_g11 < len(_g2)):
                mat = (_g2[_g11] if _g11 >= 0 and _g11 < len(_g2) else None)
                _g11 = (_g11 + 1)
                if (mid < 0):
                    mid = mat
                if (mid != mat):
                    raise _HxException("Models have several materials")
            pos = m.position.toMatrix()
            data = self.getBuffers(geom,format,defaults)
            x = (len(outVertex) / stride)
            start = None
            try:
                start = int(x)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                start = None
            _g3 = 0
            x1 = (len(data.vertexes) / stride)
            _g4 = None
            try:
                _g4 = int(x1)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e1 = _hx_e1
                _g4 = None
            while (_g3 < _g4):
                i = _g3
                _g3 = (_g3 + 1)
                p = (i * stride)
                index = p
                p = (p + 1)
                vtmp_x = data.vertexes[index]
                index1 = p
                p = (p + 1)
                vtmp_y = data.vertexes[index1]
                index2 = p
                p = (p + 1)
                vtmp_z = data.vertexes[index2]
                px = ((((vtmp_x * pos._11) + ((vtmp_y * pos._21))) + ((vtmp_z * pos._31))) + ((vtmp_w * pos._41)))
                py = ((((vtmp_x * pos._12) + ((vtmp_y * pos._22))) + ((vtmp_z * pos._32))) + ((vtmp_w * pos._42)))
                pz = ((((vtmp_x * pos._13) + ((vtmp_y * pos._23))) + ((vtmp_z * pos._33))) + ((vtmp_w * pos._43)))
                vtmp_x = px
                vtmp_y = py
                vtmp_z = pz
                outVertex.append(vtmp_x)
                outVertex.append(vtmp_y)
                outVertex.append(vtmp_z)
                _g31 = 0
                _g41 = (stride - 3)
                while (_g31 < _g41):
                    j = _g31
                    _g31 = (_g31 + 1)
                    index3 = p
                    p = (p + 1)
                    v = data.vertexes[index3]
                    outVertex.append(v)
            _g5 = 0
            _g6 = data.indexes
            while (_g5 < len(_g6)):
                idx = _g6[_g5]
                _g5 = (_g5 + 1)
                outIndex.append((idx + start))
        return _hx_AnonObject({'vertex': outVertex, 'index': outIndex})

    def getBuffers(self,geom,format,defaults = None,material = None):
        if ((material == 0) and ((len(geom.indexCounts) == 1))):
            material = None
        _hx_map = None
        stride = 0
        _g = 0
        _g1 = len(format)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            i1 = ((len(format) - 1) - i)
            f = (format[i1] if i1 >= 0 and i1 < len(format) else None)
            size = (f.format & 7)
            offset = 0
            found = False
            _g2 = 0
            _g11 = geom.vertexFormat
            while (_g2 < len(_g11)):
                f2 = (_g11[_g2] if _g2 >= 0 and _g2 < len(_g11) else None)
                _g2 = (_g2 + 1)
                if (f2.name == f.name):
                    if (((f2.format & 7)) < size):
                        raise _HxException(((((("Requested " + HxOverrides.stringOrNull(f.name)) + " data has only ") + Std.string(((f2.format & 7)))) + " regs instead of ") + Std.string(size)))
                    found = True
                    break
                offset = (offset + ((f2.format & 7)))
            if found:
                _hx_map = hxd_fmt_hmd__Library_FormatMap(size,offset,None,_hx_map)
            else:
                _hx_def = (None if ((defaults is None)) else (defaults[i1] if i1 >= 0 and i1 < len(defaults) else None))
                if (_hx_def is None):
                    raise _HxException(("Missing required " + HxOverrides.stringOrNull(f.name)))
                _hx_map = hxd_fmt_hmd__Library_FormatMap(size,0,_hx_def,_hx_map)
            stride = (stride + size)
        vsize = ((geom.vertexCount * geom.vertexStride) * 4)
        vbuf = haxe_io_Bytes.alloc(vsize)
        entry = self.resource.entry
        entry.open()
        entry.skip((self.header.dataPosition + geom.vertexPosition))
        entry.read(vbuf,0,vsize)
        entry.skip((geom.indexPosition - ((geom.vertexPosition + vsize))))
        isize = None
        if (material is None):
            isize = (geom.get_indexCount() * 2)
        else:
            ipos = 0
            _g21 = 0
            _g3 = material
            while (_g21 < _g3):
                i2 = _g21
                _g21 = (_g21 + 1)
                ipos = (ipos + (geom.indexCounts[i2] if i2 >= 0 and i2 < len(geom.indexCounts) else None))
            entry.skip((ipos * 2))
            isize = ((geom.indexCounts[material] if material >= 0 and material < len(geom.indexCounts) else None) * 2)
        ibuf = haxe_io_Bytes.alloc(isize)
        entry.read(ibuf,0,isize)
        buf = hxd_fmt_hmd_GeometryBuffer()
        if (material is None):
            this1 = [None]*(stride * geom.vertexCount)
            buf.vertexes = this1
            this2 = [None]*geom.get_indexCount()
            buf.indexes = this2
            w = 0
            _g22 = 0
            _g31 = geom.vertexCount
            while (_g22 < _g31):
                vid = _g22
                _g22 = (_g22 + 1)
                m = _hx_map
                while (m is not None):
                    if (m._hx_def is None):
                        r = (vid * geom.vertexStride)
                        _g23 = 0
                        _g32 = m.size
                        while (_g23 < _g32):
                            i3 = _g23
                            _g23 = (_g23 + 1)
                            this3 = buf.vertexes
                            index = w
                            w = (w + 1)
                            val = vbuf.getFloat((((r + m.offset) + i3) << 2))
                            this3[index] = val
                    else:
                        _g24 = m.size
                        if (_g24 == 1):
                            index1 = w
                            w = (w + 1)
                            val1 = m._hx_def.x
                            buf.vertexes[index1] = val1
                        elif (_g24 == 2):
                            index2 = w
                            w = (w + 1)
                            val2 = m._hx_def.x
                            buf.vertexes[index2] = val2
                            index3 = w
                            w = (w + 1)
                            val3 = m._hx_def.y
                            buf.vertexes[index3] = val3
                        elif (_g24 == 3):
                            index4 = w
                            w = (w + 1)
                            val4 = m._hx_def.x
                            buf.vertexes[index4] = val4
                            index5 = w
                            w = (w + 1)
                            val5 = m._hx_def.y
                            buf.vertexes[index5] = val5
                            index6 = w
                            w = (w + 1)
                            val6 = m._hx_def.z
                            buf.vertexes[index6] = val6
                        else:
                            index7 = w
                            w = (w + 1)
                            val7 = m._hx_def.x
                            buf.vertexes[index7] = val7
                            index8 = w
                            w = (w + 1)
                            val8 = m._hx_def.y
                            buf.vertexes[index8] = val8
                            index9 = w
                            w = (w + 1)
                            val9 = m._hx_def.z
                            buf.vertexes[index9] = val9
                            index10 = w
                            w = (w + 1)
                            val10 = m._hx_def.w
                            buf.vertexes[index10] = val10
                    m = m.next
            r1 = 0
            _g4 = 0
            _g5 = len(buf.indexes)
            while (_g4 < _g5):
                i4 = _g4
                _g4 = (_g4 + 1)
                this4 = buf.indexes
                pos = r1
                r1 = (r1 + 1)
                pos1 = r1
                r1 = (r1 + 1)
                val11 = (ibuf.b[pos] | ((ibuf.b[pos1] << 8)))
                this4[i4] = val11
        else:
            icount = (geom.indexCounts[material] if material >= 0 and material < len(geom.indexCounts) else None)
            this5 = [None]*geom.vertexCount
            vmap = this5
            this6 = list()
            vertexes = this6
            this7 = [None]*icount
            buf.indexes = this7
            r2 = 0
            vcount = 0
            _g25 = 0
            _g33 = len(buf.indexes)
            while (_g25 < _g33):
                i5 = _g25
                _g25 = (_g25 + 1)
                pos2 = r2
                r2 = (r2 + 1)
                pos3 = r2
                r2 = (r2 + 1)
                vid1 = (ibuf.b[pos2] | ((ibuf.b[pos3] << 8)))
                rid = vmap[vid1]
                if (rid == 0):
                    vcount = (vcount + 1)
                    rid = vcount
                    vmap[vid1] = rid
                    m1 = _hx_map
                    while (m1 is not None):
                        if (m1._hx_def is None):
                            r3 = (vid1 * geom.vertexStride)
                            _g26 = 0
                            _g34 = m1.size
                            while (_g26 < _g34):
                                i6 = _g26
                                _g26 = (_g26 + 1)
                                v = vbuf.getFloat((((r3 + m1.offset) + i6) << 2))
                                vertexes.append(v)
                        else:
                            _g27 = m1.size
                            if (_g27 == 1):
                                v1 = m1._hx_def.x
                                vertexes.append(v1)
                            elif (_g27 == 2):
                                v2 = m1._hx_def.x
                                vertexes.append(v2)
                                v3 = m1._hx_def.y
                                vertexes.append(v3)
                            elif (_g27 == 3):
                                v4 = m1._hx_def.x
                                vertexes.append(v4)
                                v5 = m1._hx_def.y
                                vertexes.append(v5)
                                v6 = m1._hx_def.z
                                vertexes.append(v6)
                            else:
                                v7 = m1._hx_def.x
                                vertexes.append(v7)
                                v8 = m1._hx_def.y
                                vertexes.append(v8)
                                v9 = m1._hx_def.z
                                vertexes.append(v9)
                                v10 = m1._hx_def.w
                                vertexes.append(v10)
                        m1 = m1.next
                val12 = (rid - 1)
                buf.indexes[i5] = val12
            buf.vertexes = vertexes
        entry.close()
        return buf

    def makePrimitive(self,id):
        p = (self.cachedPrimitives[id] if id >= 0 and id < len(self.cachedPrimitives) else None)
        if (p is not None):
            return p
        p = h3d_prim_HMDModel(python_internal_ArrayImpl._get(self.header.geometries, id),self.header.dataPosition,self)
        p.incref()
        python_internal_ArrayImpl._set(self.cachedPrimitives, id, p)
        return p

    def makeMaterial(self,model,mid,loadTexture):
        m = python_internal_ArrayImpl._get(self.header.materials, mid)
        mat = h3d_mat_MaterialSetup.current.createMaterial()
        mat.name = m.name
        if (m.diffuseTexture is not None):
            mat.set_texture(loadTexture(m.diffuseTexture))
            if (mat.get_texture() is None):
                mat.set_texture(h3d_mat_Texture.fromColor(16711935))
        if (m.specularTexture is not None):
            mat.set_specularTexture(loadTexture(m.specularTexture))
        if (m.normalMap is not None):
            mat.set_normalMap(loadTexture(m.normalMap))
        mat.set_blendMode(m.blendMode)
        mat.model = self.resource
        props = h3d_mat_MaterialSetup.current.loadMaterialProps(mat)
        if (props is None):
            props = mat.getDefaultModelProps()
        mat.set_props(props)
        return mat

    def makeSkin(self,skin):
        s = self.cachedSkin.h.get(skin.name,None)
        if (s is not None):
            return s
        s = h3d_anim_Skin(skin.name,0,3)
        s.namedJoints = haxe_ds_StringMap()
        s.allJoints = []
        s.boundJoints = []
        s.rootJoints = []
        _g = 0
        _g1 = skin.joints
        while (_g < len(_g1)):
            joint = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            j = h3d_anim_Joint()
            j.name = joint.name
            j.index = len(s.allJoints)
            j.defMat = joint.position.toMatrix()
            if (joint.bind >= 0):
                j.bindIndex = joint.bind
                j.transPos = joint.transpos.toMatrix(True)
                python_internal_ArrayImpl._set(s.boundJoints, j.bindIndex, j)
            if (joint.parent >= 0):
                p = python_internal_ArrayImpl._get(s.allJoints, joint.parent)
                _this = p.subs
                _this.append(j)
                j.parent = p
            else:
                _this1 = s.rootJoints
                _this1.append(j)
            _this2 = s.allJoints
            _this2.append(j)
            s.namedJoints.h[j.name] = j
        if (skin.split is not None):
            s.splitJoints = []
            _g2 = 0
            _g3 = skin.split
            while (_g2 < len(_g3)):
                ss = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                _g2 = (_g2 + 1)
                _this3 = s.splitJoints
                ss1 = ss.materialIndex
                _g21 = []
                _g31 = 0
                _g4 = ss.joints
                while (_g31 < len(_g4)):
                    j1 = (_g4[_g31] if _g31 >= 0 and _g31 < len(_g4) else None)
                    _g31 = (_g31 + 1)
                    x = (s.allJoints[j1] if j1 >= 0 and j1 < len(s.allJoints) else None)
                    _g21.append(x)
                _this3.append(_hx_AnonObject({'material': ss1, 'joints': _g21}))
        self.cachedSkin.h[skin.name] = s
        return s

    def getModelProperty(self,objName,p,_hx_def = None):
        _g = 0
        _g1 = self.header.models
        while (_g < len(_g1)):
            m = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (m.name == objName):
                if (m.props is not None):
                    _g2 = 0
                    _g11 = m.props
                    while (_g2 < len(_g11)):
                        pr = (_g11[_g2] if _g2 >= 0 and _g2 < len(_g11) else None)
                        _g2 = (_g2 + 1)
                        if (pr.index == p.index):
                            return python_internal_ArrayImpl._get(list(pr.params), 0)
                return _hx_def
        if (_hx_def is None):
            raise _HxException((("Model " + ("null" if objName is None else objName)) + " not found"))
        return _hx_def

    def makeObject(self,loadTexture = None):
        if (loadTexture is None):
            def _hx_local_0(_):
                return h3d_mat_Texture.fromColor(16711935)
            loadTexture = _hx_local_0
        if (len(self.header.models) == 0):
            raise _HxException("This file does not contain any model")
        objs = []
        _g = 0
        _g1 = self.header.models
        while (_g < len(_g1)):
            m = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            obj = None
            if (m.geometry < 0):
                obj = h3d_scene_Object()
            else:
                prim = self.makePrimitive(m.geometry)
                if (m.skin is not None):
                    skinData = self.makeSkin(m.skin)
                    skinData.primitive = prim
                    _g2 = []
                    _g11 = 0
                    _g21 = m.materials
                    while (_g11 < len(_g21)):
                        mat = (_g21[_g11] if _g11 >= 0 and _g11 < len(_g21) else None)
                        _g11 = (_g11 + 1)
                        x = self.makeMaterial(m,mat,loadTexture)
                        _g2.append(x)
                    obj = h3d_scene_Skin(skinData,_g2)
                elif (len(m.materials) == 1):
                    obj = h3d_scene_Mesh(prim,self.makeMaterial(m,(m.materials[0] if 0 < len(m.materials) else None),loadTexture))
                else:
                    _g3 = []
                    _g12 = 0
                    _g22 = m.materials
                    while (_g12 < len(_g22)):
                        mat1 = (_g22[_g12] if _g12 >= 0 and _g12 < len(_g22) else None)
                        _g12 = (_g12 + 1)
                        x1 = self.makeMaterial(m,mat1,loadTexture)
                        _g3.append(x1)
                    obj = h3d_scene_MultiMaterial(prim,_g3)
            obj.name = m.name
            v = m.position.toMatrix()
            obj.defaultTransform = v
            f = 1
            b = True
            if b:
                obj.flags = (obj.flags | f)
            else:
                obj.flags = (obj.flags & ~f)
            objs.append(obj)
            p = python_internal_ArrayImpl._get(objs, m.parent)
            if (p is not None):
                p.addChild(obj)
        return (objs[0] if 0 < len(objs) else None)

    def loadAnimation(self,name = None):
        a = self.cachedAnimations.h.get(("" if ((name is None)) else name),None)
        if (a is not None):
            return a
        a1 = None
        if (name is None):
            if (len(self.header.animations) == 0):
                return None
            a1 = python_internal_ArrayImpl._get(self.header.animations, 0)
        else:
            _g = 0
            _g1 = self.header.animations
            while (_g < len(_g1)):
                a2 = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (a2.name == name):
                    a1 = a2
                    break
            if (a1 is None):
                raise _HxException((("Animation " + ("null" if name is None else name)) + " not found !"))
        l = (self.makeLinearAnimation(a1) if ((self.header.version <= 2)) else self.makeAnimation(a1))
        l.speed = a1.speed
        l.loop = a1.loop
        if (a1.events is not None):
            l.setEvents(a1.events)
        l.resourcePath = self.resource.entry.get_path()
        self.cachedAnimations.h[a1.name] = l
        if (name is None):
            self.cachedAnimations.h[""] = l
        return l

    def makeAnimation(self,a):
        b = h3d_anim_BufferAnimation(a.name,a.frames,a.sampling)
        stride = 0
        singleFrames = []
        otherFrames = []
        _g = 0
        _g1 = a.objects
        while (_g < len(_g1)):
            o = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            c = b.addObject(o.name,0)
            sm = 1
            if (((o.flags & ((1 << hxd_fmt_hmd_AnimationFlag.SingleFrame.index)))) != 0):
                c.layout = (c.layout | ((1 << h3d_anim_DataLayout.SingleFrame.index)))
                singleFrames.append(c)
                sm = 0
            else:
                otherFrames.append(c)
            if (((o.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasPosition.index)))) != 0):
                c.layout = (c.layout | ((1 << h3d_anim_DataLayout.Position.index)))
                stride = (stride + ((3 * sm)))
            if (((o.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasRotation.index)))) != 0):
                c.layout = (c.layout | ((1 << h3d_anim_DataLayout.Rotation.index)))
                stride = (stride + ((3 * sm)))
            if (((o.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasScale.index)))) != 0):
                c.layout = (c.layout | ((1 << h3d_anim_DataLayout.Scale.index)))
                stride = (stride + ((3 * sm)))
            if (((o.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasUV.index)))) != 0):
                c.layout = (c.layout | ((1 << h3d_anim_DataLayout.UV.index)))
                stride = (stride + ((2 * sm)))
            if (((o.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasAlpha.index)))) != 0):
                c.layout = (c.layout | ((1 << h3d_anim_DataLayout.Alpha.index)))
                stride = (stride + sm)
            if (((o.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasProps.index)))) != 0):
                _g2 = 0
                _g11 = len(o.props)
                while (_g2 < _g11):
                    i = _g2
                    _g2 = (_g2 + 1)
                    c1 = c
                    if (i > 0):
                        c1 = b.addObject(o.name,0)
                        if (sm == 0):
                            singleFrames.append(c1)
                        else:
                            otherFrames.append(c1)
                    c1.layout = (c1.layout | ((1 << h3d_anim_DataLayout.Property.index)))
                    c1.propName = (o.props[i] if i >= 0 and i < len(o.props) else None)
                    stride = (stride + sm)
        pos = 0
        _g21 = 0
        while (_g21 < len(singleFrames)):
            b1 = (singleFrames[_g21] if _g21 >= 0 and _g21 < len(singleFrames) else None)
            _g21 = (_g21 + 1)
            b1.dataOffset = pos
            pos = (pos + b1.getStride())
        singleStride = pos
        _g3 = 0
        while (_g3 < len(otherFrames)):
            b2 = (otherFrames[_g3] if _g3 >= 0 and _g3 < len(otherFrames) else None)
            _g3 = (_g3 + 1)
            b2.dataOffset = pos
            pos = (pos + b2.getStride())
        entry = self.resource.entry
        entry.open()
        entry.skip((self.header.dataPosition + a.dataPosition))
        count = ((stride * a.frames) + singleStride)
        data = haxe_io_Bytes.alloc((count * 4))
        entry.read(data,0,data.length)
        entry.close()
        this1 = [None]*count
        v = this1
        _g4 = 0
        _g5 = count
        while (_g4 < _g5):
            i1 = _g4
            _g4 = (_g4 + 1)
            val = data.getFloat((i1 << 2))
            v[i1] = val
        b.setData(v,stride)
        return b

    def makeLinearAnimation(self,a):
        l = h3d_anim_LinearAnimation(a.name,a.frames,a.sampling)
        entry = self.resource.entry
        entry.open()
        entry.skip((self.header.dataPosition + a.dataPosition))
        _g = 0
        _g1 = a.objects
        while (_g < len(_g1)):
            o = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            pos = (((o.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasPosition.index)))) != 0)
            rot = (((o.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasRotation.index)))) != 0)
            scale = (((o.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasScale.index)))) != 0)
            if ((pos or rot) or scale):
                frameCount = a.frames
                if (((o.flags & ((1 << hxd_fmt_hmd_AnimationFlag.SingleFrame.index)))) != 0):
                    frameCount = 1
                this1 = [None]*frameCount
                fl = this1
                size = (((((((3 if pos else 0)) + ((3 if rot else 0))) + ((3 if scale else 0)))) * 4) * frameCount)
                data = haxe_io_Bytes.alloc(size)
                entry.read(data,0,size)
                p = 0
                _g2 = 0
                _g11 = frameCount
                while (_g2 < _g11):
                    i = _g2
                    _g2 = (_g2 + 1)
                    f = h3d_anim_LinearFrame()
                    if pos:
                        f.tx = data.getFloat(p)
                        p = (p + 4)
                        f.ty = data.getFloat(p)
                        p = (p + 4)
                        f.tz = data.getFloat(p)
                        p = (p + 4)
                    else:
                        f.tx = 0
                        f.ty = 0
                        f.tz = 0
                    if rot:
                        f.qx = data.getFloat(p)
                        p = (p + 4)
                        f.qy = data.getFloat(p)
                        p = (p + 4)
                        f.qz = data.getFloat(p)
                        p = (p + 4)
                        qw = (1 - ((((f.qx * f.qx) + ((f.qy * f.qy))) + ((f.qz * f.qz)))))
                        tmp = None
                        if (qw < 0):
                            f1 = -qw
                            tmp = -((Math.NaN if ((f1 < 0)) else python_lib_Math.sqrt(f1)))
                        else:
                            tmp = (Math.NaN if ((qw < 0)) else python_lib_Math.sqrt(qw))
                        f.qw = tmp
                    else:
                        f.qx = 0
                        f.qy = 0
                        f.qz = 0
                        f.qw = 1
                    if scale:
                        f.sx = data.getFloat(p)
                        p = (p + 4)
                        f.sy = data.getFloat(p)
                        p = (p + 4)
                        f.sz = data.getFloat(p)
                        p = (p + 4)
                    else:
                        f.sx = 1
                        f.sy = 1
                        f.sz = 1
                    fl[i] = f
                l.addCurve(o.name,fl,True,rot,scale)
            if (((o.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasUV.index)))) != 0):
                this2 = [None]*(a.frames * 2)
                fl1 = this2
                size1 = (8 * a.frames)
                data1 = haxe_io_Bytes.alloc(size1)
                entry.read(data1,0,size1)
                _g3 = 0
                _g12 = len(fl1)
                while (_g3 < _g12):
                    i1 = _g3
                    _g3 = (_g3 + 1)
                    val = data1.getFloat((i1 * 4))
                    fl1[i1] = val
                l.addUVCurve(o.name,fl1)
            if (((o.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasAlpha.index)))) != 0):
                this3 = [None]*a.frames
                fl2 = this3
                size2 = (4 * a.frames)
                data2 = haxe_io_Bytes.alloc(size2)
                entry.read(data2,0,size2)
                _g4 = 0
                _g13 = len(fl2)
                while (_g4 < _g13):
                    i2 = _g4
                    _g4 = (_g4 + 1)
                    val1 = data2.getFloat((i2 * 4))
                    fl2[i2] = val1
                l.addAlphaCurve(o.name,fl2)
            if (((o.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasProps.index)))) != 0):
                _g5 = 0
                _g14 = o.props
                while (_g5 < len(_g14)):
                    p1 = (_g14[_g5] if _g5 >= 0 and _g5 < len(_g14) else None)
                    _g5 = (_g5 + 1)
                    this4 = [None]*a.frames
                    fl3 = this4
                    size3 = (4 * a.frames)
                    data3 = haxe_io_Bytes.alloc(size3)
                    entry.read(data3,0,size3)
                    _g6 = 0
                    _g15 = len(fl3)
                    while (_g6 < _g15):
                        i3 = _g6
                        _g6 = (_g6 + 1)
                        val2 = data3.getFloat((i3 * 4))
                        fl3[i3] = val2
                    l.addPropCurve(o.name,p1,fl3)
        entry.close()
        return l

    def loadSkin(self,geom,skin):
        if (skin.vertexWeights is not None):
            return
        skin.vertexCount = geom.vertexCount
        w = self.getBuffers(geom,[hxd_fmt_hmd_GeometryFormat("weights",3)]).vertexes
        this1 = [None]*(skin.vertexCount * skin.bonesPerVertex)
        skin.vertexWeights = this1
        this2 = [None]*(skin.vertexCount * skin.bonesPerVertex)
        skin.vertexJoints = this2
        _g = 0
        _g1 = len(skin.vertexWeights)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            this3 = skin.vertexWeights
            val = w[i]
            this3[i] = val
        vidx = self.getBuffers(geom,[hxd_fmt_hmd_GeometryFormat("indexes",9)]).vertexes
        j = 0
        _g2 = 0
        _g3 = skin.vertexCount
        while (_g2 < _g3):
            i1 = _g2
            _g2 = (_g2 + 1)
            v = self.ftoint32(vidx[i1])
            index = j
            j = (j + 1)
            val1 = (v & 255)
            skin.vertexJoints[index] = val1
            index1 = j
            j = (j + 1)
            val2 = ((v >> 8) & 255)
            skin.vertexJoints[index1] = val2
            index2 = j
            j = (j + 1)
            val3 = ((v >> 16) & 255)
            skin.vertexJoints[index2] = val3

    def ftoint32(self,v):
        self.tmp.setFloat(0,v)
        _this = self.tmp
        v1 = (((_this.b[0] | ((_this.b[1] << 8))) | ((_this.b[2] << 16))) | ((_this.b[3] << 24)))
        if (((v1 & -2147483648)) != 0):
            return (v1 | -2147483648)
        else:
            return v1

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.resource = None
        _hx_o.header = None
        _hx_o.cachedPrimitives = None
        _hx_o.cachedAnimations = None
        _hx_o.cachedSkin = None
        _hx_o.tmp = None
hxd_fmt_hmd_Library._hx_class = hxd_fmt_hmd_Library
_hx_classes["hxd.fmt.hmd.Library"] = hxd_fmt_hmd_Library


class hxd_fmt_hmd_Reader:
    _hx_class_name = "hxd.fmt.hmd.Reader"
    _hx_is_interface = "False"
    __slots__ = ("i", "version")
    _hx_fields = ["i", "version"]
    _hx_methods = ["readProperty", "readProps", "readName", "readCachedName", "readPosition", "readBounds", "readSkin", "readHeader", "read"]
    _hx_statics = ["BLEND", "CULLING", "HMD_STRINGS"]

    def __init__(self,i):
        self.version = None
        self.i = i

    def readProperty(self):
        _g = self.i.readByte()
        _g1 = _g
        if (_g1 == 0):
            return hxd_fmt_hmd_Property.CameraFOVY(self.i.readFloat())
        elif (_g1 == 1):
            raise _HxException("Obsolete HasMaterialFlags")
        elif (_g1 == 2):
            return hxd_fmt_hmd_Property.HasExtraTextures
        else:
            unk = _g
            raise _HxException(("Unknown property #" + Std.string(unk)))

    def readProps(self):
        if (self.version == 1):
            return None
        n = self.i.readByte()
        if (n == 0):
            return None
        _g = []
        _g1 = 0
        _g2 = n
        while (_g1 < _g2):
            i = _g1
            _g1 = (_g1 + 1)
            x = self.readProperty()
            _g.append(x)
        return _g

    def readName(self):
        b = self.i.readByte()
        if (b == 255):
            return None
        return self.i.readString(b)

    def readCachedName(self):
        name = self.readName()
        if (name is None):
            return None
        if (hxd_fmt_hmd_Reader.HMD_STRINGS is None):
            hxd_fmt_hmd_Reader.HMD_STRINGS = haxe_ds_StringMap()
        n = hxd_fmt_hmd_Reader.HMD_STRINGS.h.get(name,None)
        if (n is not None):
            return n
        hxd_fmt_hmd_Reader.HMD_STRINGS.h[name] = name
        return name

    def readPosition(self,hasScale = None):
        if (hasScale is None):
            hasScale = True
        p = hxd_fmt_hmd_Position()
        p.x = self.i.readFloat()
        p.y = self.i.readFloat()
        p.z = self.i.readFloat()
        p.qx = self.i.readFloat()
        p.qy = self.i.readFloat()
        p.qz = self.i.readFloat()
        if hasScale:
            p.sx = self.i.readFloat()
            p.sy = self.i.readFloat()
            p.sz = self.i.readFloat()
        else:
            p.sx = 1
            p.sy = 1
            p.sz = 1
        return p

    def readBounds(self):
        b = h3d_col_Bounds()
        b.xMin = self.i.readFloat()
        b.yMin = self.i.readFloat()
        b.zMin = self.i.readFloat()
        b.xMax = self.i.readFloat()
        b.yMax = self.i.readFloat()
        b.zMax = self.i.readFloat()
        return b

    def readSkin(self):
        name = self.readCachedName()
        if (name is None):
            return None
        s = hxd_fmt_hmd_Skin()
        s.props = self.readProps()
        s.name = name
        s.joints = []
        _g = 0
        _g1 = self.i.readUInt16()
        while (_g < _g1):
            k = _g
            _g = (_g + 1)
            j = hxd_fmt_hmd_SkinJoint()
            j.props = self.readProps()
            j.name = self.readCachedName()
            pid = self.i.readUInt16()
            hasScale = (((pid & 32768)) != 0)
            if hasScale:
                pid = (pid & 32767)
            j.parent = (pid - 1)
            j.position = self.readPosition(hasScale)
            j.bind = (self.i.readUInt16() - 1)
            if (j.bind >= 0):
                j.transpos = self.readPosition(hasScale)
            _this = s.joints
            _this.append(j)
        count = self.i.readByte()
        if (count > 0):
            s.split = []
            _g2 = 0
            _g3 = count
            while (_g2 < _g3):
                k1 = _g2
                _g2 = (_g2 + 1)
                ss = hxd_fmt_hmd_SkinSplit()
                ss.materialIndex = self.i.readByte()
                _g21 = []
                _g31 = 0
                _g4 = self.i.readByte()
                while (_g31 < _g4):
                    k2 = _g31
                    _g31 = (_g31 + 1)
                    x = self.i.readUInt16()
                    _g21.append(x)
                ss.joints = _g21
                _this1 = s.split
                _this1.append(ss)
        return s

    def readHeader(self):
        d = hxd_fmt_hmd_Data()
        h = self.i.readString(3)
        if (h != "HMD"):
            if (HxString.charCodeAt(h,0) == 59):
                raise _HxException("FBX was not converted to HMD")
            raise _HxException(("Invalid HMD header " + HxOverrides.stringOrNull(python_lib_urllib_Parse.quote(h,""))))
        self.version = self.i.readByte()
        if (self.version > 3):
            raise _HxException(("Can't read HMD v" + Std.string(self.version)))
        d.version = self.version
        d.geometries = []
        d.dataPosition = self.i.readInt32()
        d.props = self.readProps()
        _g = 0
        _g1 = self.i.readInt32()
        while (_g < _g1):
            k = _g
            _g = (_g + 1)
            g = hxd_fmt_hmd_Geometry()
            g.props = self.readProps()
            g.vertexCount = self.i.readInt32()
            g.vertexStride = self.i.readByte()
            _g2 = []
            _g11 = 0
            _g21 = self.i.readByte()
            while (_g11 < _g21):
                k1 = _g11
                _g11 = (_g11 + 1)
                x = self.readCachedName()
                this1 = self.i.readByte()
                x1 = hxd_fmt_hmd_GeometryFormat(x,this1)
                _g2.append(x1)
            g.vertexFormat = _g2
            g.vertexPosition = self.i.readInt32()
            _g3 = []
            _g4 = 0
            _g5 = self.i.readByte()
            while (_g4 < _g5):
                k2 = _g4
                _g4 = (_g4 + 1)
                x2 = self.i.readInt32()
                _g3.append(x2)
            g.indexCounts = _g3
            g.indexPosition = self.i.readInt32()
            g.bounds = self.readBounds()
            _this = d.geometries
            _this.append(g)
        d.materials = []
        _g22 = 0
        _g31 = self.i.readInt32()
        while (_g22 < _g31):
            k3 = _g22
            _g22 = (_g22 + 1)
            m = hxd_fmt_hmd_Material()
            m.props = self.readProps()
            m.name = self.readName()
            m.diffuseTexture = self.readName()
            m.blendMode = python_internal_ArrayImpl._get(hxd_fmt_hmd_Reader.BLEND, self.i.readByte())
            self.i.readByte()
            self.i.readFloat()
            if ((m.props is not None) and ((python_internal_ArrayImpl.indexOf(m.props,hxd_fmt_hmd_Property.HasExtraTextures,None) >= 0))):
                m.specularTexture = self.readName()
                m.normalMap = self.readName()
            _this1 = d.materials
            _this1.append(m)
        d.models = []
        _g41 = 0
        _g51 = self.i.readInt32()
        while (_g41 < _g51):
            k4 = _g41
            _g41 = (_g41 + 1)
            m1 = hxd_fmt_hmd_Model()
            m1.props = self.readProps()
            m1.name = self.readCachedName()
            m1.parent = (self.i.readInt32() - 1)
            m1.follow = self.readCachedName()
            m1.position = self.readPosition()
            m1.geometry = (self.i.readInt32() - 1)
            _this2 = d.models
            _this2.append(m1)
            if (m1.geometry < 0):
                continue
            m1.materials = []
            _g42 = 0
            _g52 = self.i.readByte()
            while (_g42 < _g52):
                k5 = _g42
                _g42 = (_g42 + 1)
                _this3 = m1.materials
                x3 = self.i.readInt32()
                _this3.append(x3)
            m1.skin = self.readSkin()
        d.animations = []
        _g6 = 0
        _g7 = self.i.readInt32()
        while (_g6 < _g7):
            k6 = _g6
            _g6 = (_g6 + 1)
            a = hxd_fmt_hmd_Animation()
            a.props = self.readProps()
            a.name = self.readName()
            a.frames = self.i.readInt32()
            a.sampling = self.i.readFloat()
            a.speed = self.i.readFloat()
            flags = self.i.readByte()
            a.loop = (((flags & 1)) != 0)
            a.dataPosition = self.i.readInt32()
            a.objects = []
            _g61 = 0
            _g71 = self.i.readInt32()
            while (_g61 < _g71):
                k7 = _g61
                _g61 = (_g61 + 1)
                o = hxd_fmt_hmd_AnimationObject()
                o.name = self.readCachedName()
                i = self.i.readByte()
                if (i is None):
                    i = 0
                this2 = i
                o.flags = this2
                _this4 = a.objects
                _this4.append(o)
                if (((o.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasProps.index)))) != 0):
                    _g62 = []
                    _g72 = 0
                    _g8 = self.i.readByte()
                    while (_g72 < _g8):
                        i1 = _g72
                        _g72 = (_g72 + 1)
                        x4 = self.readName()
                        _g62.append(x4)
                    o.props = _g62
            if (((flags & 2)) != 0):
                a.events = []
                _g81 = 0
                _g9 = self.i.readInt32()
                while (_g81 < _g9):
                    k8 = _g81
                    _g81 = (_g81 + 1)
                    e = hxd_fmt_hmd_AnimationEvent()
                    e.frame = self.i.readInt32()
                    e.data = self.readCachedName()
                    _this5 = a.events
                    _this5.append(e)
            _this6 = d.animations
            _this6.append(a)
        return d

    def read(self):
        h = self.readHeader()
        h.data = self.i.read(self.i.readInt32())
        return h
    HMD_STRINGS = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.i = None
        _hx_o.version = None
hxd_fmt_hmd_Reader._hx_class = hxd_fmt_hmd_Reader
_hx_classes["hxd.fmt.hmd.Reader"] = hxd_fmt_hmd_Reader


class hxd_fmt_hmd_Writer:
    _hx_class_name = "hxd.fmt.hmd.Writer"
    _hx_is_interface = "False"
    __slots__ = ("out", "version")
    _hx_fields = ["out", "version"]
    _hx_methods = ["writeProperty", "writeProps", "writeName", "writeFloat", "writePosition", "writeBounds", "writeSkin", "write"]

    def __init__(self,out):
        self.version = None
        self.out = out

    def writeProperty(self,p):
        self.out.writeByte(p.index)
        tmp = p.index
        if (tmp == 0):
            v = p.params[0]
            self.out.writeFloat(v)
        elif (tmp == 1):
            pass
        elif (tmp == 2):
            pass
        else:
            pass

    def writeProps(self,props):
        if (props is None):
            if (self.version == 1):
                return
            self.out.writeByte(0)
            return
        if (self.version == 1):
            raise _HxException("Properties not supported in HMDv1")
        self.out.writeByte(len(props))
        _g = 0
        while (_g < len(props)):
            p = (props[_g] if _g >= 0 and _g < len(props) else None)
            _g = (_g + 1)
            self.writeProperty(p)

    def writeName(self,name):
        if (name is None):
            self.out.writeByte(255)
            return
        self.out.writeByte(len(name))
        self.out.writeString(name)

    def writeFloat(self,f):
        self.out.writeFloat((0 if ((f == 0)) else f))

    def writePosition(self,p,hasScale = None):
        if (hasScale is None):
            hasScale = True
        f = p.x
        self.out.writeFloat((0 if ((f == 0)) else f))
        f1 = p.y
        self.out.writeFloat((0 if ((f1 == 0)) else f1))
        f2 = p.z
        self.out.writeFloat((0 if ((f2 == 0)) else f2))
        f3 = p.qx
        self.out.writeFloat((0 if ((f3 == 0)) else f3))
        f4 = p.qy
        self.out.writeFloat((0 if ((f4 == 0)) else f4))
        f5 = p.qz
        self.out.writeFloat((0 if ((f5 == 0)) else f5))
        if hasScale:
            f6 = p.sx
            self.out.writeFloat((0 if ((f6 == 0)) else f6))
            f7 = p.sy
            self.out.writeFloat((0 if ((f7 == 0)) else f7))
            f8 = p.sz
            self.out.writeFloat((0 if ((f8 == 0)) else f8))

    def writeBounds(self,b):
        f = b.xMin
        self.out.writeFloat((0 if ((f == 0)) else f))
        f1 = b.yMin
        self.out.writeFloat((0 if ((f1 == 0)) else f1))
        f2 = b.zMin
        self.out.writeFloat((0 if ((f2 == 0)) else f2))
        f3 = b.xMax
        self.out.writeFloat((0 if ((f3 == 0)) else f3))
        f4 = b.yMax
        self.out.writeFloat((0 if ((f4 == 0)) else f4))
        f5 = b.zMax
        self.out.writeFloat((0 if ((f5 == 0)) else f5))

    def writeSkin(self,s):
        self.writeName(("" if ((s.name is None)) else s.name))
        self.writeProps(s.props)
        self.out.writeUInt16(len(s.joints))
        _g = 0
        _g1 = s.joints
        while (_g < len(_g1)):
            j = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            self.writeProps(j.props)
            self.writeName(j.name)
            rot = ((((j.position.sx != 1) or ((j.position.sy != 1))) or ((j.position.sz != 1))) or (((j.transpos is not None) and ((((j.transpos.sx != 1) or ((j.transpos.sy != 1))) or ((j.transpos.sz != 1)))))))
            self.out.writeUInt16(((j.parent + 1) | ((32768 if rot else 0))))
            self.writePosition(j.position,rot)
            self.out.writeUInt16((j.bind + 1))
            if (j.bind >= 0):
                self.writePosition(j.transpos,rot)
        self.out.writeByte((0 if ((s.split is None)) else len(s.split)))
        if (s.split is not None):
            _g2 = 0
            _g3 = s.split
            while (_g2 < len(_g3)):
                ss = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                _g2 = (_g2 + 1)
                self.out.writeByte(ss.materialIndex)
                self.out.writeByte(len(ss.joints))
                _g21 = 0
                _g31 = ss.joints
                while (_g21 < len(_g31)):
                    i = (_g31[_g21] if _g21 >= 0 and _g21 < len(_g31) else None)
                    _g21 = (_g21 + 1)
                    self.out.writeUInt16(i)

    def write(self,d):
        old = self.out
        header = haxe_io_BytesOutput()
        self.out = header
        self.version = d.version
        if (self.version > 3):
            raise _HxException(("Can't write HMD v" + Std.string(self.version)))
        self.writeProps(d.props)
        self.out.writeInt32(len(d.geometries))
        _g = 0
        _g1 = d.geometries
        while (_g < len(_g1)):
            g = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            self.writeProps(g.props)
            self.out.writeInt32(g.vertexCount)
            self.out.writeByte(g.vertexStride)
            self.out.writeByte(len(g.vertexFormat))
            _g2 = 0
            _g11 = g.vertexFormat
            while (_g2 < len(_g11)):
                f = (_g11[_g2] if _g2 >= 0 and _g2 < len(_g11) else None)
                _g2 = (_g2 + 1)
                self.writeName(f.name)
                self.out.writeByte(f.format)
            self.out.writeInt32(g.vertexPosition)
            self.out.writeByte(len(g.indexCounts))
            _g21 = 0
            _g3 = g.indexCounts
            while (_g21 < len(_g3)):
                i = (_g3[_g21] if _g21 >= 0 and _g21 < len(_g3) else None)
                _g21 = (_g21 + 1)
                self.out.writeInt32(i)
            self.out.writeInt32(g.indexPosition)
            self.writeBounds(g.bounds)
        self.out.writeInt32(len(d.materials))
        _g22 = 0
        _g31 = d.materials
        while (_g22 < len(_g31)):
            m = (_g31[_g22] if _g22 >= 0 and _g22 < len(_g31) else None)
            _g22 = (_g22 + 1)
            self.writeProps(m.props)
            self.writeName(m.name)
            self.writeName(m.diffuseTexture)
            self.out.writeByte(m.blendMode.index)
            self.out.writeByte(1)
            self.out.writeFloat(1)
            if ((m.props is not None) and ((python_internal_ArrayImpl.indexOf(m.props,hxd_fmt_hmd_Property.HasExtraTextures,None) >= 0))):
                self.writeName(m.specularTexture)
                self.writeName(m.normalMap)
        self.out.writeInt32(len(d.models))
        _g4 = 0
        _g5 = d.models
        while (_g4 < len(_g5)):
            m1 = (_g5[_g4] if _g4 >= 0 and _g4 < len(_g5) else None)
            _g4 = (_g4 + 1)
            self.writeProps(m1.props)
            self.writeName(m1.name)
            self.out.writeInt32((m1.parent + 1))
            self.writeName(m1.follow)
            self.writePosition(m1.position)
            self.out.writeInt32((m1.geometry + 1))
            if (m1.geometry < 0):
                continue
            self.out.writeByte(len(m1.materials))
            _g41 = 0
            _g51 = m1.materials
            while (_g41 < len(_g51)):
                m2 = (_g51[_g41] if _g41 >= 0 and _g41 < len(_g51) else None)
                _g41 = (_g41 + 1)
                self.out.writeInt32(m2)
            if (m1.skin is None):
                self.writeName(None)
            else:
                self.writeSkin(m1.skin)
        self.out.writeInt32(len(d.animations))
        _g6 = 0
        _g7 = d.animations
        while (_g6 < len(_g7)):
            a = (_g7[_g6] if _g6 >= 0 and _g6 < len(_g7) else None)
            _g6 = (_g6 + 1)
            self.writeProps(a.props)
            self.writeName(a.name)
            self.out.writeInt32(a.frames)
            f1 = a.sampling
            self.out.writeFloat((0 if ((f1 == 0)) else f1))
            f2 = a.speed
            self.out.writeFloat((0 if ((f2 == 0)) else f2))
            self.out.writeByte((((1 if (a.loop) else 0)) | ((2 if ((a.events is not None)) else 0))))
            self.out.writeInt32(a.dataPosition)
            self.out.writeInt32(len(a.objects))
            _g61 = 0
            _g71 = a.objects
            while (_g61 < len(_g71)):
                o = (_g71[_g61] if _g61 >= 0 and _g61 < len(_g71) else None)
                _g61 = (_g61 + 1)
                self.writeName(o.name)
                self.out.writeByte(o.flags)
                if (((o.flags & ((1 << hxd_fmt_hmd_AnimationFlag.HasProps.index)))) != 0):
                    self.out.writeByte(len(o.props))
                    _g62 = 0
                    _g72 = o.props
                    while (_g62 < len(_g72)):
                        n = (_g72[_g62] if _g62 >= 0 and _g62 < len(_g72) else None)
                        _g62 = (_g62 + 1)
                        self.writeName(n)
            if (a.events is not None):
                self.out.writeInt32(len(a.events))
                _g8 = 0
                _g9 = a.events
                while (_g8 < len(_g9)):
                    e = (_g9[_g8] if _g8 >= 0 and _g8 < len(_g9) else None)
                    _g8 = (_g8 + 1)
                    self.out.writeInt32(e.frame)
                    self.writeName(e.data)
        _hx_bytes = header.getBytes()
        self.out = old
        self.out.writeString("HMD")
        self.out.writeByte(d.version)
        self.out.writeInt32((_hx_bytes.length + 12))
        self.out.write(_hx_bytes)
        self.out.writeInt32(d.data.length)
        self.out.write(d.data)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.out = None
        _hx_o.version = None
hxd_fmt_hmd_Writer._hx_class = hxd_fmt_hmd_Writer
_hx_classes["hxd.fmt.hmd.Writer"] = hxd_fmt_hmd_Writer


class hxd_fs_FileEntry:
    _hx_class_name = "hxd.fs.FileEntry"
    _hx_is_interface = "False"
    __slots__ = ("name",)
    _hx_fields = ["name"]
    _hx_methods = ["getSign", "getBytes", "getText", "open", "skip", "readByte", "read", "close", "load", "loadBitmap", "watch", "exists", "get", "iterator", "get_isAvailable", "get_isDirectory", "get_size", "get_path", "get_directory", "get_extension"]

    def getSign(self):
        return 0

    def getBytes(self):
        return None

    def getText(self):
        return self.getBytes().toString()

    def open(self):
        pass

    def skip(self,nbytes):
        pass

    def readByte(self):
        return 0

    def read(self,out,pos,size):
        pass

    def close(self):
        pass

    def load(self,onReady = None):
        if (not self.get_isAvailable()):
            raise _HxException("load() not implemented")
        elif (onReady is not None):
            onReady()

    def loadBitmap(self,onLoaded):
        raise _HxException("loadBitmap() not implemented")

    def watch(self,onChanged):
        pass

    def exists(self,name):
        return False

    def get(self,name):
        return None

    def iterator(self):
        return None

    def get_isAvailable(self):
        return True

    def get_isDirectory(self):
        return False

    def get_size(self):
        return 0

    def get_path(self):
        raise _HxException("path() not implemented")

    def get_directory(self):
        _this = self.get_path()
        p = _this.split("/")
        if (len(p) != 0):
            p.pop()
        return "/".join([python_Boot.toString1(x1,'') for x1 in p])

    def get_extension(self):
        _this = self.name
        np = _this.split(".")
        if (len(np) == 1):
            return ""
        else:
            return (None if ((len(np) == 0)) else np.pop()).lower()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.name = None
hxd_fs_FileEntry._hx_class = hxd_fs_FileEntry
_hx_classes["hxd.fs.FileEntry"] = hxd_fs_FileEntry


class hxd_fs_BytesFileEntry(hxd_fs_FileEntry):
    _hx_class_name = "hxd.fs.BytesFileEntry"
    _hx_is_interface = "False"
    __slots__ = ("fullPath", "bytes", "pos")
    _hx_fields = ["fullPath", "bytes", "pos"]
    _hx_methods = ["get_path", "getSign", "getBytes", "open", "skip", "readByte", "read", "close", "load", "loadBitmap", "exists", "get", "iterator", "get_size"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = hxd_fs_FileEntry


    def __init__(self,path,_hx_bytes):
        self.pos = None
        self.fullPath = path
        _this = path.split("/")
        self.name = (None if ((len(_this) == 0)) else _this.pop())
        self.bytes = _hx_bytes

    def get_path(self):
        return self.fullPath

    def getSign(self):
        return (((self.bytes.b[0] | ((self.bytes.b[1] << 8))) | ((self.bytes.b[2] << 16))) | ((self.bytes.b[3] << 24)))

    def getBytes(self):
        return self.bytes

    def open(self):
        self.pos = 0

    def skip(self,nbytes):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + nbytes)
        _hx_local_0.pos

    def readByte(self):
        pos = self.pos
        self.pos = (self.pos + 1)
        return self.bytes.b[pos]

    def read(self,out,pos,size):
        out.blit(pos,self.bytes,self.pos,size)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + size)
        _hx_local_0.pos

    def close(self):
        pass

    def load(self,onReady = None):
        haxe_Timer.delay(onReady,1)

    def loadBitmap(self,onLoaded):
        raise _HxException("Not implemented")

    def exists(self,name):
        return False

    def get(self,name):
        return None

    def iterator(self):
        return hxd_impl_ArrayIterator_hxd_fs_FileEntry(list())

    def get_size(self):
        return self.bytes.length

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.fullPath = None
        _hx_o.bytes = None
        _hx_o.pos = None
hxd_fs_BytesFileEntry._hx_class = hxd_fs_BytesFileEntry
_hx_classes["hxd.fs.BytesFileEntry"] = hxd_fs_BytesFileEntry


class hxd_fs_FileSystem:
    _hx_class_name = "hxd.fs.FileSystem"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_methods = ["getRoot", "get", "exists", "dispose", "dir"]
hxd_fs_FileSystem._hx_class = hxd_fs_FileSystem
_hx_classes["hxd.fs.FileSystem"] = hxd_fs_FileSystem


class hxd_fs_BytesFileSystem:
    _hx_class_name = "hxd.fs.BytesFileSystem"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_methods = ["getRoot", "getBytes", "exists", "get", "dispose", "dir"]
    _hx_interfaces = [hxd_fs_FileSystem]

    def __init__(self):
        pass

    def getRoot(self):
        raise _HxException("Not implemented")

    def getBytes(self,path):
        raise _HxException("Not implemented")

    def exists(self,path):
        return (self.getBytes(path) is not None)

    def get(self,path):
        _hx_bytes = self.getBytes(path)
        if (_hx_bytes is None):
            raise _HxException((("Resource not found '" + ("null" if path is None else path)) + "'"))
        return hxd_fs_BytesFileEntry(path,_hx_bytes)

    def dispose(self):
        pass

    def dir(self,path):
        raise _HxException("Not implemented")

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
hxd_fs_BytesFileSystem._hx_class = hxd_fs_BytesFileSystem
_hx_classes["hxd.fs.BytesFileSystem"] = hxd_fs_BytesFileSystem


class hxd_fs_Convert:
    _hx_class_name = "hxd.fs.Convert"
    _hx_is_interface = "False"
    __slots__ = ("sourceExts", "destExt", "version", "params", "srcPath", "dstPath", "originalFilename", "srcBytes")
    _hx_fields = ["sourceExts", "destExt", "version", "params", "srcPath", "dstPath", "originalFilename", "srcBytes"]
    _hx_methods = ["convert", "hasParam", "getParam", "save", "command"]
    _hx_statics = ["converts", "register"]

    def __init__(self,sourceExts,destExt):
        self.srcBytes = None
        self.originalFilename = None
        self.dstPath = None
        self.srcPath = None
        self.params = None
        self.sourceExts = (None if ((sourceExts is None)) else HxOverrides.split(sourceExts, ","))
        self.destExt = destExt
        self.version = 0

    def convert(self):
        raise _HxException("Not implemented")

    def hasParam(self,name):
        f = Reflect.field(self.params,name)
        if (f is not None):
            return (f != False)
        else:
            return False

    def getParam(self,name):
        f = Reflect.field(self.params,name)
        if (f is None):
            raise _HxException(((((("Missing required parameter '" + ("null" if name is None else name)) + "' for converting ") + HxOverrides.stringOrNull(self.srcPath)) + " to ") + HxOverrides.stringOrNull(self.dstPath)))
        return f

    def save(self,_hx_bytes):
        hxd_File.saveBytes(self.dstPath,_hx_bytes)

    def command(self,cmd,args):
        code = Sys.command(cmd,args)
        if (code != 0):
            raise _HxException((((("Command '" + ("null" if cmd is None else cmd)) + HxOverrides.stringOrNull((("" if ((len(args) == 0)) else (" " + HxOverrides.stringOrNull(" ".join([python_Boot.toString1(x1,'') for x1 in args]))))))) + "' failed with exit code ") + Std.string(code)))

    @staticmethod
    def register(c):
        dest = hxd_fs_Convert.converts.h.get(c.destExt,None)
        if (dest is None):
            dest = []
            hxd_fs_Convert.converts.h[c.destExt] = dest
        dest.insert(0, c)
        return 0

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.sourceExts = None
        _hx_o.destExt = None
        _hx_o.version = None
        _hx_o.params = None
        _hx_o.srcPath = None
        _hx_o.dstPath = None
        _hx_o.originalFilename = None
        _hx_o.srcBytes = None
hxd_fs_Convert._hx_class = hxd_fs_Convert
_hx_classes["hxd.fs.Convert"] = hxd_fs_Convert


class hxd_fs_ConvertFBX2HMD(hxd_fs_Convert):
    _hx_class_name = "hxd.fs.ConvertFBX2HMD"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["convert"]
    _hx_statics = ["_"]
    _hx_interfaces = []
    _hx_super = hxd_fs_Convert


    def __init__(self):
        super().__init__("fbx","hmd")

    def convert(self):
        fbx = None
        try:
            fbx = hxd_fmt_fbx_Parser.parse(self.srcBytes)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            raise _HxException(((Std.string(e) + " in ") + HxOverrides.stringOrNull(self.srcPath)))
        hmdout = hxd_fmt_fbx_HMDOut(self.srcPath)
        hmdout.load(fbx)
        isAnim = None
        if (not self.originalFilename.startswith("Anim_")):
            _this = self.originalFilename.lower()
            startIndex = None
            isAnim = (((_this.find("_anim_") if ((startIndex is None)) else _this.find("_anim_", startIndex))) > 0)
        else:
            isAnim = True
        hmd = hmdout.toHMD(None,(not isAnim))
        out = haxe_io_BytesOutput()
        hxd_fmt_hmd_Writer(out).write(hmd)
        self.save(out.getBytes())

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
hxd_fs_ConvertFBX2HMD._hx_class = hxd_fs_ConvertFBX2HMD
_hx_classes["hxd.fs.ConvertFBX2HMD"] = hxd_fs_ConvertFBX2HMD


class hxd_fs_Command(hxd_fs_Convert):
    _hx_class_name = "hxd.fs.Command"
    _hx_is_interface = "False"
    __slots__ = ("cmd", "args")
    _hx_fields = ["cmd", "args"]
    _hx_methods = ["convert"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = hxd_fs_Convert


    def __init__(self,fr,to,cmd,args):
        self.args = None
        self.cmd = None
        super().__init__(fr,to)
        self.cmd = cmd
        self.args = args

    def convert(self):
        tmp = self.cmd
        _g = []
        _g1 = 0
        _g2 = self.args
        while (_g1 < len(_g2)):
            a = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
            _g1 = (_g1 + 1)
            x = (self.srcPath if ((a == "%SRC")) else (self.dstPath if ((a == "%DST")) else a))
            _g.append(x)
        self.command(tmp,_g)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.cmd = None
        _hx_o.args = None
hxd_fs_Command._hx_class = hxd_fs_Command
_hx_classes["hxd.fs.Command"] = hxd_fs_Command


class hxd_fs_ConvertWAV2MP3(hxd_fs_Convert):
    _hx_class_name = "hxd.fs.ConvertWAV2MP3"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["convert"]
    _hx_statics = ["_"]
    _hx_interfaces = []
    _hx_super = hxd_fs_Convert


    def __init__(self):
        super().__init__("wav","mp3")

    def convert(self):
        self.command("lame",["--resample", "44100", "--silent", "-h", self.srcPath, self.dstPath])

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
hxd_fs_ConvertWAV2MP3._hx_class = hxd_fs_ConvertWAV2MP3
_hx_classes["hxd.fs.ConvertWAV2MP3"] = hxd_fs_ConvertWAV2MP3


class hxd_fs_ConvertWAV2OGG(hxd_fs_Convert):
    _hx_class_name = "hxd.fs.ConvertWAV2OGG"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["convert"]
    _hx_statics = ["_"]
    _hx_interfaces = []
    _hx_super = hxd_fs_Convert


    def __init__(self):
        super().__init__("wav","ogg")

    def convert(self):
        cmd = "oggenc"
        args = ["--resample", "44100", "-Q", self.srcPath, "-o", self.dstPath]
        if (Sys.systemName() == "Windows"):
            cmd = "oggenc2"
        if self.hasParam("mono"):
            f = sys_io_File.read(self.srcPath)
            wav = format_wav_Reader(f).read()
            f.close()
            if (wav.header.channels >= 2):
                args.append("--downmix")
        self.command(cmd,args)

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
hxd_fs_ConvertWAV2OGG._hx_class = hxd_fs_ConvertWAV2OGG
_hx_classes["hxd.fs.ConvertWAV2OGG"] = hxd_fs_ConvertWAV2OGG


class hxd_fs_ConvertTGA2PNG(hxd_fs_Convert):
    _hx_class_name = "hxd.fs.ConvertTGA2PNG"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["convert"]
    _hx_statics = ["_"]
    _hx_interfaces = []
    _hx_super = hxd_fs_Convert


    def __init__(self):
        super().__init__("tga","png")

    def convert(self):
        input = haxe_io_BytesInput(sys_io_File.getBytes(self.srcPath))
        r = format_tga_Reader(input).read()
        if ((r.header.imageType != format_tga_ImageType.UncompressedTrueColor) or ((r.header.bitsPerPixel != 32))):
            raise _HxException(((("Not supported " + Std.string(r.header.imageType)) + "/") + Std.string(r.header.bitsPerPixel)))
        w = r.header.width
        h = r.header.height
        pix = hxd_Pixels.alloc(w,h,hxd_PixelFormat.ARGB)
        access = hxd__Pixels_PixelsARGB_Impl_.fromPixels(pix)
        p = 0
        _g = 0
        _g1 = h
        while (_g < _g1):
            y = _g
            _g = (_g + 1)
            _g2 = 0
            _g11 = w
            while (_g2 < _g11):
                x = _g2
                _g2 = (_g2 + 1)
                c = r.imageData[(x + ((y * w)))]
                _this = access.bytes
                pos = ((((x + ((y * access.width))) << 2)) + access.offset)
                v = (((HxOverrides.rshift(c, 24) | (((c >> 8) & 65280))) | (((c << 8) & 16711680))) | ((c << 24)))
                _this.b[pos] = (v & 255)
                _this.b[(pos + 1)] = ((v >> 8) & 255)
                _this.b[(pos + 2)] = ((v >> 16) & 255)
                _this.b[(pos + 3)] = (HxOverrides.rshift(v, 24) & 255)
        tmp = r.header.imageOrigin.index
        if (tmp == 0):
            pix.flags = (pix.flags | ((1 << hxd_Flags.FlipY.index)))
        elif (tmp == 2):
            pass
        else:
            raise _HxException(("Not supported " + Std.string(r.header.imageOrigin)))
        sys_io_File.saveBytes(self.dstPath,pix.toPNG())

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
hxd_fs_ConvertTGA2PNG._hx_class = hxd_fs_ConvertTGA2PNG
_hx_classes["hxd.fs.ConvertTGA2PNG"] = hxd_fs_ConvertTGA2PNG


class hxd_fs_ConvertFNT2BFNT(hxd_fs_Convert):
    _hx_class_name = "hxd.fs.ConvertFNT2BFNT"
    _hx_is_interface = "False"
    __slots__ = ("emptyTile",)
    _hx_fields = ["emptyTile"]
    _hx_methods = ["convert", "resolveTile"]
    _hx_statics = ["_"]
    _hx_interfaces = []
    _hx_super = hxd_fs_Convert


    def __init__(self):
        self.emptyTile = h2d_Tile(None,0,0,0,0,0,0)
        super().__init__("fnt","bfnt")

    def convert(self):
        font = hxd_fmt_bfnt_FontParser.parse(self.srcBytes,self.srcPath,self.resolveTile)
        out = haxe_io_BytesOutput()
        hxd_fmt_bfnt_Writer(out).write(font)
        self.save(out.getBytes())

    def resolveTile(self,path):
        if (not sys_FileSystem.exists(path)):
            raise _HxException(("Could not resolve BitmapFont texture reference at path: " + ("null" if path is None else path)))
        return self.emptyTile

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.emptyTile = None
hxd_fs_ConvertFNT2BFNT._hx_class = hxd_fs_ConvertFNT2BFNT
_hx_classes["hxd.fs.ConvertFNT2BFNT"] = hxd_fs_ConvertFNT2BFNT


class hxd_fs_CompressIMG(hxd_fs_Convert):
    _hx_class_name = "hxd.fs.CompressIMG"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["convert"]
    _hx_statics = ["_"]
    _hx_interfaces = []
    _hx_super = hxd_fs_Convert


    def __init__(self,sourceExts,destExt):
        super().__init__(sourceExts,destExt)

    def convert(self):
        self.command("CompressonatorCLI",["-silent", "-fd", self.getParam("format"), self.srcPath, self.dstPath])

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
hxd_fs_CompressIMG._hx_class = hxd_fs_CompressIMG
_hx_classes["hxd.fs.CompressIMG"] = hxd_fs_CompressIMG


class hxd_fs_DummyConvert(hxd_fs_Convert):
    _hx_class_name = "hxd.fs.DummyConvert"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["convert"]
    _hx_statics = ["_"]
    _hx_interfaces = []
    _hx_super = hxd_fs_Convert


    def __init__(self,sourceExts,destExt):
        super().__init__(sourceExts,destExt)

    def convert(self):
        self.save(haxe_io_Bytes.alloc(0))

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
hxd_fs_DummyConvert._hx_class = hxd_fs_DummyConvert
_hx_classes["hxd.fs.DummyConvert"] = hxd_fs_DummyConvert


class hxd_fs__EmbedFileSystem_EmbedEntry(hxd_fs_FileEntry):
    _hx_class_name = "hxd.fs._EmbedFileSystem.EmbedEntry"
    _hx_is_interface = "False"
    __slots__ = ("fs", "relPath", "data", "bytes", "readPos")
    _hx_fields = ["fs", "relPath", "data", "bytes", "readPos"]
    _hx_methods = ["getSign", "getBytes", "open", "skip", "readByte", "read", "close", "load", "loadBitmap", "get_isDirectory", "get_path", "exists", "get", "get_size", "iterator"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = hxd_fs_FileEntry


    def __init__(self,fs,name,relPath,data):
        self.readPos = None
        self.bytes = None
        self.fs = fs
        self.name = name
        self.relPath = relPath
        self.data = data

    def getSign(self):
        old = self.readPos
        self.open()
        self.readPos = old
        return (((self.bytes.b[0] | ((self.bytes.b[1] << 8))) | ((self.bytes.b[2] << 16))) | ((self.bytes.b[3] << 24)))

    def getBytes(self):
        if (self.bytes is None):
            self.open()
        return self.bytes

    def open(self):
        if (self.bytes is None):
            self.bytes = haxe_Resource.getBytes(self.data)
            if (self.bytes is None):
                raise _HxException(("Missing resource " + HxOverrides.stringOrNull(self.data)))
        self.readPos = 0

    def skip(self,nbytes):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.readPos
        _hx_local_0.readPos = (_hx_local_1 + nbytes)
        _hx_local_0.readPos

    def readByte(self):
        pos = self.readPos
        self.readPos = (self.readPos + 1)
        return self.bytes.b[pos]

    def read(self,out,pos,size):
        out.blit(pos,self.bytes,self.readPos,size)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.readPos
        _hx_local_0.readPos = (_hx_local_1 + size)
        _hx_local_0.readPos

    def close(self):
        self.bytes = None
        self.readPos = 0

    def load(self,onReady = None):
        pass

    def loadBitmap(self,onLoaded):
        raise _HxException("TODO")

    def get_isDirectory(self):
        return self.fs.isDirectory(self.relPath)

    def get_path(self):
        if (self.relPath == "."):
            return "<root>"
        else:
            return self.relPath

    def exists(self,name):
        return self.fs.exists((name if ((self.relPath == ".")) else ((HxOverrides.stringOrNull(self.relPath) + "/") + ("null" if name is None else name))))

    def get(self,name):
        return self.fs.get((name if ((self.relPath == ".")) else ((HxOverrides.stringOrNull(self.relPath) + "/") + ("null" if name is None else name))))

    def get_size(self):
        self.open()
        return self.bytes.length

    def iterator(self):
        return hxd_impl_ArrayIterator_hxd_fs_FileEntry(self.fs.subFiles(self.relPath))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.fs = None
        _hx_o.relPath = None
        _hx_o.data = None
        _hx_o.bytes = None
        _hx_o.readPos = None
hxd_fs__EmbedFileSystem_EmbedEntry._hx_class = hxd_fs__EmbedFileSystem_EmbedEntry
_hx_classes["hxd.fs._EmbedFileSystem.EmbedEntry"] = hxd_fs__EmbedFileSystem_EmbedEntry


class hxd_fs_EmbedFileSystem:
    _hx_class_name = "hxd.fs.EmbedFileSystem"
    _hx_is_interface = "False"
    __slots__ = ("root",)
    _hx_fields = ["root"]
    _hx_methods = ["getRoot", "splitPath", "subFiles", "isDirectory", "exists", "get", "dispose", "dir"]
    _hx_statics = ["invalidChars", "resolve"]
    _hx_interfaces = [hxd_fs_FileSystem]

    def __init__(self,root):
        self.root = root

    def getRoot(self):
        return hxd_fs__EmbedFileSystem_EmbedEntry(self,"root",".",None)

    def splitPath(self,path):
        if (path == "."):
            return []
        else:
            return path.split("/")

    def subFiles(self,path):
        r = self.root
        _g = 0
        _g1 = self.splitPath(path)
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            r = Reflect.field(r,p)
        if (r is None):
            raise _HxException((("null" if path is None else path) + " is not a directory"))
        fields = python_Boot.fields(r)
        fields.sort(key= python_lib_Functools.cmp_to_key(Reflect.compare))
        _g2 = []
        _g3 = 0
        while (_g3 < len(fields)):
            name = (fields[_g3] if _g3 >= 0 and _g3 < len(fields) else None)
            _g3 = (_g3 + 1)
            x = self.get((name if ((path == ".")) else ((("null" if path is None else path) + "/") + ("null" if name is None else name))))
            _g2.append(x)
        return _g2

    def isDirectory(self,path):
        r = self.root
        _g = 0
        _g1 = self.splitPath(path)
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            r = Reflect.field(r,p)
        if (r is not None):
            return (r != True)
        else:
            return False

    def exists(self,path):
        r = self.root
        _g = 0
        _g1 = self.splitPath(path)
        while (_g < len(_g1)):
            p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            r = Reflect.field(r,p)
            if (r is None):
                return False
        return True

    def get(self,path):
        if (not self.exists(path)):
            raise _HxException(hxd_fs_NotFound(path))
        id = hxd_fs_EmbedFileSystem.resolve(path)
        _this = path.split("/")
        return hxd_fs__EmbedFileSystem_EmbedEntry(self,(None if ((len(_this) == 0)) else _this.pop()),path,id)

    def dispose(self):
        pass

    def dir(self,path):
        raise _HxException("Not Supported")

    @staticmethod
    def resolve(path):
        return ("R_" + HxOverrides.stringOrNull(hxd_fs_EmbedFileSystem.invalidChars.replace(path,"_")))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.root = None
hxd_fs_EmbedFileSystem._hx_class = hxd_fs_EmbedFileSystem
_hx_classes["hxd.fs.EmbedFileSystem"] = hxd_fs_EmbedFileSystem

class hxd_fs_ConvertPattern(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.fs.ConvertPattern"
    _hx_constructs = ["Filename", "Regexp", "Ext", "Exts", "Wildcard"]

    @staticmethod
    def Filename(name):
        return hxd_fs_ConvertPattern("Filename", 0, (name,))

    @staticmethod
    def Regexp(r):
        return hxd_fs_ConvertPattern("Regexp", 1, (r,))

    @staticmethod
    def Ext(e):
        return hxd_fs_ConvertPattern("Ext", 2, (e,))

    @staticmethod
    def Exts(e):
        return hxd_fs_ConvertPattern("Exts", 3, (e,))
hxd_fs_ConvertPattern.Wildcard = hxd_fs_ConvertPattern("Wildcard", 4, ())
hxd_fs_ConvertPattern._hx_class = hxd_fs_ConvertPattern
_hx_classes["hxd.fs.ConvertPattern"] = hxd_fs_ConvertPattern


class hxd_fs_FileConverter:
    _hx_class_name = "hxd.fs.FileConverter"
    _hx_is_interface = "False"
    _hx_fields = ["configuration", "baseDir", "tmpDir", "configs", "defaultConfig", "cache"]
    _hx_methods = ["onConvert", "makeConfig", "loadConvert", "makeCommmand", "mergeRec", "getFileTime", "loadConfig", "getConvertRule", "run", "runConvert", "convertAndCache"]
    _hx_statics = ["extraConfigs", "addConfig", "sortByRulePiority"]

    def __init__(self,baseDir,configuration):
        self.cache = None
        self.defaultConfig = None
        self.configs = haxe_ds_StringMap()
        self.baseDir = baseDir
        self.configuration = configuration
        self.tmpDir = ".tmp/"
        defaultCfg = _hx_AnonObject({'fs.convert': _hx_AnonObject({'fbx': _hx_AnonObject({'convert': "hmd", 'priority': -1}), 'fnt': _hx_AnonObject({'convert': "bfnt", 'priority': -1})})})
        _g = 0
        _g1 = hxd_fs_FileConverter.extraConfigs
        while (_g < len(_g1)):
            conf = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            defaultCfg = self.mergeRec(defaultCfg,conf)
        self.defaultConfig = self.makeConfig(defaultCfg)

    def onConvert(self,c):
        pass

    def makeConfig(self,obj):
        cfg = _hx_AnonObject({'obj': obj, 'rules': []})
        _hx_def = Reflect.field(obj,"fs.convert")
        conf = Reflect.field(obj,("fs.convert." + HxOverrides.stringOrNull(self.configuration)))
        merge = self.mergeRec(_hx_def,conf)
        _g = 0
        _g1 = python_Boot.fields(merge)
        while (_g < len(_g1)):
            f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            cmd = self.makeCommmand(Reflect.field(merge,f))
            pt = None
            if (HxString.charCodeAt(f,0) == 94):
                pt = hxd_fs_ConvertPattern.Regexp(EReg(f,""))
            else:
                _this = EReg("^[a-zA-Z0-9,]+$","")
                _this.matchObj = python_lib_Re.search(_this.pattern,f)
                if (_this.matchObj is not None):
                    _this1 = f.lower()
                    el = _this1.split(",")
                    pt = (hxd_fs_ConvertPattern.Ext((el[0] if 0 < len(el) else None)) if ((len(el) == 1)) else hxd_fs_ConvertPattern.Exts(el))
                else:
                    pt = (hxd_fs_ConvertPattern.Wildcard if ((f == "*")) else hxd_fs_ConvertPattern.Filename(f))
            _this2 = cfg.rules
            x = _hx_AnonObject({'pt': pt, 'cmd': cmd.cmd, 'priority': cmd.priority})
            _this2.append(x)
        cfg.rules.sort(key= python_lib_Functools.cmp_to_key(hxd_fs_FileConverter.sortByRulePiority))
        return cfg

    def loadConvert(self,name):
        if (name == "none"):
            return None
        c = hxd_fs_Convert.converts.h.get(name,None)
        if (c is None):
            raise _HxException((("No convert has been registered with name/extension '" + ("null" if name is None else name)) + "'"))
        return c

    def makeCommmand(self,obj):
        if Std._hx_is(obj,str):
            return _hx_AnonObject({'cmd': _hx_AnonObject({'conv': self.loadConvert(obj)}), 'priority': 0})
        if (Reflect.field(obj,"convert") is None):
            raise _HxException(("Missing 'convert' in " + Std.string(obj)))
        cmd = _hx_AnonObject({'conv': self.loadConvert(Reflect.field(obj,"convert"))})
        priority = 0
        _g = 0
        _g1 = python_Boot.fields(obj)
        while (_g < len(_g1)):
            f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            value = Reflect.field(obj,f)
            f1 = f
            _hx_local_1 = len(f1)
            if (_hx_local_1 == 4):
                if (f1 == "then"):
                    Reflect.setField(cmd,"then",self.makeCommmand(value).cmd)
                else:
                    if (Reflect.field(cmd,"params") is None):
                        Reflect.setField(cmd,"params",_hx_AnonObject({}))
                    if (Reflect.isObject(value) and (not Std._hx_is(value,str))):
                        raise _HxException(((("Invalid parameter value " + ("null" if f is None else f)) + "=") + Std.string(value)))
                    setattr(Reflect.field(cmd,"params"),(("_hx_" + f) if ((f in python_Boot.keywords)) else (("_hx_" + f) if (((((len(f) > 2) and ((ord(f[0]) == 95))) and ((ord(f[1]) == 95))) and ((ord(f[(len(f) - 1)]) != 95)))) else f)),value)
            elif (_hx_local_1 == 7):
                if (f1 == "convert"):
                    pass
                else:
                    if (Reflect.field(cmd,"params") is None):
                        Reflect.setField(cmd,"params",_hx_AnonObject({}))
                    if (Reflect.isObject(value) and (not Std._hx_is(value,str))):
                        raise _HxException(((("Invalid parameter value " + ("null" if f is None else f)) + "=") + Std.string(value)))
                    setattr(Reflect.field(cmd,"params"),(("_hx_" + f) if ((f in python_Boot.keywords)) else (("_hx_" + f) if (((((len(f) > 2) and ((ord(f[0]) == 95))) and ((ord(f[1]) == 95))) and ((ord(f[(len(f) - 1)]) != 95)))) else f)),value)
            elif (_hx_local_1 == 8):
                if (f1 == "priority"):
                    priority = value
                else:
                    if (Reflect.field(cmd,"params") is None):
                        Reflect.setField(cmd,"params",_hx_AnonObject({}))
                    if (Reflect.isObject(value) and (not Std._hx_is(value,str))):
                        raise _HxException(((("Invalid parameter value " + ("null" if f is None else f)) + "=") + Std.string(value)))
                    setattr(Reflect.field(cmd,"params"),(("_hx_" + f) if ((f in python_Boot.keywords)) else (("_hx_" + f) if (((((len(f) > 2) and ((ord(f[0]) == 95))) and ((ord(f[1]) == 95))) and ((ord(f[(len(f) - 1)]) != 95)))) else f)),value)
            else:
                if (Reflect.field(cmd,"params") is None):
                    Reflect.setField(cmd,"params",_hx_AnonObject({}))
                if (Reflect.isObject(value) and (not Std._hx_is(value,str))):
                    raise _HxException(((("Invalid parameter value " + ("null" if f is None else f)) + "=") + Std.string(value)))
                setattr(Reflect.field(cmd,"params"),(("_hx_" + f) if ((f in python_Boot.keywords)) else (("_hx_" + f) if (((((len(f) > 2) and ((ord(f[0]) == 95))) and ((ord(f[1]) == 95))) and ((ord(f[(len(f) - 1)]) != 95)))) else f)),value)
        if (Reflect.field(cmd,"params") is not None):
            fl = python_Boot.fields(Reflect.field(cmd,"params"))
            fl.sort(key= python_lib_Functools.cmp_to_key(Reflect.compare))
            _g2 = []
            _g3 = 0
            while (_g3 < len(fl)):
                f2 = (fl[_g3] if _g3 >= 0 and _g3 < len(fl) else None)
                _g3 = (_g3 + 1)
                x = ((("null" if f2 is None else f2) + "_") + Std.string(Reflect.field(Reflect.field(cmd,"params"),f2)))
                _g2.append(x)
            Reflect.setField(cmd,"paramsStr","_".join([python_Boot.toString1(x1,'') for x1 in _g2]))
        return _hx_AnonObject({'cmd': cmd, 'priority': priority})

    def mergeRec(self,a,b):
        if (b is None):
            return a
        if (a is None):
            return b
        cp = _hx_AnonObject({})
        _g = 0
        _g1 = python_Boot.fields(a)
        while (_g < len(_g1)):
            f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            va = Reflect.field(a,f)
            if python_Boot.hasField(b,f):
                vb = Reflect.field(b,f)
                if ((Type.typeof(vb) == ValueType.TObject) and ((Type.typeof(va) == ValueType.TObject))):
                    vb = self.mergeRec(va,vb)
                setattr(cp,(("_hx_" + f) if ((f in python_Boot.keywords)) else (("_hx_" + f) if (((((len(f) > 2) and ((ord(f[0]) == 95))) and ((ord(f[1]) == 95))) and ((ord(f[(len(f) - 1)]) != 95)))) else f)),vb)
                continue
            setattr(cp,(("_hx_" + f) if ((f in python_Boot.keywords)) else (("_hx_" + f) if (((((len(f) > 2) and ((ord(f[0]) == 95))) and ((ord(f[1]) == 95))) and ((ord(f[(len(f) - 1)]) != 95)))) else f)),va)
        _g2 = 0
        _g3 = python_Boot.fields(b)
        while (_g2 < len(_g3)):
            f1 = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
            _g2 = (_g2 + 1)
            if (not python_Boot.hasField(cp,f1)):
                value = Reflect.field(b,f1)
                setattr(cp,(("_hx_" + f1) if ((f1 in python_Boot.keywords)) else (("_hx_" + f1) if (((((len(f1) > 2) and ((ord(f1[0]) == 95))) and ((ord(f1[1]) == 95))) and ((ord(f1[(len(f1) - 1)]) != 95)))) else f1)),value)
        return cp

    def getFileTime(self,filePath):
        return (sys_FileSystem.stat(filePath).mtime.date.timestamp() * 1000)

    def loadConfig(self,dir):
        c = self.configs.h.get(dir,None)
        if (c is not None):
            return c
        startIndex = None
        dirPos = None
        if (startIndex is None):
            dirPos = dir.rfind("/", 0, len(dir))
        else:
            i = dir.rfind("/", 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len("/"))) if ((i == -1)) else (i + 1))
            check = dir.find("/", startLeft, len(dir))
            dirPos = (check if (((check > i) and ((check <= startIndex)))) else i)
        parent = (self.defaultConfig if ((dir == "")) else self.loadConfig(("" if ((dirPos < 0)) else HxString.substr(dir,0,dirPos))))
        propsFile = (HxOverrides.stringOrNull(((self.baseDir if ((dir == "")) else ((HxOverrides.stringOrNull(self.baseDir) + ("null" if dir is None else dir)) + "/")))) + "props.json")
        if (not sys_FileSystem.exists(propsFile)):
            c = parent
        else:
            content = sys_io_File.getContent(propsFile)
            obj = None
            try:
                obj = python_lib_Json.loads(content,**python__KwArgs_KwArgs_Impl_.fromT(_hx_AnonObject({'object_hook': python_Lib.dictToAnon})))
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                raise _HxException((((("Failed to parse " + ("null" if propsFile is None else propsFile)) + "(") + Std.string(e)) + ")"))
            fullObj = self.mergeRec(parent.obj,obj)
            c = self.makeConfig(fullObj)
        self.configs.h[dir] = c
        return c

    def getConvertRule(self,path):
        startIndex = None
        dirPos = None
        if (startIndex is None):
            dirPos = path.rfind("/", 0, len(path))
        else:
            i = path.rfind("/", 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len("/"))) if ((i == -1)) else (i + 1))
            check = path.find("/", startLeft, len(path))
            dirPos = (check if (((check > i) and ((check <= startIndex)))) else i)
        cfg = self.loadConfig(("" if ((dirPos < 0)) else HxString.substr(path,0,dirPos)))
        name = (path if ((dirPos < 0)) else HxString.substr(path,(dirPos + 1),None))
        _this = name.split(".")
        ext = (None if ((len(_this) == 0)) else _this.pop()).lower()
        _g = 0
        _g1 = cfg.rules
        while (_g < len(_g1)):
            r = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            _g2 = r.pt
            tmp = _g2.index
            if (tmp == 0):
                f = _g2.params[0]
                if ((name == f) or ((path == f))):
                    return r
            elif (tmp == 1):
                reg = _g2.params[0]
                tmp1 = None
                reg.matchObj = python_lib_Re.search(reg.pattern,name)
                if (reg.matchObj is None):
                    reg.matchObj = python_lib_Re.search(reg.pattern,path)
                    tmp1 = (reg.matchObj is not None)
                else:
                    tmp1 = True
                if tmp1:
                    return r
            elif (tmp == 2):
                e = _g2.params[0]
                if (ext == e):
                    return r
            elif (tmp == 3):
                el = _g2.params[0]
                if (python_internal_ArrayImpl.indexOf(el,ext,None) >= 0):
                    return r
            elif (tmp == 4):
                return r
            else:
                pass
        return None

    def run(self,e):
        rule = self.getConvertRule(e.get_path())
        if (e.originalFile is None):
            e.originalFile = e.file
        else:
            e.file = e.originalFile
        if ((rule is None) or ((rule.cmd.conv is None))):
            return
        e.file = HxString.substr(e.file,len(self.baseDir),None)
        _g = rule.pt
        tmp = None
        if (_g.index == 2):
            _g1 = _g.params[0]
            tmp = True
        else:
            tmp = False
        self.runConvert(e,rule.cmd,tmp)

    def runConvert(self,e,cmd,replaceExt = None):
        if (replaceExt is None):
            replaceExt = False
        outFile = self.tmpDir
        ext = e.get_extension()
        if ((replaceExt and ((Reflect.field(cmd,"paramsStr") is None))) and ((Reflect.field(cmd,"then") is None))):
            outFile = (("null" if outFile is None else outFile) + HxOverrides.stringOrNull(HxString.substr(e.get_path(),0,-((len(ext) + 1)))))
        else:
            outFile = (("null" if outFile is None else outFile) + HxOverrides.stringOrNull(e.get_path()))
        if (Reflect.field(cmd,"paramsStr") is not None):
            outFile = (("null" if outFile is None else outFile) + HxOverrides.stringOrNull((("." + HxOverrides.stringOrNull(Reflect.field(cmd,"paramsStr"))))))
        conv = None
        _g = 0
        _g1 = cmd.conv
        while (_g < len(_g1)):
            c = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if ((c.sourceExts is None) or ((python_internal_ArrayImpl.indexOf(c.sourceExts,ext,None) >= 0))):
                conv = c
                break
        if (conv is None):
            raise _HxException(((("No converter is registered that can convert " + HxOverrides.stringOrNull(e.get_path())) + " to ") + HxOverrides.stringOrNull((cmd.conv[0] if 0 < len(cmd.conv) else None).destExt)))
        if (conv.destExt == "dummy"):
            e.file = ((HxOverrides.stringOrNull(self.baseDir) + HxOverrides.stringOrNull(self.tmpDir)) + ".dummy")
            if (not sys_FileSystem.exists(e.file)):
                sys_io_File.saveContent(e.file,"")
            return
        if (conv.destExt == "remove"):
            e.file = None
            return
        outFile = (("null" if outFile is None else outFile) + HxOverrides.stringOrNull((("." + HxOverrides.stringOrNull(conv.destExt)))))
        self.convertAndCache(e,outFile,conv,Reflect.field(cmd,"params"))
        if (Reflect.field(cmd,"then") is not None):
            e.file = outFile
            self.runConvert(e,Reflect.field(cmd,"then"))
        e.file = (HxOverrides.stringOrNull(self.baseDir) + ("null" if outFile is None else outFile))

    def convertAndCache(self,e,outFile,conv,params):
        _gthis = self
        if (self.cache is None):
            tmp = None
            try:
                tmp = haxe_Unserializer.run(sys_io_File.getContent(((HxOverrides.stringOrNull(self.baseDir) + HxOverrides.stringOrNull(self.tmpDir)) + "cache.dat")))
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e1 = _hx_e1
                tmp = haxe_ds_StringMap()
            self.cache = tmp
        entry = self.cache.h.get(e.file,None)
        needInsert = False
        if (entry is None):
            entry = []
            needInsert = True
        def _hx_local_0():
            if needInsert:
                _gthis.cache.h[e.file] = entry
            sys_FileSystem.createDirectory((HxOverrides.stringOrNull(_gthis.baseDir) + HxOverrides.stringOrNull(_gthis.tmpDir)))
            sys_io_File.saveContent(((HxOverrides.stringOrNull(_gthis.baseDir) + HxOverrides.stringOrNull(_gthis.tmpDir)) + "cache.dat"),haxe_Serializer.run(_gthis.cache))
        saveCache = _hx_local_0
        match = None
        _g = 0
        while (_g < len(entry)):
            e2 = (entry[_g] if _g >= 0 and _g < len(entry) else None)
            _g = (_g + 1)
            if (e2.out == outFile):
                match = e2
                if (match.ver is None):
                    match.ver = 0
                break
        if (match is None):
            match = _hx_AnonObject({'out': outFile, 'time': 0, 'hash': "", 'ver': conv.version})
            entry.append(match)
        fullPath = (HxOverrides.stringOrNull(self.baseDir) + HxOverrides.stringOrNull(e.file))
        fullOutPath = (HxOverrides.stringOrNull(self.baseDir) + ("null" if outFile is None else outFile))
        if (not sys_FileSystem.exists(fullPath)):
            raise _HxException(("Missing " + ("null" if fullPath is None else fullPath)))
        time = Math.floor((self.getFileTime(fullPath) / 1000))
        alreadyGen = (sys_FileSystem.exists(fullOutPath) and ((match.ver == conv.version)))
        if (alreadyGen and ((match.time == time))):
            return
        content = hxd_File.getBytes(fullPath)
        hash = haxe_crypto_Sha1.make(content).toHex()
        if (alreadyGen and ((match.hash == hash))):
            match.time = time
            saveCache()
            return
        startIndex = None
        _hx_len = None
        if (startIndex is None):
            _hx_len = fullOutPath.rfind("/", 0, len(fullOutPath))
        else:
            i = fullOutPath.rfind("/", 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len("/"))) if ((i == -1)) else (i + 1))
            check = fullOutPath.find("/", startLeft, len(fullOutPath))
            _hx_len = (check if (((check > i) and ((check <= startIndex)))) else i)
        sys_FileSystem.createDirectory(HxString.substr(fullOutPath,0,_hx_len))
        conv.srcPath = fullPath
        conv.dstPath = fullOutPath
        conv.srcBytes = content
        conv.originalFilename = e.name
        conv.params = params
        self.onConvert(conv)
        conv.convert()
        conv.srcPath = None
        conv.dstPath = None
        conv.srcBytes = None
        conv.originalFilename = None
        hxd_System.timeoutTick()
        if (not sys_FileSystem.exists(fullOutPath)):
            raise _HxException((("Converted output file " + ("null" if fullOutPath is None else fullOutPath)) + " was not created"))
        match.time = time
        match.hash = hash
        saveCache()

    @staticmethod
    def addConfig(conf):
        _this = hxd_fs_FileConverter.extraConfigs
        _this.append(conf)
        return conf

    @staticmethod
    def sortByRulePiority(r1,r2):
        if (r1.priority != r2.priority):
            return (r2.priority - r1.priority)
        return (r1.pt.index - r2.pt.index)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.configuration = None
        _hx_o.baseDir = None
        _hx_o.tmpDir = None
        _hx_o.configs = None
        _hx_o.defaultConfig = None
        _hx_o.cache = None
hxd_fs_FileConverter._hx_class = hxd_fs_FileConverter
_hx_classes["hxd.fs.FileConverter"] = hxd_fs_FileConverter


class hxd_fs_FileInput(haxe_io_Input):
    _hx_class_name = "hxd.fs.FileInput"
    _hx_is_interface = "False"
    __slots__ = ("f",)
    _hx_fields = ["f"]
    _hx_methods = ["skip", "readByte", "readBytes", "close"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Input


    def __init__(self,f):
        self.f = f
        f.open()

    def skip(self,nbytes):
        self.f.skip(nbytes)

    def readByte(self):
        return self.f.readByte()

    def readBytes(self,b,pos,_hx_len):
        self.f.read(b,pos,_hx_len)
        return _hx_len

    def close(self):
        self.f.close()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.f = None
hxd_fs_FileInput._hx_class = hxd_fs_FileInput
_hx_classes["hxd.fs.FileInput"] = hxd_fs_FileInput


class hxd_fs__LoadedBitmap_LoadedBitmap_Impl_:
    _hx_class_name = "hxd.fs._LoadedBitmap.LoadedBitmap_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "toBitmap", "toNative"]

    @staticmethod
    def _new(data):
        this1 = data
        return this1

    @staticmethod
    def toBitmap(this1):
        return this1

    @staticmethod
    def toNative(this1):
        return this1
hxd_fs__LoadedBitmap_LoadedBitmap_Impl_._hx_class = hxd_fs__LoadedBitmap_LoadedBitmap_Impl_
_hx_classes["hxd.fs._LoadedBitmap.LoadedBitmap_Impl_"] = hxd_fs__LoadedBitmap_LoadedBitmap_Impl_


class hxd_fs_LocalEntry(hxd_fs_FileEntry):
    _hx_class_name = "hxd.fs.LocalEntry"
    _hx_is_interface = "False"
    __slots__ = ("fs", "relPath", "file", "originalFile", "fread", "isDirCached", "watchCallback", "watchTime")
    _hx_fields = ["fs", "relPath", "file", "originalFile", "fread", "isDirCached", "watchCallback", "watchTime"]
    _hx_methods = ["getSign", "getBytes", "open", "skip", "readByte", "read", "close", "get_isDirectory", "load", "loadBitmap", "get_path", "exists", "get", "get_size", "iterator", "getModifTime", "watch"]
    _hx_statics = ["WATCH_INDEX", "WATCH_LIST", "tmpDir", "checkFiles"]
    _hx_interfaces = []
    _hx_super = hxd_fs_FileEntry


    def __init__(self,fs,name,relPath,file):
        self.watchTime = None
        self.watchCallback = None
        self.isDirCached = None
        self.fread = None
        self.originalFile = None
        self.fs = fs
        self.name = name
        self.relPath = relPath
        self.file = file

    def getSign(self):
        old = (-1 if ((self.fread is None)) else self.fread.tell())
        self.open()
        i = self.fread.readInt32()
        if (old < 0):
            self.close()
        else:
            self.fread.seek(old,sys_io_FileSeek.SeekBegin)
        return i

    def getBytes(self):
        return sys_io_File.getBytes(self.file)

    def open(self):
        if (self.fread is not None):
            self.fread.seek(0,sys_io_FileSeek.SeekBegin)
        else:
            self.fread = sys_io_File.read(self.file)

    def skip(self,nbytes):
        self.fread.seek(nbytes,sys_io_FileSeek.SeekCur)

    def readByte(self):
        return self.fread.readByte()

    def read(self,out,pos,size):
        self.fread.readFullBytes(out,pos,size)

    def close(self):
        if (self.fread is not None):
            self.fread.close()
            self.fread = None

    def get_isDirectory(self):
        if (self.isDirCached is not None):
            return self.isDirCached
        def _hx_local_1():
            def _hx_local_0():
                self.isDirCached = sys_FileSystem.isDirectory(self.file)
                return self.isDirCached
            return _hx_local_0()
        return _hx_local_1()

    def load(self,onReady = None):
        if (onReady is not None):
            haxe_Timer.delay(onReady,1)

    def loadBitmap(self,onLoaded):
        bmp = hxd_res_Image(self).toBitmap()
        this1 = bmp
        onLoaded(this1)

    def get_path(self):
        if (self.relPath is None):
            return "<root>"
        else:
            return self.relPath

    def exists(self,name):
        return self.fs.exists((name if ((self.relPath is None)) else ((HxOverrides.stringOrNull(self.relPath) + "/") + ("null" if name is None else name))))

    def get(self,name):
        return self.fs.get((name if ((self.relPath is None)) else ((HxOverrides.stringOrNull(self.relPath) + "/") + ("null" if name is None else name))))

    def get_size(self):
        return sys_FileSystem.stat(self.file).size

    def iterator(self):
        arr = list()
        _g = 0
        _g1 = sys_FileSystem.readDirectory(self.file)
        while (_g < len(_g1)):
            f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            f1 = f
            if ((f1 == ".svn") or ((f1 == ".git"))):
                if sys_FileSystem.isDirectory(((HxOverrides.stringOrNull(self.file) + "/") + ("null" if f is None else f))):
                    continue
                else:
                    x = self.fs.open((f if ((self.relPath is None)) else ((HxOverrides.stringOrNull(self.relPath) + "/") + ("null" if f is None else f))),False)
                    arr.append(x)
            elif (f1 == ".tmp"):
                if (self == self.fs.root):
                    continue
                else:
                    x1 = self.fs.open((f if ((self.relPath is None)) else ((HxOverrides.stringOrNull(self.relPath) + "/") + ("null" if f is None else f))),False)
                    arr.append(x1)
            else:
                x2 = self.fs.open((f if ((self.relPath is None)) else ((HxOverrides.stringOrNull(self.relPath) + "/") + ("null" if f is None else f))),False)
                arr.append(x2)
        return hxd_impl_ArrayIterator_hxd_fs_FileEntry(arr)

    def getModifTime(self):
        return (sys_FileSystem.stat((self.originalFile if ((self.originalFile is not None)) else self.file)).mtime.date.timestamp() * 1000)

    def watch(self,onChanged):
        _gthis = self
        if (onChanged is None):
            if (self.watchCallback is not None):
                python_internal_ArrayImpl.remove(hxd_fs_LocalEntry.WATCH_LIST,self)
                self.watchCallback = None
            return
        if (self.watchCallback is None):
            if (hxd_fs_LocalEntry.WATCH_LIST is None):
                hxd_fs_LocalEntry.WATCH_LIST = []
                haxe_MainLoop.add(hxd_fs_LocalEntry.checkFiles)
            path = self.get_path()
            _g = 0
            _g1 = hxd_fs_LocalEntry.WATCH_LIST
            while (_g < len(_g1)):
                w = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (w.get_path() == path):
                    w.watchCallback = None
                    python_internal_ArrayImpl.remove(hxd_fs_LocalEntry.WATCH_LIST,w)
            _this = hxd_fs_LocalEntry.WATCH_LIST
            _this.append(self)
        self.watchTime = (sys_FileSystem.stat((self.originalFile if ((self.originalFile is not None)) else self.file)).mtime.date.timestamp() * 1000)
        def _hx_local_1():
            _gthis.fs.convert.run(_gthis)
            onChanged()
        self.watchCallback = _hx_local_1

    @staticmethod
    def checkFiles():
        def _hx_local_2():
            _hx_local_0 = hxd_fs_LocalEntry
            _hx_local_1 = _hx_local_0.WATCH_INDEX
            _hx_local_0.WATCH_INDEX = (_hx_local_1 + 1)
            return _hx_local_1
        w = python_internal_ArrayImpl._get(hxd_fs_LocalEntry.WATCH_LIST, _hx_local_2())
        if (w is None):
            hxd_fs_LocalEntry.WATCH_INDEX = 0
            return
        t = None
        try:
            t = (sys_FileSystem.stat((w.originalFile if ((w.originalFile is not None)) else w.file)).mtime.date.timestamp() * 1000)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            t = -1.
        if (t == w.watchTime):
            return
        if (hxd_fs_LocalEntry.tmpDir is None):
            hxd_fs_LocalEntry.tmpDir = Sys.getEnv("TEMP")
            if (hxd_fs_LocalEntry.tmpDir is None):
                hxd_fs_LocalEntry.tmpDir = Sys.getEnv("TMPDIR")
            if (hxd_fs_LocalEntry.tmpDir is None):
                hxd_fs_LocalEntry.tmpDir = Sys.getEnv("TMP")
        lockFile = (HxOverrides.stringOrNull(hxd_fs_LocalEntry.tmpDir) + "/")
        _this = w.file
        _this1 = _this.split("/")
        lockFile1 = ((("null" if lockFile is None else lockFile) + HxOverrides.stringOrNull(((None if ((len(_this1) == 0)) else _this1.pop())))) + ".lock")
        if sys_FileSystem.exists(lockFile1):
            return
        if (not w.get_isDirectory()):
            try:
                fp = sys_io_File.append(w.file)
                fp.close()
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e1 = _hx_e1
                return
        w.watchTime = t
        w.watchCallback()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.fs = None
        _hx_o.relPath = None
        _hx_o.file = None
        _hx_o.originalFile = None
        _hx_o.fread = None
        _hx_o.isDirCached = None
        _hx_o.watchCallback = None
        _hx_o.watchTime = None
hxd_fs_LocalEntry._hx_class = hxd_fs_LocalEntry
_hx_classes["hxd.fs.LocalEntry"] = hxd_fs_LocalEntry


class hxd_fs_LocalFileSystem:
    _hx_class_name = "hxd.fs.LocalFileSystem"
    _hx_is_interface = "False"
    __slots__ = ("root", "fileCache", "baseDir", "convert", "directoryCache")
    _hx_fields = ["root", "fileCache", "baseDir", "convert", "directoryCache"]
    _hx_methods = ["getAbsolutePath", "getRoot", "checkPath", "open", "clearCache", "exists", "get", "dispose", "dir"]
    _hx_statics = ["isWindows"]
    _hx_interfaces = [hxd_fs_FileSystem]

    def __init__(self,dir,configuration):
        self.convert = None
        self.root = None
        self.directoryCache = haxe_ds_StringMap()
        self.fileCache = haxe_ds_StringMap()
        self.baseDir = dir
        if (configuration is None):
            configuration = "default"
        pr = Sys.programPath()
        exePath = None
        if (pr is None):
            exePath = None
        else:
            _this = pr.split("\\")
            _this1 = "/".join([python_Boot.toString1(x1,'') for x1 in _this])
            exePath = _this1.split("/")
        if (exePath is not None):
            if (len(exePath) != 0):
                exePath.pop()
        froot = (self.baseDir if ((exePath is None)) else sys_FileSystem.fullPath(((HxOverrides.stringOrNull("/".join([python_Boot.toString1(x1,'') for x1 in exePath])) + "/") + HxOverrides.stringOrNull(self.baseDir))))
        if (((froot is None) or (not sys_FileSystem.exists(froot))) or (not sys_FileSystem.isDirectory(froot))):
            froot = sys_FileSystem.fullPath(self.baseDir)
            if (((froot is None) or (not sys_FileSystem.exists(froot))) or (not sys_FileSystem.isDirectory(froot))):
                raise _HxException(("Could not find dir " + ("null" if dir is None else dir)))
        _this2 = froot.split("\\")
        self.baseDir = "/".join([python_Boot.toString1(x1,'') for x1 in _this2])
        if (not self.baseDir.endswith("/")):
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.baseDir
            _hx_local_0.baseDir = (("null" if _hx_local_1 is None else _hx_local_1) + "/")
            _hx_local_0.baseDir
        self.convert = hxd_fs_FileConverter(self.baseDir,configuration)
        self.root = hxd_fs_LocalEntry(self,"root",None,self.baseDir)

    def getAbsolutePath(self,f):
        def _hx_local_1():
            _hx_local_0 = f
            if (Std._hx_is(_hx_local_0,hxd_fs_LocalEntry) or ((_hx_local_0 is None))):
                _hx_local_0
            else:
                raise _HxException("Class cast error")
            return _hx_local_0
        f1 = _hx_local_1()
        return f1.file

    def getRoot(self):
        return self.root

    def checkPath(self,path):
        baseDir = haxe_io_Path(path).dir
        c = self.directoryCache.h.get(baseDir,None)
        isNew = False
        if (c is None):
            isNew = True
            c = haxe_ds_StringMap()
            _g = 0
            _g1 = None
            try:
                _g1 = sys_FileSystem.readDirectory(baseDir)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                _g1 = []
            while (_g < len(_g1)):
                f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                c.h[f] = True
            self.directoryCache.h[baseDir] = c
        if (not (HxString.substr(path,(len(baseDir) + 1),None) in c.h)):
            if (not isNew):
                self.directoryCache.remove(baseDir)
                return self.checkPath(path)
            return False
        return True

    def open(self,path,check = None):
        if (check is None):
            check = True
        r = self.fileCache.h.get(path,None)
        if (r is not None):
            return r.r
        e = None
        f = sys_FileSystem.fullPath((HxOverrides.stringOrNull(self.baseDir) + ("null" if path is None else path)))
        if (f is None):
            return None
        _this = f.split("\\")
        f = "/".join([python_Boot.toString1(x1,'') for x1 in _this])
        if ((not check) or ((((((not hxd_fs_LocalFileSystem.isWindows) or ((hxd_fs_LocalFileSystem.isWindows and ((f == ((HxOverrides.stringOrNull(self.baseDir) + ("null" if path is None else path))))))))) and sys_FileSystem.exists(f)) and self.checkPath(f)))):
            _this1 = path.split("/")
            e = hxd_fs_LocalEntry(self,(None if ((len(_this1) == 0)) else _this1.pop()),path,f)
            self.convert.run(e)
            if (e.file is None):
                e = None
        self.fileCache.h[path] = _hx_AnonObject({'r': e})
        return e

    def clearCache(self):
        path = self.fileCache.keys()
        while path.hasNext():
            path1 = path.next()
            r = self.fileCache.h.get(path1,None)
            if (r.r is None):
                self.fileCache.remove(path1)

    def exists(self,path):
        f = self.open(path)
        return (f is not None)

    def get(self,path):
        f = self.open(path)
        if (f is None):
            raise _HxException(hxd_fs_NotFound(path))
        return f

    def dispose(self):
        self.fileCache = haxe_ds_StringMap()

    def dir(self,path):
        if ((not sys_FileSystem.exists((HxOverrides.stringOrNull(self.baseDir) + ("null" if path is None else path)))) or (not sys_FileSystem.isDirectory((HxOverrides.stringOrNull(self.baseDir) + ("null" if path is None else path))))):
            raise _HxException(hxd_fs_NotFound((HxOverrides.stringOrNull(self.baseDir) + ("null" if path is None else path))))
        files = sys_FileSystem.readDirectory((HxOverrides.stringOrNull(self.baseDir) + ("null" if path is None else path)))
        r = []
        _g = 0
        while (_g < len(files)):
            f = (files[_g] if _g >= 0 and _g < len(files) else None)
            _g = (_g + 1)
            x = self.open(((("null" if path is None else path) + "/") + ("null" if f is None else f)),False)
            r.append(x)
        return r

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.root = None
        _hx_o.fileCache = None
        _hx_o.baseDir = None
        _hx_o.convert = None
        _hx_o.directoryCache = None
hxd_fs_LocalFileSystem._hx_class = hxd_fs_LocalFileSystem
_hx_classes["hxd.fs.LocalFileSystem"] = hxd_fs_LocalFileSystem


class hxd_fs_NotFound:
    _hx_class_name = "hxd.fs.NotFound"
    _hx_is_interface = "False"
    __slots__ = ("path",)
    _hx_fields = ["path"]
    _hx_methods = ["toString"]

    def __init__(self,path):
        self.path = path

    def toString(self):
        return (("Resource file not found '" + HxOverrides.stringOrNull(self.path)) + "'")

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.path = None
hxd_fs_NotFound._hx_class = hxd_fs_NotFound
_hx_classes["hxd.fs.NotFound"] = hxd_fs_NotFound


class hxd_impl__Allocator_BufferFlags_Impl_:
    _hx_class_name = "hxd.impl._Allocator.BufferFlags_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["Dynamic", "UniformDynamic", "toInt"]

    @staticmethod
    def toInt(this1):
        return this1
hxd_impl__Allocator_BufferFlags_Impl_._hx_class = hxd_impl__Allocator_BufferFlags_Impl_
_hx_classes["hxd.impl._Allocator.BufferFlags_Impl_"] = hxd_impl__Allocator_BufferFlags_Impl_


class hxd_impl_Allocator:
    _hx_class_name = "hxd.impl.Allocator"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_methods = ["allocBuffer", "disposeBuffer", "allocIndexBuffer", "disposeIndexBuffer", "onContextLost", "allocFloats", "disposeFloats", "allocIndexes", "disposeIndexes"]
    _hx_statics = ["inst", "set", "get"]

    def __init__(self):
        pass

    def allocBuffer(self,vertices,stride,flags):
        tmp = None
        flags1 = flags
        if (flags1 == 0):
            tmp = [h3d_BufferFlag.Dynamic]
        elif (flags1 == 1):
            tmp = [h3d_BufferFlag.UniformBuffer, h3d_BufferFlag.Dynamic]
        else:
            pass
        return h3d_Buffer(vertices,stride,tmp)

    def disposeBuffer(self,b):
        b.dispose()

    def allocIndexBuffer(self,count):
        return h3d_Indexes(count)

    def disposeIndexBuffer(self,i):
        i.dispose()

    def onContextLost(self):
        pass

    def allocFloats(self,count):
        length = count
        if (length is None):
            length = 0
        this1 = list()
        if (length > 0):
            if (length > len(this1)):
                python_internal_ArrayImpl._set(this1, (length - 1), 0.)
        return this1

    def disposeFloats(self,f):
        pass

    def allocIndexes(self,count):
        length = count
        if (length is None):
            length = 0
        this1 = list()
        if (length > 0):
            if (length > len(this1)):
                python_internal_ArrayImpl._set(this1, (length - 1), 0)
        return this1

    def disposeIndexes(self,i):
        pass
    inst = None

    @staticmethod
    def set(a):
        hxd_impl_Allocator.inst = a

    @staticmethod
    def get():
        if (hxd_impl_Allocator.inst is None):
            hxd_impl_Allocator.inst = hxd_impl_Allocator()
        return hxd_impl_Allocator.inst

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
hxd_impl_Allocator._hx_class = hxd_impl_Allocator
_hx_classes["hxd.impl.Allocator"] = hxd_impl_Allocator


class hxd_impl_Api:
    _hx_class_name = "hxd.impl.Api"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["downcast"]

    @staticmethod
    def downcast(value,c):
        return Std.downcast(value,c)
hxd_impl_Api._hx_class = hxd_impl_Api
_hx_classes["hxd.impl.Api"] = hxd_impl_Api


class hxd_impl_ArrayIterator:
    _hx_class_name = "hxd.impl.ArrayIterator"
    _hx_is_interface = "False"
    __slots__ = ("i", "l", "a")
    _hx_fields = ["i", "l", "a"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,a):
        self.l = None
        self.i = 0
        self.a = a
        self.l = len(self.a)

    def hasNext(self):
        return (self.i < self.l)

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.i
                _hx_local_0.i = (_hx_local_1 + 1)
                return _hx_local_1
            return python_internal_ArrayImpl._get(self.a, _hx_local_2())
        return _hx_local_3()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.i = None
        _hx_o.l = None
        _hx_o.a = None
hxd_impl_ArrayIterator._hx_class = hxd_impl_ArrayIterator
_hx_classes["hxd.impl.ArrayIterator"] = hxd_impl_ArrayIterator


class hxd_impl_ArrayIterator_h2d_Object:
    _hx_class_name = "hxd.impl.ArrayIterator_h2d_Object"
    _hx_is_interface = "False"
    __slots__ = ("i", "l", "a")
    _hx_fields = ["i", "l", "a"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,a):
        self.l = None
        self.i = 0
        self.a = a
        self.l = len(self.a)

    def hasNext(self):
        return (self.i < self.l)

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.i
                _hx_local_0.i = (_hx_local_1 + 1)
                return _hx_local_1
            return python_internal_ArrayImpl._get(self.a, _hx_local_2())
        return _hx_local_3()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.i = None
        _hx_o.l = None
        _hx_o.a = None
hxd_impl_ArrayIterator_h2d_Object._hx_class = hxd_impl_ArrayIterator_h2d_Object
_hx_classes["hxd.impl.ArrayIterator_h2d_Object"] = hxd_impl_ArrayIterator_h2d_Object


class hxd_impl_ArrayIterator_h3d_scene_Object:
    _hx_class_name = "hxd.impl.ArrayIterator_h3d_scene_Object"
    _hx_is_interface = "False"
    __slots__ = ("i", "l", "a")
    _hx_fields = ["i", "l", "a"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,a):
        self.l = None
        self.i = 0
        self.a = a
        self.l = len(self.a)

    def hasNext(self):
        return (self.i < self.l)

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.i
                _hx_local_0.i = (_hx_local_1 + 1)
                return _hx_local_1
            return python_internal_ArrayImpl._get(self.a, _hx_local_2())
        return _hx_local_3()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.i = None
        _hx_o.l = None
        _hx_o.a = None
hxd_impl_ArrayIterator_h3d_scene_Object._hx_class = hxd_impl_ArrayIterator_h3d_scene_Object
_hx_classes["hxd.impl.ArrayIterator_h3d_scene_Object"] = hxd_impl_ArrayIterator_h3d_scene_Object


class hxd_impl_ArrayIterator_hxd_fs_FileEntry:
    _hx_class_name = "hxd.impl.ArrayIterator_hxd_fs_FileEntry"
    _hx_is_interface = "False"
    __slots__ = ("i", "l", "a")
    _hx_fields = ["i", "l", "a"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,a):
        self.l = None
        self.i = 0
        self.a = a
        self.l = len(self.a)

    def hasNext(self):
        return (self.i < self.l)

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.i
                _hx_local_0.i = (_hx_local_1 + 1)
                return _hx_local_1
            return python_internal_ArrayImpl._get(self.a, _hx_local_2())
        return _hx_local_3()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.i = None
        _hx_o.l = None
        _hx_o.a = None
hxd_impl_ArrayIterator_hxd_fs_FileEntry._hx_class = hxd_impl_ArrayIterator_hxd_fs_FileEntry
_hx_classes["hxd.impl.ArrayIterator_hxd_fs_FileEntry"] = hxd_impl_ArrayIterator_hxd_fs_FileEntry


class hxd_impl_ArrayIterator_hxd_res_Any:
    _hx_class_name = "hxd.impl.ArrayIterator_hxd_res_Any"
    _hx_is_interface = "False"
    __slots__ = ("i", "l", "a")
    _hx_fields = ["i", "l", "a"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,a):
        self.l = None
        self.i = 0
        self.a = a
        self.l = len(self.a)

    def hasNext(self):
        return (self.i < self.l)

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.i
                _hx_local_0.i = (_hx_local_1 + 1)
                return _hx_local_1
            return python_internal_ArrayImpl._get(self.a, _hx_local_2())
        return _hx_local_3()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.i = None
        _hx_o.l = None
        _hx_o.a = None
hxd_impl_ArrayIterator_hxd_res_Any._hx_class = hxd_impl_ArrayIterator_hxd_res_Any
_hx_classes["hxd.impl.ArrayIterator_hxd_res_Any"] = hxd_impl_ArrayIterator_hxd_res_Any


class hxd_impl_ArrayIterator_hxd_snd_Channel:
    _hx_class_name = "hxd.impl.ArrayIterator_hxd_snd_Channel"
    _hx_is_interface = "False"
    __slots__ = ("i", "l", "a")
    _hx_fields = ["i", "l", "a"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,a):
        self.l = None
        self.i = 0
        self.a = a
        self.l = len(self.a)

    def hasNext(self):
        return (self.i < self.l)

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.i
                _hx_local_0.i = (_hx_local_1 + 1)
                return _hx_local_1
            return python_internal_ArrayImpl._get(self.a, _hx_local_2())
        return _hx_local_3()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.i = None
        _hx_o.l = None
        _hx_o.a = None
hxd_impl_ArrayIterator_hxd_snd_Channel._hx_class = hxd_impl_ArrayIterator_hxd_snd_Channel
_hx_classes["hxd.impl.ArrayIterator_hxd_snd_Channel"] = hxd_impl_ArrayIterator_hxd_snd_Channel


class hxd_impl__UncheckedBytes_UncheckedBytes_Impl_:
    _hx_class_name = "hxd.impl._UncheckedBytes.UncheckedBytes_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "get", "set", "fromBytes"]

    @staticmethod
    def _new(v):
        this1 = v
        return this1

    @staticmethod
    def get(this1,i):
        return this1[i]

    @staticmethod
    def set(this1,i,v):
        this1[i] = v
        return v

    @staticmethod
    def fromBytes(b):
        this1 = b.b
        return this1
hxd_impl__UncheckedBytes_UncheckedBytes_Impl_._hx_class = hxd_impl__UncheckedBytes_UncheckedBytes_Impl_
_hx_classes["hxd.impl._UncheckedBytes.UncheckedBytes_Impl_"] = hxd_impl__UncheckedBytes_UncheckedBytes_Impl_


class hxd_res__Any_SingleFileSystem(hxd_fs_BytesFileSystem):
    _hx_class_name = "hxd.res._Any.SingleFileSystem"
    _hx_is_interface = "False"
    __slots__ = ("path", "bytes")
    _hx_fields = ["path", "bytes"]
    _hx_methods = ["getBytes"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = hxd_fs_BytesFileSystem


    def __init__(self,path,_hx_bytes):
        self.bytes = None
        self.path = None
        super().__init__()
        self.path = path
        self.bytes = _hx_bytes

    def getBytes(self,p):
        if (p == self.path):
            return self.bytes
        else:
            return None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.path = None
        _hx_o.bytes = None
hxd_res__Any_SingleFileSystem._hx_class = hxd_res__Any_SingleFileSystem
_hx_classes["hxd.res._Any.SingleFileSystem"] = hxd_res__Any_SingleFileSystem


class hxd_res_Resource:
    _hx_class_name = "hxd.res.Resource"
    _hx_is_interface = "False"
    __slots__ = ("entry",)
    _hx_fields = ["entry"]
    _hx_methods = ["get_name", "toString", "watch"]
    _hx_statics = ["LIVE_UPDATE"]

    def __init__(self,entry):
        self.entry = entry

    def get_name(self):
        return self.entry.name

    def toString(self):
        return self.entry.get_path()

    def watch(self,onChanged):
        if hxd_res_Resource.LIVE_UPDATE:
            self.entry.watch(onChanged)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.entry = None
hxd_res_Resource._hx_class = hxd_res_Resource
_hx_classes["hxd.res.Resource"] = hxd_res_Resource


class hxd_res_Any(hxd_res_Resource):
    _hx_class_name = "hxd.res.Any"
    _hx_is_interface = "False"
    __slots__ = ("loader",)
    _hx_fields = ["loader"]
    _hx_methods = ["toModel", "toTexture", "toTile", "toText", "toImage", "toSound", "toPrefab", "to", "iterator"]
    _hx_statics = ["fromBytes"]
    _hx_interfaces = []
    _hx_super = hxd_res_Resource


    def __init__(self,loader,entry):
        self.loader = None
        super().__init__(entry)
        self.loader = loader

    def toModel(self):
        return self.loader.loadCache(self.entry.get_path(),hxd_res_Model)

    def toTexture(self):
        return self.toImage().toTexture()

    def toTile(self):
        return self.toImage().toTile()

    def toText(self):
        return self.entry.getBytes().toString()

    def toImage(self):
        return self.loader.loadCache(self.entry.get_path(),hxd_res_Image)

    def toSound(self):
        return self.loader.loadCache(self.entry.get_path(),hxd_res_Sound)

    def toPrefab(self):
        return self.loader.loadCache(self.entry.get_path(),hxd_res_Resource)

    def to(self,c):
        return self.loader.loadCache(self.entry.get_path(),c)

    def iterator(self):
        _g2 = []
        _g3 = self.entry.iterator()
        while (_g3.i < _g3.l):
            def _hx_local_1():
                _hx_local_0 = _g3.i
                _g3.i = (_g3.i + 1)
                return _hx_local_0
            f = python_internal_ArrayImpl._get(_g3.a, _hx_local_1())
            x = hxd_res_Any(self.loader,f)
            _g2.append(x)
        return hxd_impl_ArrayIterator_hxd_res_Any(_g2)

    @staticmethod
    def fromBytes(path,_hx_bytes):
        fs = hxd_res__Any_SingleFileSystem(path,_hx_bytes)
        return hxd_res_Loader(fs).load(path)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.loader = None
hxd_res_Any._hx_class = hxd_res_Any
_hx_classes["hxd.res.Any"] = hxd_res_Any


class hxd_res__Image_ImageFormat_Impl_:
    _hx_class_name = "hxd.res._Image.ImageFormat_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["Jpg", "Png", "Gif", "Tga", "Dds", "get_useAsyncDecode", "toInt"]
    useAsyncDecode = None

    @staticmethod
    def get_useAsyncDecode(this1):
        return (this1 == 0)

    @staticmethod
    def toInt(this1):
        return this1
hxd_res__Image_ImageFormat_Impl_._hx_class = hxd_res__Image_ImageFormat_Impl_
_hx_classes["hxd.res._Image.ImageFormat_Impl_"] = hxd_res__Image_ImageFormat_Impl_


class hxd_res_Image(hxd_res_Resource):
    _hx_class_name = "hxd.res.Image"
    _hx_is_interface = "False"
    __slots__ = ("tex", "inf")
    _hx_fields = ["tex", "inf"]
    _hx_methods = ["getFormat", "getSize", "getPixels", "toBitmap", "watchCallb", "loadTexture", "toTexture", "toTile"]
    _hx_statics = ["ALLOW_NPOT", "DEFAULT_FILTER", "DEFAULT_ASYNC", "ENABLE_AUTO_WATCH"]
    _hx_interfaces = []
    _hx_super = hxd_res_Resource


    def __init__(self,entry):
        self.inf = None
        self.tex = None
        super().__init__(entry)

    def getFormat(self):
        self.getSize()
        return self.inf.format

    def getSize(self):
        if (self.inf is not None):
            return self.inf
        f = hxd_fs_FileInput(self.entry)
        width = 0
        height = 0
        format = None
        bc = 0
        head = None
        try:
            head = f.readUInt16()
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            if isinstance(_hx_e1, haxe_io_Eof):
                e = _hx_e1
                head = 0
            else:
                raise _hx_e
        head1 = head
        if (head1 == 17476):
            format = 4
            f.skip(10)
            height = f.readInt32()
            width = f.readInt32()
            f.skip(64)
            fourCC = f.readInt32()
            _g = (fourCC & 16777215)
            if (_g == 4805697):
                v = ((HxOverrides.rshift(fourCC, 24)) - 48)
                v1 = v
                if (v1 == 1):
                    bc = 4
                elif (v1 == 2):
                    bc = 5
                else:
                    bc = 0
            elif (_g == 5527620):
                dxt = ((HxOverrides.rshift(fourCC, 24)) - 48)
                dxt1 = dxt
                if (dxt1 == 1):
                    bc = 1
                elif ((dxt1 == 3) or ((dxt1 == 2))):
                    bc = 2
                elif ((dxt1 == 5) or ((dxt1 == 4))):
                    bc = 3
                else:
                    bc = 0
            elif (fourCC == 808540228):
                f.skip(40)
                dxgi = f.readInt32()
                dxgi1 = dxgi
                if (dxgi1 == 95):
                    bc = 6
                elif (dxgi1 == 98):
                    bc = 7
                else:
                    raise _HxException(((HxOverrides.stringOrNull(self.entry.get_path()) + " has unsupported DXGI format ") + Std.string(dxgi)))
            if (bc == 0):
                raise _HxException((((((HxOverrides.stringOrNull(self.entry.get_path()) + " has unsupported 4CC ") + HxOverrides.stringOrNull("".join(map(chr,[(fourCC & 255)])))) + HxOverrides.stringOrNull("".join(map(chr,[((fourCC >> 8) & 255)])))) + HxOverrides.stringOrNull("".join(map(chr,[((fourCC >> 16) & 255)])))) + HxOverrides.stringOrNull("".join(map(chr,[HxOverrides.rshift(fourCC, 24)])))))
        elif (head1 == 18759):
            format = 2
            f.readInt32()
            width = f.readUInt16()
            height = f.readUInt16()
        elif (head1 == 20617):
            format = 1
            f.set_bigEndian(True)
            f.skip(6)
            while True:
                dataLen = f.readInt32()
                if (f.readInt32() == 1229472850):
                    width = f.readInt32()
                    height = f.readInt32()
                    break
                f.skip((dataLen + 4))
        elif (head1 == 55551):
            format = 0
            f.set_bigEndian(True)
            while True:
                _g1 = f.readUInt16()
                if (((_g1 == 65474) or ((_g1 == 65473))) or ((_g1 == 65472))):
                    _hx_len = f.readUInt16()
                    prec = f.readByte()
                    height = f.readUInt16()
                    width = f.readUInt16()
                    break
                else:
                    f.skip((f.readUInt16() - 2))
        elif (self.entry.get_extension() == "tga"):
            format = 3
            f.skip(10)
            width = f.readUInt16()
            height = f.readUInt16()
        else:
            raise _HxException(("Unsupported texture format " + HxOverrides.stringOrNull(self.entry.get_path())))
        f.close()
        self.inf = _hx_AnonObject({'width': width, 'height': height, 'format': format, 'bc': bc})
        return self.inf

    def getPixels(self,fmt = None,flipY = None):
        self.getSize()
        pixels = None
        _g = self.inf.format
        if (_g == 0):
            _hx_bytes = self.entry.getBytes()
            p = None
            try:
                p = hxd_res_NanoJpeg.decode(_hx_bytes)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                raise _HxException((((("Failed to decode JPG " + HxOverrides.stringOrNull(self.entry.get_path())) + " (") + Std.string(e)) + ")"))
            pixels = hxd_Pixels(p.width,p.height,p.pixels,hxd_PixelFormat.BGRA)
        elif (_g == 1):
            bytes1 = self.entry.getBytes()
            png = format_png_Reader(haxe_io_BytesInput(bytes1))
            png.checkCRC = False
            pixels = hxd_Pixels.alloc(self.inf.width,self.inf.height,hxd_PixelFormat.BGRA)
            pdata = png.read()
            format_png_Tools.extract32(pdata,pixels.bytes,flipY)
            if flipY:
                pixels.flags = (pixels.flags | ((1 << hxd_Flags.FlipY.index)))
        elif (_g == 2):
            bytes2 = self.entry.getBytes()
            gif = format_gif_Reader(haxe_io_BytesInput(bytes2)).read()
            pixels = hxd_Pixels(self.inf.width,self.inf.height,format_gif_Tools.extractFullBGRA(gif,0),hxd_PixelFormat.BGRA)
        elif (_g == 3):
            bytes3 = self.entry.getBytes()
            r = format_tga_Reader(haxe_io_BytesInput(bytes3)).read()
            if ((r.header.imageType != format_tga_ImageType.UncompressedTrueColor) or ((r.header.bitsPerPixel != 32))):
                raise _HxException(((("Not supported " + Std.string(r.header.imageType)) + "/") + Std.string(r.header.bitsPerPixel)))
            w = r.header.width
            h = r.header.height
            pixels = hxd_Pixels.alloc(w,h,hxd_PixelFormat.ARGB)
            access = hxd__Pixels_PixelsARGB_Impl_.fromPixels(pixels)
            p1 = 0
            _g1 = 0
            _g11 = h
            while (_g1 < _g11):
                y = _g1
                _g1 = (_g1 + 1)
                _g2 = 0
                _g12 = w
                while (_g2 < _g12):
                    x = _g2
                    _g2 = (_g2 + 1)
                    c = r.imageData[(x + ((y * w)))]
                    _this = access.bytes
                    pos = ((((x + ((y * access.width))) << 2)) + access.offset)
                    v = (((HxOverrides.rshift(c, 24) | (((c >> 8) & 65280))) | (((c << 8) & 16711680))) | ((c << 24)))
                    _this.b[pos] = (v & 255)
                    _this.b[(pos + 1)] = ((v >> 8) & 255)
                    _this.b[(pos + 2)] = ((v >> 16) & 255)
                    _this.b[(pos + 3)] = (HxOverrides.rshift(v, 24) & 255)
            tmp = r.header.imageOrigin.index
            if (tmp == 0):
                pixels.flags = (pixels.flags | ((1 << hxd_Flags.FlipY.index)))
            elif (tmp == 2):
                pass
            else:
                raise _HxException(("Not supported " + Std.string(r.header.imageOrigin)))
        elif (_g == 4):
            bytes4 = self.entry.getBytes()
            pixels = hxd_Pixels(self.inf.width,self.inf.height,bytes4,hxd_PixelFormat.S3TC(self.inf.bc),(128 + ((20 if ((self.inf.bc >= 6)) else 0))))
        else:
            pass
        if (fmt is not None):
            pixels.convert(fmt)
        if (flipY is not None):
            pixels.setFlip(flipY)
        return pixels

    def toBitmap(self):
        self.getSize()
        bmp = hxd_BitmapData(self.inf.width,self.inf.height)
        pixels = self.getPixels()
        bmp.setPixels(pixels)
        pixels.dispose()
        return bmp

    def watchCallb(self):
        w = self.inf.width
        h = self.inf.height
        self.inf = None
        s = self.getSize()
        if ((w != s.width) or ((h != s.height))):
            self.tex.resize(w,h)
        self.tex.realloc = None
        self.loadTexture()

    def loadTexture(self):
        _gthis = self
        if ((self.getFormat() != 0) and (not hxd_res_Image.DEFAULT_ASYNC)):
            def _hx_local_0():
                _gthis.tex.alloc()
                pixels = _gthis.getPixels(_gthis.tex.format)
                if ((pixels.width != _gthis.tex.width) or ((pixels.height != _gthis.tex.height))):
                    pixels.makeSquare()
                _gthis.tex.uploadPixels(pixels)
                pixels.dispose()
                _gthis.tex.realloc = _gthis.loadTexture
                if hxd_res_Image.ENABLE_AUTO_WATCH:
                    _gthis.watch(_gthis.watchCallb)
            load = _hx_local_0
            if self.entry.get_isAvailable():
                load()
            else:
                self.entry.load(load)
        else:
            _hx_local_1 = self.tex
            _hx_local_2 = _hx_local_1.flags
            _hx_local_1.flags = (_hx_local_2 | ((1 << h3d_mat_TextureFlags.Loading.index)))
            _hx_local_1.flags
            def _hx_local_6(bmp):
                bmp1 = hxd_fs__LoadedBitmap_LoadedBitmap_Impl_.toBitmap(bmp)
                _gthis.tex.alloc()
                if ((bmp1.data.width != _gthis.tex.width) or ((bmp1.data.height != _gthis.tex.height))):
                    pixels1 = bmp1.getPixels()
                    pixels1.makeSquare()
                    _gthis.tex.uploadPixels(pixels1)
                    pixels1.dispose()
                else:
                    _gthis.tex.uploadBitmap(bmp1)
                bmp1.data = None
                _gthis.tex.realloc = _gthis.loadTexture
                _hx_local_3 = _gthis.tex
                _hx_local_4 = _hx_local_3.flags
                _hx_local_3.flags = (_hx_local_4 & ((-1 - ((1 << h3d_mat_TextureFlags.Loading.index)))))
                _hx_local_3.flags
                if (_gthis.tex.waitLoads is not None):
                    arr = _gthis.tex.waitLoads
                    _gthis.tex.waitLoads = None
                    _g = 0
                    while (_g < len(arr)):
                        f = (arr[_g] if _g >= 0 and _g < len(arr) else None)
                        _g = (_g + 1)
                        f()
                if hxd_res_Image.ENABLE_AUTO_WATCH:
                    _gthis.watch(_gthis.watchCallb)
            self.entry.loadBitmap(_hx_local_6)

    def toTexture(self):
        if (self.tex is not None):
            return self.tex
        self.getSize()
        width = self.inf.width
        height = self.inf.height
        if (not hxd_res_Image.ALLOW_NPOT):
            tw = 1
            th = 1
            while (tw < width):
                tw = (tw << 1)
            while (th < height):
                th = (th << 1)
            width = tw
            height = th
        format = h3d_mat_Texture.nativeFormat
        if (self.inf.format == 4):
            format = hxd_PixelFormat.S3TC(self.inf.bc)
        self.tex = h3d_mat_Texture(width,height,[h3d_mat_TextureFlags.NoAlloc],format)
        if (hxd_res_Image.DEFAULT_FILTER != h3d_mat_Filter.Linear):
            self.tex.set_filter(hxd_res_Image.DEFAULT_FILTER)
        self.tex.setName(self.entry.get_path())
        self.loadTexture()
        return self.tex

    def toTile(self):
        size = self.getSize()
        return h2d_Tile.fromTexture(self.toTexture()).sub(0,0,size.width,size.height)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.tex = None
        _hx_o.inf = None
hxd_res_Image._hx_class = hxd_res_Image
_hx_classes["hxd.res.Image"] = hxd_res_Image


class hxd_res_Loader:
    _hx_class_name = "hxd.res.Loader"
    _hx_is_interface = "False"
    __slots__ = ("fs", "cache")
    _hx_fields = ["fs", "cache"]
    _hx_methods = ["cleanCache", "dir", "exists", "load", "loadCache", "dispose"]
    _hx_statics = ["currentInstance"]

    def __init__(self,fs):
        self.fs = fs
        self.cache = haxe_ds_StringMap()

    def cleanCache(self):
        self.cache = haxe_ds_StringMap()

    def dir(self,path):
        r = []
        entries = self.fs.dir(path)
        _g = 0
        while (_g < len(entries)):
            e = (entries[_g] if _g >= 0 and _g < len(entries) else None)
            _g = (_g + 1)
            x = hxd_res_Any(self,e)
            r.append(x)
        return r

    def exists(self,path):
        return self.fs.exists(path)

    def load(self,path):
        return hxd_res_Any(self,self.fs.get(path))

    def loadCache(self,path,c):
        res = self.cache.h.get(path,None)
        if (res is None):
            entry = self.fs.get(path)
            old = hxd_res_Loader.currentInstance
            hxd_res_Loader.currentInstance = self
            res = c(*[entry])
            hxd_res_Loader.currentInstance = old
            self.cache.h[path] = res
        elif (Std.downcast(res,c) is None):
            raise _HxException(((((("null" if path is None else path) + " has been reintrepreted from ") + Std.string(Type.getClass(res))) + " to ") + Std.string(c)))
        return res

    def dispose(self):
        self.cleanCache()
        self.fs.dispose()
    currentInstance = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.fs = None
        _hx_o.cache = None
hxd_res_Loader._hx_class = hxd_res_Loader
_hx_classes["hxd.res.Loader"] = hxd_res_Loader


class hxd_res_Model(hxd_res_Resource):
    _hx_class_name = "hxd.res.Model"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["toHmd"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = hxd_res_Resource


    def __init__(self,entry):
        super().__init__(entry)

    def toHmd(self):
        fs = hxd_fs_FileInput(self.entry)
        hmd = hxd_fmt_hmd_Reader(fs).readHeader()
        fs.close()
        return hxd_fmt_hmd_Library(self,hmd)

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
hxd_res_Model._hx_class = hxd_res_Model
_hx_classes["hxd.res.Model"] = hxd_res_Model

class hxd_res_Filter(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.res.Filter"
    _hx_constructs = ["Fast", "Chromatic"]
hxd_res_Filter.Fast = hxd_res_Filter("Fast", 0, ())
hxd_res_Filter.Chromatic = hxd_res_Filter("Chromatic", 1, ())
hxd_res_Filter._hx_class = hxd_res_Filter
_hx_classes["hxd.res.Filter"] = hxd_res_Filter


class hxd_res__NanoJpeg_FastBytes_Impl_:
    _hx_class_name = "hxd.res._NanoJpeg.FastBytes_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "get", "set"]

    @staticmethod
    def _new(b):
        this1 = b
        return this1

    @staticmethod
    def get(this1,i):
        return this1.b[i]

    @staticmethod
    def set(this1,i,v):
        this1.b[i] = (v & 255)
hxd_res__NanoJpeg_FastBytes_Impl_._hx_class = hxd_res__NanoJpeg_FastBytes_Impl_
_hx_classes["hxd.res._NanoJpeg.FastBytes_Impl_"] = hxd_res__NanoJpeg_FastBytes_Impl_


class hxd_res__NanoJpeg_Component:
    _hx_class_name = "hxd.res._NanoJpeg.Component"
    _hx_is_interface = "False"
    __slots__ = ("cid", "ssx", "ssy", "width", "height", "stride", "qtsel", "actabsel", "dctabsel", "dcpred", "pixels")
    _hx_fields = ["cid", "ssx", "ssy", "width", "height", "stride", "qtsel", "actabsel", "dctabsel", "dcpred", "pixels"]

    def __init__(self):
        self.pixels = None
        self.dcpred = None
        self.dctabsel = None
        self.actabsel = None
        self.qtsel = None
        self.stride = None
        self.height = None
        self.width = None
        self.ssy = None
        self.ssx = None
        self.cid = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.cid = None
        _hx_o.ssx = None
        _hx_o.ssy = None
        _hx_o.width = None
        _hx_o.height = None
        _hx_o.stride = None
        _hx_o.qtsel = None
        _hx_o.actabsel = None
        _hx_o.dctabsel = None
        _hx_o.dcpred = None
        _hx_o.pixels = None
hxd_res__NanoJpeg_Component._hx_class = hxd_res__NanoJpeg_Component
_hx_classes["hxd.res._NanoJpeg.Component"] = hxd_res__NanoJpeg_Component


class hxd_res_NanoJpeg:
    _hx_class_name = "hxd.res.NanoJpeg"
    _hx_is_interface = "False"
    __slots__ = ("bytes", "pos", "size", "length", "width", "height", "ncomp", "comps", "counts", "qtab", "qtused", "qtavail", "vlctab", "block", "njZZ", "progressive", "mbsizex", "mbsizey", "mbwidth", "mbheight", "rstinterval", "buf", "bufbits", "pixels", "filter", "vlcCode")
    _hx_fields = ["bytes", "pos", "size", "length", "width", "height", "ncomp", "comps", "counts", "qtab", "qtused", "qtavail", "vlctab", "block", "njZZ", "progressive", "mbsizex", "mbsizey", "mbwidth", "mbheight", "rstinterval", "buf", "bufbits", "pixels", "filter", "vlcCode"]
    _hx_methods = ["alloc", "free", "njInit", "cleanup", "njSkip", "syntax", "get", "njDecode16", "njByteAlign", "njShowBits", "njSkipBits", "njGetBits", "njDecodeLength", "njSkipMarker", "njDecodeSOF", "njDecodeDQT", "njDecodeDHT", "njDecodeDRI", "njGetVLC", "njRowIDCT", "njColIDCT", "njDecodeBlock", "notSupported", "njDecodeScan", "njUpsampleH", "njUpsampleV", "njUpsample", "njConvert", "njDecode"]
    _hx_statics = ["BLOCKSIZE", "W1", "W2", "W3", "W5", "W6", "W7", "CF4A", "CF4B", "CF4C", "CF4D", "CF3A", "CF3B", "CF3C", "CF3X", "CF3Y", "CF3Z", "CF2A", "CF2B", "CF", "njClip", "inst", "decode"]

    def __init__(self):
        self.vlcCode = None
        self.filter = None
        self.pixels = None
        self.bufbits = None
        self.buf = None
        self.rstinterval = None
        self.mbheight = None
        self.mbwidth = None
        self.mbsizey = None
        self.mbsizex = None
        self.progressive = None
        self.qtavail = None
        self.qtused = None
        self.ncomp = None
        self.height = None
        self.width = None
        self.length = None
        self.size = None
        self.pos = None
        self.bytes = None
        self.comps = list([hxd_res__NanoJpeg_Component(), hxd_res__NanoJpeg_Component(), hxd_res__NanoJpeg_Component()])
        this1 = [None]*64
        this2 = [None]*64
        this3 = [None]*64
        this4 = [None]*64
        self.qtab = list([this1, this2, this3, this4])
        this5 = [None]*16
        self.counts = this5
        this6 = [None]*64
        self.block = this6
        self.njZZ = list([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63])
        self.vlctab = list([None, None, None, None, None, None, None, None])

    def alloc(self,nbytes):
        return haxe_io_Bytes.alloc(nbytes)

    def free(self,_hx_bytes):
        pass

    def njInit(self,_hx_bytes,pos,size,_hx_filter):
        self.bytes = _hx_bytes
        self.pos = pos
        self.filter = (hxd_res_Filter.Chromatic if ((_hx_filter is None)) else _hx_filter)
        if (size < 0):
            size = (_hx_bytes.length - pos)
        if (self.vlctab[0] is None):
            this1 = self.vlctab
            val = haxe_io_Bytes.alloc(131072)
            this1[0] = val
        if (self.vlctab[1] is None):
            this2 = self.vlctab
            val1 = haxe_io_Bytes.alloc(131072)
            this2[1] = val1
        if (self.vlctab[2] is None):
            this3 = self.vlctab
            val2 = haxe_io_Bytes.alloc(131072)
            this3[2] = val2
        if (self.vlctab[3] is None):
            this4 = self.vlctab
            val3 = haxe_io_Bytes.alloc(131072)
            this4[3] = val3
        self.size = size
        self.qtused = 0
        self.qtavail = 0
        self.rstinterval = 0
        self.length = 0
        self.buf = 0
        self.bufbits = 0
        self.progressive = False
        self.comps[0].dcpred = 0
        self.comps[1].dcpred = 0
        self.comps[2].dcpred = 0

    def cleanup(self):
        self.bytes = None
        _g = 0
        _g1 = self.comps
        while (_g < len(_g1)):
            c = _g1[_g]
            _g = (_g + 1)
            if (c.pixels is not None):
                c.pixels = None
        if (self.vlctab[0] is not None):
            _hx_bytes = self.vlctab[0]
            val = None
            self.vlctab[0] = val
        if (self.vlctab[1] is not None):
            bytes1 = self.vlctab[1]
            val1 = None
            self.vlctab[1] = val1
        if (self.vlctab[2] is not None):
            bytes2 = self.vlctab[2]
            val2 = None
            self.vlctab[2] = val2
        if (self.vlctab[3] is not None):
            bytes3 = self.vlctab[3]
            val3 = None
            self.vlctab[3] = val3
        if (self.vlctab[4] is not None):
            bytes4 = self.vlctab[4]
            val4 = None
            self.vlctab[4] = val4
        if (self.vlctab[5] is not None):
            bytes5 = self.vlctab[5]
            val5 = None
            self.vlctab[5] = val5
        if (self.vlctab[6] is not None):
            bytes6 = self.vlctab[6]
            val6 = None
            self.vlctab[6] = val6
        if (self.vlctab[7] is not None):
            bytes7 = self.vlctab[7]
            val7 = None
            self.vlctab[7] = val7

    def njSkip(self,count):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + count)
        _hx_local_0.pos
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.size
        _hx_local_2.size = (_hx_local_3 - count)
        _hx_local_2.size
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.length
        _hx_local_4.length = (_hx_local_5 - count)
        _hx_local_4.length

    def syntax(self,flag):
        pass

    def get(self,p):
        return self.bytes.b[(self.pos + p)]

    def njDecode16(self,p):
        return ((self.bytes.b[(self.pos + p)] << 8) | self.bytes.b[(self.pos + ((p + 1)))])

    def njByteAlign(self):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.bufbits
        _hx_local_0.bufbits = (_hx_local_1 & 248)
        _hx_local_0.bufbits

    def njShowBits(self,bits):
        if (bits == 0):
            return 0
        while (self.bufbits < bits):
            if (self.size <= 0):
                self.buf = ((self.buf << 8) | 255)
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.bufbits
                _hx_local_0.bufbits = (_hx_local_1 + 8)
                _hx_local_0.bufbits
                continue
            newbyte = self.bytes.b[self.pos]
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.pos
            _hx_local_2.pos = (_hx_local_3 + 1)
            _hx_local_3
            _hx_local_4 = self
            _hx_local_5 = _hx_local_4.size
            _hx_local_4.size = (_hx_local_5 - 1)
            _hx_local_5
            _hx_local_6 = self
            _hx_local_7 = _hx_local_6.bufbits
            _hx_local_6.bufbits = (_hx_local_7 + 8)
            _hx_local_6.bufbits
            self.buf = ((self.buf << 8) | newbyte)
            if (newbyte == 255):
                marker = self.bytes.b[self.pos]
                _hx_local_8 = self
                _hx_local_9 = _hx_local_8.pos
                _hx_local_8.pos = (_hx_local_9 + 1)
                _hx_local_9
                _hx_local_10 = self
                _hx_local_11 = _hx_local_10.size
                _hx_local_10.size = (_hx_local_11 - 1)
                _hx_local_11
                marker1 = marker
                if (marker1 == 217):
                    self.size = 0
                elif ((marker1 == 255) or ((marker1 == 0))):
                    pass
                else:
                    self.buf = ((self.buf << 8) | marker)
                    _hx_local_12 = self
                    _hx_local_13 = _hx_local_12.bufbits
                    _hx_local_12.bufbits = (_hx_local_13 + 8)
                    _hx_local_12.bufbits
        return ((self.buf >> ((self.bufbits - bits))) & ((((1 << bits)) - 1)))

    def njSkipBits(self,bits):
        if (self.bufbits < bits):
            self.njShowBits(bits)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.bufbits
        _hx_local_0.bufbits = (_hx_local_1 - bits)
        _hx_local_0.bufbits

    def njGetBits(self,bits):
        r = self.njShowBits(bits)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.bufbits
        _hx_local_0.bufbits = (_hx_local_1 - bits)
        _hx_local_0.bufbits
        return r

    def njDecodeLength(self):
        self.length = ((self.bytes.b[self.pos] << 8) | self.bytes.b[(self.pos + 1)])
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + 2)
        _hx_local_0.pos
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.size
        _hx_local_2.size = (_hx_local_3 - 2)
        _hx_local_2.size
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.length
        _hx_local_4.length = (_hx_local_5 - 2)
        _hx_local_4.length

    def njSkipMarker(self):
        self.length = ((self.bytes.b[self.pos] << 8) | self.bytes.b[(self.pos + 1)])
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + 2)
        _hx_local_0.pos
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.size
        _hx_local_2.size = (_hx_local_3 - 2)
        _hx_local_2.size
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.length
        _hx_local_4.length = (_hx_local_5 - 2)
        _hx_local_4.length
        count = self.length
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6.pos
        _hx_local_6.pos = (_hx_local_7 + count)
        _hx_local_6.pos
        _hx_local_8 = self
        _hx_local_9 = _hx_local_8.size
        _hx_local_8.size = (_hx_local_9 - count)
        _hx_local_8.size
        _hx_local_10 = self
        _hx_local_11 = _hx_local_10.length
        _hx_local_10.length = (_hx_local_11 - count)
        _hx_local_10.length

    def njDecodeSOF(self):
        self.length = ((self.bytes.b[self.pos] << 8) | self.bytes.b[(self.pos + 1)])
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + 2)
        _hx_local_0.pos
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.size
        _hx_local_2.size = (_hx_local_3 - 2)
        _hx_local_2.size
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.length
        _hx_local_4.length = (_hx_local_5 - 2)
        _hx_local_4.length
        if (self.bytes.b[self.pos] != 8):
            self.notSupported()
        self.height = ((self.bytes.b[(self.pos + 1)] << 8) | self.bytes.b[(self.pos + 2)])
        self.width = ((self.bytes.b[(self.pos + 3)] << 8) | self.bytes.b[(self.pos + 4)])
        self.ncomp = self.bytes.b[(self.pos + 5)]
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6.pos
        _hx_local_6.pos = (_hx_local_7 + 6)
        _hx_local_6.pos
        _hx_local_8 = self
        _hx_local_9 = _hx_local_8.size
        _hx_local_8.size = (_hx_local_9 - 6)
        _hx_local_8.size
        _hx_local_10 = self
        _hx_local_11 = _hx_local_10.length
        _hx_local_10.length = (_hx_local_11 - 6)
        _hx_local_10.length
        _g = self.ncomp
        if ((_g == 3) or ((_g == 1))):
            pass
        else:
            self.notSupported()
        ssxmax = 0
        ssymax = 0
        _g1 = 0
        _g2 = self.ncomp
        while (_g1 < _g2):
            i = _g1
            _g1 = (_g1 + 1)
            c = self.comps[i]
            c.cid = self.bytes.b[self.pos]
            c.ssx = (self.bytes.b[(self.pos + 1)] >> 4)
            if (((c.ssx & ((c.ssx - 1)))) != 0):
                self.notSupported()
            c.ssy = (self.bytes.b[(self.pos + 1)] & 15)
            if (((c.ssy & ((c.ssy - 1)))) != 0):
                self.notSupported()
            c.qtsel = self.bytes.b[(self.pos + 2)]
            _hx_local_12 = self
            _hx_local_13 = _hx_local_12.pos
            _hx_local_12.pos = (_hx_local_13 + 3)
            _hx_local_12.pos
            _hx_local_14 = self
            _hx_local_15 = _hx_local_14.size
            _hx_local_14.size = (_hx_local_15 - 3)
            _hx_local_14.size
            _hx_local_16 = self
            _hx_local_17 = _hx_local_16.length
            _hx_local_16.length = (_hx_local_17 - 3)
            _hx_local_16.length
            _hx_local_18 = self
            _hx_local_19 = _hx_local_18.qtused
            _hx_local_18.qtused = (_hx_local_19 | ((1 << c.qtsel)))
            _hx_local_18.qtused
            if (c.ssx > ssxmax):
                ssxmax = c.ssx
            if (c.ssy > ssymax):
                ssymax = c.ssy
        if (self.ncomp == 1):
            c1 = self.comps[0]
            ssymax = 1
            ssxmax = ssymax
            def _hx_local_20():
                c1.ssy = ssxmax
                return c1.ssy
            c1.ssx = _hx_local_20()
        self.mbsizex = (ssxmax << 3)
        self.mbsizey = (ssymax << 3)
        x = ((((self.width + self.mbsizex) - 1)) / self.mbsizex)
        tmp = None
        try:
            tmp = int(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            tmp = None
        self.mbwidth = tmp
        x1 = ((((self.height + self.mbsizey) - 1)) / self.mbsizey)
        tmp1 = None
        try:
            tmp1 = int(x1)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e1 = _hx_e1
            tmp1 = None
        self.mbheight = tmp1
        _g3 = 0
        _g4 = self.ncomp
        while (_g3 < _g4):
            i1 = _g3
            _g3 = (_g3 + 1)
            c2 = self.comps[i1]
            x2 = (((((self.width * c2.ssx) + ssxmax) - 1)) / ssxmax)
            tmp2 = None
            try:
                tmp2 = int(x2)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e2 = _hx_e1
                tmp2 = None
            c2.width = tmp2
            c2.stride = ((c2.width + 7) & 2147483640)
            x3 = (((((self.height * c2.ssy) + ssymax) - 1)) / ssymax)
            tmp3 = None
            try:
                tmp3 = int(x3)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e3 = _hx_e1
                tmp3 = None
            c2.height = tmp3
            x4 = (((self.mbwidth * self.mbsizex) * c2.ssx) / ssxmax)
            tmp4 = None
            try:
                tmp4 = int(x4)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e4 = _hx_e1
                tmp4 = None
            c2.stride = tmp4
            if (((c2.width < 3) and ((c2.ssx != ssxmax))) or (((c2.height < 3) and ((c2.ssy != ssymax))))):
                self.notSupported()
            c3 = c2.stride
            x5 = (((self.mbheight * self.mbsizey) * c2.ssy) / ssymax)
            nbytes = None
            try:
                nbytes = int(x5)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e5 = _hx_e1
                nbytes = None
            c2.pixels = haxe_io_Bytes.alloc((c3 * nbytes))
        count = self.length
        _hx_local_21 = self
        _hx_local_22 = _hx_local_21.pos
        _hx_local_21.pos = (_hx_local_22 + count)
        _hx_local_21.pos
        _hx_local_23 = self
        _hx_local_24 = _hx_local_23.size
        _hx_local_23.size = (_hx_local_24 - count)
        _hx_local_23.size
        _hx_local_25 = self
        _hx_local_26 = _hx_local_25.length
        _hx_local_25.length = (_hx_local_26 - count)
        _hx_local_25.length

    def njDecodeDQT(self):
        self.length = ((self.bytes.b[self.pos] << 8) | self.bytes.b[(self.pos + 1)])
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + 2)
        _hx_local_0.pos
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.size
        _hx_local_2.size = (_hx_local_3 - 2)
        _hx_local_2.size
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.length
        _hx_local_4.length = (_hx_local_5 - 2)
        _hx_local_4.length
        while (self.length >= 65):
            i = self.bytes.b[self.pos]
            _hx_local_6 = self
            _hx_local_7 = _hx_local_6.qtavail
            _hx_local_6.qtavail = (_hx_local_7 | ((1 << i)))
            _hx_local_6.qtavail
            t = self.qtab[i]
            _g = 0
            while (_g < 64):
                k = _g
                _g = (_g + 1)
                val = self.bytes.b[(self.pos + ((k + 1)))]
                t[k] = val
            _hx_local_8 = self
            _hx_local_9 = _hx_local_8.pos
            _hx_local_8.pos = (_hx_local_9 + 65)
            _hx_local_8.pos
            _hx_local_10 = self
            _hx_local_11 = _hx_local_10.size
            _hx_local_10.size = (_hx_local_11 - 65)
            _hx_local_10.size
            _hx_local_12 = self
            _hx_local_13 = _hx_local_12.length
            _hx_local_12.length = (_hx_local_13 - 65)
            _hx_local_12.length

    def njDecodeDHT(self):
        self.length = ((self.bytes.b[self.pos] << 8) | self.bytes.b[(self.pos + 1)])
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + 2)
        _hx_local_0.pos
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.size
        _hx_local_2.size = (_hx_local_3 - 2)
        _hx_local_2.size
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.length
        _hx_local_4.length = (_hx_local_5 - 2)
        _hx_local_4.length
        while (self.length >= 17):
            i = self.bytes.b[self.pos]
            i = (((i >> 4) & 1) | ((((i & 3)) << 1)))
            this1 = self.counts
            val = self.bytes.b[(self.pos + 1)]
            this1[0] = val
            this2 = self.counts
            val1 = self.bytes.b[(self.pos + 2)]
            this2[1] = val1
            this3 = self.counts
            val2 = self.bytes.b[(self.pos + 3)]
            this3[2] = val2
            this4 = self.counts
            val3 = self.bytes.b[(self.pos + 4)]
            this4[3] = val3
            this5 = self.counts
            val4 = self.bytes.b[(self.pos + 5)]
            this5[4] = val4
            this6 = self.counts
            val5 = self.bytes.b[(self.pos + 6)]
            this6[5] = val5
            this7 = self.counts
            val6 = self.bytes.b[(self.pos + 7)]
            this7[6] = val6
            this8 = self.counts
            val7 = self.bytes.b[(self.pos + 8)]
            this8[7] = val7
            this9 = self.counts
            val8 = self.bytes.b[(self.pos + 9)]
            this9[8] = val8
            this10 = self.counts
            val9 = self.bytes.b[(self.pos + 10)]
            this10[9] = val9
            this11 = self.counts
            val10 = self.bytes.b[(self.pos + 11)]
            this11[10] = val10
            this12 = self.counts
            val11 = self.bytes.b[(self.pos + 12)]
            this12[11] = val11
            this13 = self.counts
            val12 = self.bytes.b[(self.pos + 13)]
            this13[12] = val12
            this14 = self.counts
            val13 = self.bytes.b[(self.pos + 14)]
            this14[13] = val13
            this15 = self.counts
            val14 = self.bytes.b[(self.pos + 15)]
            this15[14] = val14
            this16 = self.counts
            val15 = self.bytes.b[(self.pos + 16)]
            this16[15] = val15
            _hx_local_6 = self
            _hx_local_7 = _hx_local_6.pos
            _hx_local_6.pos = (_hx_local_7 + 17)
            _hx_local_6.pos
            _hx_local_8 = self
            _hx_local_9 = _hx_local_8.size
            _hx_local_8.size = (_hx_local_9 - 17)
            _hx_local_8.size
            _hx_local_10 = self
            _hx_local_11 = _hx_local_10.length
            _hx_local_10.length = (_hx_local_11 - 17)
            _hx_local_10.length
            vlc = self.vlctab[i]
            vpos = 0
            remain = 65536
            spread = 65536
            _g = 1
            while (_g < 17):
                codelen = _g
                _g = (_g + 1)
                spread = (spread >> 1)
                currcnt = self.counts[(codelen - 1)]
                if (currcnt == 0):
                    continue
                remain = (remain - ((currcnt << ((16 - codelen)))))
                _g1 = 0
                _g11 = currcnt
                while (_g1 < _g11):
                    i1 = _g1
                    _g1 = (_g1 + 1)
                    code = self.bytes.b[(self.pos + i1)]
                    _g2 = 0
                    _g12 = spread
                    while (_g2 < _g12):
                        j = _g2
                        _g2 = (_g2 + 1)
                        pos = vpos
                        vpos = (vpos + 1)
                        vlc.b[pos] = (codelen & 255)
                        pos1 = vpos
                        vpos = (vpos + 1)
                        vlc.b[pos1] = (code & 255)
                _hx_local_14 = self
                _hx_local_15 = _hx_local_14.pos
                _hx_local_14.pos = (_hx_local_15 + currcnt)
                _hx_local_14.pos
                _hx_local_16 = self
                _hx_local_17 = _hx_local_16.size
                _hx_local_16.size = (_hx_local_17 - currcnt)
                _hx_local_16.size
                _hx_local_18 = self
                _hx_local_19 = _hx_local_18.length
                _hx_local_18.length = (_hx_local_19 - currcnt)
                _hx_local_18.length
            while True:
                tmp = remain
                remain = (remain - 1)
                if (not ((tmp != 0))):
                    break
                vlc.b[vpos] = 0
                vpos = (vpos + 2)

    def njDecodeDRI(self):
        self.length = ((self.bytes.b[self.pos] << 8) | self.bytes.b[(self.pos + 1)])
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + 2)
        _hx_local_0.pos
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.size
        _hx_local_2.size = (_hx_local_3 - 2)
        _hx_local_2.size
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.length
        _hx_local_4.length = (_hx_local_5 - 2)
        _hx_local_4.length
        self.rstinterval = ((self.bytes.b[self.pos] << 8) | self.bytes.b[(self.pos + 1)])
        count = self.length
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6.pos
        _hx_local_6.pos = (_hx_local_7 + count)
        _hx_local_6.pos
        _hx_local_8 = self
        _hx_local_9 = _hx_local_8.size
        _hx_local_8.size = (_hx_local_9 - count)
        _hx_local_8.size
        _hx_local_10 = self
        _hx_local_11 = _hx_local_10.length
        _hx_local_10.length = (_hx_local_11 - count)
        _hx_local_10.length

    def njGetVLC(self,vlc):
        value = self.njShowBits(16)
        bits = vlc.b[(value << 1)]
        if (self.bufbits < bits):
            self.njShowBits(bits)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.bufbits
        _hx_local_0.bufbits = (_hx_local_1 - bits)
        _hx_local_0.bufbits
        value = vlc.b[((value << 1) | 1)]
        self.vlcCode = value
        bits = (value & 15)
        if (bits == 0):
            return 0
        r = self.njShowBits(bits)
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.bufbits
        _hx_local_2.bufbits = (_hx_local_3 - bits)
        _hx_local_2.bufbits
        value = r
        if (value < ((1 << ((bits - 1))))):
            value = (value + ((((-1 << bits)) + 1)))
        return value

    def njRowIDCT(self,bp):
        x1 = (self.block[(bp + 4)] << 11)
        x2 = self.block[(bp + 6)]
        x3 = self.block[(bp + 2)]
        x4 = self.block[(bp + 1)]
        x5 = self.block[(bp + 7)]
        x6 = self.block[(bp + 5)]
        x7 = self.block[(bp + 3)]
        if ((((((((x1 | x2) | x3) | x4) | x5) | x6) | x7)) == 0):
            this1 = self.block
            this2 = self.block
            this3 = self.block
            this4 = self.block
            this5 = self.block
            this6 = self.block
            this7 = self.block
            this8 = self.block
            val = (self.block[bp] << 3)
            this8[(bp + 7)] = val
            val1 = val
            this7[(bp + 6)] = val1
            val2 = val1
            this6[(bp + 5)] = val2
            val3 = val2
            this5[(bp + 4)] = val3
            val4 = val3
            this4[(bp + 3)] = val4
            val5 = val4
            this3[(bp + 2)] = val5
            val6 = val5
            this2[(bp + 1)] = val6
            val7 = val6
            this1[bp] = val7
            return
        x0 = (((self.block[bp] << 11)) + 128)
        x8 = (565 * ((x4 + x5)))
        x4 = (x8 + ((2276 * x4)))
        x5 = (x8 - ((3406 * x5)))
        x8 = (2408 * ((x6 + x7)))
        x6 = (x8 - ((799 * x6)))
        x7 = (x8 - ((4017 * x7)))
        x8 = (x0 + x1)
        x0 = (x0 - x1)
        x1 = (1108 * ((x3 + x2)))
        x2 = (x1 - ((3784 * x2)))
        x3 = (x1 + ((1568 * x3)))
        x1 = (x4 + x6)
        x4 = (x4 - x6)
        x6 = (x5 + x7)
        x5 = (x5 - x7)
        x7 = (x8 + x3)
        x8 = (x8 - x3)
        x3 = (x0 + x2)
        x0 = (x0 - x2)
        x2 = (((181 * ((x4 + x5))) + 128) >> 8)
        x4 = (((181 * ((x4 - x5))) + 128) >> 8)
        val8 = ((x7 + x1) >> 8)
        self.block[bp] = val8
        val9 = ((x3 + x2) >> 8)
        self.block[(bp + 1)] = val9
        val10 = ((x0 + x4) >> 8)
        self.block[(bp + 2)] = val10
        val11 = ((x8 + x6) >> 8)
        self.block[(bp + 3)] = val11
        val12 = ((x8 - x6) >> 8)
        self.block[(bp + 4)] = val12
        val13 = ((x0 - x4) >> 8)
        self.block[(bp + 5)] = val13
        val14 = ((x3 - x2) >> 8)
        self.block[(bp + 6)] = val14
        val15 = ((x7 - x1) >> 8)
        self.block[(bp + 7)] = val15

    def njColIDCT(self,bp,out,po,stride):
        x1 = (self.block[(bp + 32)] << 8)
        x2 = self.block[(bp + 48)]
        x3 = self.block[(bp + 16)]
        x4 = self.block[(bp + 8)]
        x5 = self.block[(bp + 56)]
        x6 = self.block[(bp + 40)]
        x7 = self.block[(bp + 24)]
        if ((((((((x1 | x2) | x3) | x4) | x5) | x6) | x7)) == 0):
            x = ((((self.block[bp] + 32) >> 6)) + 128)
            x1 = (0 if ((x < 0)) else (255 if ((x > 255)) else x))
            out.b[po] = (x1 & 255)
            po = (po + stride)
            out.b[po] = (x1 & 255)
            po = (po + stride)
            out.b[po] = (x1 & 255)
            po = (po + stride)
            out.b[po] = (x1 & 255)
            po = (po + stride)
            out.b[po] = (x1 & 255)
            po = (po + stride)
            out.b[po] = (x1 & 255)
            po = (po + stride)
            out.b[po] = (x1 & 255)
            po = (po + stride)
            out.b[po] = (x1 & 255)
            po = (po + stride)
            return
        x0 = (((self.block[bp] << 8)) + 8192)
        x8 = ((565 * ((x4 + x5))) + 4)
        x4 = ((x8 + ((2276 * x4))) >> 3)
        x5 = ((x8 - ((3406 * x5))) >> 3)
        x8 = ((2408 * ((x6 + x7))) + 4)
        x6 = ((x8 - ((799 * x6))) >> 3)
        x7 = ((x8 - ((4017 * x7))) >> 3)
        x8 = (x0 + x1)
        x0 = (x0 - x1)
        x1 = ((1108 * ((x3 + x2))) + 4)
        x2 = ((x1 - ((3784 * x2))) >> 3)
        x3 = ((x1 + ((1568 * x3))) >> 3)
        x1 = (x4 + x6)
        x4 = (x4 - x6)
        x6 = (x5 + x7)
        x5 = (x5 - x7)
        x7 = (x8 + x3)
        x8 = (x8 - x3)
        x3 = (x0 + x2)
        x0 = (x0 - x2)
        x2 = (((181 * ((x4 + x5))) + 128) >> 8)
        x4 = (((181 * ((x4 - x5))) + 128) >> 8)
        x9 = ((((x7 + x1) >> 14)) + 128)
        out.b[po] = (((0 if ((x9 < 0)) else (255 if ((x9 > 255)) else x9))) & 255)
        po = (po + stride)
        x10 = ((((x3 + x2) >> 14)) + 128)
        out.b[po] = (((0 if ((x10 < 0)) else (255 if ((x10 > 255)) else x10))) & 255)
        po = (po + stride)
        x11 = ((((x0 + x4) >> 14)) + 128)
        out.b[po] = (((0 if ((x11 < 0)) else (255 if ((x11 > 255)) else x11))) & 255)
        po = (po + stride)
        x12 = ((((x8 + x6) >> 14)) + 128)
        out.b[po] = (((0 if ((x12 < 0)) else (255 if ((x12 > 255)) else x12))) & 255)
        po = (po + stride)
        x13 = ((((x8 - x6) >> 14)) + 128)
        out.b[po] = (((0 if ((x13 < 0)) else (255 if ((x13 > 255)) else x13))) & 255)
        po = (po + stride)
        x14 = ((((x0 - x4) >> 14)) + 128)
        out.b[po] = (((0 if ((x14 < 0)) else (255 if ((x14 > 255)) else x14))) & 255)
        po = (po + stride)
        x15 = ((((x3 - x2) >> 14)) + 128)
        out.b[po] = (((0 if ((x15 < 0)) else (255 if ((x15 > 255)) else x15))) & 255)
        po = (po + stride)
        x16 = ((((x7 - x1) >> 14)) + 128)
        out.b[po] = (((0 if ((x16 < 0)) else (255 if ((x16 > 255)) else x16))) & 255)

    def njDecodeBlock(self,c,po):
        this1 = c.pixels
        out = this1
        value = None
        coef = 0
        _g = 0
        while (_g < 64):
            i = _g
            _g = (_g + 1)
            self.block[i] = 0
        c1 = c
        c2 = c1.dcpred
        vlc = self.vlctab[c.dctabsel]
        value1 = self.njShowBits(16)
        bits = vlc.b[(value1 << 1)]
        if (self.bufbits < bits):
            self.njShowBits(bits)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.bufbits
        _hx_local_0.bufbits = (_hx_local_1 - bits)
        _hx_local_0.bufbits
        value1 = vlc.b[((value1 << 1) | 1)]
        self.vlcCode = value1
        bits = (value1 & 15)
        tmp = None
        if (bits == 0):
            tmp = 0
        else:
            r = self.njShowBits(bits)
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.bufbits
            _hx_local_2.bufbits = (_hx_local_3 - bits)
            _hx_local_2.bufbits
            value1 = r
            if (value1 < ((1 << ((bits - 1))))):
                value1 = (value1 + ((((-1 << bits)) + 1)))
            tmp = value1
        c1.dcpred = (c2 + tmp)
        qt = self.qtab[c.qtsel]
        at = self.vlctab[c.actabsel]
        this2 = self.block
        val = (c.dcpred * qt[0])
        this2[0] = val
        while True:
            value2 = self.njShowBits(16)
            bits1 = at.b[(value2 << 1)]
            if (self.bufbits < bits1):
                self.njShowBits(bits1)
            _hx_local_5 = self
            _hx_local_6 = _hx_local_5.bufbits
            _hx_local_5.bufbits = (_hx_local_6 - bits1)
            _hx_local_5.bufbits
            value2 = at.b[((value2 << 1) | 1)]
            self.vlcCode = value2
            bits1 = (value2 & 15)
            if (bits1 == 0):
                value = 0
            else:
                r1 = self.njShowBits(bits1)
                _hx_local_7 = self
                _hx_local_8 = _hx_local_7.bufbits
                _hx_local_7.bufbits = (_hx_local_8 - bits1)
                _hx_local_7.bufbits
                value2 = r1
                if (value2 < ((1 << ((bits1 - 1))))):
                    value2 = (value2 + ((((-1 << bits1)) + 1)))
                value = value2
            if (self.vlcCode == 0):
                break
            coef = (coef + ((((self.vlcCode >> 4)) + 1)))
            this3 = self.block
            index = self.njZZ[coef]
            val1 = (value * qt[coef])
            this3[index] = val1
            if (not ((coef < 63))):
                break
        bp = 0
        x0 = None
        x8 = None
        x1 = (self.block[(bp + 4)] << 11)
        x2 = self.block[(bp + 6)]
        x3 = self.block[(bp + 2)]
        x4 = self.block[(bp + 1)]
        x5 = self.block[(bp + 7)]
        x6 = self.block[(bp + 5)]
        x7 = self.block[(bp + 3)]
        if ((((((((x1 | x2) | x3) | x4) | x5) | x6) | x7)) == 0):
            this4 = self.block
            this5 = self.block
            this6 = self.block
            this7 = self.block
            this8 = self.block
            this9 = self.block
            this10 = self.block
            this11 = self.block
            val2 = (self.block[bp] << 3)
            this11[(bp + 7)] = val2
            val3 = val2
            this10[(bp + 6)] = val3
            val4 = val3
            this9[(bp + 5)] = val4
            val5 = val4
            this8[(bp + 4)] = val5
            val6 = val5
            this7[(bp + 3)] = val6
            val7 = val6
            this6[(bp + 2)] = val7
            val8 = val7
            this5[(bp + 1)] = val8
            val9 = val8
            this4[bp] = val9
        else:
            x0 = (((self.block[bp] << 11)) + 128)
            x8 = (565 * ((x4 + x5)))
            x4 = (x8 + ((2276 * x4)))
            x5 = (x8 - ((3406 * x5)))
            x8 = (2408 * ((x6 + x7)))
            x6 = (x8 - ((799 * x6)))
            x7 = (x8 - ((4017 * x7)))
            x8 = (x0 + x1)
            x0 = (x0 - x1)
            x1 = (1108 * ((x3 + x2)))
            x2 = (x1 - ((3784 * x2)))
            x3 = (x1 + ((1568 * x3)))
            x1 = (x4 + x6)
            x4 = (x4 - x6)
            x6 = (x5 + x7)
            x5 = (x5 - x7)
            x7 = (x8 + x3)
            x8 = (x8 - x3)
            x3 = (x0 + x2)
            x0 = (x0 - x2)
            x2 = (((181 * ((x4 + x5))) + 128) >> 8)
            x4 = (((181 * ((x4 - x5))) + 128) >> 8)
            val10 = ((x7 + x1) >> 8)
            self.block[bp] = val10
            val11 = ((x3 + x2) >> 8)
            self.block[(bp + 1)] = val11
            val12 = ((x0 + x4) >> 8)
            self.block[(bp + 2)] = val12
            val13 = ((x8 + x6) >> 8)
            self.block[(bp + 3)] = val13
            val14 = ((x8 - x6) >> 8)
            self.block[(bp + 4)] = val14
            val15 = ((x0 - x4) >> 8)
            self.block[(bp + 5)] = val15
            val16 = ((x3 - x2) >> 8)
            self.block[(bp + 6)] = val16
            val17 = ((x7 - x1) >> 8)
            self.block[(bp + 7)] = val17
        bp1 = 8
        x01 = None
        x81 = None
        x11 = (self.block[(bp1 + 4)] << 11)
        x21 = self.block[(bp1 + 6)]
        x31 = self.block[(bp1 + 2)]
        x41 = self.block[(bp1 + 1)]
        x51 = self.block[(bp1 + 7)]
        x61 = self.block[(bp1 + 5)]
        x71 = self.block[(bp1 + 3)]
        if ((((((((x11 | x21) | x31) | x41) | x51) | x61) | x71)) == 0):
            this12 = self.block
            this13 = self.block
            this14 = self.block
            this15 = self.block
            this16 = self.block
            this17 = self.block
            this18 = self.block
            this19 = self.block
            val18 = (self.block[bp1] << 3)
            this19[(bp1 + 7)] = val18
            val19 = val18
            this18[(bp1 + 6)] = val19
            val20 = val19
            this17[(bp1 + 5)] = val20
            val21 = val20
            this16[(bp1 + 4)] = val21
            val22 = val21
            this15[(bp1 + 3)] = val22
            val23 = val22
            this14[(bp1 + 2)] = val23
            val24 = val23
            this13[(bp1 + 1)] = val24
            val25 = val24
            this12[bp1] = val25
        else:
            x01 = (((self.block[bp1] << 11)) + 128)
            x81 = (565 * ((x41 + x51)))
            x41 = (x81 + ((2276 * x41)))
            x51 = (x81 - ((3406 * x51)))
            x81 = (2408 * ((x61 + x71)))
            x61 = (x81 - ((799 * x61)))
            x71 = (x81 - ((4017 * x71)))
            x81 = (x01 + x11)
            x01 = (x01 - x11)
            x11 = (1108 * ((x31 + x21)))
            x21 = (x11 - ((3784 * x21)))
            x31 = (x11 + ((1568 * x31)))
            x11 = (x41 + x61)
            x41 = (x41 - x61)
            x61 = (x51 + x71)
            x51 = (x51 - x71)
            x71 = (x81 + x31)
            x81 = (x81 - x31)
            x31 = (x01 + x21)
            x01 = (x01 - x21)
            x21 = (((181 * ((x41 + x51))) + 128) >> 8)
            x41 = (((181 * ((x41 - x51))) + 128) >> 8)
            val26 = ((x71 + x11) >> 8)
            self.block[bp1] = val26
            val27 = ((x31 + x21) >> 8)
            self.block[(bp1 + 1)] = val27
            val28 = ((x01 + x41) >> 8)
            self.block[(bp1 + 2)] = val28
            val29 = ((x81 + x61) >> 8)
            self.block[(bp1 + 3)] = val29
            val30 = ((x81 - x61) >> 8)
            self.block[(bp1 + 4)] = val30
            val31 = ((x01 - x41) >> 8)
            self.block[(bp1 + 5)] = val31
            val32 = ((x31 - x21) >> 8)
            self.block[(bp1 + 6)] = val32
            val33 = ((x71 - x11) >> 8)
            self.block[(bp1 + 7)] = val33
        bp2 = 16
        x02 = None
        x82 = None
        x12 = (self.block[(bp2 + 4)] << 11)
        x22 = self.block[(bp2 + 6)]
        x32 = self.block[(bp2 + 2)]
        x42 = self.block[(bp2 + 1)]
        x52 = self.block[(bp2 + 7)]
        x62 = self.block[(bp2 + 5)]
        x72 = self.block[(bp2 + 3)]
        if ((((((((x12 | x22) | x32) | x42) | x52) | x62) | x72)) == 0):
            this20 = self.block
            this21 = self.block
            this22 = self.block
            this23 = self.block
            this24 = self.block
            this25 = self.block
            this26 = self.block
            this27 = self.block
            val34 = (self.block[bp2] << 3)
            this27[(bp2 + 7)] = val34
            val35 = val34
            this26[(bp2 + 6)] = val35
            val36 = val35
            this25[(bp2 + 5)] = val36
            val37 = val36
            this24[(bp2 + 4)] = val37
            val38 = val37
            this23[(bp2 + 3)] = val38
            val39 = val38
            this22[(bp2 + 2)] = val39
            val40 = val39
            this21[(bp2 + 1)] = val40
            val41 = val40
            this20[bp2] = val41
        else:
            x02 = (((self.block[bp2] << 11)) + 128)
            x82 = (565 * ((x42 + x52)))
            x42 = (x82 + ((2276 * x42)))
            x52 = (x82 - ((3406 * x52)))
            x82 = (2408 * ((x62 + x72)))
            x62 = (x82 - ((799 * x62)))
            x72 = (x82 - ((4017 * x72)))
            x82 = (x02 + x12)
            x02 = (x02 - x12)
            x12 = (1108 * ((x32 + x22)))
            x22 = (x12 - ((3784 * x22)))
            x32 = (x12 + ((1568 * x32)))
            x12 = (x42 + x62)
            x42 = (x42 - x62)
            x62 = (x52 + x72)
            x52 = (x52 - x72)
            x72 = (x82 + x32)
            x82 = (x82 - x32)
            x32 = (x02 + x22)
            x02 = (x02 - x22)
            x22 = (((181 * ((x42 + x52))) + 128) >> 8)
            x42 = (((181 * ((x42 - x52))) + 128) >> 8)
            val42 = ((x72 + x12) >> 8)
            self.block[bp2] = val42
            val43 = ((x32 + x22) >> 8)
            self.block[(bp2 + 1)] = val43
            val44 = ((x02 + x42) >> 8)
            self.block[(bp2 + 2)] = val44
            val45 = ((x82 + x62) >> 8)
            self.block[(bp2 + 3)] = val45
            val46 = ((x82 - x62) >> 8)
            self.block[(bp2 + 4)] = val46
            val47 = ((x02 - x42) >> 8)
            self.block[(bp2 + 5)] = val47
            val48 = ((x32 - x22) >> 8)
            self.block[(bp2 + 6)] = val48
            val49 = ((x72 - x12) >> 8)
            self.block[(bp2 + 7)] = val49
        bp3 = 24
        x03 = None
        x83 = None
        x13 = (self.block[(bp3 + 4)] << 11)
        x23 = self.block[(bp3 + 6)]
        x33 = self.block[(bp3 + 2)]
        x43 = self.block[(bp3 + 1)]
        x53 = self.block[(bp3 + 7)]
        x63 = self.block[(bp3 + 5)]
        x73 = self.block[(bp3 + 3)]
        if ((((((((x13 | x23) | x33) | x43) | x53) | x63) | x73)) == 0):
            this28 = self.block
            this29 = self.block
            this30 = self.block
            this31 = self.block
            this32 = self.block
            this33 = self.block
            this34 = self.block
            this35 = self.block
            val50 = (self.block[bp3] << 3)
            this35[(bp3 + 7)] = val50
            val51 = val50
            this34[(bp3 + 6)] = val51
            val52 = val51
            this33[(bp3 + 5)] = val52
            val53 = val52
            this32[(bp3 + 4)] = val53
            val54 = val53
            this31[(bp3 + 3)] = val54
            val55 = val54
            this30[(bp3 + 2)] = val55
            val56 = val55
            this29[(bp3 + 1)] = val56
            val57 = val56
            this28[bp3] = val57
        else:
            x03 = (((self.block[bp3] << 11)) + 128)
            x83 = (565 * ((x43 + x53)))
            x43 = (x83 + ((2276 * x43)))
            x53 = (x83 - ((3406 * x53)))
            x83 = (2408 * ((x63 + x73)))
            x63 = (x83 - ((799 * x63)))
            x73 = (x83 - ((4017 * x73)))
            x83 = (x03 + x13)
            x03 = (x03 - x13)
            x13 = (1108 * ((x33 + x23)))
            x23 = (x13 - ((3784 * x23)))
            x33 = (x13 + ((1568 * x33)))
            x13 = (x43 + x63)
            x43 = (x43 - x63)
            x63 = (x53 + x73)
            x53 = (x53 - x73)
            x73 = (x83 + x33)
            x83 = (x83 - x33)
            x33 = (x03 + x23)
            x03 = (x03 - x23)
            x23 = (((181 * ((x43 + x53))) + 128) >> 8)
            x43 = (((181 * ((x43 - x53))) + 128) >> 8)
            val58 = ((x73 + x13) >> 8)
            self.block[bp3] = val58
            val59 = ((x33 + x23) >> 8)
            self.block[(bp3 + 1)] = val59
            val60 = ((x03 + x43) >> 8)
            self.block[(bp3 + 2)] = val60
            val61 = ((x83 + x63) >> 8)
            self.block[(bp3 + 3)] = val61
            val62 = ((x83 - x63) >> 8)
            self.block[(bp3 + 4)] = val62
            val63 = ((x03 - x43) >> 8)
            self.block[(bp3 + 5)] = val63
            val64 = ((x33 - x23) >> 8)
            self.block[(bp3 + 6)] = val64
            val65 = ((x73 - x13) >> 8)
            self.block[(bp3 + 7)] = val65
        bp4 = 32
        x04 = None
        x84 = None
        x14 = (self.block[(bp4 + 4)] << 11)
        x24 = self.block[(bp4 + 6)]
        x34 = self.block[(bp4 + 2)]
        x44 = self.block[(bp4 + 1)]
        x54 = self.block[(bp4 + 7)]
        x64 = self.block[(bp4 + 5)]
        x74 = self.block[(bp4 + 3)]
        if ((((((((x14 | x24) | x34) | x44) | x54) | x64) | x74)) == 0):
            this36 = self.block
            this37 = self.block
            this38 = self.block
            this39 = self.block
            this40 = self.block
            this41 = self.block
            this42 = self.block
            this43 = self.block
            val66 = (self.block[bp4] << 3)
            this43[(bp4 + 7)] = val66
            val67 = val66
            this42[(bp4 + 6)] = val67
            val68 = val67
            this41[(bp4 + 5)] = val68
            val69 = val68
            this40[(bp4 + 4)] = val69
            val70 = val69
            this39[(bp4 + 3)] = val70
            val71 = val70
            this38[(bp4 + 2)] = val71
            val72 = val71
            this37[(bp4 + 1)] = val72
            val73 = val72
            this36[bp4] = val73
        else:
            x04 = (((self.block[bp4] << 11)) + 128)
            x84 = (565 * ((x44 + x54)))
            x44 = (x84 + ((2276 * x44)))
            x54 = (x84 - ((3406 * x54)))
            x84 = (2408 * ((x64 + x74)))
            x64 = (x84 - ((799 * x64)))
            x74 = (x84 - ((4017 * x74)))
            x84 = (x04 + x14)
            x04 = (x04 - x14)
            x14 = (1108 * ((x34 + x24)))
            x24 = (x14 - ((3784 * x24)))
            x34 = (x14 + ((1568 * x34)))
            x14 = (x44 + x64)
            x44 = (x44 - x64)
            x64 = (x54 + x74)
            x54 = (x54 - x74)
            x74 = (x84 + x34)
            x84 = (x84 - x34)
            x34 = (x04 + x24)
            x04 = (x04 - x24)
            x24 = (((181 * ((x44 + x54))) + 128) >> 8)
            x44 = (((181 * ((x44 - x54))) + 128) >> 8)
            val74 = ((x74 + x14) >> 8)
            self.block[bp4] = val74
            val75 = ((x34 + x24) >> 8)
            self.block[(bp4 + 1)] = val75
            val76 = ((x04 + x44) >> 8)
            self.block[(bp4 + 2)] = val76
            val77 = ((x84 + x64) >> 8)
            self.block[(bp4 + 3)] = val77
            val78 = ((x84 - x64) >> 8)
            self.block[(bp4 + 4)] = val78
            val79 = ((x04 - x44) >> 8)
            self.block[(bp4 + 5)] = val79
            val80 = ((x34 - x24) >> 8)
            self.block[(bp4 + 6)] = val80
            val81 = ((x74 - x14) >> 8)
            self.block[(bp4 + 7)] = val81
        bp5 = 40
        x05 = None
        x85 = None
        x15 = (self.block[(bp5 + 4)] << 11)
        x25 = self.block[(bp5 + 6)]
        x35 = self.block[(bp5 + 2)]
        x45 = self.block[(bp5 + 1)]
        x55 = self.block[(bp5 + 7)]
        x65 = self.block[(bp5 + 5)]
        x75 = self.block[(bp5 + 3)]
        if ((((((((x15 | x25) | x35) | x45) | x55) | x65) | x75)) == 0):
            this44 = self.block
            this45 = self.block
            this46 = self.block
            this47 = self.block
            this48 = self.block
            this49 = self.block
            this50 = self.block
            this51 = self.block
            val82 = (self.block[bp5] << 3)
            this51[(bp5 + 7)] = val82
            val83 = val82
            this50[(bp5 + 6)] = val83
            val84 = val83
            this49[(bp5 + 5)] = val84
            val85 = val84
            this48[(bp5 + 4)] = val85
            val86 = val85
            this47[(bp5 + 3)] = val86
            val87 = val86
            this46[(bp5 + 2)] = val87
            val88 = val87
            this45[(bp5 + 1)] = val88
            val89 = val88
            this44[bp5] = val89
        else:
            x05 = (((self.block[bp5] << 11)) + 128)
            x85 = (565 * ((x45 + x55)))
            x45 = (x85 + ((2276 * x45)))
            x55 = (x85 - ((3406 * x55)))
            x85 = (2408 * ((x65 + x75)))
            x65 = (x85 - ((799 * x65)))
            x75 = (x85 - ((4017 * x75)))
            x85 = (x05 + x15)
            x05 = (x05 - x15)
            x15 = (1108 * ((x35 + x25)))
            x25 = (x15 - ((3784 * x25)))
            x35 = (x15 + ((1568 * x35)))
            x15 = (x45 + x65)
            x45 = (x45 - x65)
            x65 = (x55 + x75)
            x55 = (x55 - x75)
            x75 = (x85 + x35)
            x85 = (x85 - x35)
            x35 = (x05 + x25)
            x05 = (x05 - x25)
            x25 = (((181 * ((x45 + x55))) + 128) >> 8)
            x45 = (((181 * ((x45 - x55))) + 128) >> 8)
            val90 = ((x75 + x15) >> 8)
            self.block[bp5] = val90
            val91 = ((x35 + x25) >> 8)
            self.block[(bp5 + 1)] = val91
            val92 = ((x05 + x45) >> 8)
            self.block[(bp5 + 2)] = val92
            val93 = ((x85 + x65) >> 8)
            self.block[(bp5 + 3)] = val93
            val94 = ((x85 - x65) >> 8)
            self.block[(bp5 + 4)] = val94
            val95 = ((x05 - x45) >> 8)
            self.block[(bp5 + 5)] = val95
            val96 = ((x35 - x25) >> 8)
            self.block[(bp5 + 6)] = val96
            val97 = ((x75 - x15) >> 8)
            self.block[(bp5 + 7)] = val97
        bp6 = 48
        x06 = None
        x86 = None
        x16 = (self.block[(bp6 + 4)] << 11)
        x26 = self.block[(bp6 + 6)]
        x36 = self.block[(bp6 + 2)]
        x46 = self.block[(bp6 + 1)]
        x56 = self.block[(bp6 + 7)]
        x66 = self.block[(bp6 + 5)]
        x76 = self.block[(bp6 + 3)]
        if ((((((((x16 | x26) | x36) | x46) | x56) | x66) | x76)) == 0):
            this52 = self.block
            this53 = self.block
            this54 = self.block
            this55 = self.block
            this56 = self.block
            this57 = self.block
            this58 = self.block
            this59 = self.block
            val98 = (self.block[bp6] << 3)
            this59[(bp6 + 7)] = val98
            val99 = val98
            this58[(bp6 + 6)] = val99
            val100 = val99
            this57[(bp6 + 5)] = val100
            val101 = val100
            this56[(bp6 + 4)] = val101
            val102 = val101
            this55[(bp6 + 3)] = val102
            val103 = val102
            this54[(bp6 + 2)] = val103
            val104 = val103
            this53[(bp6 + 1)] = val104
            val105 = val104
            this52[bp6] = val105
        else:
            x06 = (((self.block[bp6] << 11)) + 128)
            x86 = (565 * ((x46 + x56)))
            x46 = (x86 + ((2276 * x46)))
            x56 = (x86 - ((3406 * x56)))
            x86 = (2408 * ((x66 + x76)))
            x66 = (x86 - ((799 * x66)))
            x76 = (x86 - ((4017 * x76)))
            x86 = (x06 + x16)
            x06 = (x06 - x16)
            x16 = (1108 * ((x36 + x26)))
            x26 = (x16 - ((3784 * x26)))
            x36 = (x16 + ((1568 * x36)))
            x16 = (x46 + x66)
            x46 = (x46 - x66)
            x66 = (x56 + x76)
            x56 = (x56 - x76)
            x76 = (x86 + x36)
            x86 = (x86 - x36)
            x36 = (x06 + x26)
            x06 = (x06 - x26)
            x26 = (((181 * ((x46 + x56))) + 128) >> 8)
            x46 = (((181 * ((x46 - x56))) + 128) >> 8)
            val106 = ((x76 + x16) >> 8)
            self.block[bp6] = val106
            val107 = ((x36 + x26) >> 8)
            self.block[(bp6 + 1)] = val107
            val108 = ((x06 + x46) >> 8)
            self.block[(bp6 + 2)] = val108
            val109 = ((x86 + x66) >> 8)
            self.block[(bp6 + 3)] = val109
            val110 = ((x86 - x66) >> 8)
            self.block[(bp6 + 4)] = val110
            val111 = ((x06 - x46) >> 8)
            self.block[(bp6 + 5)] = val111
            val112 = ((x36 - x26) >> 8)
            self.block[(bp6 + 6)] = val112
            val113 = ((x76 - x16) >> 8)
            self.block[(bp6 + 7)] = val113
        bp7 = 56
        x07 = None
        x87 = None
        x17 = (self.block[(bp7 + 4)] << 11)
        x27 = self.block[(bp7 + 6)]
        x37 = self.block[(bp7 + 2)]
        x47 = self.block[(bp7 + 1)]
        x57 = self.block[(bp7 + 7)]
        x67 = self.block[(bp7 + 5)]
        x77 = self.block[(bp7 + 3)]
        if ((((((((x17 | x27) | x37) | x47) | x57) | x67) | x77)) == 0):
            this60 = self.block
            this61 = self.block
            this62 = self.block
            this63 = self.block
            this64 = self.block
            this65 = self.block
            this66 = self.block
            this67 = self.block
            val114 = (self.block[bp7] << 3)
            this67[(bp7 + 7)] = val114
            val115 = val114
            this66[(bp7 + 6)] = val115
            val116 = val115
            this65[(bp7 + 5)] = val116
            val117 = val116
            this64[(bp7 + 4)] = val117
            val118 = val117
            this63[(bp7 + 3)] = val118
            val119 = val118
            this62[(bp7 + 2)] = val119
            val120 = val119
            this61[(bp7 + 1)] = val120
            val121 = val120
            this60[bp7] = val121
        else:
            x07 = (((self.block[bp7] << 11)) + 128)
            x87 = (565 * ((x47 + x57)))
            x47 = (x87 + ((2276 * x47)))
            x57 = (x87 - ((3406 * x57)))
            x87 = (2408 * ((x67 + x77)))
            x67 = (x87 - ((799 * x67)))
            x77 = (x87 - ((4017 * x77)))
            x87 = (x07 + x17)
            x07 = (x07 - x17)
            x17 = (1108 * ((x37 + x27)))
            x27 = (x17 - ((3784 * x27)))
            x37 = (x17 + ((1568 * x37)))
            x17 = (x47 + x67)
            x47 = (x47 - x67)
            x67 = (x57 + x77)
            x57 = (x57 - x77)
            x77 = (x87 + x37)
            x87 = (x87 - x37)
            x37 = (x07 + x27)
            x07 = (x07 - x27)
            x27 = (((181 * ((x47 + x57))) + 128) >> 8)
            x47 = (((181 * ((x47 - x57))) + 128) >> 8)
            val122 = ((x77 + x17) >> 8)
            self.block[bp7] = val122
            val123 = ((x37 + x27) >> 8)
            self.block[(bp7 + 1)] = val123
            val124 = ((x07 + x47) >> 8)
            self.block[(bp7 + 2)] = val124
            val125 = ((x87 + x67) >> 8)
            self.block[(bp7 + 3)] = val125
            val126 = ((x87 - x67) >> 8)
            self.block[(bp7 + 4)] = val126
            val127 = ((x07 - x47) >> 8)
            self.block[(bp7 + 5)] = val127
            val128 = ((x37 - x27) >> 8)
            self.block[(bp7 + 6)] = val128
            val129 = ((x77 - x17) >> 8)
            self.block[(bp7 + 7)] = val129
        po1 = po
        stride = c.stride
        x08 = None
        x88 = None
        x18 = (self.block[32] << 8)
        x28 = self.block[48]
        x38 = self.block[16]
        x48 = self.block[8]
        x58 = self.block[56]
        x68 = self.block[40]
        x78 = self.block[24]
        if ((((((((x18 | x28) | x38) | x48) | x58) | x68) | x78)) == 0):
            x = ((((self.block[0] + 32) >> 6)) + 128)
            x18 = (0 if ((x < 0)) else (255 if ((x > 255)) else x))
            out.b[po1] = (x18 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x18 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x18 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x18 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x18 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x18 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x18 & 255)
            po1 = (po1 + stride)
            out.b[po1] = (x18 & 255)
            po1 = (po1 + stride)
        else:
            x08 = (((self.block[0] << 8)) + 8192)
            x88 = ((565 * ((x48 + x58))) + 4)
            x48 = ((x88 + ((2276 * x48))) >> 3)
            x58 = ((x88 - ((3406 * x58))) >> 3)
            x88 = ((2408 * ((x68 + x78))) + 4)
            x68 = ((x88 - ((799 * x68))) >> 3)
            x78 = ((x88 - ((4017 * x78))) >> 3)
            x88 = (x08 + x18)
            x08 = (x08 - x18)
            x18 = ((1108 * ((x38 + x28))) + 4)
            x28 = ((x18 - ((3784 * x28))) >> 3)
            x38 = ((x18 + ((1568 * x38))) >> 3)
            x18 = (x48 + x68)
            x48 = (x48 - x68)
            x68 = (x58 + x78)
            x58 = (x58 - x78)
            x78 = (x88 + x38)
            x88 = (x88 - x38)
            x38 = (x08 + x28)
            x08 = (x08 - x28)
            x28 = (((181 * ((x48 + x58))) + 128) >> 8)
            x48 = (((181 * ((x48 - x58))) + 128) >> 8)
            x9 = ((((x78 + x18) >> 14)) + 128)
            out.b[po1] = (((0 if ((x9 < 0)) else (255 if ((x9 > 255)) else x9))) & 255)
            po1 = (po1 + stride)
            x10 = ((((x38 + x28) >> 14)) + 128)
            out.b[po1] = (((0 if ((x10 < 0)) else (255 if ((x10 > 255)) else x10))) & 255)
            po1 = (po1 + stride)
            x19 = ((((x08 + x48) >> 14)) + 128)
            out.b[po1] = (((0 if ((x19 < 0)) else (255 if ((x19 > 255)) else x19))) & 255)
            po1 = (po1 + stride)
            x20 = ((((x88 + x68) >> 14)) + 128)
            out.b[po1] = (((0 if ((x20 < 0)) else (255 if ((x20 > 255)) else x20))) & 255)
            po1 = (po1 + stride)
            x29 = ((((x88 - x68) >> 14)) + 128)
            out.b[po1] = (((0 if ((x29 < 0)) else (255 if ((x29 > 255)) else x29))) & 255)
            po1 = (po1 + stride)
            x30 = ((((x08 - x48) >> 14)) + 128)
            out.b[po1] = (((0 if ((x30 < 0)) else (255 if ((x30 > 255)) else x30))) & 255)
            po1 = (po1 + stride)
            x39 = ((((x38 - x28) >> 14)) + 128)
            out.b[po1] = (((0 if ((x39 < 0)) else (255 if ((x39 > 255)) else x39))) & 255)
            po1 = (po1 + stride)
            x40 = ((((x78 - x18) >> 14)) + 128)
            out.b[po1] = (((0 if ((x40 < 0)) else (255 if ((x40 > 255)) else x40))) & 255)
        po2 = (1 + po)
        stride1 = c.stride
        x09 = None
        x89 = None
        x110 = (self.block[33] << 8)
        x210 = self.block[49]
        x310 = self.block[17]
        x49 = self.block[9]
        x59 = self.block[57]
        x69 = self.block[41]
        x79 = self.block[25]
        if ((((((((x110 | x210) | x310) | x49) | x59) | x69) | x79)) == 0):
            x50 = ((((self.block[1] + 32) >> 6)) + 128)
            x110 = (0 if ((x50 < 0)) else (255 if ((x50 > 255)) else x50))
            out.b[po2] = (x110 & 255)
            po2 = (po2 + stride1)
            out.b[po2] = (x110 & 255)
            po2 = (po2 + stride1)
            out.b[po2] = (x110 & 255)
            po2 = (po2 + stride1)
            out.b[po2] = (x110 & 255)
            po2 = (po2 + stride1)
            out.b[po2] = (x110 & 255)
            po2 = (po2 + stride1)
            out.b[po2] = (x110 & 255)
            po2 = (po2 + stride1)
            out.b[po2] = (x110 & 255)
            po2 = (po2 + stride1)
            out.b[po2] = (x110 & 255)
            po2 = (po2 + stride1)
        else:
            x09 = (((self.block[1] << 8)) + 8192)
            x89 = ((565 * ((x49 + x59))) + 4)
            x49 = ((x89 + ((2276 * x49))) >> 3)
            x59 = ((x89 - ((3406 * x59))) >> 3)
            x89 = ((2408 * ((x69 + x79))) + 4)
            x69 = ((x89 - ((799 * x69))) >> 3)
            x79 = ((x89 - ((4017 * x79))) >> 3)
            x89 = (x09 + x110)
            x09 = (x09 - x110)
            x110 = ((1108 * ((x310 + x210))) + 4)
            x210 = ((x110 - ((3784 * x210))) >> 3)
            x310 = ((x110 + ((1568 * x310))) >> 3)
            x110 = (x49 + x69)
            x49 = (x49 - x69)
            x69 = (x59 + x79)
            x59 = (x59 - x79)
            x79 = (x89 + x310)
            x89 = (x89 - x310)
            x310 = (x09 + x210)
            x09 = (x09 - x210)
            x210 = (((181 * ((x49 + x59))) + 128) >> 8)
            x49 = (((181 * ((x49 - x59))) + 128) >> 8)
            x60 = ((((x79 + x110) >> 14)) + 128)
            out.b[po2] = (((0 if ((x60 < 0)) else (255 if ((x60 > 255)) else x60))) & 255)
            po2 = (po2 + stride1)
            x70 = ((((x310 + x210) >> 14)) + 128)
            out.b[po2] = (((0 if ((x70 < 0)) else (255 if ((x70 > 255)) else x70))) & 255)
            po2 = (po2 + stride1)
            x80 = ((((x09 + x49) >> 14)) + 128)
            out.b[po2] = (((0 if ((x80 < 0)) else (255 if ((x80 > 255)) else x80))) & 255)
            po2 = (po2 + stride1)
            x90 = ((((x89 + x69) >> 14)) + 128)
            out.b[po2] = (((0 if ((x90 < 0)) else (255 if ((x90 > 255)) else x90))) & 255)
            po2 = (po2 + stride1)
            x91 = ((((x89 - x69) >> 14)) + 128)
            out.b[po2] = (((0 if ((x91 < 0)) else (255 if ((x91 > 255)) else x91))) & 255)
            po2 = (po2 + stride1)
            x92 = ((((x09 - x49) >> 14)) + 128)
            out.b[po2] = (((0 if ((x92 < 0)) else (255 if ((x92 > 255)) else x92))) & 255)
            po2 = (po2 + stride1)
            x93 = ((((x310 - x210) >> 14)) + 128)
            out.b[po2] = (((0 if ((x93 < 0)) else (255 if ((x93 > 255)) else x93))) & 255)
            po2 = (po2 + stride1)
            x94 = ((((x79 - x110) >> 14)) + 128)
            out.b[po2] = (((0 if ((x94 < 0)) else (255 if ((x94 > 255)) else x94))) & 255)
        po3 = (2 + po)
        stride2 = c.stride
        x010 = None
        x810 = None
        x111 = (self.block[34] << 8)
        x211 = self.block[50]
        x311 = self.block[18]
        x410 = self.block[10]
        x510 = self.block[58]
        x610 = self.block[42]
        x710 = self.block[26]
        if ((((((((x111 | x211) | x311) | x410) | x510) | x610) | x710)) == 0):
            x95 = ((((self.block[2] + 32) >> 6)) + 128)
            x111 = (0 if ((x95 < 0)) else (255 if ((x95 > 255)) else x95))
            out.b[po3] = (x111 & 255)
            po3 = (po3 + stride2)
            out.b[po3] = (x111 & 255)
            po3 = (po3 + stride2)
            out.b[po3] = (x111 & 255)
            po3 = (po3 + stride2)
            out.b[po3] = (x111 & 255)
            po3 = (po3 + stride2)
            out.b[po3] = (x111 & 255)
            po3 = (po3 + stride2)
            out.b[po3] = (x111 & 255)
            po3 = (po3 + stride2)
            out.b[po3] = (x111 & 255)
            po3 = (po3 + stride2)
            out.b[po3] = (x111 & 255)
            po3 = (po3 + stride2)
        else:
            x010 = (((self.block[2] << 8)) + 8192)
            x810 = ((565 * ((x410 + x510))) + 4)
            x410 = ((x810 + ((2276 * x410))) >> 3)
            x510 = ((x810 - ((3406 * x510))) >> 3)
            x810 = ((2408 * ((x610 + x710))) + 4)
            x610 = ((x810 - ((799 * x610))) >> 3)
            x710 = ((x810 - ((4017 * x710))) >> 3)
            x810 = (x010 + x111)
            x010 = (x010 - x111)
            x111 = ((1108 * ((x311 + x211))) + 4)
            x211 = ((x111 - ((3784 * x211))) >> 3)
            x311 = ((x111 + ((1568 * x311))) >> 3)
            x111 = (x410 + x610)
            x410 = (x410 - x610)
            x610 = (x510 + x710)
            x510 = (x510 - x710)
            x710 = (x810 + x311)
            x810 = (x810 - x311)
            x311 = (x010 + x211)
            x010 = (x010 - x211)
            x211 = (((181 * ((x410 + x510))) + 128) >> 8)
            x410 = (((181 * ((x410 - x510))) + 128) >> 8)
            x96 = ((((x710 + x111) >> 14)) + 128)
            out.b[po3] = (((0 if ((x96 < 0)) else (255 if ((x96 > 255)) else x96))) & 255)
            po3 = (po3 + stride2)
            x97 = ((((x311 + x211) >> 14)) + 128)
            out.b[po3] = (((0 if ((x97 < 0)) else (255 if ((x97 > 255)) else x97))) & 255)
            po3 = (po3 + stride2)
            x98 = ((((x010 + x410) >> 14)) + 128)
            out.b[po3] = (((0 if ((x98 < 0)) else (255 if ((x98 > 255)) else x98))) & 255)
            po3 = (po3 + stride2)
            x99 = ((((x810 + x610) >> 14)) + 128)
            out.b[po3] = (((0 if ((x99 < 0)) else (255 if ((x99 > 255)) else x99))) & 255)
            po3 = (po3 + stride2)
            x100 = ((((x810 - x610) >> 14)) + 128)
            out.b[po3] = (((0 if ((x100 < 0)) else (255 if ((x100 > 255)) else x100))) & 255)
            po3 = (po3 + stride2)
            x101 = ((((x010 - x410) >> 14)) + 128)
            out.b[po3] = (((0 if ((x101 < 0)) else (255 if ((x101 > 255)) else x101))) & 255)
            po3 = (po3 + stride2)
            x102 = ((((x311 - x211) >> 14)) + 128)
            out.b[po3] = (((0 if ((x102 < 0)) else (255 if ((x102 > 255)) else x102))) & 255)
            po3 = (po3 + stride2)
            x103 = ((((x710 - x111) >> 14)) + 128)
            out.b[po3] = (((0 if ((x103 < 0)) else (255 if ((x103 > 255)) else x103))) & 255)
        po4 = (3 + po)
        stride3 = c.stride
        x011 = None
        x811 = None
        x112 = (self.block[35] << 8)
        x212 = self.block[51]
        x312 = self.block[19]
        x411 = self.block[11]
        x511 = self.block[59]
        x611 = self.block[43]
        x711 = self.block[27]
        if ((((((((x112 | x212) | x312) | x411) | x511) | x611) | x711)) == 0):
            x104 = ((((self.block[3] + 32) >> 6)) + 128)
            x112 = (0 if ((x104 < 0)) else (255 if ((x104 > 255)) else x104))
            out.b[po4] = (x112 & 255)
            po4 = (po4 + stride3)
            out.b[po4] = (x112 & 255)
            po4 = (po4 + stride3)
            out.b[po4] = (x112 & 255)
            po4 = (po4 + stride3)
            out.b[po4] = (x112 & 255)
            po4 = (po4 + stride3)
            out.b[po4] = (x112 & 255)
            po4 = (po4 + stride3)
            out.b[po4] = (x112 & 255)
            po4 = (po4 + stride3)
            out.b[po4] = (x112 & 255)
            po4 = (po4 + stride3)
            out.b[po4] = (x112 & 255)
            po4 = (po4 + stride3)
        else:
            x011 = (((self.block[3] << 8)) + 8192)
            x811 = ((565 * ((x411 + x511))) + 4)
            x411 = ((x811 + ((2276 * x411))) >> 3)
            x511 = ((x811 - ((3406 * x511))) >> 3)
            x811 = ((2408 * ((x611 + x711))) + 4)
            x611 = ((x811 - ((799 * x611))) >> 3)
            x711 = ((x811 - ((4017 * x711))) >> 3)
            x811 = (x011 + x112)
            x011 = (x011 - x112)
            x112 = ((1108 * ((x312 + x212))) + 4)
            x212 = ((x112 - ((3784 * x212))) >> 3)
            x312 = ((x112 + ((1568 * x312))) >> 3)
            x112 = (x411 + x611)
            x411 = (x411 - x611)
            x611 = (x511 + x711)
            x511 = (x511 - x711)
            x711 = (x811 + x312)
            x811 = (x811 - x312)
            x312 = (x011 + x212)
            x011 = (x011 - x212)
            x212 = (((181 * ((x411 + x511))) + 128) >> 8)
            x411 = (((181 * ((x411 - x511))) + 128) >> 8)
            x105 = ((((x711 + x112) >> 14)) + 128)
            out.b[po4] = (((0 if ((x105 < 0)) else (255 if ((x105 > 255)) else x105))) & 255)
            po4 = (po4 + stride3)
            x106 = ((((x312 + x212) >> 14)) + 128)
            out.b[po4] = (((0 if ((x106 < 0)) else (255 if ((x106 > 255)) else x106))) & 255)
            po4 = (po4 + stride3)
            x107 = ((((x011 + x411) >> 14)) + 128)
            out.b[po4] = (((0 if ((x107 < 0)) else (255 if ((x107 > 255)) else x107))) & 255)
            po4 = (po4 + stride3)
            x108 = ((((x811 + x611) >> 14)) + 128)
            out.b[po4] = (((0 if ((x108 < 0)) else (255 if ((x108 > 255)) else x108))) & 255)
            po4 = (po4 + stride3)
            x109 = ((((x811 - x611) >> 14)) + 128)
            out.b[po4] = (((0 if ((x109 < 0)) else (255 if ((x109 > 255)) else x109))) & 255)
            po4 = (po4 + stride3)
            x113 = ((((x011 - x411) >> 14)) + 128)
            out.b[po4] = (((0 if ((x113 < 0)) else (255 if ((x113 > 255)) else x113))) & 255)
            po4 = (po4 + stride3)
            x114 = ((((x312 - x212) >> 14)) + 128)
            out.b[po4] = (((0 if ((x114 < 0)) else (255 if ((x114 > 255)) else x114))) & 255)
            po4 = (po4 + stride3)
            x115 = ((((x711 - x112) >> 14)) + 128)
            out.b[po4] = (((0 if ((x115 < 0)) else (255 if ((x115 > 255)) else x115))) & 255)
        po5 = (4 + po)
        stride4 = c.stride
        x012 = None
        x812 = None
        x116 = (self.block[36] << 8)
        x213 = self.block[52]
        x313 = self.block[20]
        x412 = self.block[12]
        x512 = self.block[60]
        x612 = self.block[44]
        x712 = self.block[28]
        if ((((((((x116 | x213) | x313) | x412) | x512) | x612) | x712)) == 0):
            x117 = ((((self.block[4] + 32) >> 6)) + 128)
            x116 = (0 if ((x117 < 0)) else (255 if ((x117 > 255)) else x117))
            out.b[po5] = (x116 & 255)
            po5 = (po5 + stride4)
            out.b[po5] = (x116 & 255)
            po5 = (po5 + stride4)
            out.b[po5] = (x116 & 255)
            po5 = (po5 + stride4)
            out.b[po5] = (x116 & 255)
            po5 = (po5 + stride4)
            out.b[po5] = (x116 & 255)
            po5 = (po5 + stride4)
            out.b[po5] = (x116 & 255)
            po5 = (po5 + stride4)
            out.b[po5] = (x116 & 255)
            po5 = (po5 + stride4)
            out.b[po5] = (x116 & 255)
            po5 = (po5 + stride4)
        else:
            x012 = (((self.block[4] << 8)) + 8192)
            x812 = ((565 * ((x412 + x512))) + 4)
            x412 = ((x812 + ((2276 * x412))) >> 3)
            x512 = ((x812 - ((3406 * x512))) >> 3)
            x812 = ((2408 * ((x612 + x712))) + 4)
            x612 = ((x812 - ((799 * x612))) >> 3)
            x712 = ((x812 - ((4017 * x712))) >> 3)
            x812 = (x012 + x116)
            x012 = (x012 - x116)
            x116 = ((1108 * ((x313 + x213))) + 4)
            x213 = ((x116 - ((3784 * x213))) >> 3)
            x313 = ((x116 + ((1568 * x313))) >> 3)
            x116 = (x412 + x612)
            x412 = (x412 - x612)
            x612 = (x512 + x712)
            x512 = (x512 - x712)
            x712 = (x812 + x313)
            x812 = (x812 - x313)
            x313 = (x012 + x213)
            x012 = (x012 - x213)
            x213 = (((181 * ((x412 + x512))) + 128) >> 8)
            x412 = (((181 * ((x412 - x512))) + 128) >> 8)
            x118 = ((((x712 + x116) >> 14)) + 128)
            out.b[po5] = (((0 if ((x118 < 0)) else (255 if ((x118 > 255)) else x118))) & 255)
            po5 = (po5 + stride4)
            x119 = ((((x313 + x213) >> 14)) + 128)
            out.b[po5] = (((0 if ((x119 < 0)) else (255 if ((x119 > 255)) else x119))) & 255)
            po5 = (po5 + stride4)
            x120 = ((((x012 + x412) >> 14)) + 128)
            out.b[po5] = (((0 if ((x120 < 0)) else (255 if ((x120 > 255)) else x120))) & 255)
            po5 = (po5 + stride4)
            x121 = ((((x812 + x612) >> 14)) + 128)
            out.b[po5] = (((0 if ((x121 < 0)) else (255 if ((x121 > 255)) else x121))) & 255)
            po5 = (po5 + stride4)
            x122 = ((((x812 - x612) >> 14)) + 128)
            out.b[po5] = (((0 if ((x122 < 0)) else (255 if ((x122 > 255)) else x122))) & 255)
            po5 = (po5 + stride4)
            x123 = ((((x012 - x412) >> 14)) + 128)
            out.b[po5] = (((0 if ((x123 < 0)) else (255 if ((x123 > 255)) else x123))) & 255)
            po5 = (po5 + stride4)
            x124 = ((((x313 - x213) >> 14)) + 128)
            out.b[po5] = (((0 if ((x124 < 0)) else (255 if ((x124 > 255)) else x124))) & 255)
            po5 = (po5 + stride4)
            x125 = ((((x712 - x116) >> 14)) + 128)
            out.b[po5] = (((0 if ((x125 < 0)) else (255 if ((x125 > 255)) else x125))) & 255)
        po6 = (5 + po)
        stride5 = c.stride
        x013 = None
        x813 = None
        x126 = (self.block[37] << 8)
        x214 = self.block[53]
        x314 = self.block[21]
        x413 = self.block[13]
        x513 = self.block[61]
        x613 = self.block[45]
        x713 = self.block[29]
        if ((((((((x126 | x214) | x314) | x413) | x513) | x613) | x713)) == 0):
            x127 = ((((self.block[5] + 32) >> 6)) + 128)
            x126 = (0 if ((x127 < 0)) else (255 if ((x127 > 255)) else x127))
            out.b[po6] = (x126 & 255)
            po6 = (po6 + stride5)
            out.b[po6] = (x126 & 255)
            po6 = (po6 + stride5)
            out.b[po6] = (x126 & 255)
            po6 = (po6 + stride5)
            out.b[po6] = (x126 & 255)
            po6 = (po6 + stride5)
            out.b[po6] = (x126 & 255)
            po6 = (po6 + stride5)
            out.b[po6] = (x126 & 255)
            po6 = (po6 + stride5)
            out.b[po6] = (x126 & 255)
            po6 = (po6 + stride5)
            out.b[po6] = (x126 & 255)
            po6 = (po6 + stride5)
        else:
            x013 = (((self.block[5] << 8)) + 8192)
            x813 = ((565 * ((x413 + x513))) + 4)
            x413 = ((x813 + ((2276 * x413))) >> 3)
            x513 = ((x813 - ((3406 * x513))) >> 3)
            x813 = ((2408 * ((x613 + x713))) + 4)
            x613 = ((x813 - ((799 * x613))) >> 3)
            x713 = ((x813 - ((4017 * x713))) >> 3)
            x813 = (x013 + x126)
            x013 = (x013 - x126)
            x126 = ((1108 * ((x314 + x214))) + 4)
            x214 = ((x126 - ((3784 * x214))) >> 3)
            x314 = ((x126 + ((1568 * x314))) >> 3)
            x126 = (x413 + x613)
            x413 = (x413 - x613)
            x613 = (x513 + x713)
            x513 = (x513 - x713)
            x713 = (x813 + x314)
            x813 = (x813 - x314)
            x314 = (x013 + x214)
            x013 = (x013 - x214)
            x214 = (((181 * ((x413 + x513))) + 128) >> 8)
            x413 = (((181 * ((x413 - x513))) + 128) >> 8)
            x128 = ((((x713 + x126) >> 14)) + 128)
            out.b[po6] = (((0 if ((x128 < 0)) else (255 if ((x128 > 255)) else x128))) & 255)
            po6 = (po6 + stride5)
            x129 = ((((x314 + x214) >> 14)) + 128)
            out.b[po6] = (((0 if ((x129 < 0)) else (255 if ((x129 > 255)) else x129))) & 255)
            po6 = (po6 + stride5)
            x130 = ((((x013 + x413) >> 14)) + 128)
            out.b[po6] = (((0 if ((x130 < 0)) else (255 if ((x130 > 255)) else x130))) & 255)
            po6 = (po6 + stride5)
            x131 = ((((x813 + x613) >> 14)) + 128)
            out.b[po6] = (((0 if ((x131 < 0)) else (255 if ((x131 > 255)) else x131))) & 255)
            po6 = (po6 + stride5)
            x132 = ((((x813 - x613) >> 14)) + 128)
            out.b[po6] = (((0 if ((x132 < 0)) else (255 if ((x132 > 255)) else x132))) & 255)
            po6 = (po6 + stride5)
            x133 = ((((x013 - x413) >> 14)) + 128)
            out.b[po6] = (((0 if ((x133 < 0)) else (255 if ((x133 > 255)) else x133))) & 255)
            po6 = (po6 + stride5)
            x134 = ((((x314 - x214) >> 14)) + 128)
            out.b[po6] = (((0 if ((x134 < 0)) else (255 if ((x134 > 255)) else x134))) & 255)
            po6 = (po6 + stride5)
            x135 = ((((x713 - x126) >> 14)) + 128)
            out.b[po6] = (((0 if ((x135 < 0)) else (255 if ((x135 > 255)) else x135))) & 255)
        po7 = (6 + po)
        stride6 = c.stride
        x014 = None
        x814 = None
        x136 = (self.block[38] << 8)
        x215 = self.block[54]
        x315 = self.block[22]
        x414 = self.block[14]
        x514 = self.block[62]
        x614 = self.block[46]
        x714 = self.block[30]
        if ((((((((x136 | x215) | x315) | x414) | x514) | x614) | x714)) == 0):
            x137 = ((((self.block[6] + 32) >> 6)) + 128)
            x136 = (0 if ((x137 < 0)) else (255 if ((x137 > 255)) else x137))
            out.b[po7] = (x136 & 255)
            po7 = (po7 + stride6)
            out.b[po7] = (x136 & 255)
            po7 = (po7 + stride6)
            out.b[po7] = (x136 & 255)
            po7 = (po7 + stride6)
            out.b[po7] = (x136 & 255)
            po7 = (po7 + stride6)
            out.b[po7] = (x136 & 255)
            po7 = (po7 + stride6)
            out.b[po7] = (x136 & 255)
            po7 = (po7 + stride6)
            out.b[po7] = (x136 & 255)
            po7 = (po7 + stride6)
            out.b[po7] = (x136 & 255)
            po7 = (po7 + stride6)
        else:
            x014 = (((self.block[6] << 8)) + 8192)
            x814 = ((565 * ((x414 + x514))) + 4)
            x414 = ((x814 + ((2276 * x414))) >> 3)
            x514 = ((x814 - ((3406 * x514))) >> 3)
            x814 = ((2408 * ((x614 + x714))) + 4)
            x614 = ((x814 - ((799 * x614))) >> 3)
            x714 = ((x814 - ((4017 * x714))) >> 3)
            x814 = (x014 + x136)
            x014 = (x014 - x136)
            x136 = ((1108 * ((x315 + x215))) + 4)
            x215 = ((x136 - ((3784 * x215))) >> 3)
            x315 = ((x136 + ((1568 * x315))) >> 3)
            x136 = (x414 + x614)
            x414 = (x414 - x614)
            x614 = (x514 + x714)
            x514 = (x514 - x714)
            x714 = (x814 + x315)
            x814 = (x814 - x315)
            x315 = (x014 + x215)
            x014 = (x014 - x215)
            x215 = (((181 * ((x414 + x514))) + 128) >> 8)
            x414 = (((181 * ((x414 - x514))) + 128) >> 8)
            x138 = ((((x714 + x136) >> 14)) + 128)
            out.b[po7] = (((0 if ((x138 < 0)) else (255 if ((x138 > 255)) else x138))) & 255)
            po7 = (po7 + stride6)
            x139 = ((((x315 + x215) >> 14)) + 128)
            out.b[po7] = (((0 if ((x139 < 0)) else (255 if ((x139 > 255)) else x139))) & 255)
            po7 = (po7 + stride6)
            x140 = ((((x014 + x414) >> 14)) + 128)
            out.b[po7] = (((0 if ((x140 < 0)) else (255 if ((x140 > 255)) else x140))) & 255)
            po7 = (po7 + stride6)
            x141 = ((((x814 + x614) >> 14)) + 128)
            out.b[po7] = (((0 if ((x141 < 0)) else (255 if ((x141 > 255)) else x141))) & 255)
            po7 = (po7 + stride6)
            x142 = ((((x814 - x614) >> 14)) + 128)
            out.b[po7] = (((0 if ((x142 < 0)) else (255 if ((x142 > 255)) else x142))) & 255)
            po7 = (po7 + stride6)
            x143 = ((((x014 - x414) >> 14)) + 128)
            out.b[po7] = (((0 if ((x143 < 0)) else (255 if ((x143 > 255)) else x143))) & 255)
            po7 = (po7 + stride6)
            x144 = ((((x315 - x215) >> 14)) + 128)
            out.b[po7] = (((0 if ((x144 < 0)) else (255 if ((x144 > 255)) else x144))) & 255)
            po7 = (po7 + stride6)
            x145 = ((((x714 - x136) >> 14)) + 128)
            out.b[po7] = (((0 if ((x145 < 0)) else (255 if ((x145 > 255)) else x145))) & 255)
        po8 = (7 + po)
        stride7 = c.stride
        x015 = None
        x815 = None
        x146 = (self.block[39] << 8)
        x216 = self.block[55]
        x316 = self.block[23]
        x415 = self.block[15]
        x515 = self.block[63]
        x615 = self.block[47]
        x715 = self.block[31]
        if ((((((((x146 | x216) | x316) | x415) | x515) | x615) | x715)) == 0):
            x147 = ((((self.block[7] + 32) >> 6)) + 128)
            x146 = (0 if ((x147 < 0)) else (255 if ((x147 > 255)) else x147))
            out.b[po8] = (x146 & 255)
            po8 = (po8 + stride7)
            out.b[po8] = (x146 & 255)
            po8 = (po8 + stride7)
            out.b[po8] = (x146 & 255)
            po8 = (po8 + stride7)
            out.b[po8] = (x146 & 255)
            po8 = (po8 + stride7)
            out.b[po8] = (x146 & 255)
            po8 = (po8 + stride7)
            out.b[po8] = (x146 & 255)
            po8 = (po8 + stride7)
            out.b[po8] = (x146 & 255)
            po8 = (po8 + stride7)
            out.b[po8] = (x146 & 255)
            po8 = (po8 + stride7)
        else:
            x015 = (((self.block[7] << 8)) + 8192)
            x815 = ((565 * ((x415 + x515))) + 4)
            x415 = ((x815 + ((2276 * x415))) >> 3)
            x515 = ((x815 - ((3406 * x515))) >> 3)
            x815 = ((2408 * ((x615 + x715))) + 4)
            x615 = ((x815 - ((799 * x615))) >> 3)
            x715 = ((x815 - ((4017 * x715))) >> 3)
            x815 = (x015 + x146)
            x015 = (x015 - x146)
            x146 = ((1108 * ((x316 + x216))) + 4)
            x216 = ((x146 - ((3784 * x216))) >> 3)
            x316 = ((x146 + ((1568 * x316))) >> 3)
            x146 = (x415 + x615)
            x415 = (x415 - x615)
            x615 = (x515 + x715)
            x515 = (x515 - x715)
            x715 = (x815 + x316)
            x815 = (x815 - x316)
            x316 = (x015 + x216)
            x015 = (x015 - x216)
            x216 = (((181 * ((x415 + x515))) + 128) >> 8)
            x415 = (((181 * ((x415 - x515))) + 128) >> 8)
            x148 = ((((x715 + x146) >> 14)) + 128)
            out.b[po8] = (((0 if ((x148 < 0)) else (255 if ((x148 > 255)) else x148))) & 255)
            po8 = (po8 + stride7)
            x149 = ((((x316 + x216) >> 14)) + 128)
            out.b[po8] = (((0 if ((x149 < 0)) else (255 if ((x149 > 255)) else x149))) & 255)
            po8 = (po8 + stride7)
            x150 = ((((x015 + x415) >> 14)) + 128)
            out.b[po8] = (((0 if ((x150 < 0)) else (255 if ((x150 > 255)) else x150))) & 255)
            po8 = (po8 + stride7)
            x151 = ((((x815 + x615) >> 14)) + 128)
            out.b[po8] = (((0 if ((x151 < 0)) else (255 if ((x151 > 255)) else x151))) & 255)
            po8 = (po8 + stride7)
            x152 = ((((x815 - x615) >> 14)) + 128)
            out.b[po8] = (((0 if ((x152 < 0)) else (255 if ((x152 > 255)) else x152))) & 255)
            po8 = (po8 + stride7)
            x153 = ((((x015 - x415) >> 14)) + 128)
            out.b[po8] = (((0 if ((x153 < 0)) else (255 if ((x153 > 255)) else x153))) & 255)
            po8 = (po8 + stride7)
            x154 = ((((x316 - x216) >> 14)) + 128)
            out.b[po8] = (((0 if ((x154 < 0)) else (255 if ((x154 > 255)) else x154))) & 255)
            po8 = (po8 + stride7)
            x155 = ((((x715 - x146) >> 14)) + 128)
            out.b[po8] = (((0 if ((x155 < 0)) else (255 if ((x155 > 255)) else x155))) & 255)

    def notSupported(self):
        raise _HxException("This JPG file is not supported")

    def njDecodeScan(self):
        self.length = ((self.bytes.b[self.pos] << 8) | self.bytes.b[(self.pos + 1)])
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + 2)
        _hx_local_0.pos
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.size
        _hx_local_2.size = (_hx_local_3 - 2)
        _hx_local_2.size
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.length
        _hx_local_4.length = (_hx_local_5 - 2)
        _hx_local_4.length
        if (self.bytes.b[self.pos] != self.ncomp):
            self.notSupported()
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6.pos
        _hx_local_6.pos = (_hx_local_7 + 1)
        _hx_local_6.pos
        _hx_local_8 = self
        _hx_local_9 = _hx_local_8.size
        _hx_local_8.size = (_hx_local_9 - 1)
        _hx_local_8.size
        _hx_local_10 = self
        _hx_local_11 = _hx_local_10.length
        _hx_local_10.length = (_hx_local_11 - 1)
        _hx_local_10.length
        _g = 0
        _g1 = self.ncomp
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            c = self.comps[i]
            flag = (self.bytes.b[self.pos] != c.cid)
            flag1 = (((self.bytes.b[(self.pos + 1)] & 236)) != 0)
            c.dctabsel = ((self.bytes.b[(self.pos + 1)] >> 4) << 1)
            c.actabsel = ((((self.bytes.b[(self.pos + 1)] & 3)) << 1) | 1)
            _hx_local_12 = self
            _hx_local_13 = _hx_local_12.pos
            _hx_local_12.pos = (_hx_local_13 + 2)
            _hx_local_12.pos
            _hx_local_14 = self
            _hx_local_15 = _hx_local_14.size
            _hx_local_14.size = (_hx_local_15 - 2)
            _hx_local_14.size
            _hx_local_16 = self
            _hx_local_17 = _hx_local_16.length
            _hx_local_16.length = (_hx_local_17 - 2)
            _hx_local_16.length
        start = self.bytes.b[self.pos]
        count = self.bytes.b[(self.pos + 1)]
        other = self.bytes.b[(self.pos + 2)]
        if ((((not self.progressive) and ((start != 0))) or ((count != ((63 - start))))) or ((other != 0))):
            self.notSupported()
        count1 = self.length
        _hx_local_18 = self
        _hx_local_19 = _hx_local_18.pos
        _hx_local_18.pos = (_hx_local_19 + count1)
        _hx_local_18.pos
        _hx_local_20 = self
        _hx_local_21 = _hx_local_20.size
        _hx_local_20.size = (_hx_local_21 - count1)
        _hx_local_20.size
        _hx_local_22 = self
        _hx_local_23 = _hx_local_22.length
        _hx_local_22.length = (_hx_local_23 - count1)
        _hx_local_22.length
        mbx = 0
        mby = 0
        rstcount = self.rstinterval
        nextrst = 0
        while True:
            _g2 = 0
            _g3 = self.ncomp
            while (_g2 < _g3):
                i1 = _g2
                _g2 = (_g2 + 1)
                c1 = self.comps[i1]
                _g21 = 0
                _g31 = c1.ssy
                while (_g21 < _g31):
                    sby = _g21
                    _g21 = (_g21 + 1)
                    _g22 = 0
                    _g32 = c1.ssx
                    while (_g22 < _g32):
                        sbx = _g22
                        _g22 = (_g22 + 1)
                        self.njDecodeBlock(c1,(((((((mby * c1.ssy) + sby)) * c1.stride) + ((mbx * c1.ssx))) + sbx) << 3))
            mbx = (mbx + 1)
            tmp = mbx
            if (tmp >= self.mbwidth):
                mbx = 0
                mby = (mby + 1)
                tmp1 = mby
                if (tmp1 >= self.mbheight):
                    break
            tmp2 = None
            if (self.rstinterval != 0):
                rstcount = (rstcount - 1)
                tmp3 = rstcount
                tmp2 = (tmp3 == 0)
            else:
                tmp2 = False
            if tmp2:
                _hx_local_24 = self
                _hx_local_25 = _hx_local_24.bufbits
                _hx_local_24.bufbits = (_hx_local_25 & 248)
                _hx_local_24.bufbits
                r = self.njShowBits(16)
                _hx_local_26 = self
                _hx_local_27 = _hx_local_26.bufbits
                _hx_local_26.bufbits = (_hx_local_27 - 16)
                _hx_local_26.bufbits
                i2 = r
                nextrst = ((nextrst + 1) & 7)
                rstcount = self.rstinterval
                self.comps[0].dcpred = 0
                self.comps[1].dcpred = 0
                self.comps[2].dcpred = 0

    def njUpsampleH(self,c):
        xmax = (c.width - 3)
        cout = haxe_io_Bytes.alloc(((c.width * c.height) << 1))
        this1 = cout
        lout = this1
        this2 = c.pixels
        lin = this2
        pi = 0
        po = 0
        _g = 0
        _g1 = c.height
        while (_g < _g1):
            y = _g
            _g = (_g + 1)
            x = ((((139 * lin.b[pi]) + ((-11 * lin.b[(pi + 1)]))) + 64) >> 7)
            lout.b[po] = (((0 if ((x < 0)) else (255 if ((x > 255)) else x))) & 255)
            x1 = (((((104 * lin.b[pi]) + ((27 * lin.b[(pi + 1)]))) + ((-3 * lin.b[(pi + 2)]))) + 64) >> 7)
            lout.b[(po + 1)] = (((0 if ((x1 < 0)) else (255 if ((x1 > 255)) else x1))) & 255)
            x2 = (((((28 * lin.b[pi]) + ((109 * lin.b[(pi + 1)]))) + ((-9 * lin.b[(pi + 2)]))) + 64) >> 7)
            lout.b[(po + 2)] = (((0 if ((x2 < 0)) else (255 if ((x2 > 255)) else x2))) & 255)
            _g2 = 0
            _g11 = xmax
            while (_g2 < _g11):
                x3 = _g2
                _g2 = (_g2 + 1)
                x4 = ((((((-9 * lin.b[(pi + x3)]) + ((111 * lin.b[((pi + x3) + 1)]))) + ((29 * lin.b[((pi + x3) + 2)]))) + ((-3 * lin.b[((pi + x3) + 3)]))) + 64) >> 7)
                lout.b[((po + ((x3 << 1))) + 3)] = (((0 if ((x4 < 0)) else (255 if ((x4 > 255)) else x4))) & 255)
                x5 = ((((((-3 * lin.b[(pi + x3)]) + ((29 * lin.b[((pi + x3) + 1)]))) + ((111 * lin.b[((pi + x3) + 2)]))) + ((-9 * lin.b[((pi + x3) + 3)]))) + 64) >> 7)
                lout.b[((po + ((x3 << 1))) + 4)] = (((0 if ((x5 < 0)) else (255 if ((x5 > 255)) else x5))) & 255)
            pi = (pi + c.stride)
            po = (po + ((c.width << 1)))
            x6 = (((((28 * lin.b[(pi - 1)]) + ((109 * lin.b[(pi - 2)]))) + ((-9 * lin.b[(pi - 3)]))) + 64) >> 7)
            lout.b[(po - 3)] = (((0 if ((x6 < 0)) else (255 if ((x6 > 255)) else x6))) & 255)
            x7 = (((((104 * lin.b[(pi - 1)]) + ((27 * lin.b[(pi - 2)]))) + ((-3 * lin.b[(pi - 3)]))) + 64) >> 7)
            lout.b[(po - 2)] = (((0 if ((x7 < 0)) else (255 if ((x7 > 255)) else x7))) & 255)
            x8 = ((((139 * lin.b[(pi - 1)]) + ((-11 * lin.b[(pi - 2)]))) + 64) >> 7)
            lout.b[(po - 1)] = (((0 if ((x8 < 0)) else (255 if ((x8 > 255)) else x8))) & 255)
        c.width = (c.width << 1)
        c.stride = c.width
        c.pixels = cout

    def njUpsampleV(self,c):
        w = c.width
        s1 = c.stride
        s2 = (s1 + s1)
        out = haxe_io_Bytes.alloc(((c.width * c.height) << 1))
        pi = 0
        po = 0
        this1 = out
        cout = this1
        this2 = c.pixels
        cin = this2
        _g = 0
        _g1 = w
        while (_g < _g1):
            x = _g
            _g = (_g + 1)
            po = x
            pi = po
            x1 = ((((139 * cin.b[pi]) + ((-11 * cin.b[(pi + s1)]))) + 64) >> 7)
            cout.b[po] = (((0 if ((x1 < 0)) else (255 if ((x1 > 255)) else x1))) & 255)
            po = (po + w)
            x2 = (((((104 * cin.b[pi]) + ((27 * cin.b[(pi + s1)]))) + ((-3 * cin.b[(pi + s2)]))) + 64) >> 7)
            cout.b[po] = (((0 if ((x2 < 0)) else (255 if ((x2 > 255)) else x2))) & 255)
            po = (po + w)
            x3 = (((((28 * cin.b[pi]) + ((109 * cin.b[(pi + s1)]))) + ((-9 * cin.b[(pi + s2)]))) + 64) >> 7)
            cout.b[po] = (((0 if ((x3 < 0)) else (255 if ((x3 > 255)) else x3))) & 255)
            po = (po + w)
            pi = (pi + s1)
            _g2 = 0
            _g11 = (c.height - 2)
            while (_g2 < _g11):
                y = _g2
                _g2 = (_g2 + 1)
                x4 = ((((((-9 * cin.b[(pi - s1)]) + ((111 * cin.b[pi]))) + ((29 * cin.b[(pi + s1)]))) + ((-3 * cin.b[(pi + s2)]))) + 64) >> 7)
                cout.b[po] = (((0 if ((x4 < 0)) else (255 if ((x4 > 255)) else x4))) & 255)
                po = (po + w)
                x5 = ((((((-3 * cin.b[(pi - s1)]) + ((29 * cin.b[pi]))) + ((111 * cin.b[(pi + s1)]))) + ((-9 * cin.b[(pi + s2)]))) + 64) >> 7)
                cout.b[po] = (((0 if ((x5 < 0)) else (255 if ((x5 > 255)) else x5))) & 255)
                po = (po + w)
                pi = (pi + s1)
            pi = (pi + s1)
            x6 = (((((28 * cin.b[pi]) + ((109 * cin.b[(pi - s1)]))) + ((-9 * cin.b[(pi - s2)]))) + 64) >> 7)
            cout.b[po] = (((0 if ((x6 < 0)) else (255 if ((x6 > 255)) else x6))) & 255)
            po = (po + w)
            x7 = (((((104 * cin.b[pi]) + ((27 * cin.b[(pi - s1)]))) + ((-3 * cin.b[(pi - s2)]))) + 64) >> 7)
            cout.b[po] = (((0 if ((x7 < 0)) else (255 if ((x7 > 255)) else x7))) & 255)
            po = (po + w)
            x8 = ((((139 * cin.b[pi]) + ((-11 * cin.b[(pi - s1)]))) + 64) >> 7)
            cout.b[po] = (((0 if ((x8 < 0)) else (255 if ((x8 > 255)) else x8))) & 255)
        c.height = (c.height << 1)
        c.stride = c.width
        c.pixels = out

    def njUpsample(self,c):
        xshift = 0
        yshift = 0
        while (c.width < self.width):
            c.width = (c.width << 1)
            xshift = (xshift + 1)
        while (c.height < self.height):
            c.height = (c.height << 1)
            yshift = (yshift + 1)
        out = haxe_io_Bytes.alloc((c.width * c.height))
        this1 = c.pixels
        lin = this1
        pout = 0
        this2 = out
        lout = this2
        _g = 0
        _g1 = c.height
        while (_g < _g1):
            y = _g
            _g = (_g + 1)
            pin = (((y >> yshift)) * c.stride)
            _g2 = 0
            _g11 = c.width
            while (_g2 < _g11):
                x = _g2
                _g2 = (_g2 + 1)
                pos = pout
                pout = (pout + 1)
                v = lin.b[(((x >> xshift)) + pin)]
                lout.b[pos] = (v & 255)
        c.stride = c.width
        c.pixels = out

    def njConvert(self):
        _g = 0
        _g1 = self.ncomp
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            c = self.comps[i]
            tmp = self.filter.index
            if (tmp == 0):
                if ((c.width < self.width) or ((c.height < self.height))):
                    self.njUpsample(c)
            elif (tmp == 1):
                while ((c.width < self.width) or ((c.height < self.height))):
                    if (c.width < self.width):
                        self.njUpsampleH(c)
                    if (c.height < self.height):
                        self.njUpsampleV(c)
            else:
                pass
            if ((c.width < self.width) or ((c.height < self.height))):
                raise _HxException("assert")
        pixels = haxe_io_Bytes.alloc(((self.width * self.height) * 4))
        if (self.ncomp == 3):
            this1 = self.comps[0].pixels
            py = this1
            this2 = self.comps[1].pixels
            pcb = this2
            this3 = self.comps[2].pixels
            pcr = this3
            this4 = pixels
            pix = this4
            k1 = 0
            k2 = 0
            k3 = 0
            out = 0
            _g2 = 0
            _g3 = self.height
            while (_g2 < _g3):
                yy = _g2
                _g2 = (_g2 + 1)
                _g21 = 0
                _g31 = self.width
                while (_g21 < _g31):
                    x = _g21
                    _g21 = (_g21 + 1)
                    i1 = k1
                    k1 = (k1 + 1)
                    y = (py.b[i1] << 8)
                    i2 = k2
                    k2 = (k2 + 1)
                    cb = (pcb.b[i2] - 128)
                    i3 = k3
                    k3 = (k3 + 1)
                    cr = (pcr.b[i3] - 128)
                    x1 = (((y + ((359 * cr))) + 128) >> 8)
                    r = (0 if ((x1 < 0)) else (255 if ((x1 > 255)) else x1))
                    x2 = ((((y - ((88 * cb))) - ((183 * cr))) + 128) >> 8)
                    g = (0 if ((x2 < 0)) else (255 if ((x2 > 255)) else x2))
                    x3 = (((y + ((454 * cb))) + 128) >> 8)
                    b = (0 if ((x3 < 0)) else (255 if ((x3 > 255)) else x3))
                    out1 = out
                    out = (out + 1)
                    pix.b[out1] = (b & 255)
                    out2 = out
                    out = (out + 1)
                    pix.b[out2] = (g & 255)
                    out3 = out
                    out = (out + 1)
                    pix.b[out3] = (r & 255)
                    out4 = out
                    out = (out + 1)
                    pix.b[out4] = 255
                k1 = (k1 + ((self.comps[0].stride - self.width)))
                k2 = (k2 + ((self.comps[1].stride - self.width)))
                k3 = (k3 + ((self.comps[2].stride - self.width)))
        else:
            raise _HxException("TODO")
        return pixels

    def njDecode(self):
        if (((self.size < 2) or ((self.bytes.b[self.pos] != 255))) or ((self.bytes.b[(self.pos + 1)] != 216))):
            raise _HxException("This file is not a JPEG")
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + 2)
        _hx_local_0.pos
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.size
        _hx_local_2.size = (_hx_local_3 - 2)
        _hx_local_2.size
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.length
        _hx_local_4.length = (_hx_local_5 - 2)
        _hx_local_4.length
        while True:
            flag = ((self.size < 2) or ((self.bytes.b[self.pos] != 255)))
            _hx_local_6 = self
            _hx_local_7 = _hx_local_6.pos
            _hx_local_6.pos = (_hx_local_7 + 2)
            _hx_local_6.pos
            _hx_local_8 = self
            _hx_local_9 = _hx_local_8.size
            _hx_local_8.size = (_hx_local_9 - 2)
            _hx_local_8.size
            _hx_local_10 = self
            _hx_local_11 = _hx_local_10.length
            _hx_local_10.length = (_hx_local_11 - 2)
            _hx_local_10.length
            _g = self.bytes.b[(self.pos + (-1))]
            if (_g == 192):
                self.njDecodeSOF()
            elif (_g == 194):
                self.progressive = True
                if self.progressive:
                    raise _HxException("Unsupported progressive JPG")
                if (self.vlctab[4] is None):
                    this1 = self.vlctab
                    val = haxe_io_Bytes.alloc(131072)
                    this1[4] = val
                if (self.vlctab[5] is None):
                    this2 = self.vlctab
                    val1 = haxe_io_Bytes.alloc(131072)
                    this2[5] = val1
                if (self.vlctab[6] is None):
                    this3 = self.vlctab
                    val2 = haxe_io_Bytes.alloc(131072)
                    this3[6] = val2
                if (self.vlctab[7] is None):
                    this4 = self.vlctab
                    val3 = haxe_io_Bytes.alloc(131072)
                    this4[7] = val3
                self.njDecodeSOF()
            elif (_g == 195):
                raise _HxException("Unsupported lossless JPG")
            elif (_g == 196):
                self.njDecodeDHT()
            elif (_g == 218):
                self.njDecodeScan()
                break
            elif (_g == 219):
                self.njDecodeDQT()
            elif (_g == 221):
                self.njDecodeDRI()
            elif (_g == 254):
                self.length = ((self.bytes.b[self.pos] << 8) | self.bytes.b[(self.pos + 1)])
                _hx_local_12 = self
                _hx_local_13 = _hx_local_12.pos
                _hx_local_12.pos = (_hx_local_13 + 2)
                _hx_local_12.pos
                _hx_local_14 = self
                _hx_local_15 = _hx_local_14.size
                _hx_local_14.size = (_hx_local_15 - 2)
                _hx_local_14.size
                _hx_local_16 = self
                _hx_local_17 = _hx_local_16.length
                _hx_local_16.length = (_hx_local_17 - 2)
                _hx_local_16.length
                count = self.length
                _hx_local_18 = self
                _hx_local_19 = _hx_local_18.pos
                _hx_local_18.pos = (_hx_local_19 + count)
                _hx_local_18.pos
                _hx_local_20 = self
                _hx_local_21 = _hx_local_20.size
                _hx_local_20.size = (_hx_local_21 - count)
                _hx_local_20.size
                _hx_local_22 = self
                _hx_local_23 = _hx_local_22.length
                _hx_local_22.length = (_hx_local_23 - count)
                _hx_local_22.length
            else:
                _g1 = (self.bytes.b[(self.pos + (-1))] & 240)
                if (_g1 == 192):
                    raise _HxException(("Unsupported jpeg type " + Std.string(((self.bytes.b[(self.pos + (-1))] & 15)))))
                elif (_g1 == 224):
                    self.length = ((self.bytes.b[self.pos] << 8) | self.bytes.b[(self.pos + 1)])
                    _hx_local_24 = self
                    _hx_local_25 = _hx_local_24.pos
                    _hx_local_24.pos = (_hx_local_25 + 2)
                    _hx_local_24.pos
                    _hx_local_26 = self
                    _hx_local_27 = _hx_local_26.size
                    _hx_local_26.size = (_hx_local_27 - 2)
                    _hx_local_26.size
                    _hx_local_28 = self
                    _hx_local_29 = _hx_local_28.length
                    _hx_local_28.length = (_hx_local_29 - 2)
                    _hx_local_28.length
                    count1 = self.length
                    _hx_local_30 = self
                    _hx_local_31 = _hx_local_30.pos
                    _hx_local_30.pos = (_hx_local_31 + count1)
                    _hx_local_30.pos
                    _hx_local_32 = self
                    _hx_local_33 = _hx_local_32.size
                    _hx_local_32.size = (_hx_local_33 - count1)
                    _hx_local_32.size
                    _hx_local_34 = self
                    _hx_local_35 = _hx_local_34.length
                    _hx_local_34.length = (_hx_local_35 - count1)
                    _hx_local_34.length
                else:
                    raise _HxException(("Unsupported jpeg tag 0x" + HxOverrides.stringOrNull(StringTools.hex(self.bytes.b[(self.pos + (-1))],2))))
        pixels = self.njConvert()
        self.cleanup()
        return _hx_AnonObject({'pixels': pixels, 'width': self.width, 'height': self.height})

    @staticmethod
    def CF(x):
        x1 = ((x + 64) >> 7)
        if (x1 < 0):
            return 0
        elif (x1 > 255):
            return 255
        else:
            return x1

    @staticmethod
    def njClip(x):
        if (x < 0):
            return 0
        elif (x > 255):
            return 255
        else:
            return x

    @staticmethod
    def decode(_hx_bytes,_hx_filter = None,position = None,size = None):
        if (position is None):
            position = 0
        if (size is None):
            size = -1
        if (hxd_res_NanoJpeg.inst is None):
            hxd_res_NanoJpeg.inst = hxd_res_NanoJpeg()
        hxd_res_NanoJpeg.inst.njInit(_hx_bytes,position,size,_hx_filter)
        return hxd_res_NanoJpeg.inst.njDecode()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.bytes = None
        _hx_o.pos = None
        _hx_o.size = None
        _hx_o.length = None
        _hx_o.width = None
        _hx_o.height = None
        _hx_o.ncomp = None
        _hx_o.comps = None
        _hx_o.counts = None
        _hx_o.qtab = None
        _hx_o.qtused = None
        _hx_o.qtavail = None
        _hx_o.vlctab = None
        _hx_o.block = None
        _hx_o.njZZ = None
        _hx_o.progressive = None
        _hx_o.mbsizex = None
        _hx_o.mbsizey = None
        _hx_o.mbwidth = None
        _hx_o.mbheight = None
        _hx_o.rstinterval = None
        _hx_o.buf = None
        _hx_o.bufbits = None
        _hx_o.pixels = None
        _hx_o.filter = None
        _hx_o.vlcCode = None
hxd_res_NanoJpeg._hx_class = hxd_res_NanoJpeg
_hx_classes["hxd.res.NanoJpeg"] = hxd_res_NanoJpeg

class hxd_res_SoundFormat(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.res.SoundFormat"
    _hx_constructs = ["Wav", "Mp3", "OggVorbis"]
hxd_res_SoundFormat.Wav = hxd_res_SoundFormat("Wav", 0, ())
hxd_res_SoundFormat.Mp3 = hxd_res_SoundFormat("Mp3", 1, ())
hxd_res_SoundFormat.OggVorbis = hxd_res_SoundFormat("OggVorbis", 2, ())
hxd_res_SoundFormat._hx_class = hxd_res_SoundFormat
_hx_classes["hxd.res.SoundFormat"] = hxd_res_SoundFormat


class hxd_res_Sound(hxd_res_Resource):
    _hx_class_name = "hxd.res.Sound"
    _hx_is_interface = "False"
    __slots__ = ("data", "channel", "lastPlay")
    _hx_fields = ["data", "channel", "lastPlay"]
    _hx_methods = ["getData", "dispose", "stop", "play", "watchCallb"]
    _hx_statics = ["ENABLE_AUTO_WATCH", "supportedFormat", "startWorker"]
    _hx_interfaces = []
    _hx_super = hxd_res_Resource


    def __init__(self,entry):
        self.channel = None
        self.data = None
        self.lastPlay = 0.
        super().__init__(entry)

    def getData(self):
        if (self.data is not None):
            return self.data
        _hx_bytes = self.entry.getBytes()
        _g = _hx_bytes.b[0]
        if ((_g == 255) or ((_g == 73))):
            self.data = hxd_snd_Mp3Data(_hx_bytes)
        elif (_g == 79):
            raise _HxException((("OGG format requires -lib stb_ogg_sound (for " + HxOverrides.stringOrNull(self.entry.get_path())) + ")"))
        elif (_g == 82):
            self.data = hxd_snd_WavData(_hx_bytes)
        else:
            pass
        if (self.data is None):
            raise _HxException(("Unsupported sound format " + HxOverrides.stringOrNull(self.entry.get_path())))
        if hxd_res_Sound.ENABLE_AUTO_WATCH:
            self.watch(self.watchCallb)
        return self.data

    def dispose(self):
        self.stop()
        self.data = None

    def stop(self):
        if (self.channel is not None):
            self.channel.stop()
            self.channel = None

    def play(self,loop = None,volume = None,channelGroup = None,soundGroup = None):
        if (loop is None):
            loop = False
        if (volume is None):
            volume = 1.
        self.lastPlay = python_lib_Timeit.default_timer()
        self.channel = hxd_snd_Manager.get().play(self,channelGroup,soundGroup)
        self.channel.loop = loop
        self.channel.set_volume(volume)
        return self.channel

    def watchCallb(self):
        old = self.data
        self.data = None
        data = self.getData()
        if (old is not None):
            if ((((old.channels != data.channels) or ((old.samples != data.samples))) or ((old.sampleFormat != data.sampleFormat))) or ((old.samplingRate != data.samplingRate))):
                manager = hxd_snd_Manager.get()
                ch = manager.getAll(self)
                while ch.hasNext():
                    ch1 = ch.next()
                    ch1.duration = data.get_duration()
                    ch1.set_position(ch1.position)

    @staticmethod
    def supportedFormat(fmt):
        tmp = fmt.index
        if ((tmp == 1) or ((tmp == 0))):
            return True
        elif (tmp == 2):
            return False
        else:
            pass

    @staticmethod
    def startWorker():
        return False

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.data = None
        _hx_o.channel = None
        _hx_o.lastPlay = None
hxd_res_Sound._hx_class = hxd_res_Sound
_hx_classes["hxd.res.Sound"] = hxd_res_Sound


class hxd_snd_ChannelBase:
    _hx_class_name = "hxd.snd.ChannelBase"
    _hx_is_interface = "False"
    __slots__ = ("priority", "mute", "effects", "bindedEffects", "volume", "currentFade", "currentVolume")
    _hx_fields = ["priority", "mute", "effects", "bindedEffects", "volume", "currentFade", "currentVolume"]
    _hx_methods = ["getEffect", "set_volume", "fadeTo", "updateCurrentVolume", "addEffect", "removeEffect"]

    def __init__(self):
        self.currentVolume = None
        self.currentFade = None
        self.volume = 1.
        self.bindedEffects = []
        self.effects = []
        self.mute = False
        self.priority = 0.

    def getEffect(self,etype):
        if (self.effects is None):
            return None
        _g = 0
        _g1 = self.effects
        while (_g < len(_g1)):
            e = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            e1 = Std.downcast(e,etype)
            if (e1 is not None):
                return e1
        return None

    def set_volume(self,v):
        self.currentFade = None
        def _hx_local_1():
            def _hx_local_0():
                self.volume = v
                return self.volume
            return _hx_local_0()
        return _hx_local_1()

    def fadeTo(self,volume,time = None,onEnd = None):
        if (time is None):
            time = 1.
        self.currentFade = _hx_AnonObject({'start': python_lib_Timeit.default_timer(), 'duration': time, 'startVolume': self.volume, 'targetVolume': volume, 'onEnd': onEnd})

    def updateCurrentVolume(self,now):
        if (self.currentFade is not None):
            f = self.currentFade
            dt = (now - f.start)
            if (dt >= f.duration):
                self.set_volume(f.targetVolume)
                if (f.onEnd is not None):
                    f.onEnd()
            else:
                self.set_volume((f.startVolume + (((dt / f.duration) * ((f.targetVolume - f.startVolume))))))
                self.currentFade = f
        self.currentVolume = self.volume

    def addEffect(self,e):
        if (e is None):
            raise _HxException("Can't add null effect")
        if (python_internal_ArrayImpl.indexOf(self.effects,e,None) >= 0):
            raise _HxException("effect already added on this channel")
        _this = self.effects
        _this.append(e)
        return e

    def removeEffect(self,e):
        python_internal_ArrayImpl.remove(self.effects,e)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.priority = None
        _hx_o.mute = None
        _hx_o.effects = None
        _hx_o.bindedEffects = None
        _hx_o.volume = None
        _hx_o.currentFade = None
        _hx_o.currentVolume = None
hxd_snd_ChannelBase._hx_class = hxd_snd_ChannelBase
_hx_classes["hxd.snd.ChannelBase"] = hxd_snd_ChannelBase


class hxd_snd_Channel(hxd_snd_ChannelBase):
    _hx_class_name = "hxd.snd.Channel"
    _hx_is_interface = "False"
    _hx_fields = ["next", "manager", "source", "id", "sound", "duration", "soundGroup", "channelGroup", "position", "pause", "loop", "allowVirtual", "audibleVolume", "lastStamp", "isVirtual", "isLoading", "positionChanged", "queue"]
    _hx_methods = ["onEnd", "set_position", "set_pause", "updateCurrentVolume", "calcAudibleVolume", "queueSound", "stop", "isReleased"]
    _hx_statics = ["ID"]
    _hx_interfaces = []
    _hx_super = hxd_snd_ChannelBase


    def __init__(self):
        self.channelGroup = None
        self.soundGroup = None
        self.duration = None
        self.sound = None
        self.id = None
        self.source = None
        self.manager = None
        self.next = None
        self.queue = []
        self.positionChanged = False
        self.isLoading = False
        self.isVirtual = False
        self.lastStamp = 0.0
        self.audibleVolume = 1.0
        self.allowVirtual = True
        self.loop = False
        self.pause = False
        self.position = 0.0
        super().__init__()
        def _hx_local_2():
            _hx_local_0 = hxd_snd_Channel
            _hx_local_1 = _hx_local_0.ID
            _hx_local_0.ID = (_hx_local_1 + 1)
            return _hx_local_1
        self.id = _hx_local_2()

    def onEnd(self):
        pass

    def set_position(self,v):
        self.lastStamp = python_lib_Timeit.default_timer()
        self.positionChanged = True
        if (v > self.duration):
            v = self.duration
        elif (v < 0):
            v = 0
        def _hx_local_1():
            def _hx_local_0():
                self.position = v
                return self.position
            return _hx_local_0()
        return _hx_local_1()

    def set_pause(self,v):
        if (not v):
            self.lastStamp = python_lib_Timeit.default_timer()
        def _hx_local_1():
            def _hx_local_0():
                self.pause = v
                return self.pause
            return _hx_local_0()
        return _hx_local_1()

    def updateCurrentVolume(self,now):
        if (self.pause and ((self.currentFade is not None))):
            f = self.currentFade
            self.currentFade = None
            self.updateCurrentVolume(now)
            self.currentFade = f
        super().updateCurrentVolume(now)
        self.channelGroup.updateCurrentVolume(now)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.currentVolume
        _hx_local_0.currentVolume = (_hx_local_1 * ((self.channelGroup.currentVolume * self.soundGroup.volume)))
        _hx_local_0.currentVolume
        if (self.manager is not None):
            _g = 0
            _g1 = self.channelGroup.effects
            while (_g < len(_g1)):
                e = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                _hx_local_3 = self
                _hx_local_4 = _hx_local_3.currentVolume
                _hx_local_3.currentVolume = (_hx_local_4 * e.getVolumeModifier())
                _hx_local_3.currentVolume
            _g2 = 0
            _g3 = self.effects
            while (_g2 < len(_g3)):
                e1 = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                _g2 = (_g2 + 1)
                _hx_local_6 = self
                _hx_local_7 = _hx_local_6.currentVolume
                _hx_local_6.currentVolume = (_hx_local_7 * e1.getVolumeModifier())
                _hx_local_6.currentVolume

    def calcAudibleVolume(self,now):
        self.updateCurrentVolume(now)
        self.audibleVolume = self.currentVolume
        if (self.manager is not None):
            _g = 0
            _g1 = self.channelGroup.effects
            while (_g < len(_g1)):
                e = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                self.audibleVolume = e.applyAudibleVolumeModifier(self.audibleVolume)
            _g2 = 0
            _g3 = self.effects
            while (_g2 < len(_g3)):
                e1 = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                _g2 = (_g2 + 1)
                self.audibleVolume = e1.applyAudibleVolumeModifier(self.audibleVolume)

    def queueSound(self,sound):
        _this = self.queue
        _this.append(sound)

    def stop(self):
        if (self.manager is not None):
            self.manager.releaseChannel(self)

    def isReleased(self):
        return (self.manager is None)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.next = None
        _hx_o.manager = None
        _hx_o.source = None
        _hx_o.id = None
        _hx_o.sound = None
        _hx_o.duration = None
        _hx_o.soundGroup = None
        _hx_o.channelGroup = None
        _hx_o.position = None
        _hx_o.pause = None
        _hx_o.loop = None
        _hx_o.allowVirtual = None
        _hx_o.audibleVolume = None
        _hx_o.lastStamp = None
        _hx_o.isVirtual = None
        _hx_o.isLoading = None
        _hx_o.positionChanged = None
        _hx_o.queue = None
hxd_snd_Channel._hx_class = hxd_snd_Channel
_hx_classes["hxd.snd.Channel"] = hxd_snd_Channel


class hxd_snd_ChannelGroup(hxd_snd_ChannelBase):
    _hx_class_name = "hxd.snd.ChannelGroup"
    _hx_is_interface = "False"
    __slots__ = ("name",)
    _hx_fields = ["name"]
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = hxd_snd_ChannelBase


    def __init__(self,name):
        self.name = None
        super().__init__()
        self.name = name

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.name = None
hxd_snd_ChannelGroup._hx_class = hxd_snd_ChannelGroup
_hx_classes["hxd.snd.ChannelGroup"] = hxd_snd_ChannelGroup

class hxd_snd_SampleFormat(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.snd.SampleFormat"
    _hx_constructs = ["UI8", "I16", "F32"]
hxd_snd_SampleFormat.UI8 = hxd_snd_SampleFormat("UI8", 0, ())
hxd_snd_SampleFormat.I16 = hxd_snd_SampleFormat("I16", 1, ())
hxd_snd_SampleFormat.F32 = hxd_snd_SampleFormat("F32", 2, ())
hxd_snd_SampleFormat._hx_class = hxd_snd_SampleFormat
_hx_classes["hxd.snd.SampleFormat"] = hxd_snd_SampleFormat


class hxd_snd_Data:
    _hx_class_name = "hxd.snd.Data"
    _hx_is_interface = "False"
    __slots__ = ("samples", "samplingRate", "sampleFormat", "channels")
    _hx_fields = ["samples", "samplingRate", "sampleFormat", "channels"]
    _hx_methods = ["isLoading", "decode", "resample", "resampleBuffer", "decodeBuffer", "getBytesPerSample", "load", "get_duration"]
    _hx_statics = ["formatBytes"]

    def isLoading(self):
        return False

    def decode(self,out,outPos,sampleStart,sampleCount):
        bpp = self.getBytesPerSample()
        if ((((sampleStart < 0) or ((sampleCount < 0))) or ((outPos < 0))) or (((outPos + ((sampleCount * bpp))) > out.length))):
            s = ("sampleStart = " + Std.string(sampleStart))
            s = (("null" if s is None else s) + HxOverrides.stringOrNull(((" sampleCount = " + Std.string(sampleCount)))))
            s = (("null" if s is None else s) + HxOverrides.stringOrNull(((" outPos = " + Std.string(outPos)))))
            s = (("null" if s is None else s) + HxOverrides.stringOrNull(((" bpp = " + Std.string(bpp)))))
            s = (("null" if s is None else s) + HxOverrides.stringOrNull(((" out.length = " + Std.string(out.length)))))
            raise _HxException(s)
        if ((sampleStart + sampleCount) >= self.samples):
            count = 0
            if (sampleStart < self.samples):
                count = (self.samples - sampleStart)
                self.decodeBuffer(out,outPos,sampleStart,count)
            out.fill((outPos + ((count * bpp))),(((sampleCount - count)) * bpp),0)
            return
        self.decodeBuffer(out,outPos,sampleStart,sampleCount)

    def resample(self,rate,format,channels):
        if (((self.sampleFormat == format) and ((self.samplingRate == rate))) and ((self.channels == channels))):
            return self
        newSamples = Math.ceil((self.samples * ((rate / self.samplingRate))))
        bpp = self.getBytesPerSample()
        data = haxe_io_Bytes.alloc((bpp * self.samples))
        self.decodeBuffer(data,0,0,self.samples)
        out = (channels * newSamples)
        out1 = None
        out2 = format.index
        if (out2 == 0):
            out1 = 1
        elif (out2 == 1):
            out1 = 2
        elif (out2 == 2):
            out1 = 4
        else:
            pass
        out3 = haxe_io_Bytes.alloc((out * out1))
        self.resampleBuffer(out3,0,data,0,rate,format,channels,self.samples)
        data1 = hxd_snd_WavData(None)
        data1.channels = channels
        data1.samples = newSamples
        data1.sampleFormat = format
        data1.samplingRate = rate
        data1.rawData = out3
        return data1

    def resampleBuffer(self,out,outPos,input,inPos,rate,format,channels,samples):
        bpp = self.getBytesPerSample()
        newSamples = Math.ceil((samples * ((rate / self.samplingRate))))
        resample = (samples != newSamples)
        if (((((not resample) and ((self.sampleFormat == hxd_snd_SampleFormat.I16))) and ((format == hxd_snd_SampleFormat.I16))) and ((channels == 1))) and ((self.channels == 2))):
            r = inPos
            w = outPos
            _g = 0
            _g1 = samples
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                sl = (input.b[r] | ((input.b[(r + 1)] << 8)))
                r = (r + 2)
                sr = (input.b[r] | ((input.b[(r + 1)] << 8)))
                r = (r + 2)
                s = None
                if (((sl ^ sr)) >= 32768):
                    if (((sl & 32768)) == 0):
                        sl = sl
                    else:
                        sl = (sl | -65536)
                    if (((sr & 32768)) == 0):
                        sr = sr
                    else:
                        sr = (sr | -65536)
                    s = (((sl + sr) >> 1) & 65535)
                else:
                    s = ((sl + sr) >> 1)
                out.b[w] = (s & 255)
                out.b[(w + 1)] = ((s >> 8) & 255)
                w = (w + 2)
            return
        srcChannels = self.channels
        commonChannels = (channels if ((channels < srcChannels)) else srcChannels)
        extraChannels = (channels - commonChannels)
        sval = 0.
        ival = 0
        _g2 = 0
        _g11 = newSamples
        while (_g2 < _g11):
            i1 = _g2
            _g2 = (_g2 + 1)
            targetSample = ((i1 / ((newSamples - 1))) * ((samples - 1)))
            isample = None
            try:
                isample = int(targetSample)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                isample = None
            isample1 = isample
            offset = (targetSample - isample1)
            srcPos = (inPos + ((isample1 * bpp)))
            if (isample1 == ((samples - 1))):
                resample = False
            _g3 = 0
            _g12 = commonChannels
            while (_g3 < _g12):
                k = _g3
                _g3 = (_g3 + 1)
                sval1 = None
                sval2 = 0.
                tmp = self.sampleFormat.index
                if (tmp == 0):
                    sval1 = (input.b[srcPos] / 255)
                    if resample:
                        sval2 = (input.b[(srcPos + bpp)] / 255)
                    srcPos = (srcPos + 1)
                elif (tmp == 1):
                    v = (input.b[srcPos] | ((input.b[(srcPos + 1)] << 8)))
                    sval1 = (((v if ((((v & 32768)) == 0)) else (v | -65536))) / 32768)
                    if resample:
                        pos = (srcPos + bpp)
                        v1 = (input.b[pos] | ((input.b[(pos + 1)] << 8)))
                        sval2 = (((v1 if ((((v1 & 32768)) == 0)) else (v1 | -65536))) / 32768)
                    srcPos = (srcPos + 2)
                elif (tmp == 2):
                    sval1 = input.getFloat(srcPos)
                    if resample:
                        sval2 = input.getFloat((srcPos + bpp))
                    srcPos = (srcPos + 4)
                else:
                    pass
                sval = ((sval1 + ((offset * ((sval2 - sval1))))) if resample else sval1)
                tmp1 = format.index
                if (tmp1 == 0):
                    ival1 = None
                    try:
                        ival1 = int((((sval + 1)) * 128))
                    except Exception as _hx_e:
                        _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                        e1 = _hx_e1
                        ival1 = None
                    ival = ival1
                    if (ival > 255):
                        ival = 255
                    pos1 = outPos
                    outPos = (outPos + 1)
                    out.b[pos1] = (ival & 255)
                elif (tmp1 == 1):
                    ival2 = None
                    try:
                        ival2 = int((sval * 32768))
                    except Exception as _hx_e:
                        _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                        e2 = _hx_e1
                        ival2 = None
                    ival = ival2
                    if (ival > 32767):
                        ival = 32767
                    ival = (ival & 65535)
                    out.b[outPos] = (ival & 255)
                    out.b[(outPos + 1)] = ((ival >> 8) & 255)
                    outPos = (outPos + 2)
                elif (tmp1 == 2):
                    out.setFloat(outPos,sval)
                    outPos = (outPos + 4)
                else:
                    pass
            _g21 = 0
            _g31 = extraChannels
            while (_g21 < _g31):
                i2 = _g21
                _g21 = (_g21 + 1)
                tmp2 = format.index
                if (tmp2 == 0):
                    pos2 = outPos
                    outPos = (outPos + 1)
                    out.b[pos2] = (ival & 255)
                elif (tmp2 == 1):
                    out.b[outPos] = (ival & 255)
                    out.b[(outPos + 1)] = ((ival >> 8) & 255)
                    outPos = (outPos + 2)
                elif (tmp2 == 2):
                    out.setFloat(outPos,sval)
                    outPos = (outPos + 4)
                else:
                    pass

    def decodeBuffer(self,out,outPos,sampleStart,sampleCount):
        raise _HxException("Not implemented")

    def getBytesPerSample(self):
        tmp = None
        tmp1 = self.sampleFormat.index
        if (tmp1 == 0):
            tmp = 1
        elif (tmp1 == 1):
            tmp = 2
        elif (tmp1 == 2):
            tmp = 4
        else:
            pass
        return (self.channels * tmp)

    def load(self,onEnd):
        onEnd()

    def get_duration(self):
        return (self.samples / self.samplingRate)

    @staticmethod
    def formatBytes(format):
        tmp = format.index
        if (tmp == 0):
            return 1
        elif (tmp == 1):
            return 2
        elif (tmp == 2):
            return 4
        else:
            pass

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.samples = None
        _hx_o.samplingRate = None
        _hx_o.sampleFormat = None
        _hx_o.channels = None
hxd_snd_Data._hx_class = hxd_snd_Data
_hx_classes["hxd.snd.Data"] = hxd_snd_Data


class hxd_snd_EffectDriver:
    _hx_class_name = "hxd.snd.EffectDriver"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_methods = ["acquire", "release", "update", "bind", "apply", "unbind"]

    def __init__(self):
        pass

    def acquire(self):
        pass

    def release(self):
        pass

    def update(self,e):
        pass

    def bind(self,e,source):
        pass

    def apply(self,e,source):
        pass

    def unbind(self,e,source):
        pass

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
hxd_snd_EffectDriver._hx_class = hxd_snd_EffectDriver
_hx_classes["hxd.snd.EffectDriver"] = hxd_snd_EffectDriver

class hxd_snd_DriverFeature(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.snd.DriverFeature"
    _hx_constructs = ["MasterVolume"]
hxd_snd_DriverFeature.MasterVolume = hxd_snd_DriverFeature("MasterVolume", 0, ())
hxd_snd_DriverFeature._hx_class = hxd_snd_DriverFeature
_hx_classes["hxd.snd.DriverFeature"] = hxd_snd_DriverFeature


class hxd_snd_Driver:
    _hx_class_name = "hxd.snd.Driver"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_methods = ["hasFeature", "setMasterVolume", "setListenerParams", "createSource", "playSource", "stopSource", "setSourceVolume", "destroySource", "createBuffer", "setBufferData", "destroyBuffer", "queueBuffer", "unqueueBuffer", "getProcessedBuffers", "getPlayedSampleCount", "update", "dispose", "getEffectDriver"]
hxd_snd_Driver._hx_class = hxd_snd_Driver
_hx_classes["hxd.snd.Driver"] = hxd_snd_Driver


class hxd_snd_Effect:
    _hx_class_name = "hxd.snd.Effect"
    _hx_is_interface = "False"
    __slots__ = ("next", "refs", "retainTime", "lastStamp", "driver", "priority")
    _hx_fields = ["next", "refs", "retainTime", "lastStamp", "driver", "priority"]
    _hx_methods = ["applyAudibleVolumeModifier", "getVolumeModifier"]

    def __init__(self,_hx_type):
        self.driver = None
        self.next = None
        self.refs = 0
        self.priority = 0
        self.retainTime = 0.0
        self.lastStamp = 0.0
        managerDriver = hxd_snd_Manager.get().driver
        if (managerDriver is not None):
            self.driver = managerDriver.getEffectDriver(_hx_type)

    def applyAudibleVolumeModifier(self,v):
        return v

    def getVolumeModifier(self):
        return 1

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.next = None
        _hx_o.refs = None
        _hx_o.retainTime = None
        _hx_o.lastStamp = None
        _hx_o.driver = None
        _hx_o.priority = None
hxd_snd_Effect._hx_class = hxd_snd_Effect
_hx_classes["hxd.snd.Effect"] = hxd_snd_Effect


class hxd_snd_Listener:
    _hx_class_name = "hxd.snd.Listener"
    _hx_is_interface = "False"
    __slots__ = ("position", "direction", "velocity", "up")
    _hx_fields = ["position", "direction", "velocity", "up"]
    _hx_methods = ["syncCamera"]

    def __init__(self):
        self.position = h3d_Vector()
        self.velocity = h3d_Vector()
        self.direction = h3d_Vector(1,0,0)
        self.up = h3d_Vector(0,0,1)

    def syncCamera(self,cam):
        _this = self.position
        v = cam.pos
        _this.x = v.x
        _this.y = v.y
        _this.z = v.z
        _this.w = v.w
        _this1 = self.direction
        x = (cam.target.x - cam.pos.x)
        y = (cam.target.y - cam.pos.y)
        z = (cam.target.z - cam.pos.z)
        if (z is None):
            z = 0.
        if (y is None):
            y = 0.
        if (x is None):
            x = 0.
        _this1.x = x
        _this1.y = y
        _this1.z = z
        _this1.w = 1.
        self.direction.normalize()
        _this2 = self.up
        v1 = cam.up
        _this2.x = v1.x
        _this2.y = v1.y
        _this2.z = v1.z
        _this2.w = v1.w

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.position = None
        _hx_o.direction = None
        _hx_o.velocity = None
        _hx_o.up = None
hxd_snd_Listener._hx_class = hxd_snd_Listener
_hx_classes["hxd.snd.Listener"] = hxd_snd_Listener


class hxd_snd_Source:
    _hx_class_name = "hxd.snd.Source"
    _hx_is_interface = "False"
    __slots__ = ("id", "handle", "channel", "buffers", "volume", "playing", "start", "streamSound", "streamBuffer", "streamStart", "streamPos")
    _hx_fields = ["id", "handle", "channel", "buffers", "volume", "playing", "start", "streamSound", "streamBuffer", "streamStart", "streamPos"]
    _hx_methods = ["dispose"]
    _hx_statics = ["ID"]

    def __init__(self,driver):
        self.streamPos = None
        self.streamStart = None
        self.streamBuffer = None
        self.streamSound = None
        self.channel = None
        self.start = 0
        self.playing = False
        self.volume = -1.0
        def _hx_local_2():
            _hx_local_0 = hxd_snd_Source
            _hx_local_1 = _hx_local_0.ID
            _hx_local_0.ID = (_hx_local_1 + 1)
            return _hx_local_1
        self.id = _hx_local_2()
        self.handle = driver.createSource()
        self.buffers = []

    def dispose(self):
        hxd_snd_Manager.get().driver.destroySource(self.handle)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.id = None
        _hx_o.handle = None
        _hx_o.channel = None
        _hx_o.buffers = None
        _hx_o.volume = None
        _hx_o.playing = None
        _hx_o.start = None
        _hx_o.streamSound = None
        _hx_o.streamBuffer = None
        _hx_o.streamStart = None
        _hx_o.streamPos = None
hxd_snd_Source._hx_class = hxd_snd_Source
_hx_classes["hxd.snd.Source"] = hxd_snd_Source


class hxd_snd_Buffer:
    _hx_class_name = "hxd.snd.Buffer"
    _hx_is_interface = "False"
    __slots__ = ("handle", "sound", "isEnd", "isStream", "refs", "lastStop", "start", "end", "samples", "sampleRate")
    _hx_fields = ["handle", "sound", "isEnd", "isStream", "refs", "lastStop", "start", "end", "samples", "sampleRate"]
    _hx_methods = ["dispose"]

    def __init__(self,driver):
        self.sampleRate = None
        self.samples = None
        self.start = None
        self.isStream = None
        self.isEnd = None
        self.sound = None
        self.end = 0
        self.handle = driver.createBuffer()
        self.refs = 0
        self.lastStop = python_lib_Timeit.default_timer()

    def dispose(self):
        hxd_snd_Manager.get().driver.destroyBuffer(self.handle)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.handle = None
        _hx_o.sound = None
        _hx_o.isEnd = None
        _hx_o.isStream = None
        _hx_o.refs = None
        _hx_o.lastStop = None
        _hx_o.start = None
        _hx_o.end = None
        _hx_o.samples = None
        _hx_o.sampleRate = None
hxd_snd_Buffer._hx_class = hxd_snd_Buffer
_hx_classes["hxd.snd.Buffer"] = hxd_snd_Buffer


class hxd_snd_Manager:
    _hx_class_name = "hxd.snd.Manager"
    _hx_is_interface = "False"
    __slots__ = ("masterVolume", "masterSoundGroup", "masterChannelGroup", "listener", "timeOffset", "updateEvent", "cachedBytes", "resampleBytes", "driver", "channels", "sources", "now", "soundBufferCount", "soundBufferMap", "soundBufferKeys", "freeStreamBuffers", "effectGC", "hasMasterVolume", "suspended", "targetRate", "targetFormat", "targetChannels")
    _hx_fields = ["masterVolume", "masterSoundGroup", "masterChannelGroup", "listener", "timeOffset", "updateEvent", "cachedBytes", "resampleBytes", "driver", "channels", "sources", "now", "soundBufferCount", "soundBufferMap", "soundBufferKeys", "freeStreamBuffers", "effectGC", "hasMasterVolume", "suspended", "targetRate", "targetFormat", "targetChannels"]
    _hx_methods = ["getTmpBytes", "getResampleBytes", "stopAll", "stopAllNotLooping", "stopByName", "getAll", "cleanCache", "dispose", "play", "updateVirtualChannels", "update", "progressiveDecodeBuffer", "queueBuffer", "unqueueBuffer", "bindEffect", "unbindEffect", "releaseSource", "checkTargetFormat", "getSoundBuffer", "fillSoundBuffer", "getStreamBuffer", "sortChannel", "sortEffect", "releaseChannel"]
    _hx_statics = ["STREAM_DURATION", "STREAM_BUFFER_SAMPLE_COUNT", "BUFFER_QUEUE_LENGTH", "MAX_SOURCES", "SOUND_BUFFER_CACHE_SIZE", "VIRTUAL_VOLUME_THRESHOLD", "BUFFER_STREAM_SPLIT", "instance", "get", "regEffect"]

    def __init__(self):
        self.targetChannels = None
        self.targetFormat = None
        self.targetRate = None
        self.hasMasterVolume = None
        self.effectGC = None
        self.freeStreamBuffers = None
        self.soundBufferKeys = None
        self.soundBufferMap = None
        self.soundBufferCount = None
        self.now = None
        self.sources = None
        self.channels = None
        self.resampleBytes = None
        self.cachedBytes = None
        self.updateEvent = None
        self.listener = None
        self.masterChannelGroup = None
        self.masterSoundGroup = None
        self.suspended = False
        self.timeOffset = 0.
        try:
            self.driver = hxd_snd_openal_Driver()
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            if isinstance(_hx_e1, str):
                e = _hx_e1
                self.driver = None
            else:
                raise _hx_e
        self.masterVolume = 1.0
        self.hasMasterVolume = (True if ((self.driver is None)) else self.driver.hasFeature(hxd_snd_DriverFeature.MasterVolume))
        self.masterSoundGroup = hxd_snd_SoundGroup("master")
        self.masterChannelGroup = hxd_snd_ChannelGroup("master")
        self.listener = hxd_snd_Listener()
        self.soundBufferMap = haxe_ds_StringMap()
        self.soundBufferKeys = []
        self.freeStreamBuffers = []
        self.effectGC = []
        self.soundBufferCount = 0
        if (self.driver is not None):
            self.sources = []
            _g = 0
            _g1 = hxd_snd_Manager.MAX_SOURCES
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                _this = self.sources
                x = hxd_snd_Source(self.driver)
                _this.append(x)
        self.cachedBytes = haxe_io_Bytes.alloc(24)
        self.resampleBytes = haxe_io_Bytes.alloc((hxd_snd_Manager.STREAM_BUFFER_SAMPLE_COUNT * 2))

    def getTmpBytes(self,size):
        if (self.cachedBytes.length < size):
            self.cachedBytes = haxe_io_Bytes.alloc(size)
        return self.cachedBytes

    def getResampleBytes(self,size):
        if (self.resampleBytes.length < size):
            self.resampleBytes = haxe_io_Bytes.alloc(size)
        return self.resampleBytes

    def stopAll(self):
        while (self.channels is not None):
            self.channels.stop()

    def stopAllNotLooping(self):
        c = self.channels
        while (c is not None):
            n = c.next
            if (not c.loop):
                c.stop()
            c = n

    def stopByName(self,name):
        c = self.channels
        while (c is not None):
            n = c.next
            if ((c.soundGroup is not None) and ((c.soundGroup.name == name))):
                c.stop()
            c = n

    def getAll(self,sound):
        ch = self.channels
        result = list()
        while (ch is not None):
            if (ch.sound == sound):
                result.append(ch)
            ch = ch.next
        return hxd_impl_ArrayIterator_hxd_snd_Channel(result)

    def cleanCache(self):
        i = 0
        while (i < len(self.soundBufferKeys)):
            k = (self.soundBufferKeys[i] if i >= 0 and i < len(self.soundBufferKeys) else None)
            b = self.soundBufferMap.h.get(k,None)
            i = (i + 1)
            if (b.refs > 0):
                continue
            self.soundBufferMap.remove(k)
            python_internal_ArrayImpl.remove(self.soundBufferKeys,k)
            i = (i - 1)
            b.dispose()
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.soundBufferCount
            _hx_local_2.soundBufferCount = (_hx_local_3 - 1)
            _hx_local_2.soundBufferCount

    def dispose(self):
        self.stopAll()
        if (self.driver is not None):
            _g = 0
            _g1 = self.sources
            while (_g < len(_g1)):
                s = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                s.dispose()
            b = self.soundBufferMap.iterator()
            while b.hasNext():
                b1 = b.next()
                b1.dispose()
            _g2 = 0
            _g3 = self.freeStreamBuffers
            while (_g2 < len(_g3)):
                b2 = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                _g2 = (_g2 + 1)
                b2.dispose()
            _g4 = 0
            _g5 = self.effectGC
            while (_g4 < len(_g5)):
                e = (_g5[_g4] if _g4 >= 0 and _g4 < len(_g5) else None)
                _g4 = (_g4 + 1)
                e.driver.release()
            self.driver.dispose()
        self.sources = None
        self.soundBufferMap = None
        self.soundBufferKeys = None
        self.freeStreamBuffers = None
        self.effectGC = None
        self.updateEvent.stop()
        hxd_snd_Manager.instance = None

    def play(self,sound,channelGroup = None,soundGroup = None):
        if (soundGroup is None):
            soundGroup = self.masterSoundGroup
        if (channelGroup is None):
            channelGroup = self.masterChannelGroup
        sdat = sound.getData()
        if (sdat.samples == 0):
            raise _HxException((Std.string(sound) + " has no samples"))
        c = hxd_snd_Channel()
        c.sound = sound
        c.duration = sdat.get_duration()
        c.manager = self
        c.soundGroup = soundGroup
        c.channelGroup = channelGroup
        c.next = self.channels
        c.isLoading = sdat.isLoading()
        c.isVirtual = (self.driver is None)
        self.channels = c
        return c

    def updateVirtualChannels(self,now):
        c = self.channels
        while (c is not None):
            if ((c.pause or (not c.isVirtual)) or c.isLoading):
                c = c.next
                continue
            _g = c
            a = (now - c.lastStamp)
            _g.set_position((_g.position + ((0.0 if ((a < 0.0)) else a))))
            c.lastStamp = now
            next = c.next
            while (c.position >= c.duration):
                _g1 = c
                _g1.set_position((_g1.position - c.duration))
                c.onEnd()
                if ((next is not None) and ((next.manager is None))):
                    next = None
                if (len(c.queue) > 0):
                    _this = c.queue
                    c.sound = (None if ((len(_this) == 0)) else _this.pop(0))
                    c.duration = c.sound.getData().get_duration()
                elif (not c.loop):
                    self.releaseChannel(c)
                    break
            c = next

    def update(self):
        if (self.timeOffset != 0):
            c = self.channels
            while (c is not None):
                c.lastStamp = (c.lastStamp + self.timeOffset)
                if (c.currentFade is not None):
                    _hx_local_1 = c.currentFade
                    _hx_local_2 = _hx_local_1.start
                    _hx_local_1.start = (_hx_local_2 + self.timeOffset)
                    _hx_local_1.start
                c = c.next
            _g = 0
            _g1 = self.sources
            while (_g < len(_g1)):
                s = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                _g2 = 0
                _g11 = s.buffers
                while (_g2 < len(_g11)):
                    b = (_g11[_g2] if _g2 >= 0 and _g2 < len(_g11) else None)
                    _g2 = (_g2 + 1)
                    b.lastStop = (b.lastStop + self.timeOffset)
            self.timeOffset = 0
        self.now = python_lib_Timeit.default_timer()
        if (self.driver is None):
            self.updateVirtualChannels(self.now)
            return
        _g3 = 0
        _g12 = self.sources
        while (_g3 < len(_g12)):
            s1 = (_g12[_g3] if _g3 >= 0 and _g3 < len(_g12) else None)
            _g3 = (_g3 + 1)
            c1 = s1.channel
            if (c1 is None):
                continue
            if c1.positionChanged:
                self.releaseSource(s1)
                continue
            lastBuffer = None
            count = self.driver.getProcessedBuffers(s1.handle)
            _g4 = 0
            _g13 = count
            while (_g4 < _g13):
                i = _g4
                _g4 = (_g4 + 1)
                b1 = self.unqueueBuffer(s1)
                if (b1 is None):
                    continue
                lastBuffer = b1
                if b1.isEnd:
                    c1.sound = b1.sound
                    c1.duration = b1.sound.getData().get_duration()
                    c1.set_position(c1.duration)
                    c1.positionChanged = False
                    c1.onEnd()
                    s1.start = 0
            if (len(s1.buffers) == 0):
                if (not lastBuffer.isEnd):
                    c1.set_position((((lastBuffer.start + lastBuffer.samples)) / lastBuffer.sampleRate))
                    self.releaseSource(s1)
                elif (len(c1.queue) > 0):
                    c1.sound = (c1.queue[0] if 0 < len(c1.queue) else None)
                    c1.duration = c1.sound.getData().get_duration()
                    c1.set_position(0)
                    self.releaseSource(s1)
                elif c1.loop:
                    c1.set_position(0)
                    self.releaseSource(s1)
                else:
                    self.releaseChannel(c1)
                continue
            c1.sound = (s1.buffers[0] if 0 < len(s1.buffers) else None).sound
            c1.duration = c1.sound.getData().get_duration()
            playedSamples = self.driver.getPlayedSampleCount(s1.handle)
            if (playedSamples < 0):
                playedSamples = 0
            c1.set_position((((s1.start + playedSamples)) / (s1.buffers[0] if 0 < len(s1.buffers) else None).sampleRate))
            c1.positionChanged = False
            if (len(s1.buffers) < hxd_snd_Manager.BUFFER_QUEUE_LENGTH):
                b2 = python_internal_ArrayImpl._get(s1.buffers, (len(s1.buffers) - 1))
                if (not b2.isEnd):
                    self.queueBuffer(s1,b2.sound,(b2.start + b2.samples))
                elif (len(c1.queue) > 0):
                    snd = (c1.queue[0] if 0 < len(c1.queue) else None)
                    if self.queueBuffer(s1,snd,0):
                        _this = c1.queue
                        if (len(_this) != 0):
                            _this.pop(0)
                elif c1.loop:
                    self.queueBuffer(s1,b2.sound,0)
        c2 = self.channels
        while (c2 is not None):
            c2.calcAudibleVolume(self.now)
            if (c2.isLoading and (not c2.sound.getData().isLoading())):
                c2.isLoading = False
            c2.isVirtual = (((((self.suspended or c2.pause) or c2.mute) or c2.channelGroup.mute) or ((c2.allowVirtual and ((c2.audibleVolume < hxd_snd_Manager.VIRTUAL_VOLUME_THRESHOLD))))) or c2.isLoading)
            c2 = c2.next
        _hx_list = self.channels
        cmp = self.sortChannel
        tmp = None
        if (_hx_list is None):
            tmp = None
        else:
            insize = 1
            nmerges = None
            psize = 0
            qsize = 0
            p = None
            q = None
            e = None
            tail = None
            while True:
                p = _hx_list
                _hx_list = None
                tail = None
                nmerges = 0
                while (p is not None):
                    nmerges = (nmerges + 1)
                    q = p
                    psize = 0
                    _g5 = 0
                    _g14 = insize
                    while (_g5 < _g14):
                        i1 = _g5
                        _g5 = (_g5 + 1)
                        psize = (psize + 1)
                        q = q.next
                        if (q is None):
                            break
                    qsize = insize
                    while ((psize > 0) or (((qsize > 0) and ((q is not None))))):
                        if (psize == 0):
                            e = q
                            q = q.next
                            qsize = (qsize - 1)
                        elif (((qsize == 0) or ((q is None))) or ((cmp(p,q) <= 0))):
                            e = p
                            p = p.next
                            psize = (psize - 1)
                        else:
                            e = q
                            q = q.next
                            qsize = (qsize - 1)
                        if (tail is not None):
                            tail.next = e
                        else:
                            _hx_list = e
                        tail = e
                    p = q
                tail.next = None
                if (nmerges <= 1):
                    break
                insize = (insize * 2)
            tmp = _hx_list
        self.channels = tmp
        audibleCount = 0
        c3 = self.channels
        while ((c3 is not None) and (not c3.isVirtual)):
            audibleCount = (audibleCount + 1)
            tmp1 = audibleCount
            if (tmp1 > len(self.sources)):
                c3.isVirtual = True
            elif (c3.soundGroup.maxAudible >= 0):
                if (c3.soundGroup.lastUpdate != self.now):
                    c3.soundGroup.lastUpdate = self.now
                    c3.soundGroup.numAudible = 0
                def _hx_local_15():
                    _hx_local_13 = c3.soundGroup
                    _hx_local_14 = _hx_local_13.numAudible
                    _hx_local_13.numAudible = (_hx_local_14 + 1)
                    return _hx_local_13.numAudible
                tmp2 = (_hx_local_15() > c3.soundGroup.maxAudible)
                if tmp2:
                    c3.isVirtual = True
                    audibleCount = (audibleCount - 1)
            c3 = c3.next
        _g21 = 0
        _g31 = self.sources
        while (_g21 < len(_g31)):
            s2 = (_g31[_g21] if _g21 >= 0 and _g21 < len(_g31) else None)
            _g21 = (_g21 + 1)
            if ((s2.channel is None) or (not s2.channel.isVirtual)):
                continue
            self.releaseSource(s2)
        c4 = self.channels
        while (c4 is not None):
            if ((c4.source is not None) or c4.isVirtual):
                c4 = c4.next
                continue
            s3 = None
            _g41 = 0
            _g51 = self.sources
            while (_g41 < len(_g51)):
                s21 = (_g51[_g41] if _g41 >= 0 and _g41 < len(_g51) else None)
                _g41 = (_g41 + 1)
                if (s21.channel is None):
                    s3 = s21
                    break
            if (s3 is None):
                raise _HxException("could not get a source")
            s3.channel = c4
            c4.source = s3
            self.checkTargetFormat(c4.sound.getData(),c4.soundGroup.mono)
            s3.start = Math.floor((c4.position * self.targetRate))
            if (s3.start < 0):
                s3.start = 0
            self.queueBuffer(s3,c4.sound,s3.start)
            c4.positionChanged = False
            c4 = c4.next
        usedEffects = None
        volume = (1. if (self.hasMasterVolume) else self.masterVolume)
        _g42 = 0
        _g52 = self.sources
        while (_g42 < len(_g52)):
            s4 = (_g52[_g42] if _g42 >= 0 and _g42 < len(_g52) else None)
            _g42 = (_g42 + 1)
            c5 = s4.channel
            if (c5 is None):
                continue
            v = (c5.currentVolume * volume)
            if (s4.volume != v):
                if (v < 0):
                    v = 0
                s4.volume = v
                self.driver.setSourceVolume(s4.handle,v)
            if (not s4.playing):
                self.driver.playSource(s4.handle)
                s4.playing = True
            i2 = len(c5.bindedEffects)
            while True:
                i2 = (i2 - 1)
                tmp3 = i2
                if (not ((tmp3 >= 0))):
                    break
                e1 = (c5.bindedEffects[i2] if i2 >= 0 and i2 < len(c5.bindedEffects) else None)
                if ((python_internal_ArrayImpl.indexOf(c5.effects,e1,None) < 0) and ((python_internal_ArrayImpl.indexOf(c5.channelGroup.effects,e1,None) < 0))):
                    self.unbindEffect(c5,s4,e1)
            _g43 = 0
            _g53 = c5.channelGroup.effects
            while (_g43 < len(_g53)):
                e2 = (_g53[_g43] if _g43 >= 0 and _g43 < len(_g53) else None)
                _g43 = (_g43 + 1)
                if (python_internal_ArrayImpl.indexOf(c5.bindedEffects,e2,None) < 0):
                    self.bindEffect(c5,s4,e2)
            _g6 = 0
            _g7 = c5.effects
            while (_g6 < len(_g7)):
                e3 = (_g7[_g6] if _g6 >= 0 and _g6 < len(_g7) else None)
                _g6 = (_g6 + 1)
                if (python_internal_ArrayImpl.indexOf(c5.bindedEffects,e3,None) < 0):
                    self.bindEffect(c5,s4,e3)
            _g8 = 0
            _g9 = c5.bindedEffects
            while (_g8 < len(_g9)):
                e4 = (_g9[_g8] if _g8 >= 0 and _g8 < len(_g9) else None)
                _g8 = (_g8 + 1)
                usedEffects = hxd_snd_Manager.regEffect(usedEffects,e4)
        list1 = usedEffects
        cmp1 = self.sortEffect
        if (list1 is None):
            usedEffects = None
        else:
            insize1 = 1
            nmerges1 = None
            psize1 = 0
            qsize1 = 0
            p1 = None
            q1 = None
            e5 = None
            tail1 = None
            while True:
                p1 = list1
                list1 = None
                tail1 = None
                nmerges1 = 0
                while (p1 is not None):
                    nmerges1 = (nmerges1 + 1)
                    q1 = p1
                    psize1 = 0
                    _g10 = 0
                    _g15 = insize1
                    while (_g10 < _g15):
                        i3 = _g10
                        _g10 = (_g10 + 1)
                        psize1 = (psize1 + 1)
                        q1 = q1.next
                        if (q1 is None):
                            break
                    qsize1 = insize1
                    while ((psize1 > 0) or (((qsize1 > 0) and ((q1 is not None))))):
                        if (psize1 == 0):
                            e5 = q1
                            q1 = q1.next
                            qsize1 = (qsize1 - 1)
                        elif (((qsize1 == 0) or ((q1 is None))) or ((cmp1(p1,q1) <= 0))):
                            e5 = p1
                            p1 = p1.next
                            psize1 = (psize1 - 1)
                        else:
                            e5 = q1
                            q1 = q1.next
                            qsize1 = (qsize1 - 1)
                        if (tail1 is not None):
                            tail1.next = e5
                        else:
                            list1 = e5
                        tail1 = e5
                    p1 = q1
                tail1.next = None
                if (nmerges1 <= 1):
                    break
                insize1 = (insize1 * 2)
            usedEffects = list1
        e6 = usedEffects
        while (e6 is not None):
            e6.driver.update(e6)
            e6 = e6.next
        _g61 = 0
        _g71 = self.sources
        while (_g61 < len(_g71)):
            s5 = (_g71[_g61] if _g61 >= 0 and _g61 < len(_g71) else None)
            _g61 = (_g61 + 1)
            c6 = s5.channel
            if (c6 is None):
                continue
            _g62 = 0
            _g72 = c6.bindedEffects
            while (_g62 < len(_g72)):
                e7 = (_g72[_g62] if _g62 >= 0 and _g62 < len(_g72) else None)
                _g62 = (_g62 + 1)
                e7.driver.apply(e7,s5.handle)
        _g81 = 0
        _g91 = self.effectGC
        while (_g81 < len(_g91)):
            e8 = (_g91[_g81] if _g81 >= 0 and _g81 < len(_g91) else None)
            _g81 = (_g81 + 1)
            if ((self.now - e8.lastStamp) > e8.retainTime):
                e8.driver.release()
                python_internal_ArrayImpl.remove(self.effectGC,e8)
                break
        self.updateVirtualChannels(self.now)
        self.listener.direction.normalize()
        self.listener.up.normalize()
        if self.hasMasterVolume:
            self.driver.setMasterVolume(self.masterVolume)
        self.driver.setListenerParams(self.listener.position,self.listener.direction,self.listener.up,self.listener.velocity)
        self.driver.update()
        if (self.soundBufferCount >= hxd_snd_Manager.SOUND_BUFFER_CACHE_SIZE):
            now = python_lib_Timeit.default_timer()
            i4 = 0
            while (i4 < len(self.soundBufferKeys)):
                k = (self.soundBufferKeys[i4] if i4 >= 0 and i4 < len(self.soundBufferKeys) else None)
                b3 = self.soundBufferMap.h.get(k,None)
                i4 = (i4 + 1)
                if ((b3.refs > 0) or (((b3.lastStop + 60.0) > now))):
                    continue
                self.soundBufferMap.remove(k)
                python_internal_ArrayImpl.remove(self.soundBufferKeys,k)
                i4 = (i4 - 1)
                b3.dispose()
                _hx_local_34 = self
                _hx_local_35 = _hx_local_34.soundBufferCount
                _hx_local_34.soundBufferCount = (_hx_local_35 - 1)
                _hx_local_34.soundBufferCount

    def progressiveDecodeBuffer(self,s,snd,start):
        data = snd.getData()
        samples = Math.ceil((hxd_snd_Manager.STREAM_BUFFER_SAMPLE_COUNT / hxd_snd_Manager.BUFFER_STREAM_SPLIT))
        if ((s.streamStart != start) or ((s.streamSound != snd))):
            s.streamSound = snd
            s.streamStart = start
            s.streamPos = start
        end = (start + hxd_snd_Manager.STREAM_BUFFER_SAMPLE_COUNT)
        if (s.streamPos == end):
            return True
        bpp = data.getBytesPerSample()
        reqSize = (hxd_snd_Manager.STREAM_BUFFER_SAMPLE_COUNT * bpp)
        if ((s.streamBuffer is None) or ((s.streamBuffer.length < reqSize))):
            s.streamBuffer = haxe_io_Bytes.alloc(reqSize)
            s.streamPos = start
        remain = (end - s.streamPos)
        if (remain > samples):
            remain = samples
        data.decode(s.streamBuffer,(((s.streamPos - start)) * bpp),s.streamPos,remain)
        s.streamPos = (s.streamPos + remain)
        return (s.streamPos == end)

    def queueBuffer(self,s,snd,start):
        data = snd.getData()
        sgroup = s.channel.soundGroup
        b = None
        if (data.get_duration() <= hxd_snd_Manager.STREAM_DURATION):
            b = self.getSoundBuffer(snd,sgroup)
            self.driver.queueBuffer(s.handle,b.handle,start,True)
        else:
            if (((len(s.buffers) > 0) and ((hxd_snd_Manager.BUFFER_STREAM_SPLIT > 1))) and (not self.progressiveDecodeBuffer(s,snd,start))):
                return False
            b = self.getStreamBuffer(s,snd,sgroup,start)
            self.driver.queueBuffer(s.handle,b.handle,0,b.isEnd)
        _this = s.buffers
        _this.append(b)
        return True

    def unqueueBuffer(self,s):
        _this = s.buffers
        b = (None if ((len(_this) == 0)) else _this.pop(0))
        if (b is None):
            return None
        self.driver.unqueueBuffer(s.handle,b.handle)
        if b.isStream:
            self.freeStreamBuffers.insert(0, b)
        else:
            def _hx_local_1():
                b.refs = (b.refs - 1)
                return b.refs
            tmp = (_hx_local_1() == 0)
            if tmp:
                b.lastStop = python_lib_Timeit.default_timer()
        return b

    def bindEffect(self,c,s,e):
        if ((e.refs == 0) and (not python_internal_ArrayImpl.remove(self.effectGC,e))):
            e.driver.acquire()
        e.refs = (e.refs + 1)
        e.driver.bind(e,s.handle)
        _this = c.bindedEffects
        _this.append(e)

    def unbindEffect(self,c,s,e):
        e.driver.unbind(e,s.handle)
        python_internal_ArrayImpl.remove(c.bindedEffects,e)
        def _hx_local_1():
            e.refs = (e.refs - 1)
            return e.refs
        tmp = (_hx_local_1() == 0)
        if tmp:
            e.lastStamp = self.now
            _this = self.effectGC
            _this.append(e)

    def releaseSource(self,s):
        if (s.channel is not None):
            _g = 0
            _g1 = list(s.channel.bindedEffects)
            while (_g < len(_g1)):
                e = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                self.unbindEffect(s.channel,s,e)
            s.channel.bindedEffects = []
            s.channel.source = None
            s.channel = None
        if s.playing:
            s.playing = False
            self.driver.stopSource(s.handle)
            s.volume = -1.0
        while (len(s.buffers) > 0):
            self.unqueueBuffer(s)

    def checkTargetFormat(self,dat,forceMono = None):
        if (forceMono is None):
            forceMono = False
        self.targetRate = dat.samplingRate
        self.targetRate = hxd_snd_openal_Emulator.get_NATIVE_FREQ()
        self.targetChannels = (1 if ((forceMono or ((dat.channels == 1)))) else 2)
        tmp = None
        tmp1 = dat.sampleFormat.index
        if (tmp1 == 0):
            tmp = hxd_snd_SampleFormat.UI8
        elif (tmp1 == 1):
            tmp = hxd_snd_SampleFormat.I16
        elif (tmp1 == 2):
            tmp = hxd_snd_SampleFormat.I16
        else:
            pass
        self.targetFormat = tmp
        if ((self.targetChannels == dat.channels) and ((self.targetFormat == dat.sampleFormat))):
            return (self.targetRate == dat.samplingRate)
        else:
            return False

    def getSoundBuffer(self,snd,grp):
        _gthis = self
        data = snd.getData()
        mono = grp.mono
        key = snd.entry.get_path()
        if (mono and ((data.channels != 1))):
            key = (("null" if key is None else key) + "mono")
        b = self.soundBufferMap.h.get(key,None)
        if (b is None):
            b = hxd_snd_Buffer(self.driver)
            b.isStream = False
            b.isEnd = True
            b.sound = snd
            def _hx_local_1():
                _gthis.fillSoundBuffer(b,data,mono)
            data.load(_hx_local_1)
            self.soundBufferMap.h[key] = b
            _this = self.soundBufferKeys
            _this.append(key)
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.soundBufferCount
            _hx_local_2.soundBufferCount = (_hx_local_3 + 1)
            _hx_local_2.soundBufferCount
        b.refs = (b.refs + 1)
        return b

    def fillSoundBuffer(self,buf,dat,forceMono = None):
        if (forceMono is None):
            forceMono = False
        if (not self.checkTargetFormat(dat,forceMono)):
            dat = dat.resample(self.targetRate,self.targetFormat,self.targetChannels)
        length = (dat.samples * dat.getBytesPerSample())
        _hx_bytes = self.getTmpBytes(length)
        dat.decode(_hx_bytes,0,0,dat.samples)
        self.driver.setBufferData(buf.handle,_hx_bytes,length,self.targetFormat,self.targetChannels,self.targetRate)
        buf.sampleRate = self.targetRate
        buf.samples = dat.samples

    def getStreamBuffer(self,src,snd,grp,start):
        data = snd.getData()
        _this = self.freeStreamBuffers
        b = (None if ((len(_this) == 0)) else _this.pop(0))
        if (b is None):
            b = hxd_snd_Buffer(self.driver)
            b.isStream = True
        samples = hxd_snd_Manager.STREAM_BUFFER_SAMPLE_COUNT
        if ((start + samples) >= data.samples):
            samples = (data.samples - start)
            b.isEnd = True
        else:
            b.isEnd = False
        b.sound = snd
        b.samples = samples
        b.start = start
        size = (samples * data.getBytesPerSample())
        _hx_bytes = None
        if ((src.streamSound == snd) and ((src.streamStart == start))):
            while (not self.progressiveDecodeBuffer(src,snd,start)):
                pass
            _hx_bytes = src.streamBuffer
        else:
            _hx_bytes = self.getTmpBytes(size)
            data.decode(_hx_bytes,0,start,samples)
        if (not self.checkTargetFormat(data,grp.mono)):
            size1 = (Math.ceil((samples * ((self.targetRate / data.samplingRate)))) * self.targetChannels)
            size2 = None
            size3 = self.targetFormat.index
            if (size3 == 0):
                size2 = 1
            elif (size3 == 1):
                size2 = 2
            elif (size3 == 2):
                size2 = 4
            else:
                pass
            size = (size1 * size2)
            resampleBytes = self.getResampleBytes(size)
            data.resampleBuffer(resampleBytes,0,_hx_bytes,0,self.targetRate,self.targetFormat,self.targetChannels,samples)
            _hx_bytes = resampleBytes
        self.driver.setBufferData(b.handle,_hx_bytes,size,self.targetFormat,self.targetChannels,self.targetRate)
        b.sampleRate = self.targetRate
        return b

    def sortChannel(self,a,b):
        if (a.isVirtual != b.isVirtual):
            if a.isVirtual:
                return 1
            else:
                return -1
        if (a.channelGroup.priority != b.channelGroup.priority):
            if (a.channelGroup.priority < b.channelGroup.priority):
                return 1
            else:
                return -1
        if (a.priority != b.priority):
            if (a.priority < b.priority):
                return 1
            else:
                return -1
        if (a.audibleVolume != b.audibleVolume):
            if (a.audibleVolume < b.audibleVolume):
                return 1
            else:
                return -1
        if (a.id < b.id):
            return 1
        else:
            return -1

    def sortEffect(self,a,b):
        return (b.priority - a.priority)

    def releaseChannel(self,c):
        if (c.manager is None):
            return
        if (self.channels == c):
            self.channels = c.next
        else:
            prev = self.channels
            while (prev.next != c):
                prev = prev.next
            prev.next = c.next
        _g = 0
        _g1 = c.effects
        while (_g < len(_g1)):
            e = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            c.removeEffect(e)
        if (c.source is not None):
            self.releaseSource(c.source)
        c.next = None
        c.manager = None
        c.effects = None
        c.bindedEffects = None
        c.currentFade = None
        snd = c.sound
        if ((snd is not None) and ((snd.channel == c))):
            snd.channel = None
    instance = None

    @staticmethod
    def get():
        if (hxd_snd_Manager.instance is None):
            hxd_snd_Manager.instance = hxd_snd_Manager()
            hxd_snd_Manager.instance.updateEvent = haxe_MainLoop.add(hxd_snd_Manager.instance.update)
            hxd_snd_Manager.instance.updateEvent.isBlocking = False
        return hxd_snd_Manager.instance

    @staticmethod
    def regEffect(_hx_list,e):
        l = _hx_list
        while (l is not None):
            if (l == e):
                return _hx_list
            l = l.next
        e.next = _hx_list
        return e

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.masterVolume = None
        _hx_o.masterSoundGroup = None
        _hx_o.masterChannelGroup = None
        _hx_o.listener = None
        _hx_o.timeOffset = None
        _hx_o.updateEvent = None
        _hx_o.cachedBytes = None
        _hx_o.resampleBytes = None
        _hx_o.driver = None
        _hx_o.channels = None
        _hx_o.sources = None
        _hx_o.now = None
        _hx_o.soundBufferCount = None
        _hx_o.soundBufferMap = None
        _hx_o.soundBufferKeys = None
        _hx_o.freeStreamBuffers = None
        _hx_o.effectGC = None
        _hx_o.hasMasterVolume = None
        _hx_o.suspended = None
        _hx_o.targetRate = None
        _hx_o.targetFormat = None
        _hx_o.targetChannels = None
hxd_snd_Manager._hx_class = hxd_snd_Manager
_hx_classes["hxd.snd.Manager"] = hxd_snd_Manager


class hxd_snd_Mp3Data(hxd_snd_Data):
    _hx_class_name = "hxd.snd.Mp3Data"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["decodeBuffer"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = hxd_snd_Data


    def __init__(self,_hx_bytes):
        mp = format_mp3_Reader(haxe_io_BytesInput(_hx_bytes)).read()
        self.samples = mp.sampleCount
        frame = (mp.frames[0] if 0 < len(mp.frames) else None).data
        lame = -1
        _g = 0
        _g1 = (frame.length - 24)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if ((((frame.b[i] == 76) and ((frame.b[(i + 1)] == 65))) and ((frame.b[(i + 2)] == 77))) and ((frame.b[(i + 3)] == 69))):
                lame = i
                break
        if (lame >= 0):
            startEnd = (((frame.b[(lame + 21)] << 16) | ((frame.b[(lame + 22)] << 8))) | frame.b[(lame + 23)])
            start = (startEnd >> 12)
            end = (startEnd & 4095)
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.samples
            _hx_local_0.samples = (_hx_local_1 - (((start + end) + 1152)))
            _hx_local_0.samples
        header = (mp.frames[0] if 0 < len(mp.frames) else None).header
        self.sampleFormat = hxd_snd_SampleFormat.F32
        self.samplingRate = format_mp3_MPEG.srEnum2Num(header.samplingRate)
        self.channels = (1 if ((header.channelMode == format_mp3_ChannelMode.Mono)) else 2)

    def decodeBuffer(self,out,outPos,sampleStart,sampleCount):
        raise _HxException("MP3 decoding is not available for this platform")

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
hxd_snd_Mp3Data._hx_class = hxd_snd_Mp3Data
_hx_classes["hxd.snd.Mp3Data"] = hxd_snd_Mp3Data


class hxd_snd_NativeChannel:
    _hx_class_name = "hxd.snd.NativeChannel"
    _hx_is_interface = "False"
    __slots__ = ("bufferSamples",)
    _hx_fields = ["bufferSamples"]
    _hx_methods = ["onSample", "stop"]

    def __init__(self,bufferSamples):
        self.bufferSamples = bufferSamples

    def onSample(self,out):
        pass

    def stop(self):
        pass

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.bufferSamples = None
hxd_snd_NativeChannel._hx_class = hxd_snd_NativeChannel
_hx_classes["hxd.snd.NativeChannel"] = hxd_snd_NativeChannel


class hxd_snd_SoundGroup:
    _hx_class_name = "hxd.snd.SoundGroup"
    _hx_is_interface = "False"
    __slots__ = ("name", "volume", "maxAudible", "mono", "numAudible", "lastUpdate")
    _hx_fields = ["name", "volume", "maxAudible", "mono", "numAudible", "lastUpdate"]

    def __init__(self,name):
        self.lastUpdate = None
        self.numAudible = None
        self.name = name
        self.maxAudible = -1
        self.volume = 1
        self.mono = False

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.name = None
        _hx_o.volume = None
        _hx_o.maxAudible = None
        _hx_o.mono = None
        _hx_o.numAudible = None
        _hx_o.lastUpdate = None
hxd_snd_SoundGroup._hx_class = hxd_snd_SoundGroup
_hx_classes["hxd.snd.SoundGroup"] = hxd_snd_SoundGroup


class hxd_snd_WavData(hxd_snd_Data):
    _hx_class_name = "hxd.snd.WavData"
    _hx_is_interface = "False"
    __slots__ = ("rawData",)
    _hx_fields = ["rawData"]
    _hx_methods = ["init", "decodeBuffer"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = hxd_snd_Data


    def __init__(self,_hx_bytes):
        self.rawData = None
        if (_hx_bytes is not None):
            self.init(format_wav_Reader(haxe_io_BytesInput(_hx_bytes)).read())

    def init(self,d):
        h = d.header
        self.samplingRate = h.samplingRate
        self.channels = h.channels
        tmp = None
        _g = h.bitsPerSample
        if (_g == 8):
            tmp = hxd_snd_SampleFormat.UI8
        elif (_g == 16):
            tmp = hxd_snd_SampleFormat.I16
        else:
            raise _HxException((("Unsupported WAV " + Std.string(h.bitsPerSample)) + " bits"))
        self.sampleFormat = tmp
        self.rawData = d.data
        x = (self.rawData.length / self.getBytesPerSample())
        tmp1 = None
        try:
            tmp1 = int(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            tmp1 = None
        self.samples = tmp1

    def decodeBuffer(self,out,outPos,sampleStart,sampleCount):
        bpp = self.getBytesPerSample()
        out.blit(outPos,self.rawData,(sampleStart * bpp),(sampleCount * bpp))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.rawData = None
hxd_snd_WavData._hx_class = hxd_snd_WavData
_hx_classes["hxd.snd.WavData"] = hxd_snd_WavData


class hxd_snd_openal_BufferHandle:
    _hx_class_name = "hxd.snd.openal.BufferHandle"
    _hx_is_interface = "False"
    __slots__ = ("inst", "isEnd")
    _hx_fields = ["inst", "isEnd"]

    def __init__(self):
        self.isEnd = None
        self.inst = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.inst = None
        _hx_o.isEnd = None
hxd_snd_openal_BufferHandle._hx_class = hxd_snd_openal_BufferHandle
_hx_classes["hxd.snd.openal.BufferHandle"] = hxd_snd_openal_BufferHandle


class hxd_snd_openal_SourceHandle:
    _hx_class_name = "hxd.snd.openal.SourceHandle"
    _hx_is_interface = "False"
    __slots__ = ("inst", "sampleOffset", "playing", "nextAuxiliarySend", "freeAuxiliarySends", "effectToAuxiliarySend")
    _hx_fields = ["inst", "sampleOffset", "playing", "nextAuxiliarySend", "freeAuxiliarySends", "effectToAuxiliarySend"]
    _hx_methods = ["acquireAuxiliarySend", "getAuxiliarySend", "releaseAuxiliarySend"]

    def __init__(self):
        self.playing = None
        self.inst = None
        self.sampleOffset = 0
        self.nextAuxiliarySend = 0
        self.freeAuxiliarySends = []
        self.effectToAuxiliarySend = haxe_ds_ObjectMap()

    def acquireAuxiliarySend(self,effect):
        send = None
        if (len(self.freeAuxiliarySends) > 0):
            _this = self.freeAuxiliarySends
            send = (None if ((len(_this) == 0)) else _this.pop(0))
        else:
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.nextAuxiliarySend
                _hx_local_0.nextAuxiliarySend = (_hx_local_1 + 1)
                return _hx_local_1
            send = _hx_local_2()
        self.effectToAuxiliarySend.set(effect,send)
        return send

    def getAuxiliarySend(self,effect):
        return self.effectToAuxiliarySend.h.get(effect,None)

    def releaseAuxiliarySend(self,effect):
        send = self.effectToAuxiliarySend.h.get(effect,None)
        self.effectToAuxiliarySend.remove(effect)
        _this = self.freeAuxiliarySends
        _this.append(send)
        return send

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.inst = None
        _hx_o.sampleOffset = None
        _hx_o.playing = None
        _hx_o.nextAuxiliarySend = None
        _hx_o.freeAuxiliarySends = None
        _hx_o.effectToAuxiliarySend = None
hxd_snd_openal_SourceHandle._hx_class = hxd_snd_openal_SourceHandle
_hx_classes["hxd.snd.openal.SourceHandle"] = hxd_snd_openal_SourceHandle


class hxd_snd_openal_Driver:
    _hx_class_name = "hxd.snd.openal.Driver"
    _hx_is_interface = "False"
    __slots__ = ("device", "context", "maxAuxiliarySends", "tmpBytes")
    _hx_fields = ["device", "context", "maxAuxiliarySends", "tmpBytes"]
    _hx_methods = ["hasFeature", "getTmpBytes", "setMasterVolume", "setListenerParams", "createSource", "destroySource", "playSource", "stopSource", "setSourceVolume", "createBuffer", "destroyBuffer", "setBufferData", "getPlayedSampleCount", "getProcessedBuffers", "queueBuffer", "unqueueBuffer", "update", "dispose", "getEffectDriver"]
    _hx_interfaces = [hxd_snd_Driver]

    def __init__(self):
        self.maxAuxiliarySends = None
        self.context = None
        self.tmpBytes = haxe_io_Bytes.alloc(24)
        self.device = hxd_snd_openal_ALC.openDevice(None)
        self.context = hxd_snd_openal_ALC.createContext(self.device,None)
        hxd_snd_openal_ALC.makeContextCurrent(self.context)
        hxd_snd_openal_ALC.loadExtensions(self.device)
        hxd_snd_openal_Emulator.loadExtensions()
        _hx_bytes = self.getTmpBytes(4)
        hxd_snd_openal_ALC.getIntegerv(self.device,131075,1,_hx_bytes)
        v = (((_hx_bytes.b[0] | ((_hx_bytes.b[1] << 8))) | ((_hx_bytes.b[2] << 16))) | ((_hx_bytes.b[3] << 24)))
        self.maxAuxiliarySends = ((v | -2147483648) if ((((v & -2147483648)) != 0)) else v)
        if (hxd_snd_openal_Emulator.getError() != 0):
            raise _HxException("could not init openAL Driver")

    def hasFeature(self,f):
        return False

    def getTmpBytes(self,size):
        if (self.tmpBytes.length < size):
            self.tmpBytes = haxe_io_Bytes.alloc(size)
        return self.tmpBytes

    def setMasterVolume(self,value):
        hxd_snd_openal_Emulator.listenerf(4106,value)

    def setListenerParams(self,position,direction,up,velocity = None):
        hxd_snd_openal_Emulator.listener3f(4100,-position.x,position.y,position.z)
        _hx_bytes = self.getTmpBytes(24)
        _hx_bytes.setFloat(0,-direction.x)
        _hx_bytes.setFloat(4,direction.y)
        _hx_bytes.setFloat(8,direction.z)
        up.normalize()
        _hx_bytes.setFloat(12,-up.x)
        _hx_bytes.setFloat(16,up.y)
        _hx_bytes.setFloat(20,up.z)
        hxd_snd_openal_Emulator.listenerfv(4111,self.tmpBytes)
        if (velocity is not None):
            hxd_snd_openal_Emulator.listener3f(4102,-velocity.x,velocity.y,velocity.z)

    def createSource(self):
        source = hxd_snd_openal_SourceHandle()
        _hx_bytes = self.getTmpBytes(4)
        hxd_snd_openal_Emulator.genSources(1,_hx_bytes)
        if (hxd_snd_openal_Emulator.getError() != 0):
            raise _HxException("could not create source")
        v = (((_hx_bytes.b[0] | ((_hx_bytes.b[1] << 8))) | ((_hx_bytes.b[2] << 16))) | ((_hx_bytes.b[3] << 24)))
        source.inst = hxd_snd_openal_Source.all.h.get(((v | -2147483648) if ((((v & -2147483648)) != 0)) else v),None)
        hxd_snd_openal_Emulator.sourcei(source.inst,514,1)
        return source

    def destroySource(self,source):
        hxd_snd_openal_Emulator.sourcei(source.inst,131077,0)
        _hx_bytes = self.getTmpBytes(4)
        v = source.inst.id
        _hx_bytes.b[0] = (v & 255)
        _hx_bytes.b[1] = ((v >> 8) & 255)
        _hx_bytes.b[2] = ((v >> 16) & 255)
        _hx_bytes.b[3] = (HxOverrides.rshift(v, 24) & 255)
        hxd_snd_openal_Emulator.deleteSources(1,_hx_bytes)

    def playSource(self,source):
        hxd_snd_openal_Emulator.sourcePlay(source.inst)
        source.sampleOffset = 0
        source.playing = True

    def stopSource(self,source):
        hxd_snd_openal_Emulator.sourceStop(source.inst)
        source.playing = False

    def setSourceVolume(self,source,value):
        hxd_snd_openal_Emulator.sourcef(source.inst,4106,value)

    def createBuffer(self):
        buffer = hxd_snd_openal_BufferHandle()
        _hx_bytes = self.getTmpBytes(4)
        hxd_snd_openal_Emulator.genBuffers(1,_hx_bytes)
        v = (((_hx_bytes.b[0] | ((_hx_bytes.b[1] << 8))) | ((_hx_bytes.b[2] << 16))) | ((_hx_bytes.b[3] << 24)))
        buffer.inst = hxd_snd_openal_Buffer.all.h.get(((v | -2147483648) if ((((v & -2147483648)) != 0)) else v),None)
        return buffer

    def destroyBuffer(self,buffer):
        _hx_bytes = self.getTmpBytes(4)
        v = buffer.inst.id
        _hx_bytes.b[0] = (v & 255)
        _hx_bytes.b[1] = ((v >> 8) & 255)
        _hx_bytes.b[2] = ((v >> 16) & 255)
        _hx_bytes.b[3] = (HxOverrides.rshift(v, 24) & 255)
        hxd_snd_openal_Emulator.deleteBuffers(1,_hx_bytes)

    def setBufferData(self,buffer,data,size,format,channelCount,samplingRate):
        alFormat = None
        alFormat1 = format.index
        if (alFormat1 == 0):
            alFormat = (4352 if ((channelCount == 1)) else 4354)
        elif (alFormat1 == 1):
            alFormat = (4353 if ((channelCount == 1)) else 4355)
        elif (alFormat1 == 2):
            alFormat = (4353 if ((channelCount == 1)) else 4355)
        else:
            pass
        hxd_snd_openal_Emulator.bufferData(buffer.inst,alFormat,data,size,samplingRate)

    def getPlayedSampleCount(self,source):
        v = (source.sampleOffset + hxd_snd_openal_Emulator.getSourcei(source.inst,4133))
        if (v < 0):
            v = 0
        return v

    def getProcessedBuffers(self,source):
        return hxd_snd_openal_Emulator.getSourcei(source.inst,4118)

    def queueBuffer(self,source,buffer,sampleStart,endOfStream):
        _hx_bytes = self.getTmpBytes(4)
        v = buffer.inst.id
        _hx_bytes.b[0] = (v & 255)
        _hx_bytes.b[1] = ((v >> 8) & 255)
        _hx_bytes.b[2] = ((v >> 16) & 255)
        _hx_bytes.b[3] = (HxOverrides.rshift(v, 24) & 255)
        hxd_snd_openal_Emulator.sourceQueueBuffers(source.inst,1,_hx_bytes)
        err = hxd_snd_openal_Emulator.getError()
        if (err != 0):
            raise _HxException((((("Failed to queue buffers: " + HxOverrides.stringOrNull(StringTools.hex(err))) + " (") + Std.string(buffer.inst.id)) + ")"))
        if (hxd_snd_openal_Emulator.getSourcei(source.inst,4112) == 4116):
            if (sampleStart > 0):
                hxd_snd_openal_Emulator.sourcei(source.inst,4133,sampleStart)
            else:
                hxd_snd_openal_Emulator.sourcei(source.inst,4133,0)
            if source.playing:
                hxd_snd_openal_Emulator.sourcePlay(source.inst)
        buffer.isEnd = endOfStream

    def unqueueBuffer(self,source,buffer):
        _hx_bytes = self.getTmpBytes(4)
        v = buffer.inst.id
        _hx_bytes.b[0] = (v & 255)
        _hx_bytes.b[1] = ((v >> 8) & 255)
        _hx_bytes.b[2] = ((v >> 16) & 255)
        _hx_bytes.b[3] = (HxOverrides.rshift(v, 24) & 255)
        hxd_snd_openal_Emulator.sourceUnqueueBuffers(source.inst,1,_hx_bytes)
        size = hxd_snd_openal_Emulator.getBufferi(buffer.inst,8196)
        bps = ((hxd_snd_openal_Emulator.getBufferi(buffer.inst,8194) * hxd_snd_openal_Emulator.getBufferi(buffer.inst,8195)) / 8)
        samples = None
        try:
            samples = int((size / bps))
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            samples = None
        samples1 = samples
        if buffer.isEnd:
            source.sampleOffset = 0
        else:
            source.sampleOffset = (source.sampleOffset + samples1)

    def update(self):
        pass

    def dispose(self):
        hxd_snd_openal_ALC.makeContextCurrent(None)
        hxd_snd_openal_ALC.destroyContext(self.context)
        hxd_snd_openal_ALC.closeDevice(self.device)

    def getEffectDriver(self,_hx_type):
        return hxd_snd_EffectDriver()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.device = None
        _hx_o.context = None
        _hx_o.maxAuxiliarySends = None
        _hx_o.tmpBytes = None
hxd_snd_openal_Driver._hx_class = hxd_snd_openal_Driver
_hx_classes["hxd.snd.openal.Driver"] = hxd_snd_openal_Driver


class hxd_snd_openal__Emulator_Channel(hxd_snd_NativeChannel):
    _hx_class_name = "hxd.snd.openal._Emulator.Channel"
    _hx_is_interface = "False"
    __slots__ = ("source", "startup")
    _hx_fields = ["source", "startup"]
    _hx_methods = ["onSample"]
    _hx_statics = ["FADE_START"]
    _hx_interfaces = []
    _hx_super = hxd_snd_NativeChannel


    def __init__(self,source,samples):
        self.startup = 0.
        self.source = source
        super().__init__(samples)

    def onSample(self,out):
        pos = 0
        count = ((out.byteLength >> 2) >> 1)
        if (self.source.duration > 0):
            volume = self.source.volume
            bufferIndex = 0
            baseSample = 0
            curSample = self.source.currentSample
            buffer = bufferIndex
            bufferIndex = (bufferIndex + 1)
            buffer1 = python_internal_ArrayImpl._get(self.source.buffers, buffer)
            while (count > 0):
                while ((buffer1 is not None) and ((curSample >= buffer1.samples))):
                    baseSample = (baseSample + buffer1.samples)
                    curSample = (curSample - buffer1.samples)
                    buffer2 = bufferIndex
                    bufferIndex = (bufferIndex + 1)
                    buffer1 = python_internal_ArrayImpl._get(self.source.buffers, buffer2)
                if (buffer1 is None):
                    if self.source.loop:
                        curSample = 0
                        baseSample = 0
                        bufferIndex = 0
                        buffer3 = bufferIndex
                        bufferIndex = (bufferIndex + 1)
                        buffer1 = python_internal_ArrayImpl._get(self.source.buffers, buffer3)
                        continue
                    break
                scount = (buffer1.samples - curSample)
                if (scount > count):
                    scount = count
                read = (curSample << 1)
                data = buffer1.data
                if (self.startup < 1):
                    _g = 0
                    _g1 = scount
                    while (_g < _g1):
                        i = _g
                        _g = (_g + 1)
                        index = pos
                        pos = (pos + 1)
                        index1 = read
                        read = (read + 1)
                        value = ((data[index1] * volume) * self.startup)
                        if ((index >= 0) and ((index < ((out.byteLength >> 2))))):
                            out.bytes.setFloat((((index << 2)) + out.byteOffset),value)
                        index2 = pos
                        pos = (pos + 1)
                        index3 = read
                        read = (read + 1)
                        value1 = ((data[index3] * volume) * self.startup)
                        if ((index2 >= 0) and ((index2 < ((out.byteLength >> 2))))):
                            out.bytes.setFloat((((index2 << 2)) + out.byteOffset),value1)
                        if (self.startup < 1.):
                            _hx_local_2 = self
                            _hx_local_3 = _hx_local_2.startup
                            _hx_local_2.startup = (_hx_local_3 + 0.1)
                            _hx_local_2.startup
                            if (self.startup > 1):
                                self.startup = 1
                else:
                    _g2 = 0
                    _g11 = scount
                    while (_g2 < _g11):
                        i1 = _g2
                        _g2 = (_g2 + 1)
                        index4 = pos
                        pos = (pos + 1)
                        index5 = read
                        read = (read + 1)
                        value2 = (data[index5] * volume)
                        if ((index4 >= 0) and ((index4 < ((out.byteLength >> 2))))):
                            out.bytes.setFloat((((index4 << 2)) + out.byteOffset),value2)
                        index6 = pos
                        pos = (pos + 1)
                        index7 = read
                        read = (read + 1)
                        value3 = (data[index7] * volume)
                        if ((index6 >= 0) and ((index6 < ((out.byteLength >> 2))))):
                            out.bytes.setFloat((((index6 << 2)) + out.byteOffset),value3)
                count = (count - scount)
                curSample = (curSample + scount)
            self.source.currentSample = (baseSample + curSample)
            if (self.source.currentSample < 0):
                raise _HxException(((Std.string(baseSample) + "/") + Std.string(curSample)))
        _g3 = 0
        _g12 = (count << 1)
        while (_g3 < _g12):
            i2 = _g3
            _g3 = (_g3 + 1)
            index8 = pos
            pos = (pos + 1)
            if ((index8 >= 0) and ((index8 < ((out.byteLength >> 2))))):
                out.bytes.setFloat((((index8 << 2)) + out.byteOffset),0.)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.source = None
        _hx_o.startup = None
hxd_snd_openal__Emulator_Channel._hx_class = hxd_snd_openal__Emulator_Channel
_hx_classes["hxd.snd.openal._Emulator.Channel"] = hxd_snd_openal__Emulator_Channel


class hxd_snd_openal_Source:
    _hx_class_name = "hxd.snd.openal.Source"
    _hx_is_interface = "False"
    __slots__ = ("id", "chan", "playedTime", "currentSample", "buffers", "loop", "volume", "duration", "frequency")
    _hx_fields = ["id", "chan", "playedTime", "currentSample", "buffers", "loop", "volume", "duration", "frequency"]
    _hx_methods = ["updateDuration", "get_playing", "play", "stop", "dispose", "toInt"]
    _hx_statics = ["STOP_DELAY", "CHANNEL_BUFSIZE", "ID", "all", "ofInt"]

    def __init__(self):
        self.frequency = None
        self.duration = None
        self.chan = None
        self.volume = 1.
        self.loop = False
        self.buffers = []
        self.currentSample = 0
        self.playedTime = 0.
        def _hx_local_2():
            _hx_local_0 = hxd_snd_openal_Source
            _hx_local_1 = _hx_local_0.ID
            _hx_local_0.ID = (_hx_local_1 + 1)
            return _hx_local_0.ID
        self.id = _hx_local_2()
        hxd_snd_openal_Source.all.set(self.id,self)

    def updateDuration(self):
        self.frequency = (1 if ((len(self.buffers) == 0)) else (self.buffers[0] if 0 < len(self.buffers) else None).frequency)
        self.duration = 0.
        _g = 0
        _g1 = self.buffers
        while (_g < len(_g1)):
            b = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            _hx_local_1 = self
            _hx_local_2 = _hx_local_1.duration
            _hx_local_1.duration = (_hx_local_2 + ((b.samples / b.frequency)))
            _hx_local_1.duration

    def get_playing(self):
        return (self.chan is not None)

    def play(self):
        if (self.chan is None):
            self.playedTime = (python_lib_Timeit.default_timer() - ((self.currentSample / self.frequency)))
            self.chan = hxd_snd_openal__Emulator_Channel(self,hxd_snd_openal_Source.CHANNEL_BUFSIZE)

    def stop(self,immediate = None):
        if (immediate is None):
            immediate = False
        if (self.chan is not None):
            self.chan.stop()
            self.chan = None

    def dispose(self):
        self.stop()
        hxd_snd_openal_Source.all.remove(self.id)
        self.id = 0

    def toInt(self):
        return self.id

    @staticmethod
    def ofInt(i):
        return hxd_snd_openal_Source.all.h.get(i,None)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.id = None
        _hx_o.chan = None
        _hx_o.playedTime = None
        _hx_o.currentSample = None
        _hx_o.buffers = None
        _hx_o.loop = None
        _hx_o.volume = None
        _hx_o.duration = None
        _hx_o.frequency = None
hxd_snd_openal_Source._hx_class = hxd_snd_openal_Source
_hx_classes["hxd.snd.openal.Source"] = hxd_snd_openal_Source


class hxd_snd_openal_Buffer:
    _hx_class_name = "hxd.snd.openal.Buffer"
    _hx_is_interface = "False"
    __slots__ = ("id", "data", "frequency", "samples")
    _hx_fields = ["id", "data", "frequency", "samples"]
    _hx_methods = ["dispose", "alloc", "toInt"]
    _hx_statics = ["ID", "all", "ofInt"]

    def __init__(self):
        self.data = None
        self.samples = 0
        self.frequency = 1
        def _hx_local_2():
            _hx_local_0 = hxd_snd_openal_Buffer
            _hx_local_1 = _hx_local_0.ID
            _hx_local_0.ID = (_hx_local_1 + 1)
            return _hx_local_0.ID
        self.id = _hx_local_2()
        hxd_snd_openal_Buffer.all.set(self.id,self)

    def dispose(self):
        self.data = None
        hxd_snd_openal_Buffer.all.remove(self.id)
        self.id = 0

    def alloc(self,size):
        if ((self.data is None) or ((len(self.data) != size))):
            this1 = [None]*size
            self.data = this1
        return self.data

    def toInt(self):
        return self.id

    @staticmethod
    def ofInt(i):
        return hxd_snd_openal_Buffer.all.h.get(i,None)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.id = None
        _hx_o.data = None
        _hx_o.frequency = None
        _hx_o.samples = None
hxd_snd_openal_Buffer._hx_class = hxd_snd_openal_Buffer
_hx_classes["hxd.snd.openal.Buffer"] = hxd_snd_openal_Buffer


class hxd_snd_openal_Emulator:
    _hx_class_name = "hxd.snd.openal.Emulator"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["CACHED_FREQ", "get_NATIVE_FREQ", "dopplerFactor", "dopplerVelocity", "speedOfSound", "distanceModel", "enable", "disable", "isEnabled", "getBooleanv", "getIntegerv", "getFloatv", "getDoublev", "getString", "getBoolean", "getInteger", "getFloat", "getDouble", "getError", "loadExtensions", "isExtensionPresent", "getEnumValue", "listenerf", "listener3f", "listenerfv", "listeneri", "listener3i", "listeneriv", "getListenerf", "getListener3f", "getListenerfv", "getListeneri", "getListener3i", "getListeneriv", "genSources", "deleteSources", "isSource", "sourcef", "source3f", "sourcefv", "sourcei", "source3i", "sourceiv", "getSourcef", "getSourcei", "getSource3f", "getSourcefv", "getSource3i", "getSourceiv", "sourcePlayv", "sourceStopv", "sourceRewindv", "sourcePausev", "sourcePlay", "sourceStop", "sourceRewind", "sourcePause", "sourceQueueBuffers", "sourceUnqueueBuffers", "genBuffers", "deleteBuffers", "isBuffer", "bufferData", "bufferf", "buffer3f", "bufferfv", "bufferi", "buffer3i", "bufferiv", "getBufferf", "getBuffer3f", "getBufferfv", "getBufferi", "getBuffer3i", "getBufferiv", "FORMAT_MONOF32", "FORMAT_STEREOF32", "NONE", "FALSE", "TRUE", "SOURCE_RELATIVE", "CONE_INNER_ANGLE", "CONE_OUTER_ANGLE", "PITCH", "POSITION", "DIRECTION", "VELOCITY", "LOOPING", "BUFFER", "GAIN", "MIN_GAIN", "MAX_GAIN", "ORIENTATION", "SOURCE_STATE", "INITIAL", "PLAYING", "PAUSED", "STOPPED", "BUFFERS_QUEUED", "BUFFERS_PROCESSED", "REFERENCE_DISTANCE", "ROLLOFF_FACTOR", "CONE_OUTER_GAIN", "MAX_DISTANCE", "SEC_OFFSET", "SAMPLE_OFFSET", "BYTE_OFFSET", "SOURCE_TYPE", "STATIC", "STREAMING", "UNDETERMINED", "FORMAT_MONO8", "FORMAT_MONO16", "FORMAT_STEREO8", "FORMAT_STEREO16", "FREQUENCY", "BITS", "CHANNELS", "SIZE", "UNUSED", "PENDING", "PROCESSED", "NO_ERROR", "INVALID_NAME", "INVALID_ENUM", "INVALID_VALUE", "INVALID_OPERATION", "OUT_OF_MEMORY", "VENDOR", "VERSION", "RENDERER", "EXTENSIONS", "DOPPLER_FACTOR", "DOPPLER_VELOCITY", "SPEED_OF_SOUND", "DISTANCE_MODEL", "INVERSE_DISTANCE", "INVERSE_DISTANCE_CLAMPED", "LINEAR_DISTANCE", "LINEAR_DISTANCE_CLAMPED", "EXPONENT_DISTANCE", "EXPONENT_DISTANCE_CLAMPED"]
    NATIVE_FREQ = None
    CACHED_FREQ = None

    @staticmethod
    def get_NATIVE_FREQ():
        if (hxd_snd_openal_Emulator.CACHED_FREQ is None):
            hxd_snd_openal_Emulator.CACHED_FREQ = 44100
        return hxd_snd_openal_Emulator.CACHED_FREQ

    @staticmethod
    def dopplerFactor(value):
        pass

    @staticmethod
    def dopplerVelocity(value):
        pass

    @staticmethod
    def speedOfSound(value):
        pass

    @staticmethod
    def distanceModel(distanceModel):
        pass

    @staticmethod
    def enable(capability):
        pass

    @staticmethod
    def disable(capability):
        pass

    @staticmethod
    def isEnabled(capability):
        return False

    @staticmethod
    def getBooleanv(param,values):
        raise _HxException("TODO")

    @staticmethod
    def getIntegerv(param,values):
        raise _HxException("TODO")

    @staticmethod
    def getFloatv(param,values):
        raise _HxException("TODO")

    @staticmethod
    def getDoublev(param,values):
        raise _HxException("TODO")

    @staticmethod
    def getString(param):
        raise _HxException("TODO")

    @staticmethod
    def getBoolean(param):
        raise _HxException("TODO")

    @staticmethod
    def getInteger(param):
        raise _HxException("TODO")

    @staticmethod
    def getFloat(param):
        raise _HxException("TODO")

    @staticmethod
    def getDouble(param):
        raise _HxException("TODO")

    @staticmethod
    def getError():
        return 0

    @staticmethod
    def loadExtensions():
        pass

    @staticmethod
    def isExtensionPresent(extname):
        return False

    @staticmethod
    def getEnumValue(ename):
        raise _HxException("TODO")

    @staticmethod
    def listenerf(param,value):
        pass

    @staticmethod
    def listener3f(param,value1,value2,value3):
        pass

    @staticmethod
    def listenerfv(param,values):
        pass

    @staticmethod
    def listeneri(param,value):
        pass

    @staticmethod
    def listener3i(param,value1,value2,value3):
        pass

    @staticmethod
    def listeneriv(param,values):
        pass

    @staticmethod
    def getListenerf(param):
        raise _HxException("TODO")

    @staticmethod
    def getListener3f(param,values):
        raise _HxException("TODO")

    @staticmethod
    def getListenerfv(param,values):
        raise _HxException("TODO")

    @staticmethod
    def getListeneri(param):
        raise _HxException("TODO")

    @staticmethod
    def getListener3i(param,values):
        raise _HxException("TODO")

    @staticmethod
    def getListeneriv(param,values):
        raise _HxException("TODO")

    @staticmethod
    def genSources(n,sources):
        _g = 0
        _g1 = n
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            pos = (i << 2)
            v = hxd_snd_openal_Source().id
            sources.b[pos] = (v & 255)
            sources.b[(pos + 1)] = ((v >> 8) & 255)
            sources.b[(pos + 2)] = ((v >> 16) & 255)
            sources.b[(pos + 3)] = (HxOverrides.rshift(v, 24) & 255)

    @staticmethod
    def deleteSources(n,sources):
        _g = 0
        _g1 = n
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            pos = (i << 2)
            v = (((sources.b[pos] | ((sources.b[(pos + 1)] << 8))) | ((sources.b[(pos + 2)] << 16))) | ((sources.b[(pos + 3)] << 24)))
            hxd_snd_openal_Source.all.h.get(((v | -2147483648) if ((((v & -2147483648)) != 0)) else v),None).dispose()

    @staticmethod
    def isSource(source):
        return (source is not None)

    @staticmethod
    def sourcef(source,param,value):
        param1 = param
        if (param1 == 4099):
            pass
        elif (param1 == 4106):
            source.volume = value
        elif (((param1 == 4131) or ((param1 == 4129))) or ((param1 == 4128))):
            pass
        elif (param1 == 4132):
            tmp = None
            if (len(source.buffers) == 0):
                tmp = 0
            else:
                x = (value * source.frequency)
                try:
                    tmp = int(x)
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e = _hx_e1
                    tmp = None
            source.currentSample = tmp
            if (source.chan is not None):
                source.stop(True)
                source.play()
        else:
            raise _HxException(("Unsupported param 0x" + HxOverrides.stringOrNull(StringTools.hex(param))))

    @staticmethod
    def source3f(source,param,value1,value2,value3):
        param1 = param
        if (((param1 == 4102) or ((param1 == 4101))) or ((param1 == 4100))):
            pass
        else:
            raise _HxException(("Unsupported param 0x" + HxOverrides.stringOrNull(StringTools.hex(param))))

    @staticmethod
    def sourcefv(source,param,values):
        raise _HxException(("Unsupported param 0x" + HxOverrides.stringOrNull(StringTools.hex(param))))

    @staticmethod
    def sourcei(source,param,value):
        param1 = param
        if (param1 == 514):
            pass
        elif (param1 == 4103):
            source.loop = (value != 0)
        elif (param1 == 4105):
            b = hxd_snd_openal_Buffer.all.h.get(value,None)
            source.buffers = ([] if ((b is None)) else [b])
            source.updateDuration()
            source.currentSample = 0
        elif (param1 == 4133):
            x = (hxd_snd_openal_Emulator.getSourcef(source,4132) / source.frequency)
            tmp = None
            try:
                tmp = int(x)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                tmp = None
            source.currentSample = tmp
            if (source.chan is not None):
                source.stop(True)
                source.play()
        elif (param1 == 131077):
            pass
        else:
            raise _HxException(("Unsupported param 0x" + HxOverrides.stringOrNull(StringTools.hex(param))))

    @staticmethod
    def source3i(source,param,value1,value2,value3):
        raise _HxException(("Unsupported param 0x" + HxOverrides.stringOrNull(StringTools.hex(param))))

    @staticmethod
    def sourceiv(source,param,values):
        raise _HxException(("Unsupported param 0x" + HxOverrides.stringOrNull(StringTools.hex(param))))

    @staticmethod
    def getSourcef(source,param):
        if (param == 4132):
            if (len(source.buffers) == 0):
                return 0
            now = python_lib_Timeit.default_timer()
            t = (now - source.playedTime)
            maxT = source.duration
            if source.loop:
                while (t > maxT):
                    t = (t - maxT)
                    source.playedTime = (source.playedTime + maxT)
            elif (t > maxT):
                t = maxT
            return t
        else:
            raise _HxException(("Unsupported param 0x" + HxOverrides.stringOrNull(StringTools.hex(param))))

    @staticmethod
    def getSourcei(source,param):
        param1 = param
        if (param1 == 4112):
            if (((source.chan is None) or ((len(source.buffers) == 0))) or (((not source.loop) and (((python_lib_Timeit.default_timer() - source.playedTime) >= source.duration))))):
                return 4116
            else:
                return 4114
        elif (param1 == 4118):
            if source.loop:
                return 0
            count = 0
            cur = source.currentSample
            _g = 0
            _g1 = source.buffers
            while (_g < len(_g1)):
                b = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (cur >= b.samples):
                    cur = (cur - b.samples)
                    count = (count + 1)
                else:
                    break
            return count
        elif (param1 == 4133):
            x = (hxd_snd_openal_Emulator.getSourcef(source,4132) * source.frequency)
            try:
                return int(x)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                return None
        else:
            raise _HxException(("Unsupported param 0x" + HxOverrides.stringOrNull(StringTools.hex(param))))

    @staticmethod
    def getSource3f(source,param,values):
        raise _HxException("TODO")

    @staticmethod
    def getSourcefv(source,param,values):
        raise _HxException("TODO")

    @staticmethod
    def getSource3i(source,param,values):
        raise _HxException("TODO")

    @staticmethod
    def getSourceiv(source,param,values):
        raise _HxException("TODO")

    @staticmethod
    def sourcePlayv(n,sources):
        raise _HxException("TODO")

    @staticmethod
    def sourceStopv(n,sources):
        raise _HxException("TODO")

    @staticmethod
    def sourceRewindv(n,sources):
        raise _HxException("TODO")

    @staticmethod
    def sourcePausev(n,sources):
        raise _HxException("TODO")

    @staticmethod
    def sourcePlay(source):
        source.play()

    @staticmethod
    def sourceStop(source):
        source.stop()
        source.currentSample = 0

    @staticmethod
    def sourceRewind(source):
        raise _HxException("TODO")

    @staticmethod
    def sourcePause(source):
        raise _HxException("TODO")

    @staticmethod
    def sourceQueueBuffers(source,nb,buffers):
        _g = 0
        _g1 = nb
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            pos = (i * 4)
            v = (((buffers.b[pos] | ((buffers.b[(pos + 1)] << 8))) | ((buffers.b[(pos + 2)] << 16))) | ((buffers.b[(pos + 3)] << 24)))
            b = hxd_snd_openal_Buffer.all.h.get(((v | -2147483648) if ((((v & -2147483648)) != 0)) else v),None)
            if (b is None):
                raise _HxException("assert")
            _this = source.buffers
            _this.append(b)
        source.updateDuration()

    @staticmethod
    def sourceUnqueueBuffers(source,nb,buffers):
        _g = 0
        _g1 = nb
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            pos = (i * 4)
            v = (((buffers.b[pos] | ((buffers.b[(pos + 1)] << 8))) | ((buffers.b[(pos + 2)] << 16))) | ((buffers.b[(pos + 3)] << 24)))
            b = hxd_snd_openal_Buffer.all.h.get(((v | -2147483648) if ((((v & -2147483648)) != 0)) else v),None)
            if (b != (source.buffers[0] if 0 < len(source.buffers) else None)):
                raise _HxException("assert")
            if (source.chan is not None):
                if (source.currentSample < b.samples):
                    raise _HxException("assert")
                _this = source.buffers
                if (len(_this) != 0):
                    _this.pop(0)
                source.currentSample = (source.currentSample - b.samples)
                source.playedTime = (source.playedTime + ((b.samples / b.frequency)))
            else:
                _this1 = source.buffers
                if (len(_this1) != 0):
                    _this1.pop(0)
            source.updateDuration()

    @staticmethod
    def genBuffers(n,buffers):
        _g = 0
        _g1 = n
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            pos = (i << 2)
            v = hxd_snd_openal_Buffer().id
            buffers.b[pos] = (v & 255)
            buffers.b[(pos + 1)] = ((v >> 8) & 255)
            buffers.b[(pos + 2)] = ((v >> 16) & 255)
            buffers.b[(pos + 3)] = (HxOverrides.rshift(v, 24) & 255)

    @staticmethod
    def deleteBuffers(n,buffers):
        _g = 0
        _g1 = n
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            pos = (i << 2)
            v = (((buffers.b[pos] | ((buffers.b[(pos + 1)] << 8))) | ((buffers.b[(pos + 2)] << 16))) | ((buffers.b[(pos + 3)] << 24)))
            hxd_snd_openal_Buffer.all.h.get(((v | -2147483648) if ((((v & -2147483648)) != 0)) else v),None).dispose()

    @staticmethod
    def isBuffer(buffer):
        return (buffer is not None)

    @staticmethod
    def bufferData(buffer,format,data,size,freq):
        if (freq != hxd_snd_openal_Emulator.get_NATIVE_FREQ()):
            raise _HxException(((("Unsupported frequency value: " + Std.string(freq)) + " should be ") + Std.string(hxd_snd_openal_Emulator.get_NATIVE_FREQ())))
        format1 = format
        if (format1 == 4352):
            bdata = buffer.alloc((size * 2))
            _g = 0
            _g1 = size
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                v = (data.b[i] / 255)
                bdata[(i << 1)] = v
                bdata[((i << 1) | 1)] = v
        elif (format1 == 4353):
            bdata1 = buffer.alloc(size)
            _g2 = 0
            _g11 = (size >> 1)
            while (_g2 < _g11):
                i1 = _g2
                _g2 = (_g2 + 1)
                pos = (i1 << 1)
                v1 = (data.b[pos] | ((data.b[(pos + 1)] << 8)))
                v2 = (((v1 if ((((v1 & 32768)) == 0)) else (v1 | -65536))) / 32768)
                bdata1[(i1 << 1)] = v2
                bdata1[((i1 << 1) | 1)] = v2
        elif (format1 == 4354):
            bdata2 = buffer.alloc(size)
            _g3 = 0
            _g12 = size
            while (_g3 < _g12):
                i2 = _g3
                _g3 = (_g3 + 1)
                v3 = (data.b[i2] / 255)
                bdata2[i2] = v3
        elif (format1 == 4355):
            bdata3 = buffer.alloc((size >> 1))
            _g4 = 0
            _g13 = (size >> 1)
            while (_g4 < _g13):
                i3 = _g4
                _g4 = (_g4 + 1)
                pos1 = (i3 << 1)
                v4 = (data.b[pos1] | ((data.b[(pos1 + 1)] << 8)))
                v5 = (((v4 if ((((v4 & 32768)) == 0)) else (v4 | -65536))) / 32768)
                bdata3[i3] = v5
        elif (format1 == 4368):
            bdata4 = buffer.alloc((size >> 1))
            _g5 = 0
            _g14 = (size >> 2)
            while (_g5 < _g14):
                i4 = _g5
                _g5 = (_g5 + 1)
                f = data.getFloat((i4 << 2))
                bdata4[(i4 << 1)] = f
                bdata4[((i4 << 1) | 1)] = f
        elif (format1 == 4369):
            bdata5 = buffer.alloc((size >> 2))
            _g6 = 0
            _g15 = (size >> 2)
            while (_g6 < _g15):
                i5 = _g6
                _g6 = (_g6 + 1)
                this1 = buffer.data
                val = data.getFloat((i5 << 2))
                this1[i5] = val
        else:
            raise _HxException(("Format not supported 0x" + HxOverrides.stringOrNull(StringTools.hex(format))))
        buffer.samples = (len(buffer.data) >> 1)
        buffer.frequency = freq

    @staticmethod
    def bufferf(buffer,param,value):
        raise _HxException(("Unsupported param 0x" + HxOverrides.stringOrNull(StringTools.hex(param))))

    @staticmethod
    def buffer3f(buffer,param,value1,value2,value3):
        raise _HxException(("Unsupported param 0x" + HxOverrides.stringOrNull(StringTools.hex(param))))

    @staticmethod
    def bufferfv(buffer,param,values):
        raise _HxException(("Unsupported param 0x" + HxOverrides.stringOrNull(StringTools.hex(param))))

    @staticmethod
    def bufferi(buffer,param,value):
        raise _HxException(("Unsupported param 0x" + HxOverrides.stringOrNull(StringTools.hex(param))))

    @staticmethod
    def buffer3i(buffer,param,value1,value2,value3):
        raise _HxException(("Unsupported param 0x" + HxOverrides.stringOrNull(StringTools.hex(param))))

    @staticmethod
    def bufferiv(buffer,param,values):
        raise _HxException(("Unsupported param 0x" + HxOverrides.stringOrNull(StringTools.hex(param))))

    @staticmethod
    def getBufferf(buffer,param):
        raise _HxException("TODO")

    @staticmethod
    def getBuffer3f(buffer,param,values):
        raise _HxException("TODO")

    @staticmethod
    def getBufferfv(buffer,param,values):
        raise _HxException("TODO")

    @staticmethod
    def getBufferi(buffer,param):
        param1 = param
        if (param1 == 8194):
            return 32
        elif (param1 == 8195):
            return 2
        elif (param1 == 8196):
            return (len(buffer.data) * 4)
        else:
            raise _HxException(("Unsupported param 0x" + HxOverrides.stringOrNull(StringTools.hex(param))))

    @staticmethod
    def getBuffer3i(buffer,param,values):
        raise _HxException("TODO")

    @staticmethod
    def getBufferiv(buffer,param,values):
        raise _HxException("TODO")
hxd_snd_openal_Emulator._hx_class = hxd_snd_openal_Emulator
_hx_classes["hxd.snd.openal.Emulator"] = hxd_snd_openal_Emulator


class hxd_snd_openal_Device:
    _hx_class_name = "hxd.snd.openal.Device"
    _hx_is_interface = "False"
    __slots__ = ()

    def __init__(self):
        pass
hxd_snd_openal_Device._hx_class = hxd_snd_openal_Device
_hx_classes["hxd.snd.openal.Device"] = hxd_snd_openal_Device


class hxd_snd_openal_Context:
    _hx_class_name = "hxd.snd.openal.Context"
    _hx_is_interface = "False"
    __slots__ = ("device",)
    _hx_fields = ["device"]

    def __init__(self,d):
        self.device = d

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.device = None
hxd_snd_openal_Context._hx_class = hxd_snd_openal_Context
_hx_classes["hxd.snd.openal.Context"] = hxd_snd_openal_Context


class hxd_snd_openal_ALC:
    _hx_class_name = "hxd.snd.openal.ALC"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["ctx", "getError", "createContext", "makeContextCurrent", "processContext", "suspendContext", "destroyContext", "getCurrentContext", "getContextsDevice", "openDevice", "closeDevice", "loadExtensions", "isExtensionPresent", "getEnumValue", "getString", "getIntegerv", "FALSE", "TRUE", "FREQUENCY", "REFRESH", "SYNC", "MONO_SOURCES", "STEREO_SOURCES", "NO_ERROR", "INVALID_DEVICE", "INVALID_CONTEXT", "INVALID_ENUM", "INVALID_VALUE", "OUT_OF_MEMORY", "MAJOR_VERSION", "MINOR_VERSION", "ATTRIBUTES_SIZE", "ALL_ATTRIBUTES", "DEFAULT_DEVICE_SPECIFIER", "DEVICE_SPECIFIER", "EXTENSIONS", "EXT_CAPTURE", "CAPTURE_DEVICE_SPECIFIER", "CAPTURE_DEFAULT_DEVICE_SPECIFIER", "CAPTURE_SAMPLES", "ENUMERATE_ALL_EXT", "DEFAULT_ALL_DEVICES_SPECIFIER", "ALL_DEVICES_SPECIFIER"]

    @staticmethod
    def getError(device):
        return 0

    @staticmethod
    def createContext(device,attrlist):
        return hxd_snd_openal_Context(device)

    @staticmethod
    def makeContextCurrent(context):
        hxd_snd_openal_ALC.ctx = context
        return True

    @staticmethod
    def processContext(context):
        pass

    @staticmethod
    def suspendContext(context):
        pass

    @staticmethod
    def destroyContext(context):
        pass

    @staticmethod
    def getCurrentContext():
        return hxd_snd_openal_ALC.ctx

    @staticmethod
    def getContextsDevice(context):
        return hxd_snd_openal_ALC.ctx.device

    @staticmethod
    def openDevice(devicename):
        return hxd_snd_openal_Device()

    @staticmethod
    def closeDevice(device):
        return True

    @staticmethod
    def loadExtensions(alDevice):
        pass

    @staticmethod
    def isExtensionPresent(device,extname):
        return False

    @staticmethod
    def getEnumValue(device,enumname):
        raise _HxException("TODO")

    @staticmethod
    def getString(device,param):
        raise _HxException("TODO")

    @staticmethod
    def getIntegerv(device,param,size,values):
        if (param != 131075):
            raise _HxException(("Unsupported param 0x" + HxOverrides.stringOrNull(StringTools.hex(param))))
hxd_snd_openal_ALC._hx_class = hxd_snd_openal_ALC
_hx_classes["hxd.snd.openal.ALC"] = hxd_snd_openal_ALC


class hxd_snd_openal_EFX:
    _hx_class_name = "hxd.snd.openal.EFX"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["EFX_MAJOR_VERSION", "EFX_MINOR_VERSION", "MAX_AUXILIARY_SENDS", "METERS_PER_UNIT", "DIRECT_FILTER", "FILTER_NULL"]
hxd_snd_openal_EFX._hx_class = hxd_snd_openal_EFX
_hx_classes["hxd.snd.openal.EFX"] = hxd_snd_openal_EFX

class hxsl_Type(Enum):
    __slots__ = ()
    _hx_class_name = "hxsl.Type"
    _hx_constructs = ["TVoid", "TInt", "TBool", "TFloat", "TString", "TVec", "TMat3", "TMat4", "TMat3x4", "TBytes", "TSampler2D", "TSampler2DArray", "TSamplerCube", "TStruct", "TFun", "TArray", "TBuffer", "TChannel"]

    @staticmethod
    def TVec(size,t):
        return hxsl_Type("TVec", 5, (size,t))

    @staticmethod
    def TBytes(size):
        return hxsl_Type("TBytes", 9, (size,))

    @staticmethod
    def TStruct(vl):
        return hxsl_Type("TStruct", 13, (vl,))

    @staticmethod
    def TFun(variants):
        return hxsl_Type("TFun", 14, (variants,))

    @staticmethod
    def TArray(t,size):
        return hxsl_Type("TArray", 15, (t,size))

    @staticmethod
    def TBuffer(t,size):
        return hxsl_Type("TBuffer", 16, (t,size))

    @staticmethod
    def TChannel(size):
        return hxsl_Type("TChannel", 17, (size,))
hxsl_Type.TVoid = hxsl_Type("TVoid", 0, ())
hxsl_Type.TInt = hxsl_Type("TInt", 1, ())
hxsl_Type.TBool = hxsl_Type("TBool", 2, ())
hxsl_Type.TFloat = hxsl_Type("TFloat", 3, ())
hxsl_Type.TString = hxsl_Type("TString", 4, ())
hxsl_Type.TMat3 = hxsl_Type("TMat3", 6, ())
hxsl_Type.TMat4 = hxsl_Type("TMat4", 7, ())
hxsl_Type.TMat3x4 = hxsl_Type("TMat3x4", 8, ())
hxsl_Type.TSampler2D = hxsl_Type("TSampler2D", 10, ())
hxsl_Type.TSampler2DArray = hxsl_Type("TSampler2DArray", 11, ())
hxsl_Type.TSamplerCube = hxsl_Type("TSamplerCube", 12, ())
hxsl_Type._hx_class = hxsl_Type
_hx_classes["hxsl.Type"] = hxsl_Type

class hxsl_VecType(Enum):
    __slots__ = ()
    _hx_class_name = "hxsl.VecType"
    _hx_constructs = ["VInt", "VFloat", "VBool"]
hxsl_VecType.VInt = hxsl_VecType("VInt", 0, ())
hxsl_VecType.VFloat = hxsl_VecType("VFloat", 1, ())
hxsl_VecType.VBool = hxsl_VecType("VBool", 2, ())
hxsl_VecType._hx_class = hxsl_VecType
_hx_classes["hxsl.VecType"] = hxsl_VecType

class hxsl_SizeDecl(Enum):
    __slots__ = ()
    _hx_class_name = "hxsl.SizeDecl"
    _hx_constructs = ["SConst", "SVar"]

    @staticmethod
    def SConst(v):
        return hxsl_SizeDecl("SConst", 0, (v,))

    @staticmethod
    def SVar(v):
        return hxsl_SizeDecl("SVar", 1, (v,))
hxsl_SizeDecl._hx_class = hxsl_SizeDecl
_hx_classes["hxsl.SizeDecl"] = hxsl_SizeDecl


class hxsl_Error:
    _hx_class_name = "hxsl.Error"
    _hx_is_interface = "False"
    __slots__ = ("msg", "pos")
    _hx_fields = ["msg", "pos"]
    _hx_methods = ["toString"]
    _hx_statics = ["t"]

    def __init__(self,msg,pos):
        self.msg = msg
        self.pos = pos

    def toString(self):
        return ((("Error(" + HxOverrides.stringOrNull(self.msg)) + ")@") + Std.string(self.pos))

    @staticmethod
    def t(msg,pos):
        raise _HxException(hxsl_Error(msg,pos))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.msg = None
        _hx_o.pos = None
hxsl_Error._hx_class = hxsl_Error
_hx_classes["hxsl.Error"] = hxsl_Error

class hxsl_VarKind(Enum):
    __slots__ = ()
    _hx_class_name = "hxsl.VarKind"
    _hx_constructs = ["Global", "Input", "Param", "Var", "Local", "Output", "Function"]
hxsl_VarKind.Global = hxsl_VarKind("Global", 0, ())
hxsl_VarKind.Input = hxsl_VarKind("Input", 1, ())
hxsl_VarKind.Param = hxsl_VarKind("Param", 2, ())
hxsl_VarKind.Var = hxsl_VarKind("Var", 3, ())
hxsl_VarKind.Local = hxsl_VarKind("Local", 4, ())
hxsl_VarKind.Output = hxsl_VarKind("Output", 5, ())
hxsl_VarKind.Function = hxsl_VarKind("Function", 6, ())
hxsl_VarKind._hx_class = hxsl_VarKind
_hx_classes["hxsl.VarKind"] = hxsl_VarKind

class hxsl_VarQualifier(Enum):
    __slots__ = ()
    _hx_class_name = "hxsl.VarQualifier"
    _hx_constructs = ["Const", "Private", "Nullable", "PerObject", "Name", "Shared", "Precision", "Range", "Ignore", "PerInstance"]

    @staticmethod
    def Const(max = None):
        return hxsl_VarQualifier("Const", 0, (max,))

    @staticmethod
    def Name(n):
        return hxsl_VarQualifier("Name", 4, (n,))

    @staticmethod
    def Precision(p):
        return hxsl_VarQualifier("Precision", 6, (p,))

    @staticmethod
    def Range(min,max):
        return hxsl_VarQualifier("Range", 7, (min,max))

    @staticmethod
    def PerInstance(v):
        return hxsl_VarQualifier("PerInstance", 9, (v,))
hxsl_VarQualifier.Private = hxsl_VarQualifier("Private", 1, ())
hxsl_VarQualifier.Nullable = hxsl_VarQualifier("Nullable", 2, ())
hxsl_VarQualifier.PerObject = hxsl_VarQualifier("PerObject", 3, ())
hxsl_VarQualifier.Shared = hxsl_VarQualifier("Shared", 5, ())
hxsl_VarQualifier.Ignore = hxsl_VarQualifier("Ignore", 8, ())
hxsl_VarQualifier._hx_class = hxsl_VarQualifier
_hx_classes["hxsl.VarQualifier"] = hxsl_VarQualifier

class hxsl_Prec(Enum):
    __slots__ = ()
    _hx_class_name = "hxsl.Prec"
    _hx_constructs = ["Low", "Medium", "High"]
hxsl_Prec.Low = hxsl_Prec("Low", 0, ())
hxsl_Prec.Medium = hxsl_Prec("Medium", 1, ())
hxsl_Prec.High = hxsl_Prec("High", 2, ())
hxsl_Prec._hx_class = hxsl_Prec
_hx_classes["hxsl.Prec"] = hxsl_Prec

class hxsl_Const(Enum):
    __slots__ = ()
    _hx_class_name = "hxsl.Const"
    _hx_constructs = ["CNull", "CBool", "CInt", "CFloat", "CString"]

    @staticmethod
    def CBool(b):
        return hxsl_Const("CBool", 1, (b,))

    @staticmethod
    def CInt(v):
        return hxsl_Const("CInt", 2, (v,))

    @staticmethod
    def CFloat(v):
        return hxsl_Const("CFloat", 3, (v,))

    @staticmethod
    def CString(v):
        return hxsl_Const("CString", 4, (v,))
hxsl_Const.CNull = hxsl_Const("CNull", 0, ())
hxsl_Const._hx_class = hxsl_Const
_hx_classes["hxsl.Const"] = hxsl_Const

class hxsl_ExprDef(Enum):
    __slots__ = ()
    _hx_class_name = "hxsl.ExprDef"
    _hx_constructs = ["EConst", "EIdent", "EParenthesis", "EField", "EBinop", "EUnop", "ECall", "EBlock", "EVars", "EFunction", "EIf", "EDiscard", "EFor", "EReturn", "EBreak", "EContinue", "EArray", "EArrayDecl", "ESwitch", "EWhile", "EMeta"]

    @staticmethod
    def EConst(c):
        return hxsl_ExprDef("EConst", 0, (c,))

    @staticmethod
    def EIdent(i):
        return hxsl_ExprDef("EIdent", 1, (i,))

    @staticmethod
    def EParenthesis(e):
        return hxsl_ExprDef("EParenthesis", 2, (e,))

    @staticmethod
    def EField(e,f):
        return hxsl_ExprDef("EField", 3, (e,f))

    @staticmethod
    def EBinop(op,e1,e2):
        return hxsl_ExprDef("EBinop", 4, (op,e1,e2))

    @staticmethod
    def EUnop(op,e1):
        return hxsl_ExprDef("EUnop", 5, (op,e1))

    @staticmethod
    def ECall(e,args):
        return hxsl_ExprDef("ECall", 6, (e,args))

    @staticmethod
    def EBlock(el):
        return hxsl_ExprDef("EBlock", 7, (el,))

    @staticmethod
    def EVars(v):
        return hxsl_ExprDef("EVars", 8, (v,))

    @staticmethod
    def EFunction(f):
        return hxsl_ExprDef("EFunction", 9, (f,))

    @staticmethod
    def EIf(econd,eif,eelse):
        return hxsl_ExprDef("EIf", 10, (econd,eif,eelse))

    @staticmethod
    def EFor(v,loop,block):
        return hxsl_ExprDef("EFor", 12, (v,loop,block))

    @staticmethod
    def EReturn(e = None):
        return hxsl_ExprDef("EReturn", 13, (e,))

    @staticmethod
    def EArray(e,eindex):
        return hxsl_ExprDef("EArray", 16, (e,eindex))

    @staticmethod
    def EArrayDecl(el):
        return hxsl_ExprDef("EArrayDecl", 17, (el,))

    @staticmethod
    def ESwitch(e,cases,_hx_def):
        return hxsl_ExprDef("ESwitch", 18, (e,cases,_hx_def))

    @staticmethod
    def EWhile(cond,loop,normalWhile):
        return hxsl_ExprDef("EWhile", 19, (cond,loop,normalWhile))

    @staticmethod
    def EMeta(name,args,e):
        return hxsl_ExprDef("EMeta", 20, (name,args,e))
hxsl_ExprDef.EDiscard = hxsl_ExprDef("EDiscard", 11, ())
hxsl_ExprDef.EBreak = hxsl_ExprDef("EBreak", 14, ())
hxsl_ExprDef.EContinue = hxsl_ExprDef("EContinue", 15, ())
hxsl_ExprDef._hx_class = hxsl_ExprDef
_hx_classes["hxsl.ExprDef"] = hxsl_ExprDef

class hxsl_FunctionKind(Enum):
    __slots__ = ()
    _hx_class_name = "hxsl.FunctionKind"
    _hx_constructs = ["Vertex", "Fragment", "Init", "Helper"]
hxsl_FunctionKind.Vertex = hxsl_FunctionKind("Vertex", 0, ())
hxsl_FunctionKind.Fragment = hxsl_FunctionKind("Fragment", 1, ())
hxsl_FunctionKind.Init = hxsl_FunctionKind("Init", 2, ())
hxsl_FunctionKind.Helper = hxsl_FunctionKind("Helper", 3, ())
hxsl_FunctionKind._hx_class = hxsl_FunctionKind
_hx_classes["hxsl.FunctionKind"] = hxsl_FunctionKind

class hxsl_TGlobal(Enum):
    __slots__ = ()
    _hx_class_name = "hxsl.TGlobal"
    _hx_constructs = ["Radians", "Degrees", "Sin", "Cos", "Tan", "Asin", "Acos", "Atan", "Pow", "Exp", "Log", "Exp2", "Log2", "Sqrt", "Inversesqrt", "Abs", "Sign", "Floor", "Ceil", "Fract", "Mod", "Min", "Max", "Clamp", "Mix", "Step", "Smoothstep", "Length", "Distance", "Dot", "Cross", "Normalize", "LReflect", "Texture", "TextureLod", "Texel", "TexelLod", "ToInt", "ToFloat", "ToBool", "Vec2", "Vec3", "Vec4", "IVec2", "IVec3", "IVec4", "BVec2", "BVec3", "BVec4", "Mat2", "Mat3", "Mat4", "Mat3x4", "Saturate", "Pack", "Unpack", "PackNormal", "UnpackNormal", "ScreenToUv", "UvToScreen", "DFdx", "DFdy", "Fwidth", "ChannelRead", "ChannelReadLod", "ChannelFetch", "ChannelFetchLod", "Trace", "VertexID", "InstanceID", "FragCoord"]
hxsl_TGlobal.Radians = hxsl_TGlobal("Radians", 0, ())
hxsl_TGlobal.Degrees = hxsl_TGlobal("Degrees", 1, ())
hxsl_TGlobal.Sin = hxsl_TGlobal("Sin", 2, ())
hxsl_TGlobal.Cos = hxsl_TGlobal("Cos", 3, ())
hxsl_TGlobal.Tan = hxsl_TGlobal("Tan", 4, ())
hxsl_TGlobal.Asin = hxsl_TGlobal("Asin", 5, ())
hxsl_TGlobal.Acos = hxsl_TGlobal("Acos", 6, ())
hxsl_TGlobal.Atan = hxsl_TGlobal("Atan", 7, ())
hxsl_TGlobal.Pow = hxsl_TGlobal("Pow", 8, ())
hxsl_TGlobal.Exp = hxsl_TGlobal("Exp", 9, ())
hxsl_TGlobal.Log = hxsl_TGlobal("Log", 10, ())
hxsl_TGlobal.Exp2 = hxsl_TGlobal("Exp2", 11, ())
hxsl_TGlobal.Log2 = hxsl_TGlobal("Log2", 12, ())
hxsl_TGlobal.Sqrt = hxsl_TGlobal("Sqrt", 13, ())
hxsl_TGlobal.Inversesqrt = hxsl_TGlobal("Inversesqrt", 14, ())
hxsl_TGlobal.Abs = hxsl_TGlobal("Abs", 15, ())
hxsl_TGlobal.Sign = hxsl_TGlobal("Sign", 16, ())
hxsl_TGlobal.Floor = hxsl_TGlobal("Floor", 17, ())
hxsl_TGlobal.Ceil = hxsl_TGlobal("Ceil", 18, ())
hxsl_TGlobal.Fract = hxsl_TGlobal("Fract", 19, ())
hxsl_TGlobal.Mod = hxsl_TGlobal("Mod", 20, ())
hxsl_TGlobal.Min = hxsl_TGlobal("Min", 21, ())
hxsl_TGlobal.Max = hxsl_TGlobal("Max", 22, ())
hxsl_TGlobal.Clamp = hxsl_TGlobal("Clamp", 23, ())
hxsl_TGlobal.Mix = hxsl_TGlobal("Mix", 24, ())
hxsl_TGlobal.Step = hxsl_TGlobal("Step", 25, ())
hxsl_TGlobal.Smoothstep = hxsl_TGlobal("Smoothstep", 26, ())
hxsl_TGlobal.Length = hxsl_TGlobal("Length", 27, ())
hxsl_TGlobal.Distance = hxsl_TGlobal("Distance", 28, ())
hxsl_TGlobal.Dot = hxsl_TGlobal("Dot", 29, ())
hxsl_TGlobal.Cross = hxsl_TGlobal("Cross", 30, ())
hxsl_TGlobal.Normalize = hxsl_TGlobal("Normalize", 31, ())
hxsl_TGlobal.LReflect = hxsl_TGlobal("LReflect", 32, ())
hxsl_TGlobal.Texture = hxsl_TGlobal("Texture", 33, ())
hxsl_TGlobal.TextureLod = hxsl_TGlobal("TextureLod", 34, ())
hxsl_TGlobal.Texel = hxsl_TGlobal("Texel", 35, ())
hxsl_TGlobal.TexelLod = hxsl_TGlobal("TexelLod", 36, ())
hxsl_TGlobal.ToInt = hxsl_TGlobal("ToInt", 37, ())
hxsl_TGlobal.ToFloat = hxsl_TGlobal("ToFloat", 38, ())
hxsl_TGlobal.ToBool = hxsl_TGlobal("ToBool", 39, ())
hxsl_TGlobal.Vec2 = hxsl_TGlobal("Vec2", 40, ())
hxsl_TGlobal.Vec3 = hxsl_TGlobal("Vec3", 41, ())
hxsl_TGlobal.Vec4 = hxsl_TGlobal("Vec4", 42, ())
hxsl_TGlobal.IVec2 = hxsl_TGlobal("IVec2", 43, ())
hxsl_TGlobal.IVec3 = hxsl_TGlobal("IVec3", 44, ())
hxsl_TGlobal.IVec4 = hxsl_TGlobal("IVec4", 45, ())
hxsl_TGlobal.BVec2 = hxsl_TGlobal("BVec2", 46, ())
hxsl_TGlobal.BVec3 = hxsl_TGlobal("BVec3", 47, ())
hxsl_TGlobal.BVec4 = hxsl_TGlobal("BVec4", 48, ())
hxsl_TGlobal.Mat2 = hxsl_TGlobal("Mat2", 49, ())
hxsl_TGlobal.Mat3 = hxsl_TGlobal("Mat3", 50, ())
hxsl_TGlobal.Mat4 = hxsl_TGlobal("Mat4", 51, ())
hxsl_TGlobal.Mat3x4 = hxsl_TGlobal("Mat3x4", 52, ())
hxsl_TGlobal.Saturate = hxsl_TGlobal("Saturate", 53, ())
hxsl_TGlobal.Pack = hxsl_TGlobal("Pack", 54, ())
hxsl_TGlobal.Unpack = hxsl_TGlobal("Unpack", 55, ())
hxsl_TGlobal.PackNormal = hxsl_TGlobal("PackNormal", 56, ())
hxsl_TGlobal.UnpackNormal = hxsl_TGlobal("UnpackNormal", 57, ())
hxsl_TGlobal.ScreenToUv = hxsl_TGlobal("ScreenToUv", 58, ())
hxsl_TGlobal.UvToScreen = hxsl_TGlobal("UvToScreen", 59, ())
hxsl_TGlobal.DFdx = hxsl_TGlobal("DFdx", 60, ())
hxsl_TGlobal.DFdy = hxsl_TGlobal("DFdy", 61, ())
hxsl_TGlobal.Fwidth = hxsl_TGlobal("Fwidth", 62, ())
hxsl_TGlobal.ChannelRead = hxsl_TGlobal("ChannelRead", 63, ())
hxsl_TGlobal.ChannelReadLod = hxsl_TGlobal("ChannelReadLod", 64, ())
hxsl_TGlobal.ChannelFetch = hxsl_TGlobal("ChannelFetch", 65, ())
hxsl_TGlobal.ChannelFetchLod = hxsl_TGlobal("ChannelFetchLod", 66, ())
hxsl_TGlobal.Trace = hxsl_TGlobal("Trace", 67, ())
hxsl_TGlobal.VertexID = hxsl_TGlobal("VertexID", 68, ())
hxsl_TGlobal.InstanceID = hxsl_TGlobal("InstanceID", 69, ())
hxsl_TGlobal.FragCoord = hxsl_TGlobal("FragCoord", 70, ())
hxsl_TGlobal._hx_class = hxsl_TGlobal
_hx_classes["hxsl.TGlobal"] = hxsl_TGlobal

class hxsl_Component(Enum):
    __slots__ = ()
    _hx_class_name = "hxsl.Component"
    _hx_constructs = ["X", "Y", "Z", "W"]
hxsl_Component.X = hxsl_Component("X", 0, ())
hxsl_Component.Y = hxsl_Component("Y", 1, ())
hxsl_Component.Z = hxsl_Component("Z", 2, ())
hxsl_Component.W = hxsl_Component("W", 3, ())
hxsl_Component._hx_class = hxsl_Component
_hx_classes["hxsl.Component"] = hxsl_Component

class hxsl_TExprDef(Enum):
    __slots__ = ()
    _hx_class_name = "hxsl.TExprDef"
    _hx_constructs = ["TConst", "TVar", "TGlobal", "TParenthesis", "TBlock", "TBinop", "TUnop", "TVarDecl", "TCall", "TSwiz", "TIf", "TDiscard", "TReturn", "TFor", "TContinue", "TBreak", "TArray", "TArrayDecl", "TSwitch", "TWhile", "TMeta"]

    @staticmethod
    def TConst(c):
        return hxsl_TExprDef("TConst", 0, (c,))

    @staticmethod
    def TVar(v):
        return hxsl_TExprDef("TVar", 1, (v,))

    @staticmethod
    def TGlobal(g):
        return hxsl_TExprDef("TGlobal", 2, (g,))

    @staticmethod
    def TParenthesis(e):
        return hxsl_TExprDef("TParenthesis", 3, (e,))

    @staticmethod
    def TBlock(el):
        return hxsl_TExprDef("TBlock", 4, (el,))

    @staticmethod
    def TBinop(op,e1,e2):
        return hxsl_TExprDef("TBinop", 5, (op,e1,e2))

    @staticmethod
    def TUnop(op,e1):
        return hxsl_TExprDef("TUnop", 6, (op,e1))

    @staticmethod
    def TVarDecl(v,init = None):
        return hxsl_TExprDef("TVarDecl", 7, (v,init))

    @staticmethod
    def TCall(e,args):
        return hxsl_TExprDef("TCall", 8, (e,args))

    @staticmethod
    def TSwiz(e,regs):
        return hxsl_TExprDef("TSwiz", 9, (e,regs))

    @staticmethod
    def TIf(econd,eif,eelse):
        return hxsl_TExprDef("TIf", 10, (econd,eif,eelse))

    @staticmethod
    def TReturn(e = None):
        return hxsl_TExprDef("TReturn", 12, (e,))

    @staticmethod
    def TFor(v,it,loop):
        return hxsl_TExprDef("TFor", 13, (v,it,loop))

    @staticmethod
    def TArray(e,index):
        return hxsl_TExprDef("TArray", 16, (e,index))

    @staticmethod
    def TArrayDecl(el):
        return hxsl_TExprDef("TArrayDecl", 17, (el,))

    @staticmethod
    def TSwitch(e,cases,_hx_def):
        return hxsl_TExprDef("TSwitch", 18, (e,cases,_hx_def))

    @staticmethod
    def TWhile(e,loop,normalWhile):
        return hxsl_TExprDef("TWhile", 19, (e,loop,normalWhile))

    @staticmethod
    def TMeta(m,args,e):
        return hxsl_TExprDef("TMeta", 20, (m,args,e))
hxsl_TExprDef.TDiscard = hxsl_TExprDef("TDiscard", 11, ())
hxsl_TExprDef.TContinue = hxsl_TExprDef("TContinue", 14, ())
hxsl_TExprDef.TBreak = hxsl_TExprDef("TBreak", 15, ())
hxsl_TExprDef._hx_class = hxsl_TExprDef
_hx_classes["hxsl.TExprDef"] = hxsl_TExprDef


class hxsl_Tools:
    _hx_class_name = "hxsl.Tools"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["UID", "SWIZ", "MAX_CHANNELS_BITS", "allocVarId", "getName", "getConstBits", "isConst", "isStruct", "isArray", "hasQualifier", "isSampler", "toString", "toType", "hasSideEffect", "iter", "map", "size", "evalConst"]

    @staticmethod
    def allocVarId():
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = hxsl_Tools
                _hx_local_1 = _hx_local_0.UID
                _hx_local_0.UID = (_hx_local_1 + 1)
                return _hx_local_0.UID
            return _hx_local_2()
        return _hx_local_3()

    @staticmethod
    def getName(v):
        if (Reflect.field(v,"qualifiers") is None):
            return v.name
        _g = 0
        _g1 = Reflect.field(v,"qualifiers")
        while (_g < len(_g1)):
            q = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (q.index == 4):
                n = q.params[0]
                return n
        return v.name

    @staticmethod
    def getConstBits(v):
        _g = v.type
        tmp = _g.index
        if (tmp == 1):
            _g1 = 0
            _g11 = Reflect.field(v,"qualifiers")
            while (_g1 < len(_g11)):
                q = (_g11[_g1] if _g1 >= 0 and _g1 < len(_g11) else None)
                _g1 = (_g1 + 1)
                if (q.index == 0):
                    n = q.params[0]
                    if (n is not None):
                        bits = 0
                        while (n >= ((1 << bits))):
                            bits = (bits + 1)
                        return bits
                    return 8
        elif (tmp == 2):
            return 1
        elif (tmp == 17):
            _g12 = _g.params[0]
            return (3 + hxsl_Tools.MAX_CHANNELS_BITS)
        else:
            pass
        return 0

    @staticmethod
    def isConst(v):
        _g = v.type
        tmp = None
        if (_g.index == 17):
            _g1 = _g.params[0]
            tmp = True
        else:
            tmp = False
        if tmp:
            return True
        if (Reflect.field(v,"qualifiers") is not None):
            _g2 = 0
            _g3 = Reflect.field(v,"qualifiers")
            while (_g2 < len(_g3)):
                q = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
                _g2 = (_g2 + 1)
                if (q.index == 0):
                    _g21 = q.params[0]
                    return True
        return False

    @staticmethod
    def isStruct(v):
        _g = v.type
        if (_g.index == 13):
            _g1 = _g.params[0]
            return True
        else:
            return False

    @staticmethod
    def isArray(v):
        _g = v.type
        if (_g.index == 15):
            _g2 = _g.params[1]
            _g1 = _g.params[0]
            return True
        else:
            return False

    @staticmethod
    def hasQualifier(v,q):
        if (Reflect.field(v,"qualifiers") is not None):
            _g = 0
            _g1 = Reflect.field(v,"qualifiers")
            while (_g < len(_g1)):
                q2 = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (q2 == q):
                    return True
        return False

    @staticmethod
    def isSampler(t):
        tmp = t.index
        if (((tmp == 12) or ((tmp == 11))) or ((tmp == 10))):
            return True
        elif (tmp == 17):
            _g = t.params[0]
            return True
        else:
            return False

    @staticmethod
    def toString(t):
        tmp = t.index
        if (tmp == 5):
            t1 = t.params[1]
            size = t.params[0]
            prefix = None
            prefix1 = t1.index
            if (prefix1 == 0):
                prefix = "I"
            elif (prefix1 == 1):
                prefix = ""
            elif (prefix1 == 2):
                prefix = "B"
            else:
                pass
            return ((("null" if prefix is None else prefix) + "Vec") + Std.string(size))
        elif (tmp == 9):
            n = t.params[0]
            return ("Bytes" + Std.string(n))
        elif (tmp == 13):
            vl = t.params[0]
            _g = []
            _g1 = 0
            while (_g1 < len(vl)):
                v = (vl[_g1] if _g1 >= 0 and _g1 < len(vl) else None)
                _g1 = (_g1 + 1)
                x = ((HxOverrides.stringOrNull(v.name) + " : ") + HxOverrides.stringOrNull(hxsl_Tools.toString(v.type)))
                _g.append(x)
            return (("{" + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in _g]))) + "}")
        elif (tmp == 15):
            s = t.params[1]
            t2 = t.params[0]
            tmp1 = (HxOverrides.stringOrNull(hxsl_Tools.toString(t2)) + "[")
            tmp2 = None
            tmp3 = s.index
            if (tmp3 == 0):
                i = s.params[0]
                tmp2 = ("" + Std.string(i))
            elif (tmp3 == 1):
                v1 = s.params[0]
                tmp2 = v1.name
            else:
                pass
            return ((("null" if tmp1 is None else tmp1) + ("null" if tmp2 is None else tmp2)) + "]")
        elif (tmp == 16):
            s1 = t.params[1]
            t3 = t.params[0]
            tmp4 = (("buffer " + HxOverrides.stringOrNull(hxsl_Tools.toString(t3))) + "[")
            tmp5 = None
            tmp6 = s1.index
            if (tmp6 == 0):
                i1 = s1.params[0]
                tmp5 = ("" + Std.string(i1))
            elif (tmp6 == 1):
                v2 = s1.params[0]
                tmp5 = v2.name
            else:
                pass
            return ((("null" if tmp4 is None else tmp4) + ("null" if tmp5 is None else tmp5)) + "]")
        else:
            return HxString.substr(t.tag,1,None)

    @staticmethod
    def toType(t):
        tmp = t.index
        if (tmp == 0):
            return hxsl_Type.TInt
        elif (tmp == 1):
            return hxsl_Type.TFloat
        elif (tmp == 2):
            return hxsl_Type.TBool
        else:
            pass

    @staticmethod
    def hasSideEffect(e):
        _g = e.e
        tmp = _g.index
        if (tmp == 0):
            _g27 = _g.params[0]
            return False
        elif (tmp == 1):
            _g9 = _g.params[0]
            return False
        elif (tmp == 2):
            _g5 = _g.params[0]
            return False
        elif (tmp == 3):
            e1 = _g.params[0]
            return hxsl_Tools.hasSideEffect(e1)
        elif (tmp == 4):
            el = _g.params[0]
            _g1 = 0
            while (_g1 < len(el)):
                e2 = (el[_g1] if _g1 >= 0 and _g1 < len(el) else None)
                _g1 = (_g1 + 1)
                if hxsl_Tools.hasSideEffect(e2):
                    return True
            return False
        elif (tmp == 5):
            _g33 = _g.params[2]
            _g32 = _g.params[1]
            _g31 = _g.params[0]
            tmp1 = _g31.index
            if (tmp1 == 4):
                return True
            elif (tmp1 == 20):
                _g34 = _g31.params[0]
                return True
            else:
                e21 = _g33
                e11 = _g32
                if (not hxsl_Tools.hasSideEffect(e11)):
                    return hxsl_Tools.hasSideEffect(e21)
                else:
                    return True
        elif (tmp == 6):
            _g17 = _g.params[0]
            e12 = _g.params[1]
            return hxsl_Tools.hasSideEffect(e12)
        elif (tmp == 7):
            _g25 = _g.params[1]
            _g24 = _g.params[0]
            return True
        elif (tmp == 8):
            _g36 = _g.params[1]
            _g35 = _g.params[0]
            return True
        elif (tmp == 9):
            _g20 = _g.params[1]
            e3 = _g.params[0]
            return hxsl_Tools.hasSideEffect(e3)
        elif (tmp == 10):
            eelse = _g.params[2]
            eif = _g.params[1]
            econd = _g.params[0]
            if (not ((hxsl_Tools.hasSideEffect(econd) or hxsl_Tools.hasSideEffect(eif)))):
                if (eelse is not None):
                    return hxsl_Tools.hasSideEffect(eelse)
                else:
                    return False
            else:
                return True
        elif (tmp == 12):
            _g13 = _g.params[0]
            return True
        elif (tmp == 13):
            _g21 = _g.params[0]
            loop = _g.params[2]
            it = _g.params[1]
            if (not hxsl_Tools.hasSideEffect(it)):
                return hxsl_Tools.hasSideEffect(loop)
            else:
                return True
        elif (((tmp == 15) or ((tmp == 14))) or ((tmp == 11))):
            return True
        elif (tmp == 16):
            index = _g.params[1]
            e4 = _g.params[0]
            if (not hxsl_Tools.hasSideEffect(e4)):
                return hxsl_Tools.hasSideEffect(index)
            else:
                return True
        elif (tmp == 17):
            el1 = _g.params[0]
            _g2 = 0
            while (_g2 < len(el1)):
                e5 = (el1[_g2] if _g2 >= 0 and _g2 < len(el1) else None)
                _g2 = (_g2 + 1)
                if hxsl_Tools.hasSideEffect(e5):
                    return True
            return False
        elif (tmp == 18):
            _hx_def = _g.params[2]
            cases = _g.params[1]
            e6 = _g.params[0]
            _g3 = 0
            while (_g3 < len(cases)):
                c = (cases[_g3] if _g3 >= 0 and _g3 < len(cases) else None)
                _g3 = (_g3 + 1)
                _g4 = 0
                _g11 = c.values
                while (_g4 < len(_g11)):
                    v = (_g11[_g4] if _g4 >= 0 and _g4 < len(_g11) else None)
                    _g4 = (_g4 + 1)
                    if hxsl_Tools.hasSideEffect(v):
                        return True
                if hxsl_Tools.hasSideEffect(c.expr):
                    return True
            if (not hxsl_Tools.hasSideEffect(e6)):
                if (_hx_def is not None):
                    return hxsl_Tools.hasSideEffect(_hx_def)
                else:
                    return False
            else:
                return True
        elif (tmp == 19):
            _g12 = _g.params[2]
            loop1 = _g.params[1]
            e7 = _g.params[0]
            if (not hxsl_Tools.hasSideEffect(e7)):
                return hxsl_Tools.hasSideEffect(loop1)
            else:
                return True
        elif (tmp == 20):
            _g7 = _g.params[1]
            _g6 = _g.params[0]
            e8 = _g.params[2]
            return hxsl_Tools.hasSideEffect(e8)
        else:
            pass

    @staticmethod
    def iter(e,f):
        _g = e.e
        tmp = _g.index
        if (tmp == 0):
            _g27 = _g.params[0]
        elif (tmp == 1):
            _g9 = _g.params[0]
        elif (tmp == 2):
            _g5 = _g.params[0]
        elif (tmp == 3):
            e1 = _g.params[0]
            f(e1)
        elif (tmp == 4):
            el = _g.params[0]
            _g1 = 0
            while (_g1 < len(el)):
                e2 = (el[_g1] if _g1 >= 0 and _g1 < len(el) else None)
                _g1 = (_g1 + 1)
                f(e2)
        elif (tmp == 5):
            _g31 = _g.params[0]
            e21 = _g.params[2]
            e11 = _g.params[1]
            f(e11)
            f(e21)
        elif (tmp == 6):
            _g17 = _g.params[0]
            e12 = _g.params[1]
            f(e12)
        elif (tmp == 7):
            _g24 = _g.params[0]
            init = _g.params[1]
            if (init is not None):
                f(init)
        elif (tmp == 8):
            args = _g.params[1]
            e3 = _g.params[0]
            f(e3)
            _g2 = 0
            while (_g2 < len(args)):
                a = (args[_g2] if _g2 >= 0 and _g2 < len(args) else None)
                _g2 = (_g2 + 1)
                f(a)
        elif (tmp == 9):
            _g20 = _g.params[1]
            e4 = _g.params[0]
            f(e4)
        elif (tmp == 10):
            eelse = _g.params[2]
            eif = _g.params[1]
            econd = _g.params[0]
            f(econd)
            f(eif)
            if (eelse is not None):
                f(eelse)
        elif (tmp == 12):
            e5 = _g.params[0]
            if (e5 is not None):
                f(e5)
        elif (tmp == 13):
            _g21 = _g.params[0]
            loop = _g.params[2]
            it = _g.params[1]
            f(it)
            f(loop)
        elif (((tmp == 15) or ((tmp == 14))) or ((tmp == 11))):
            pass
        elif (tmp == 16):
            index = _g.params[1]
            e6 = _g.params[0]
            f(e6)
            f(index)
        elif (tmp == 17):
            el1 = _g.params[0]
            _g3 = 0
            while (_g3 < len(el1)):
                e7 = (el1[_g3] if _g3 >= 0 and _g3 < len(el1) else None)
                _g3 = (_g3 + 1)
                f(e7)
        elif (tmp == 18):
            _hx_def = _g.params[2]
            cases = _g.params[1]
            e8 = _g.params[0]
            f(e8)
            _g4 = 0
            while (_g4 < len(cases)):
                c = (cases[_g4] if _g4 >= 0 and _g4 < len(cases) else None)
                _g4 = (_g4 + 1)
                _g6 = 0
                _g11 = c.values
                while (_g6 < len(_g11)):
                    v = (_g11[_g6] if _g6 >= 0 and _g6 < len(_g11) else None)
                    _g6 = (_g6 + 1)
                    f(v)
                f(c.expr)
            if (_hx_def is not None):
                f(_hx_def)
        elif (tmp == 19):
            _g12 = _g.params[2]
            loop1 = _g.params[1]
            e9 = _g.params[0]
            f(e9)
            f(loop1)
        elif (tmp == 20):
            _g7 = _g.params[1]
            _g61 = _g.params[0]
            e10 = _g.params[2]
            f(e10)
        else:
            pass

    @staticmethod
    def map(e,f):
        ed = None
        _g = e.e
        ed1 = _g.index
        if (ed1 == 0):
            _g27 = _g.params[0]
            ed = e.e
        elif (ed1 == 1):
            _g9 = _g.params[0]
            ed = e.e
        elif (ed1 == 2):
            _g5 = _g.params[0]
            ed = e.e
        elif (ed1 == 3):
            e1 = _g.params[0]
            ed = hxsl_TExprDef.TParenthesis(f(e1))
        elif (ed1 == 4):
            el = _g.params[0]
            _g1 = []
            _g11 = 0
            while (_g11 < len(el)):
                e2 = (el[_g11] if _g11 >= 0 and _g11 < len(el) else None)
                _g11 = (_g11 + 1)
                x = f(e2)
                _g1.append(x)
            ed = hxsl_TExprDef.TBlock(_g1)
        elif (ed1 == 5):
            e21 = _g.params[2]
            e11 = _g.params[1]
            op = _g.params[0]
            ed = hxsl_TExprDef.TBinop(op,f(e11),f(e21))
        elif (ed1 == 6):
            e12 = _g.params[1]
            op1 = _g.params[0]
            ed = hxsl_TExprDef.TUnop(op1,f(e12))
        elif (ed1 == 7):
            init = _g.params[1]
            v = _g.params[0]
            ed = hxsl_TExprDef.TVarDecl(v,(f(init) if ((init is not None)) else None))
        elif (ed1 == 8):
            args = _g.params[1]
            e3 = _g.params[0]
            ed2 = f(e3)
            _g2 = []
            _g12 = 0
            while (_g12 < len(args)):
                a = (args[_g12] if _g12 >= 0 and _g12 < len(args) else None)
                _g12 = (_g12 + 1)
                x1 = f(a)
                _g2.append(x1)
            ed = hxsl_TExprDef.TCall(ed2,_g2)
        elif (ed1 == 9):
            c = _g.params[1]
            e4 = _g.params[0]
            ed = hxsl_TExprDef.TSwiz(f(e4),c)
        elif (ed1 == 10):
            eelse = _g.params[2]
            eif = _g.params[1]
            econd = _g.params[0]
            ed = hxsl_TExprDef.TIf(f(econd),f(eif),(f(eelse) if ((eelse is not None)) else None))
        elif (ed1 == 12):
            e5 = _g.params[0]
            ed = hxsl_TExprDef.TReturn((f(e5) if ((e5 is not None)) else None))
        elif (ed1 == 13):
            loop = _g.params[2]
            it = _g.params[1]
            v1 = _g.params[0]
            ed = hxsl_TExprDef.TFor(v1,f(it),f(loop))
        elif (((ed1 == 15) or ((ed1 == 14))) or ((ed1 == 11))):
            ed = e.e
        elif (ed1 == 16):
            index = _g.params[1]
            e6 = _g.params[0]
            ed = hxsl_TExprDef.TArray(f(e6),f(index))
        elif (ed1 == 17):
            el1 = _g.params[0]
            _g3 = []
            _g13 = 0
            while (_g13 < len(el1)):
                e7 = (el1[_g13] if _g13 >= 0 and _g13 < len(el1) else None)
                _g13 = (_g13 + 1)
                x2 = f(e7)
                _g3.append(x2)
            ed = hxsl_TExprDef.TArrayDecl(_g3)
        elif (ed1 == 18):
            _hx_def = _g.params[2]
            cases = _g.params[1]
            e8 = _g.params[0]
            ed3 = f(e8)
            _g4 = []
            _g14 = 0
            while (_g14 < len(cases)):
                c1 = (cases[_g14] if _g14 >= 0 and _g14 < len(cases) else None)
                _g14 = (_g14 + 1)
                _g15 = []
                _g21 = 0
                _g31 = c1.values
                while (_g21 < len(_g31)):
                    v2 = (_g31[_g21] if _g21 >= 0 and _g21 < len(_g31) else None)
                    _g21 = (_g21 + 1)
                    x3 = f(v2)
                    _g15.append(x3)
                x4 = _hx_AnonObject({'values': _g15, 'expr': f(c1.expr)})
                _g4.append(x4)
            ed = hxsl_TExprDef.TSwitch(ed3,_g4,(None if ((_hx_def is None)) else f(_hx_def)))
        elif (ed1 == 19):
            normalWhile = _g.params[2]
            loop1 = _g.params[1]
            e9 = _g.params[0]
            ed = hxsl_TExprDef.TWhile(f(e9),f(loop1),normalWhile)
        elif (ed1 == 20):
            e10 = _g.params[2]
            args1 = _g.params[1]
            m = _g.params[0]
            ed = hxsl_TExprDef.TMeta(m,args1,f(e10))
        else:
            pass
        return _hx_AnonObject({'e': ed, 't': e.t, 'p': e.p})

    @staticmethod
    def size(t):
        tmp = t.index
        if (tmp == 0):
            return 0
        elif ((tmp == 3) or ((tmp == 1))):
            return 1
        elif (((((tmp == 12) or ((tmp == 11))) or ((tmp == 10))) or ((tmp == 4))) or ((tmp == 2))):
            return 0
        elif (tmp == 5):
            _g1 = t.params[1]
            n = t.params[0]
            return n
        elif (tmp == 6):
            return 9
        elif (tmp == 7):
            return 16
        elif (tmp == 8):
            return 12
        elif (tmp == 9):
            s = t.params[0]
            return s
        elif (tmp == 13):
            vl = t.params[0]
            s1 = 0
            _g = 0
            while (_g < len(vl)):
                v = (vl[_g] if _g >= 0 and _g < len(vl) else None)
                _g = (_g + 1)
                s1 = (s1 + hxsl_Tools.size(v.type))
            return s1
        elif (tmp == 14):
            _g8 = t.params[0]
            return 0
        elif (tmp == 15):
            _g10 = t.params[1]
            _g9 = t.params[0]
            tmp1 = _g10.index
            if (tmp1 == 0):
                t1 = _g9
                v1 = _g10.params[0]
                return (hxsl_Tools.size(t1) * v1)
            elif (tmp1 == 1):
                _g11 = _g10.params[0]
                return 0
            else:
                pass
        elif (tmp == 16):
            _g5 = t.params[1]
            if (_g5.index == 0):
                t2 = t.params[0]
                v2 = _g5.params[0]
                return (hxsl_Tools.size(t2) * v2)
            else:
                return 0
        elif (tmp == 17):
            n1 = t.params[0]
            return n1
        else:
            pass

    @staticmethod
    def evalConst(e):
        _g = e.e
        tmp = _g.index
        if (tmp == 0):
            c = _g.params[0]
            tmp1 = c.index
            if (tmp1 == 0):
                return None
            elif (tmp1 == 1):
                b = c.params[0]
                return b
            elif (tmp1 == 2):
                i = c.params[0]
                return i
            elif (tmp1 == 3):
                f = c.params[0]
                return f
            elif (tmp1 == 4):
                s = c.params[0]
                return s
            else:
                pass
        elif (tmp == 8):
            _g3 = _g.params[1]
            _g2 = _g.params[0]
            _g6 = _g2.t
            _g5 = _g2.p
            _g4 = _g2.e
            if (_g4.index == 2):
                tmp2 = _g4.params[0].index
                if (((tmp2 == 42) or ((tmp2 == 41))) or ((tmp2 == 40))):
                    args = _g3
                    _g1 = []
                    _g11 = 0
                    while (_g11 < len(args)):
                        a = (args[_g11] if _g11 >= 0 and _g11 < len(args) else None)
                        _g11 = (_g11 + 1)
                        x = hxsl_Tools.evalConst(a)
                        _g1.append(x)
                    vals = _g1
                    if (len(vals) == 1):
                        return h3d_Vector((vals[0] if 0 < len(vals) else None),(vals[0] if 0 < len(vals) else None),(vals[0] if 0 < len(vals) else None),(vals[0] if 0 < len(vals) else None))
                    return h3d_Vector((vals[0] if 0 < len(vals) else None),(vals[1] if 1 < len(vals) else None),(vals[2] if 2 < len(vals) else None),(vals[3] if 3 < len(vals) else None))
                else:
                    raise _HxException(("Unhandled constant init " + HxOverrides.stringOrNull(hxsl_Printer.toString(e))))
            else:
                raise _HxException(("Unhandled constant init " + HxOverrides.stringOrNull(hxsl_Printer.toString(e))))
        else:
            raise _HxException(("Unhandled constant init " + HxOverrides.stringOrNull(hxsl_Printer.toString(e))))
hxsl_Tools._hx_class = hxsl_Tools
_hx_classes["hxsl.Tools"] = hxsl_Tools


class hxsl_Tools2:
    _hx_class_name = "hxsl.Tools2"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["toString"]

    @staticmethod
    def toString(g):
        n = g.tag
        return (HxOverrides.stringOrNull(("" if ((0 >= len(n))) else n[0]).lower()) + HxOverrides.stringOrNull(HxString.substr(n,1,None)))
hxsl_Tools2._hx_class = hxsl_Tools2
_hx_classes["hxsl.Tools2"] = hxsl_Tools2


class hxsl_Tools3:
    _hx_class_name = "hxsl.Tools3"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["toString"]

    @staticmethod
    def toString(s):
        return hxsl_Printer.shaderToString(s)
hxsl_Tools3._hx_class = hxsl_Tools3
_hx_classes["hxsl.Tools3"] = hxsl_Tools3


class hxsl_Tools4:
    _hx_class_name = "hxsl.Tools4"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["toString"]

    @staticmethod
    def toString(e):
        return hxsl_Printer.toString(e)
hxsl_Tools4._hx_class = hxsl_Tools4
_hx_classes["hxsl.Tools4"] = hxsl_Tools4


class hxsl_BatchShader(hxsl_Shader):
    _hx_class_name = "hxsl.BatchShader"
    _hx_is_interface = "False"
    __slots__ = ("Batch_Count__", "Batch_Buffer__")
    _hx_fields = ["Batch_Count__", "Batch_Buffer__"]
    _hx_methods = ["get_Batch_Count", "set_Batch_Count", "get_Batch_Buffer", "set_Batch_Buffer", "updateConstants", "getParamValue", "getParamFloatValue", "clone"]
    _hx_statics = ["SRC", "_SHADER"]
    _hx_interfaces = []
    _hx_super = hxsl_Shader


    def __init__(self):
        self.Batch_Buffer__ = None
        self.Batch_Count__ = 0
        super().__init__()

    def get_Batch_Count(self):
        return self.Batch_Count__

    def set_Batch_Count(self,_v):
        self.constModified = True
        def _hx_local_1():
            def _hx_local_0():
                self.Batch_Count__ = _v
                return self.Batch_Count__
            return _hx_local_0()
        return _hx_local_1()

    def get_Batch_Buffer(self):
        return self.Batch_Buffer__

    def set_Batch_Buffer(self,_v):
        def _hx_local_1():
            def _hx_local_0():
                self.Batch_Buffer__ = _v
                return self.Batch_Buffer__
            return _hx_local_0()
        return _hx_local_1()

    def updateConstants(self,globals):
        self.constBits = 0
        v = self.Batch_Count__
        if (HxOverrides.rshift(v, 17) != 0):
            raise _HxException((((("Batch_Count" + " is out of range ") + Std.string(v)) + ">") + Std.string(131071)))
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.constBits
        _hx_local_0.constBits = (_hx_local_1 | v)
        _hx_local_0.constBits
        self.updateConstantsFinal(globals)

    def getParamValue(self,index):
        index1 = index
        if (index1 == 0):
            return self.Batch_Count__
        elif (index1 == 1):
            return self.Batch_Buffer__
        else:
            pass
        return None

    def getParamFloatValue(self,index):
        return 0.

    def clone(self):
        s = Type.createEmptyInstance(hxsl_BatchShader)
        s.shader = self.shader
        s.Batch_Count__ = self.Batch_Count__
        s.Batch_Buffer__ = self.Batch_Buffer__
        return s
    _SHADER = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.Batch_Count__ = None
        _hx_o.Batch_Buffer__ = None
hxsl_BatchShader._hx_class = hxsl_BatchShader
_hx_classes["hxsl.BatchShader"] = hxsl_BatchShader


class hxsl_SearchMap:
    _hx_class_name = "hxsl.SearchMap"
    _hx_is_interface = "False"
    __slots__ = ("linked", "next")
    _hx_fields = ["linked", "next"]

    def __init__(self):
        self.next = None
        self.linked = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.linked = None
        _hx_o.next = None
hxsl_SearchMap._hx_class = hxsl_SearchMap
_hx_classes["hxsl.SearchMap"] = hxsl_SearchMap


class hxsl_Cache:
    _hx_class_name = "hxsl.Cache"
    _hx_is_interface = "False"
    __slots__ = ("linkCache", "linkShaders", "batchShaders", "byID", "constsToGlobal")
    _hx_fields = ["linkCache", "linkShaders", "batchShaders", "byID", "constsToGlobal"]
    _hx_methods = ["getLinkShader", "link", "compileRuntimeShader", "buildRuntimeShader", "initGlobals", "getPath", "flattenShader", "makeBatchShader", "createBatchShader"]
    _hx_statics = ["INST", "get", "set", "clear"]

    def __init__(self):
        self.constsToGlobal = False
        self.linkCache = hxsl_SearchMap()
        self.linkShaders = haxe_ds_StringMap()
        self.batchShaders = haxe_ds_IntMap()
        self.byID = haxe_ds_StringMap()

    def getLinkShader(self,vars):
        _g = []
        _g1 = 0
        while (_g1 < len(vars)):
            v = (vars[_g1] if _g1 >= 0 and _g1 < len(vars) else None)
            _g1 = (_g1 + 1)
            x = Std.string(v)
            _g.append(x)
        key = ",".join([python_Boot.toString1(x1,'') for x1 in _g])
        shader = self.linkShaders.h.get(key,None)
        if (shader is not None):
            return shader
        s = hxsl_SharedShader("")
        id = HxString.substr(haxe_crypto_Md5.encode(key),0,8)
        s.data = _hx_AnonObject({'name': ("shaderLinker_" + ("null" if id is None else id)), 'vars': [], 'funs': []})
        pos = None
        outVars = haxe_ds_StringMap()
        outputCount = 0
        tvec4 = hxsl_Type.TVec(4,hxsl_VecType.VFloat)
        def _hx_local_2(g,size,args,makeOutExpr):
            out = []
            rem = size
            _g2 = 0
            _g3 = len(args)
            while (_g2 < _g3):
                i = _g2
                _g2 = (_g2 + 1)
                e = makeOutExpr(python_internal_ArrayImpl._get(args, ((len(args) - 1) - i)),(rem - (((len(args) - 1) - i))))
                rem = (rem - hxsl_Tools.size(e.t))
                out.insert(0, e)
            return _hx_AnonObject({'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(g), 't': hxsl_Type.TVoid, 'p': pos}),out), 't': hxsl_Type.TVec(size,hxsl_VecType.VFloat), 'p': pos})
        makeVec = _hx_local_2
        def _hx_local_3(name,t,parent):
            path = (name if ((parent is None)) else ((HxOverrides.stringOrNull(hxsl_Tools.getName(parent)) + ".") + ("null" if name is None else name)))
            v1 = outVars.h.get(path,None)
            if (v1 is not None):
                return v1
            v1 = _hx_AnonObject({'id': hxsl_Tools.allocVarId(), 'name': name, 'type': t, 'kind': hxsl_VarKind.Var, 'parent': parent})
            if (parent is None):
                _this = s.data.vars
                _this.append(v1)
            else:
                _g21 = parent.type
                if (_g21.index == 13):
                    vl = _g21.params[0]
                    vl.append(v1)
                else:
                    raise _HxException("assert")
            outVars.h[path] = v1
            return v1
        makeVar = _hx_local_3
        makeOutExpr1 = None
        def _hx_local_4(v2,rem1):
            makeOutExpr2 = v2.index
            if (makeOutExpr2 == 0):
                v3 = v2.params[0]
                return _hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CFloat(v3)), 't': hxsl_Type.TFloat, 'p': pos})
            elif (makeOutExpr2 == 1):
                size1 = v2.params[1]
                vname = v2.params[0]
                v4 = outVars.h.get(vname,None)
                if (v4 is not None):
                    return _hx_AnonObject({'e': hxsl_TExprDef.TVar(v4), 't': v4.type, 'p': pos})
                path1 = vname.split(".")
                parent1 = None
                while (len(path1) > 1):
                    parent2 = (None if ((len(path1) == 0)) else path1.pop(0))
                    parent1 = makeVar(parent2,hxsl_Type.TStruct([]),parent1)
                if (size1 is not None):
                    rem1 = size1
                v5 = (None if ((len(path1) == 0)) else path1.pop(0))
                v4 = makeVar(v5,(hxsl_Type.TFloat if ((rem1 == 1)) else hxsl_Type.TVec(rem1,hxsl_VecType.VFloat)),parent1)
                return _hx_AnonObject({'e': hxsl_TExprDef.TVar(v4), 't': v4.type, 'p': pos})
            elif (makeOutExpr2 == 2):
                v6 = v2.params[0]
                return _hx_AnonObject({'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(hxsl_TGlobal.PackNormal), 't': hxsl_Type.TVoid, 'p': pos}),[makeOutExpr1(v6,3)]), 't': tvec4, 'p': pos})
            elif (makeOutExpr2 == 3):
                v7 = v2.params[0]
                return _hx_AnonObject({'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(hxsl_TGlobal.Pack), 't': hxsl_Type.TVoid, 'p': pos}),[makeOutExpr1(v7,1)]), 't': tvec4, 'p': pos})
            elif (makeOutExpr2 == 4):
                args1 = v2.params[0]
                return makeVec(hxsl_TGlobal.Vec2,2,args1,makeOutExpr1)
            elif (makeOutExpr2 == 5):
                args2 = v2.params[0]
                return makeVec(hxsl_TGlobal.Vec3,3,args2,makeOutExpr1)
            elif (makeOutExpr2 == 6):
                args3 = v2.params[0]
                return makeVec(hxsl_TGlobal.Vec4,4,args3,makeOutExpr1)
            elif (makeOutExpr2 == 7):
                comps = v2.params[1]
                v8 = v2.params[0]
                return _hx_AnonObject({'e': hxsl_TExprDef.TSwiz(makeOutExpr1(v8,4),comps), 't': hxsl_Type.TVec(len(comps),hxsl_VecType.VFloat), 'p': pos})
            else:
                pass
        makeOutExpr1 = _hx_local_4
        def _hx_local_6(v9):
            nonlocal outputCount
            outputCount = (outputCount + 1)
            ov = _hx_AnonObject({'id': hxsl_Tools.allocVarId(), 'type': tvec4, 'name': ("OUTPUT" + Std.string(((outputCount - 1)))), 'kind': hxsl_VarKind.Output})
            _this1 = s.data.vars
            _this1.append(ov)
            return _hx_AnonObject({'e': hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAssign,_hx_AnonObject({'e': hxsl_TExprDef.TVar(ov), 't': tvec4, 'p': pos}),makeOutExpr1(v9,4)), 't': hxsl_Type.TVoid, 'p': pos})
        makeOutput = _hx_local_6
        def _hx_local_8(kind,vars1):
            fv = _hx_AnonObject({'id': hxsl_Tools.allocVarId(), 'type': hxsl_Type.TFun([]), 'name': ("" + Std.string(kind)).lower(), 'kind': hxsl_VarKind.Function})
            _g22 = []
            _g31 = 0
            while (_g31 < len(vars1)):
                v10 = (vars1[_g31] if _g31 >= 0 and _g31 < len(vars1) else None)
                _g31 = (_g31 + 1)
                x1 = makeOutput(v10)
                _g22.append(x1)
            f = _hx_AnonObject({'kind': kind, 'ref': fv, 'args': [], 'ret': hxsl_Type.TVoid, 'expr': _hx_AnonObject({'e': hxsl_TExprDef.TBlock(_g22), 'p': pos, 't': hxsl_Type.TVoid})})
            _this2 = s.data.funs
            _this2.append(f)
        defineFun = _hx_local_8
        defineFun(hxsl_FunctionKind.Vertex,[hxsl_Output.Value("output.position")])
        defineFun(hxsl_FunctionKind.Fragment,vars)
        shader = Type.createEmptyInstance(hxsl_Shader)
        shader.shader = s
        self.linkShaders.h[key] = shader
        shader.updateConstantsFinal(None)
        return shader

    def link(self,shaders,batchMode):
        c = self.linkCache
        _g_l = shaders
        _g_last = None
        while (_g_l != _g_last):
            s = _g_l.s
            _g_l = _g_l.next
            s1 = s
            i = s1.instance
            if (c.next is None):
                c.next = haxe_ds_IntMap()
            cs = c.next.h.get(i.id,None)
            if (cs is None):
                cs = hxsl_SearchMap()
                c.next.set(i.id,cs)
            c = cs
        if (c.linked is None):
            c.linked = self.compileRuntimeShader(shaders,batchMode)
        return c.linked

    def compileRuntimeShader(self,shaders,batchMode):
        shaderDatas = []
        index = 0
        _g_l = shaders
        _g_last = None
        while (_g_l != _g_last):
            s = _g_l.s
            _g_l = _g_l.next
            s1 = s
            i = s1.instance
            x = index
            index = (index + 1)
            x1 = _hx_AnonObject({'inst': i, 'p': s1.priority, 'index': x})
            shaderDatas.append(x1)
        shaderDatas.reverse()
        def _hx_local_0(s11,s2):
            return (s2.p - s11.p)
        haxe_ds_ArraySort.sort(shaderDatas,_hx_local_0)
        linker = hxsl_Linker(batchMode)
        s3 = None
        try:
            _g1 = []
            _g2 = 0
            while (_g2 < len(shaderDatas)):
                s4 = (shaderDatas[_g2] if _g2 >= 0 and _g2 < len(shaderDatas) else None)
                _g2 = (_g2 + 1)
                x2 = s4.inst.shader
                _g1.append(x2)
            s3 = linker.link(_g1)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            if isinstance(_hx_e1, hxsl_Error):
                e = _hx_e1
                _g11 = []
                _g21 = 0
                while (_g21 < len(shaderDatas)):
                    s5 = (shaderDatas[_g21] if _g21 >= 0 and _g21 < len(shaderDatas) else None)
                    _g21 = (_g21 + 1)
                    x3 = hxsl_Printer.shaderToString(s5.inst.shader)
                    _g11.append(x3)
                shaders1 = _g11
                e.msg = (HxOverrides.stringOrNull(e.msg) + HxOverrides.stringOrNull((("\n\nin\n\n" + HxOverrides.stringOrNull("\n-----\n".join([python_Boot.toString1(x1,'') for x1 in shaders1]))))))
                raise _HxException(e)
            else:
                raise _hx_e
        paramVars = haxe_ds_IntMap()
        _g12 = 0
        _g22 = linker.allVars
        while (_g12 < len(_g22)):
            v = (_g22[_g12] if _g12 >= 0 and _g12 < len(_g22) else None)
            _g12 = (_g12 + 1)
            if (v.v.kind == hxsl_VarKind.Param):
                _g13 = v.v.type
                if (_g13.index == 13):
                    _g23 = _g13.params[0]
                    continue
                inf = python_internal_ArrayImpl._get(shaderDatas, v.instanceIndex)
                paramVars.set(v.id,_hx_AnonObject({'instance': inf.index, 'index': inf.inst.params.h.get((v.merged[0] if 0 < len(v.merged) else None).id,None)}))
        prev = s3
        s6 = None
        try:
            s6 = hxsl_Splitter().split(s3)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            if isinstance(_hx_e1, hxsl_Error):
                e1 = _hx_e1
                e1.msg = (HxOverrides.stringOrNull(e1.msg) + HxOverrides.stringOrNull((("\n\nin\n\n" + HxOverrides.stringOrNull(hxsl_Printer.shaderToString(s3))))))
                raise _HxException(e1)
            else:
                raise _hx_e
        if batchMode:
            _g3 = 0
            _g4 = s6.vertex.vars
            while (_g3 < len(_g4)):
                v1 = (_g4[_g3] if _g3 >= 0 and _g3 < len(_g4) else None)
                _g3 = (_g3 + 1)
                if ((Reflect.field(v1,"qualifiers") is not None) and ((python_internal_ArrayImpl.indexOf(Reflect.field(v1,"qualifiers"),hxsl_VarQualifier.PerObject,None) >= 0))):
                    v1.kind = hxsl_VarKind.Local
        prev1 = s6
        s7 = hxsl_Dce().dce(s6.vertex,s6.fragment)
        r = self.buildRuntimeShader(s7.vertex,s7.fragment,paramVars)
        _g31 = []
        _g4_l = shaders
        _g4_last = None
        while (_g4_l != _g4_last):
            s8 = _g4_l.s
            _g4_l = _g4_l.next
            s9 = s8
            x4 = hxsl_ShaderInstanceDesc(s9.shader,s9.constBits)
            _g31.append(x4)
        r.spec = _hx_AnonObject({'instances': _g31, 'signature': None})
        _g5 = 0
        _g6 = len(shaderDatas)
        while (_g5 < _g6):
            i1 = _g5
            _g5 = (_g5 + 1)
            s10 = python_internal_ArrayImpl._get(shaderDatas, ((len(shaderDatas) - 1) - i1))
            python_internal_ArrayImpl._get(r.spec.instances, s10.index).index = i1
        _g7 = []
        _g8 = 0
        _g9 = r.spec.instances
        while (_g8 < len(_g9)):
            i2 = (_g9[_g8] if _g8 >= 0 and _g8 < len(_g9) else None)
            _g8 = (_g8 + 1)
            x5 = ((((HxOverrides.stringOrNull(i2.shader.data.name) + "_") + Std.string(i2.bits)) + "_") + Std.string(i2.index))
            _g7.append(x5)
        signParts = _g7
        tmp = ":".join
        tmp1 = [python_Boot.toString1(x1,'') for x1 in signParts]
        r.spec.signature = haxe_crypto_Md5.encode(tmp(tmp1))
        r.signature = haxe_crypto_Md5.encode((HxOverrides.stringOrNull(hxsl_Printer.shaderToString(r.vertex.data)) + HxOverrides.stringOrNull(hxsl_Printer.shaderToString(r.fragment.data))))
        r.batchMode = batchMode
        r2 = self.byID.h.get(r.signature,None)
        if (r2 is not None):
            r.id = r2.id
        else:
            self.byID.h[r.signature] = r
        return r

    def buildRuntimeShader(self,vertex,fragment,paramVars):
        r = hxsl_RuntimeShader()
        r.vertex = self.flattenShader(vertex,hxsl_FunctionKind.Vertex,paramVars)
        r.vertex.vertex = True
        r.fragment = self.flattenShader(fragment,hxsl_FunctionKind.Fragment,paramVars)
        r.globals = haxe_ds_IntMap()
        self.initGlobals(r,r.vertex)
        self.initGlobals(r,r.fragment)
        return r

    def initGlobals(self,r,s):
        p = s.globals
        while (p is not None):
            r.globals.set(p.gid,True)
            p = p.next
        p1 = s.params
        while (p1 is not None):
            if (p1.perObjectGlobal is not None):
                r.globals.set(p1.perObjectGlobal.gid,True)
            p1 = p1.next

    def getPath(self,v):
        if (Reflect.field(v,"parent") is None):
            return v.name
        return ((HxOverrides.stringOrNull(self.getPath(Reflect.field(v,"parent"))) + ".") + HxOverrides.stringOrNull(v.name))

    def flattenShader(self,s,kind,params):
        flat = hxsl_Flatten()
        c = hxsl_RuntimeShaderData()
        data = flat.flatten(s,kind,self.constsToGlobal)
        textures = []
        c.consts = flat.consts
        c.texturesCount = 0
        g = flat.allocData.keys()
        while g.hasNext():
            g1 = g.next()
            alloc = flat.allocData.h.get(g1,None)
            tmp = g1.kind.index
            if (tmp == 0):
                _g = []
                _g1 = 0
                while (_g1 < len(alloc)):
                    a = (alloc[_g1] if _g1 >= 0 and _g1 < len(alloc) else None)
                    _g1 = (_g1 + 1)
                    if (a.v is not None):
                        x = hxsl_AllocGlobal(a.pos,self.getPath(a.v),a.v.type)
                        _g.append(x)
                out = _g
                _g2 = 0
                _g3 = (len(out) - 1)
                while (_g2 < _g3):
                    i = _g2
                    _g2 = (_g2 + 1)
                    (out[i] if i >= 0 and i < len(out) else None).next = python_internal_ArrayImpl._get(out, (i + 1))
                _g4 = g1.type
                if (_g4.index == 15):
                    _g6 = _g4.params[1]
                    _g5 = _g4.params[0]
                    if (_g5.index == 5):
                        if (_g5.params[0] == 4):
                            if (_g5.params[1].index == 1):
                                if (_g6.index == 0):
                                    size = _g6.params[0]
                                    c.globals = (out[0] if 0 < len(out) else None)
                                    c.globalsSize = size
                                else:
                                    raise _HxException("assert")
                            else:
                                raise _HxException("assert")
                        else:
                            raise _HxException("assert")
                    else:
                        raise _HxException("assert")
                else:
                    raise _HxException("assert")
            elif (tmp == 2):
                out1 = []
                _g7 = 0
                while (_g7 < len(alloc)):
                    a1 = (alloc[_g7] if _g7 >= 0 and _g7 < len(alloc) else None)
                    _g7 = (_g7 + 1)
                    if (a1.v is None):
                        continue
                    p = params.h.get(a1.v.id,None)
                    if (p is None):
                        ap = hxsl_AllocParam(a1.v.name,a1.pos,-1,-1,a1.v.type)
                        ap.perObjectGlobal = hxsl_AllocGlobal(-1,self.getPath(a1.v),a1.v.type)
                        out1.append(ap)
                        continue
                    x1 = hxsl_AllocParam(a1.v.name,a1.pos,p.instance,p.index,a1.v.type)
                    out1.append(x1)
                _g11 = 0
                _g21 = (len(out1) - 1)
                while (_g11 < _g21):
                    i1 = _g11
                    _g11 = (_g11 + 1)
                    (out1[i1] if i1 >= 0 and i1 < len(out1) else None).next = python_internal_ArrayImpl._get(out1, (i1 + 1))
                _g31 = g1.type
                if (_g31.index == 15):
                    _g51 = _g31.params[1]
                    _g41 = _g31.params[0]
                    t = _g41
                    if hxsl_Tools.isSampler(t):
                        textures.append(_hx_AnonObject({'t': t, 'all': out1}))
                        c.texturesCount = (c.texturesCount + len(out1))
                    else:
                        tmp1 = _g41.index
                        if (tmp1 == 5):
                            if (_g41.params[0] == 4):
                                if (_g41.params[1].index == 1):
                                    if (_g51.index == 0):
                                        size1 = _g51.params[0]
                                        c.params = (out1[0] if 0 < len(out1) else None)
                                        c.paramsSize = size1
                                    else:
                                        raise _HxException("assert")
                                else:
                                    raise _HxException("assert")
                            else:
                                raise _HxException("assert")
                        elif (tmp1 == 16):
                            _g10 = _g41.params[1]
                            _g9 = _g41.params[0]
                            c.buffers = (out1[0] if 0 < len(out1) else None)
                            c.bufferCount = len(out1)
                        else:
                            raise _HxException("assert")
                else:
                    raise _HxException("assert")
            else:
                raise _HxException("assert")
        if (len(textures) > 0):
            def _hx_local_3(t1,t2):
                return (t1.t.index - t2.t.index)
            textures.sort(key= python_lib_Functools.cmp_to_key(_hx_local_3))
            c.textures = python_internal_ArrayImpl._get((textures[0] if 0 < len(textures) else None).all, 0)
            _g8 = 1
            _g12 = len(textures)
            while (_g8 < _g12):
                i2 = _g8
                _g8 = (_g8 + 1)
                prevAll = python_internal_ArrayImpl._get(textures, (i2 - 1)).all
                prev = python_internal_ArrayImpl._get(prevAll, (len(prevAll) - 1))
                prev.next = python_internal_ArrayImpl._get((textures[i2] if i2 >= 0 and i2 < len(textures) else None).all, 0)
        if (c.globals is None):
            c.globalsSize = 0
        if (c.params is None):
            c.paramsSize = 0
        if (c.buffers is None):
            c.bufferCount = 0
        c.data = data
        return c

    def makeBatchShader(self,rt):
        sh = self.batchShaders.h.get(rt.id,None)
        if (sh is None):
            sh = self.createBatchShader(rt)
            self.batchShaders.set(rt.id,sh)
        shader = Type.createEmptyInstance(hxsl_BatchShader)
        shader.shader = sh
        return shader

    def createBatchShader(self,rt):
        s = hxsl_SharedShader("")
        id = HxString.substr(rt.spec.signature,0,8)
        def _hx_local_0(name,t,kind):
            return _hx_AnonObject({'id': hxsl_Tools.allocVarId(), 'type': t, 'name': name, 'kind': kind})
        declVar = _hx_local_0
        pos = None
        vcount = declVar("Batch_Count",hxsl_Type.TInt,hxsl_VarKind.Param)
        vbuffer = declVar("Batch_Buffer",hxsl_Type.TBuffer(hxsl_Type.TVec(4,hxsl_VecType.VFloat),hxsl_SizeDecl.SVar(vcount)),hxsl_VarKind.Param)
        voffset = declVar("Batch_Offset",hxsl_Type.TInt,hxsl_VarKind.Local)
        ebuffer = _hx_AnonObject({'e': hxsl_TExprDef.TVar(vbuffer), 'p': pos, 't': vbuffer.type})
        eoffset = _hx_AnonObject({'e': hxsl_TExprDef.TVar(voffset), 'p': pos, 't': voffset.type})
        tvec4 = hxsl_Type.TVec(4,hxsl_VecType.VFloat)
        countBits = 16
        Reflect.setField(vcount,"qualifiers",[hxsl_VarQualifier.Const((1 << countBits))])
        s.data = _hx_AnonObject({'name': ("batchShader_" + ("null" if id is None else id)), 'vars': [vcount, vbuffer, voffset], 'funs': []})
        stride = (rt.vertex.paramsSize + rt.fragment.paramsSize)
        parentVars = haxe_ds_ObjectMap()
        swiz = [[hxsl_Component.X], [hxsl_Component.Y], [hxsl_Component.Z], [hxsl_Component.W]]
        def _hx_local_1(index):
            return _hx_AnonObject({'e': hxsl_TExprDef.TArray(ebuffer,_hx_AnonObject({'e': hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,eoffset,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TInt, 'p': pos})), 't': tvec4, 'p': pos})
        readOffset = _hx_local_1
        def _hx_local_2(v,offset):
            vreal = declVar(v.name,v.type,hxsl_VarKind.Local)
            if (v.perObjectGlobal is not None):
                _this = v.perObjectGlobal.path
                path = _this.split(".")
                if (len(path) != 0):
                    path.pop()
                cur = vreal
                while (len(path) > 0):
                    key = ".".join([python_Boot.toString1(x1,'') for x1 in path])
                    name1 = (None if ((len(path) == 0)) else path.pop())
                    vp = parentVars.h.get(path,None)
                    if (vp is None):
                        vp = declVar(name1,hxsl_Type.TStruct([]),hxsl_VarKind.Local)
                        parentVars.set(path,vp)
                    _g = vp.type
                    if (_g.index == 13):
                        vl = _g.params[0]
                        vl.append(cur)
                    Reflect.setField(cur,"parent",vp)
                    cur = vp
            _this1 = s.data.vars
            _this1.append(vreal)
            index1 = (((v.pos >> 2)) + offset)
            extract = None
            _g1 = v.type
            extract1 = _g1.index
            if (extract1 == 3):
                v1 = v.type
                extract2 = readOffset(index1)
                extract = _hx_AnonObject({'p': pos, 't': v1, 'e': hxsl_TExprDef.TSwiz(extract2,python_internal_ArrayImpl._get(swiz, (v.pos & 3)))})
            elif (extract1 == 5):
                _g2 = _g1.params[1]
                _g11 = _g1.params[0]
                if (_g11 == 2):
                    if (_g2.index == 1):
                        swiz1 = None
                        _g3 = (v.pos & 3)
                        if (_g3 == 0):
                            swiz1 = [hxsl_Component.X, hxsl_Component.Y]
                        elif (_g3 == 1):
                            swiz1 = [hxsl_Component.Y, hxsl_Component.Z]
                        else:
                            swiz1 = [hxsl_Component.Z, hxsl_Component.W]
                        v2 = v.type
                        extract3 = hxsl_TExprDef.TSwiz(readOffset(index1),swiz1)
                        extract = _hx_AnonObject({'p': pos, 't': v2, 'e': extract3})
                    else:
                        raise _HxException(("Unsupported batch var type " + Std.string(v.type)))
                elif (_g11 == 3):
                    if (_g2.index == 1):
                        v3 = v.type
                        extract4 = readOffset(index1)
                        extract = _hx_AnonObject({'p': pos, 't': v3, 'e': hxsl_TExprDef.TSwiz(extract4,([hxsl_Component.X, hxsl_Component.Y, hxsl_Component.Z] if ((((v.pos & 3)) == 0)) else [hxsl_Component.Y, hxsl_Component.Z, hxsl_Component.W]))})
                    else:
                        raise _HxException(("Unsupported batch var type " + Std.string(v.type)))
                elif (_g11 == 4):
                    if (_g2.index == 1):
                        extract = readOffset(index1)
                    else:
                        raise _HxException(("Unsupported batch var type " + Std.string(v.type)))
                else:
                    raise _HxException(("Unsupported batch var type " + Std.string(v.type)))
            elif (extract1 == 7):
                v4 = v.type
                extract5 = hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(hxsl_TGlobal.Mat4), 't': hxsl_Type.TVoid, 'p': pos}),[readOffset(index1), readOffset((index1 + 1)), readOffset((index1 + 2)), readOffset((index1 + 3))])
                extract = _hx_AnonObject({'p': pos, 't': v4, 'e': extract5})
            else:
                raise _HxException(("Unsupported batch var type " + Std.string(v.type)))
            return _hx_AnonObject({'p': pos, 'e': hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAssign,_hx_AnonObject({'e': hxsl_TExprDef.TVar(vreal), 'p': pos, 't': v.type}),extract), 't': hxsl_Type.TVoid})
        extractVar = _hx_local_2
        exprs = []
        p = rt.vertex.params
        while (p is not None):
            x = extractVar(p,0)
            exprs.append(x)
            p = p.next
        p1 = rt.fragment.params
        while (p1 is not None):
            x1 = extractVar(p1,rt.vertex.paramsSize)
            exprs.append(x1)
            p1 = p1.next
        x2 = _hx_AnonObject({'p': pos, 'e': hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAssign,eoffset,_hx_AnonObject({'p': pos, 't': hxsl_Type.TInt, 'e': hxsl_TExprDef.TBinop(haxe_macro_Binop.OpMult,_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(hxsl_TGlobal.InstanceID), 't': hxsl_Type.TInt, 'p': pos}),_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(stride)), 'p': pos, 't': hxsl_Type.TInt}))})), 't': hxsl_Type.TVoid})
        exprs.insert(0, x2)
        fv = declVar("init",hxsl_Type.TFun([]),hxsl_VarKind.Function)
        f = _hx_AnonObject({'kind': hxsl_FunctionKind.Init, 'ref': fv, 'args': [], 'ret': hxsl_Type.TVoid, 'expr': _hx_AnonObject({'e': hxsl_TExprDef.TBlock(exprs), 'p': pos, 't': hxsl_Type.TVoid})})
        _this2 = s.data.funs
        _this2.append(f)
        s.consts = hxsl_ShaderConst(vcount,0,countBits)
        s.consts.globalId = 0
        return s
    INST = None

    @staticmethod
    def get():
        c = hxsl_Cache.INST
        if (c is None):
            c = hxsl_Cache()
            hxsl_Cache.INST = c
        return c

    @staticmethod
    def set(c):
        hxsl_Cache.INST = c

    @staticmethod
    def clear():
        hxsl_Cache.INST = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.linkCache = None
        _hx_o.linkShaders = None
        _hx_o.batchShaders = None
        _hx_o.byID = None
        _hx_o.constsToGlobal = None
hxsl_Cache._hx_class = hxsl_Cache
_hx_classes["hxsl.Cache"] = hxsl_Cache

class hxsl_Channel(Enum):
    __slots__ = ()
    _hx_class_name = "hxsl.Channel"
    _hx_constructs = ["Unknown", "R", "G", "B", "A", "PackedFloat", "PackedNormal"]
hxsl_Channel.Unknown = hxsl_Channel("Unknown", 0, ())
hxsl_Channel.R = hxsl_Channel("R", 1, ())
hxsl_Channel.G = hxsl_Channel("G", 2, ())
hxsl_Channel.B = hxsl_Channel("B", 3, ())
hxsl_Channel.A = hxsl_Channel("A", 4, ())
hxsl_Channel.PackedFloat = hxsl_Channel("PackedFloat", 5, ())
hxsl_Channel.PackedNormal = hxsl_Channel("PackedNormal", 6, ())
hxsl_Channel._hx_class = hxsl_Channel
_hx_classes["hxsl.Channel"] = hxsl_Channel


class hxsl_Clone:
    _hx_class_name = "hxsl.Clone"
    _hx_is_interface = "False"
    __slots__ = ("varMap",)
    _hx_fields = ["varMap"]
    _hx_methods = ["tvar", "tfun", "ttype", "texpr", "shader"]
    _hx_statics = ["shaderData"]

    def __init__(self):
        self.varMap = haxe_ds_IntMap()

    def tvar(self,v):
        v2 = self.varMap.h.get(v.id,None)
        if (v2 is not None):
            return v2
        v2 = _hx_AnonObject({'id': hxsl_Tools.allocVarId(), 'type': v.type, 'name': v.name, 'kind': v.kind})
        self.varMap.set(v.id,v2)
        if (Reflect.field(v,"parent") is not None):
            Reflect.setField(v2,"parent",self.tvar(Reflect.field(v,"parent")))
        if (Reflect.field(v,"qualifiers") is not None):
            Reflect.setField(v2,"qualifiers",list(Reflect.field(v,"qualifiers")))
        v2.type = self.ttype(v.type)
        return v2

    def tfun(self,f):
        tmp = self.ttype(f.ret)
        f1 = f.kind
        tmp1 = self.tvar(f.ref)
        _g = []
        _g1 = 0
        _g2 = f.args
        while (_g1 < len(_g2)):
            a = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
            _g1 = (_g1 + 1)
            x = self.tvar(a)
            _g.append(x)
        return _hx_AnonObject({'ret': tmp, 'kind': f1, 'ref': tmp1, 'args': _g, 'expr': self.texpr(f.expr)})

    def ttype(self,t):
        tmp = t.index
        if (tmp == 13):
            vl = t.params[0]
            _g = []
            _g1 = 0
            while (_g1 < len(vl)):
                v = (vl[_g1] if _g1 >= 0 and _g1 < len(vl) else None)
                _g1 = (_g1 + 1)
                x = self.tvar(v)
                _g.append(x)
            return hxsl_Type.TStruct(_g)
        elif (tmp == 14):
            vars = t.params[0]
            return hxsl_Type.TFun(vars)
        elif (tmp == 15):
            size = t.params[1]
            t1 = t.params[0]
            tmp1 = self.ttype(t1)
            tmp2 = None
            tmp3 = size.index
            if (tmp3 == 0):
                _g11 = size.params[0]
                tmp2 = size
            elif (tmp3 == 1):
                v1 = size.params[0]
                tmp2 = hxsl_SizeDecl.SVar(self.tvar(v1))
            else:
                pass
            return hxsl_Type.TArray(tmp1,tmp2)
        else:
            return t

    def texpr(self,e):
        e2 = hxsl_Tools.map(e,self.texpr)
        e2.t = self.ttype(e.t)
        _g = e2.e
        tmp = None
        tmp1 = _g.index
        if (tmp1 == 1):
            v = _g.params[0]
            tmp = hxsl_TExprDef.TVar(self.tvar(v))
        elif (tmp1 == 7):
            init = _g.params[1]
            v1 = _g.params[0]
            tmp = hxsl_TExprDef.TVarDecl(self.tvar(v1),init)
        elif (tmp1 == 13):
            loop = _g.params[2]
            it = _g.params[1]
            v2 = _g.params[0]
            tmp = hxsl_TExprDef.TFor(self.tvar(v2),it,loop)
        else:
            tmp = e2.e
        e2.e = tmp
        return e2

    def shader(self,s):
        s1 = s.name
        _g = []
        _g1 = 0
        _g2 = s.vars
        while (_g1 < len(_g2)):
            v = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
            _g1 = (_g1 + 1)
            x = self.tvar(v)
            _g.append(x)
        tmp = _g
        _g3 = []
        _g4 = 0
        _g5 = s.funs
        while (_g4 < len(_g5)):
            f = (_g5[_g4] if _g4 >= 0 and _g4 < len(_g5) else None)
            _g4 = (_g4 + 1)
            x1 = self.tfun(f)
            _g3.append(x1)
        return _hx_AnonObject({'name': s1, 'vars': tmp, 'funs': _g3})

    @staticmethod
    def shaderData(s):
        return hxsl_Clone().shader(s)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.varMap = None
hxsl_Clone._hx_class = hxsl_Clone
_hx_classes["hxsl.Clone"] = hxsl_Clone


class hxsl__Dce_Exit:
    _hx_class_name = "hxsl._Dce.Exit"
    _hx_is_interface = "False"
    __slots__ = ()

    def __init__(self):
        pass
hxsl__Dce_Exit._hx_class = hxsl__Dce_Exit
_hx_classes["hxsl._Dce.Exit"] = hxsl__Dce_Exit


class hxsl__Dce_VarDeps:
    _hx_class_name = "hxsl._Dce.VarDeps"
    _hx_is_interface = "False"
    __slots__ = ("v", "keep", "used", "deps")
    _hx_fields = ["v", "keep", "used", "deps"]

    def __init__(self,v):
        self.keep = None
        self.v = v
        self.used = False
        self.deps = haxe_ds_IntMap()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.v = None
        _hx_o.keep = None
        _hx_o.used = None
        _hx_o.deps = None
hxsl__Dce_VarDeps._hx_class = hxsl__Dce_VarDeps
_hx_classes["hxsl._Dce.VarDeps"] = hxsl__Dce_VarDeps


class hxsl_Dce:
    _hx_class_name = "hxsl.Dce"
    _hx_is_interface = "False"
    __slots__ = ("used", "channelVars", "markAsKeep")
    _hx_fields = ["used", "channelVars", "markAsKeep"]
    _hx_methods = ["debug", "dce", "get", "markRec", "link", "check", "checkBranches", "mapExpr"]

    def __init__(self):
        self.markAsKeep = None
        self.channelVars = None
        self.used = None

    def debug(self,msg,pos = None):
        pass

    def dce(self,vertex,fragment):
        self.used = haxe_ds_IntMap()
        self.channelVars = []
        inputs = []
        _g = 0
        _g1 = vertex.vars
        while (_g < len(_g1)):
            v = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            i = self.get(v)
            if (v.kind == hxsl_VarKind.Input):
                inputs.append(i)
            if (v.kind == hxsl_VarKind.Output):
                i.keep = True
        _g2 = 0
        _g3 = fragment.vars
        while (_g2 < len(_g3)):
            v1 = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
            _g2 = (_g2 + 1)
            i1 = self.get(v1)
            if (v1.kind == hxsl_VarKind.Output):
                i1.keep = True
        _g4 = 0
        _g5 = vertex.funs
        while (_g4 < len(_g5)):
            f = (_g5[_g4] if _g4 >= 0 and _g4 < len(_g5) else None)
            _g4 = (_g4 + 1)
            self.check(f.expr,[],[])
        _g6 = 0
        _g7 = fragment.funs
        while (_g6 < len(_g7)):
            f1 = (_g7[_g6] if _g6 >= 0 and _g6 < len(_g7) else None)
            _g6 = (_g6 + 1)
            self.check(f1.expr,[],[])
        outExprs = []
        while True:
            v2 = self.used.iterator()
            while v2.hasNext():
                v3 = v2.next()
                if v3.keep:
                    self.markRec(v3)
            while ((len(inputs) > 1) and (not python_internal_ArrayImpl._get(inputs, (len(inputs) - 1)).used)):
                if (len(inputs) != 0):
                    inputs.pop()
            _g8 = 0
            while (_g8 < len(inputs)):
                v4 = (inputs[_g8] if _g8 >= 0 and _g8 < len(inputs) else None)
                _g8 = (_g8 + 1)
                self.markRec(v4)
            outExprs = []
            _g9 = 0
            _g10 = vertex.funs
            while (_g9 < len(_g10)):
                f2 = (_g10[_g9] if _g9 >= 0 and _g9 < len(_g10) else None)
                _g9 = (_g9 + 1)
                x = self.mapExpr(f2.expr,False)
                outExprs.append(x)
            _g11 = 0
            _g12 = fragment.funs
            while (_g11 < len(_g12)):
                f3 = (_g12[_g11] if _g11 >= 0 and _g11 < len(_g12) else None)
                _g11 = (_g11 + 1)
                x1 = self.mapExpr(f3.expr,False)
                outExprs.append(x1)
            self.markAsKeep = False
            _g13 = 0
            while (_g13 < len(outExprs)):
                e = (outExprs[_g13] if _g13 >= 0 and _g13 < len(outExprs) else None)
                _g13 = (_g13 + 1)
                self.checkBranches(e)
            if (not self.markAsKeep):
                break
        _g81 = 0
        _g91 = vertex.funs
        while (_g81 < len(_g91)):
            f4 = (_g91[_g81] if _g81 >= 0 and _g81 < len(_g91) else None)
            _g81 = (_g81 + 1)
            f4.expr = (None if ((len(outExprs) == 0)) else outExprs.pop(0))
        _g101 = 0
        _g111 = fragment.funs
        while (_g101 < len(_g111)):
            f5 = (_g111[_g101] if _g101 >= 0 and _g101 < len(_g111) else None)
            _g101 = (_g101 + 1)
            f5.expr = (None if ((len(outExprs) == 0)) else outExprs.pop(0))
        v5 = self.used.iterator()
        while v5.hasNext():
            v6 = v5.next()
            if v6.used:
                continue
            if (v6.v.kind == hxsl_VarKind.Input):
                continue
            python_internal_ArrayImpl.remove(vertex.vars,v6.v)
            python_internal_ArrayImpl.remove(fragment.vars,v6.v)
        return _hx_AnonObject({'fragment': fragment, 'vertex': vertex})

    def get(self,v):
        vd = self.used.h.get(v.id,None)
        if (vd is None):
            vd = hxsl__Dce_VarDeps(v)
            self.used.set(v.id,vd)
        return vd

    def markRec(self,v):
        if v.used:
            return
        v.used = True
        d = v.deps.iterator()
        while d.hasNext():
            d1 = d.next()
            self.markRec(d1)

    def link(self,v,writeTo):
        vd = self.get(v)
        _g = 0
        while (_g < len(writeTo)):
            w = (writeTo[_g] if _g >= 0 and _g < len(writeTo) else None)
            _g = (_g + 1)
            if (w is None):
                if (not vd.keep):
                    vd.keep = True
                    self.markAsKeep = True
                continue
            w.deps.set(v.id,vd)

    def check(self,e,writeTo,isAffected):
        _g = e.e
        tmp = _g.index
        if (tmp == 1):
            v = _g.params[0]
            self.link(v,writeTo)
        elif (tmp == 4):
            el = _g.params[0]
            noWrite = []
            _g1 = 0
            _g11 = len(el)
            while (_g1 < _g11):
                i = _g1
                _g1 = (_g1 + 1)
                self.check((el[i] if i >= 0 and i < len(el) else None),(noWrite if ((i < ((len(el) - 1)))) else writeTo),isAffected)
        elif (tmp == 5):
            _g13 = _g.params[2]
            _g12 = _g.params[1]
            _g111 = _g.params[0]
            tmp1 = _g111.index
            if (tmp1 == 4):
                _g16 = _g12.t
                _g15 = _g12.p
                _g14 = _g12.e
                tmp2 = _g14.index
                if (tmp2 == 1):
                    e1 = _g13
                    v1 = _g14.params[0]
                    v2 = self.get(v1)
                    writeTo.append(v2)
                    self.check(e1,writeTo,isAffected)
                    if (len(writeTo) != 0):
                        writeTo.pop()
                    if (python_internal_ArrayImpl.indexOf(isAffected,v2,None) < 0):
                        isAffected.append(v2)
                elif (tmp2 == 9):
                    _g19 = _g14.params[1]
                    _g18 = _g14.params[0]
                    _g22 = _g18.t
                    _g21 = _g18.p
                    _g20 = _g18.e
                    if (_g20.index == 1):
                        e2 = _g13
                        v3 = _g20.params[0]
                        v4 = self.get(v3)
                        writeTo.append(v4)
                        self.check(e2,writeTo,isAffected)
                        if (len(writeTo) != 0):
                            writeTo.pop()
                        if (python_internal_ArrayImpl.indexOf(isAffected,v4,None) < 0):
                            isAffected.append(v4)
                    else:
                        f = self.check
                        writeTo1 = writeTo
                        isAffected1 = isAffected
                        def _hx_local_0(e3):
                            f(e3,writeTo1,isAffected1)
                        hxsl_Tools.iter(e,_hx_local_0)
                else:
                    f1 = self.check
                    writeTo2 = writeTo
                    isAffected2 = isAffected
                    def _hx_local_1(e4):
                        f1(e4,writeTo2,isAffected2)
                    hxsl_Tools.iter(e,_hx_local_1)
            elif (tmp1 == 20):
                _g24 = _g111.params[0]
                _g27 = _g12.t
                _g26 = _g12.p
                _g25 = _g12.e
                tmp3 = _g25.index
                if (tmp3 == 1):
                    e5 = _g13
                    v5 = _g25.params[0]
                    v6 = self.get(v5)
                    writeTo.append(v6)
                    self.check(e5,writeTo,isAffected)
                    if (len(writeTo) != 0):
                        writeTo.pop()
                    if (python_internal_ArrayImpl.indexOf(isAffected,v6,None) < 0):
                        isAffected.append(v6)
                elif (tmp3 == 9):
                    _g30 = _g25.params[1]
                    _g29 = _g25.params[0]
                    _g33 = _g29.t
                    _g32 = _g29.p
                    _g31 = _g29.e
                    if (_g31.index == 1):
                        e6 = _g13
                        v7 = _g31.params[0]
                        v8 = self.get(v7)
                        writeTo.append(v8)
                        self.check(e6,writeTo,isAffected)
                        if (len(writeTo) != 0):
                            writeTo.pop()
                        if (python_internal_ArrayImpl.indexOf(isAffected,v8,None) < 0):
                            isAffected.append(v8)
                    else:
                        f2 = self.check
                        writeTo3 = writeTo
                        isAffected3 = isAffected
                        def _hx_local_2(e7):
                            f2(e7,writeTo3,isAffected3)
                        hxsl_Tools.iter(e,_hx_local_2)
                else:
                    f3 = self.check
                    writeTo4 = writeTo
                    isAffected4 = isAffected
                    def _hx_local_3(e8):
                        f3(e8,writeTo4,isAffected4)
                    hxsl_Tools.iter(e,_hx_local_3)
            else:
                f4 = self.check
                writeTo5 = writeTo
                isAffected5 = isAffected
                def _hx_local_4(e9):
                    f4(e9,writeTo5,isAffected5)
                hxsl_Tools.iter(e,_hx_local_4)
        elif (tmp == 7):
            init = _g.params[1]
            v9 = _g.params[0]
            if (init is not None):
                x = self.get(v9)
                writeTo.append(x)
                self.check(init,writeTo,isAffected)
                if (len(writeTo) != 0):
                    writeTo.pop()
            else:
                f5 = self.check
                writeTo6 = writeTo
                isAffected6 = isAffected
                def _hx_local_5(e10):
                    f5(e10,writeTo6,isAffected6)
                hxsl_Tools.iter(e,_hx_local_5)
        elif (tmp == 8):
            _g36 = _g.params[1]
            _g35 = _g.params[0]
            _g39 = _g35.t
            _g38 = _g35.p
            _g37 = _g35.e
            if (_g37.index == 2):
                tmp4 = _g37.params[0].index
                if (tmp4 == 63):
                    if (len(_g36) == 3):
                        _g56 = (_g36[2] if 2 < len(_g36) else None)
                        _g54 = (_g36[0] if 0 < len(_g36) else None)
                        _g59 = _g54.t
                        _g58 = _g54.p
                        _g57 = _g54.e
                        if (_g57.index == 1):
                            _g63 = _g56.t
                            _g62 = _g56.p
                            _g61 = _g56.e
                            if (_g61.index == 0):
                                _g64 = _g61.params[0]
                                if (_g64.index == 2):
                                    c = _g57.params[0]
                                    uv = (_g36[1] if 1 < len(_g36) else None)
                                    cid = _g64.params[0]
                                    self.check(uv,writeTo,isAffected)
                                    if ((self.channelVars[cid] if cid >= 0 and cid < len(self.channelVars) else None) is None):
                                        python_internal_ArrayImpl._set(self.channelVars, cid, c)
                                        self.link(c,writeTo)
                                    else:
                                        self.link((self.channelVars[cid] if cid >= 0 and cid < len(self.channelVars) else None),writeTo)
                                else:
                                    f6 = self.check
                                    writeTo7 = writeTo
                                    isAffected7 = isAffected
                                    def _hx_local_6(e11):
                                        f6(e11,writeTo7,isAffected7)
                                    hxsl_Tools.iter(e,_hx_local_6)
                            else:
                                f7 = self.check
                                writeTo8 = writeTo
                                isAffected8 = isAffected
                                def _hx_local_7(e12):
                                    f7(e12,writeTo8,isAffected8)
                                hxsl_Tools.iter(e,_hx_local_7)
                        else:
                            f8 = self.check
                            writeTo9 = writeTo
                            isAffected9 = isAffected
                            def _hx_local_8(e13):
                                f8(e13,writeTo9,isAffected9)
                            hxsl_Tools.iter(e,_hx_local_8)
                    else:
                        f9 = self.check
                        writeTo10 = writeTo
                        isAffected10 = isAffected
                        def _hx_local_9(e14):
                            f9(e14,writeTo10,isAffected10)
                        hxsl_Tools.iter(e,_hx_local_9)
                elif (tmp4 == 64):
                    if (len(_g36) == 4):
                        _g44 = (_g36[3] if 3 < len(_g36) else None)
                        _g41 = (_g36[0] if 0 < len(_g36) else None)
                        _g47 = _g41.t
                        _g46 = _g41.p
                        _g45 = _g41.e
                        if (_g45.index == 1):
                            _g51 = _g44.t
                            _g50 = _g44.p
                            _g49 = _g44.e
                            if (_g49.index == 0):
                                _g52 = _g49.params[0]
                                if (_g52.index == 2):
                                    c1 = _g45.params[0]
                                    uv1 = (_g36[1] if 1 < len(_g36) else None)
                                    lod = (_g36[2] if 2 < len(_g36) else None)
                                    cid1 = _g52.params[0]
                                    self.check(uv1,writeTo,isAffected)
                                    self.check(lod,writeTo,isAffected)
                                    if ((self.channelVars[cid1] if cid1 >= 0 and cid1 < len(self.channelVars) else None) is None):
                                        python_internal_ArrayImpl._set(self.channelVars, cid1, c1)
                                        self.link(c1,writeTo)
                                    else:
                                        self.link((self.channelVars[cid1] if cid1 >= 0 and cid1 < len(self.channelVars) else None),writeTo)
                                else:
                                    f10 = self.check
                                    writeTo11 = writeTo
                                    isAffected11 = isAffected
                                    def _hx_local_10(e15):
                                        f10(e15,writeTo11,isAffected11)
                                    hxsl_Tools.iter(e,_hx_local_10)
                            else:
                                f11 = self.check
                                writeTo12 = writeTo
                                isAffected12 = isAffected
                                def _hx_local_11(e16):
                                    f11(e16,writeTo12,isAffected12)
                                hxsl_Tools.iter(e,_hx_local_11)
                        else:
                            f12 = self.check
                            writeTo13 = writeTo
                            isAffected13 = isAffected
                            def _hx_local_12(e17):
                                f12(e17,writeTo13,isAffected13)
                            hxsl_Tools.iter(e,_hx_local_12)
                    else:
                        f13 = self.check
                        writeTo14 = writeTo
                        isAffected14 = isAffected
                        def _hx_local_13(e18):
                            f13(e18,writeTo14,isAffected14)
                        hxsl_Tools.iter(e,_hx_local_13)
                else:
                    f14 = self.check
                    writeTo15 = writeTo
                    isAffected15 = isAffected
                    def _hx_local_14(e19):
                        f14(e19,writeTo15,isAffected15)
                    hxsl_Tools.iter(e,_hx_local_14)
            else:
                f15 = self.check
                writeTo16 = writeTo
                isAffected16 = isAffected
                def _hx_local_15(e20):
                    f15(e20,writeTo16,isAffected16)
                hxsl_Tools.iter(e,_hx_local_15)
        elif (tmp == 10):
            eelse = _g.params[2]
            eif = _g.params[1]
            e21 = _g.params[0]
            affect = []
            self.check(eif,writeTo,affect)
            if (eelse is not None):
                self.check(eelse,writeTo,affect)
            _hx_len = len(affect)
            _g2 = 0
            while (_g2 < len(writeTo)):
                v10 = (writeTo[_g2] if _g2 >= 0 and _g2 < len(writeTo) else None)
                _g2 = (_g2 + 1)
                if (python_internal_ArrayImpl.indexOf(affect,v10,None) < 0):
                    affect.append(v10)
            self.check(e21,affect,isAffected)
            _g17 = 0
            _g23 = _hx_len
            while (_g17 < _g23):
                i1 = _g17
                _g17 = (_g17 + 1)
                v11 = (affect[i1] if i1 >= 0 and i1 < len(affect) else None)
                if (python_internal_ArrayImpl.indexOf(isAffected,v11,None) < 0):
                    isAffected.append(v11)
        elif (tmp == 13):
            loop = _g.params[2]
            it = _g.params[1]
            v12 = _g.params[0]
            affect1 = []
            self.check(loop,writeTo,affect1)
            self.check(it,affect1,isAffected)
            _g3 = 0
            while (_g3 < len(affect1)):
                v13 = (affect1[_g3] if _g3 >= 0 and _g3 < len(affect1) else None)
                _g3 = (_g3 + 1)
                if (python_internal_ArrayImpl.indexOf(isAffected,v13,None) < 0):
                    isAffected.append(v13)
        else:
            f16 = self.check
            writeTo17 = writeTo
            isAffected17 = isAffected
            def _hx_local_18(e22):
                f16(e22,writeTo17,isAffected17)
            hxsl_Tools.iter(e,_hx_local_18)

    def checkBranches(self,e):
        _g = e.e
        if (_g.index == 10):
            _g3 = _g.params[2]
            _g2 = _g.params[1]
            cond = _g.params[0]
            writeTo = [None]
            self.check(cond,writeTo,[])
        hxsl_Tools.iter(e,self.checkBranches)

    def mapExpr(self,e,isVar):
        _gthis = self
        _g = e.e
        tmp = _g.index
        if (tmp == 4):
            el = _g.params[0]
            out = []
            count = 0
            _g1 = 0
            while (_g1 < len(el)):
                e1 = (el[_g1] if _g1 >= 0 and _g1 < len(el) else None)
                _g1 = (_g1 + 1)
                isVar1 = (isVar and ((count == ((len(el) - 1)))))
                e2 = self.mapExpr(e1,isVar1)
                if (hxsl_Tools.hasSideEffect(e2) or isVar1):
                    out.append(e2)
                count = (count + 1)
            return _hx_AnonObject({'e': hxsl_TExprDef.TBlock(out), 'p': e.p, 't': e.t})
        elif (tmp == 5):
            _g12 = _g.params[2]
            _g11 = _g.params[1]
            _g10 = _g.params[0]
            tmp1 = _g10.index
            if (tmp1 == 4):
                _g15 = _g11.t
                _g14 = _g11.p
                _g13 = _g11.e
                tmp2 = _g13.index
                if (tmp2 == 1):
                    v = _g13.params[0]
                    if (not self.get(v).used):
                        return _hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CNull), 't': e.t, 'p': e.p})
                    else:
                        def _hx_local_3():
                            def _hx_local_2(e3):
                                return _gthis.mapExpr(e3,True)
                            return hxsl_Tools.map(e,_hx_local_2)
                        return _hx_local_3()
                elif (tmp2 == 9):
                    _g18 = _g13.params[1]
                    _g17 = _g13.params[0]
                    _g21 = _g17.t
                    _g20 = _g17.p
                    _g19 = _g17.e
                    if (_g19.index == 1):
                        v1 = _g19.params[0]
                        if (not self.get(v1).used):
                            return _hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CNull), 't': e.t, 'p': e.p})
                        else:
                            def _hx_local_5():
                                def _hx_local_4(e4):
                                    return _gthis.mapExpr(e4,True)
                                return hxsl_Tools.map(e,_hx_local_4)
                            return _hx_local_5()
                    else:
                        def _hx_local_7():
                            def _hx_local_6(e5):
                                return _gthis.mapExpr(e5,True)
                            return hxsl_Tools.map(e,_hx_local_6)
                        return _hx_local_7()
                else:
                    def _hx_local_9():
                        def _hx_local_8(e6):
                            return _gthis.mapExpr(e6,True)
                        return hxsl_Tools.map(e,_hx_local_8)
                    return _hx_local_9()
            elif (tmp1 == 20):
                _g23 = _g10.params[0]
                _g26 = _g11.t
                _g25 = _g11.p
                _g24 = _g11.e
                tmp3 = _g24.index
                if (tmp3 == 1):
                    v2 = _g24.params[0]
                    if (not self.get(v2).used):
                        return _hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CNull), 't': e.t, 'p': e.p})
                    else:
                        def _hx_local_11():
                            def _hx_local_10(e7):
                                return _gthis.mapExpr(e7,True)
                            return hxsl_Tools.map(e,_hx_local_10)
                        return _hx_local_11()
                elif (tmp3 == 9):
                    _g29 = _g24.params[1]
                    _g28 = _g24.params[0]
                    _g32 = _g28.t
                    _g31 = _g28.p
                    _g30 = _g28.e
                    if (_g30.index == 1):
                        v3 = _g30.params[0]
                        if (not self.get(v3).used):
                            return _hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CNull), 't': e.t, 'p': e.p})
                        else:
                            def _hx_local_13():
                                def _hx_local_12(e8):
                                    return _gthis.mapExpr(e8,True)
                                return hxsl_Tools.map(e,_hx_local_12)
                            return _hx_local_13()
                    else:
                        def _hx_local_15():
                            def _hx_local_14(e9):
                                return _gthis.mapExpr(e9,True)
                            return hxsl_Tools.map(e,_hx_local_14)
                        return _hx_local_15()
                else:
                    def _hx_local_17():
                        def _hx_local_16(e10):
                            return _gthis.mapExpr(e10,True)
                        return hxsl_Tools.map(e,_hx_local_16)
                    return _hx_local_17()
            else:
                def _hx_local_19():
                    def _hx_local_18(e11):
                        return _gthis.mapExpr(e11,True)
                    return hxsl_Tools.map(e,_hx_local_18)
                return _hx_local_19()
        elif (tmp == 7):
            _g6 = _g.params[1]
            v4 = _g.params[0]
            if (not self.get(v4).used):
                return _hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CNull), 't': e.t, 'p': e.p})
            else:
                def _hx_local_21():
                    def _hx_local_20(e12):
                        return _gthis.mapExpr(e12,True)
                    return hxsl_Tools.map(e,_hx_local_20)
                return _hx_local_21()
        elif (tmp == 8):
            _g35 = _g.params[1]
            _g34 = _g.params[0]
            _g38 = _g34.t
            _g37 = _g34.p
            _g36 = _g34.e
            if (_g36.index == 2):
                tmp4 = _g36.params[0].index
                if (tmp4 == 63):
                    if (len(_g35) == 3):
                        _g59 = (_g35[2] if 2 < len(_g35) else None)
                        _g57 = (_g35[0] if 0 < len(_g35) else None)
                        _g62 = _g59.t
                        _g61 = _g59.p
                        _g60 = _g59.e
                        if (_g60.index == 0):
                            _g63 = _g60.params[0]
                            if (_g63.index == 2):
                                uv = (_g35[1] if 1 < len(_g35) else None)
                                cid = _g63.params[0]
                                c = (self.channelVars[cid] if cid >= 0 and cid < len(self.channelVars) else None)
                                return _hx_AnonObject({'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(hxsl_TGlobal.Texture), 'p': e.p, 't': hxsl_Type.TVoid}),[_hx_AnonObject({'e': hxsl_TExprDef.TVar(c), 't': c.type, 'p': e.p}), self.mapExpr(uv,True)]), 't': hxsl_Type.TVoid, 'p': e.p})
                            else:
                                def _hx_local_23():
                                    def _hx_local_22(e13):
                                        return _gthis.mapExpr(e13,True)
                                    return hxsl_Tools.map(e,_hx_local_22)
                                return _hx_local_23()
                        else:
                            def _hx_local_25():
                                def _hx_local_24(e14):
                                    return _gthis.mapExpr(e14,True)
                                return hxsl_Tools.map(e,_hx_local_24)
                            return _hx_local_25()
                    else:
                        def _hx_local_27():
                            def _hx_local_26(e15):
                                return _gthis.mapExpr(e15,True)
                            return hxsl_Tools.map(e,_hx_local_26)
                        return _hx_local_27()
                elif (tmp4 == 64):
                    if (len(_g35) == 4):
                        _g43 = (_g35[3] if 3 < len(_g35) else None)
                        _g40 = (_g35[0] if 0 < len(_g35) else None)
                        _g46 = _g43.t
                        _g45 = _g43.p
                        _g44 = _g43.e
                        if (_g44.index == 0):
                            _g47 = _g44.params[0]
                            if (_g47.index == 2):
                                uv1 = (_g35[1] if 1 < len(_g35) else None)
                                lod = (_g35[2] if 2 < len(_g35) else None)
                                cid1 = _g47.params[0]
                                c1 = (self.channelVars[cid1] if cid1 >= 0 and cid1 < len(self.channelVars) else None)
                                return _hx_AnonObject({'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(hxsl_TGlobal.TextureLod), 'p': e.p, 't': hxsl_Type.TVoid}),[_hx_AnonObject({'e': hxsl_TExprDef.TVar(c1), 't': c1.type, 'p': e.p}), self.mapExpr(uv1,True), self.mapExpr(lod,True)]), 't': hxsl_Type.TVoid, 'p': e.p})
                            else:
                                def _hx_local_29():
                                    def _hx_local_28(e16):
                                        return _gthis.mapExpr(e16,True)
                                    return hxsl_Tools.map(e,_hx_local_28)
                                return _hx_local_29()
                        else:
                            def _hx_local_31():
                                def _hx_local_30(e17):
                                    return _gthis.mapExpr(e17,True)
                                return hxsl_Tools.map(e,_hx_local_30)
                            return _hx_local_31()
                    else:
                        def _hx_local_33():
                            def _hx_local_32(e18):
                                return _gthis.mapExpr(e18,True)
                            return hxsl_Tools.map(e,_hx_local_32)
                        return _hx_local_33()
                elif (tmp4 == 65):
                    if (len(_g35) == 3):
                        _g51 = (_g35[2] if 2 < len(_g35) else None)
                        _g49 = (_g35[0] if 0 < len(_g35) else None)
                        _g54 = _g51.t
                        _g53 = _g51.p
                        _g52 = _g51.e
                        if (_g52.index == 0):
                            _g55 = _g52.params[0]
                            if (_g55.index == 2):
                                pos = (_g35[1] if 1 < len(_g35) else None)
                                cid2 = _g55.params[0]
                                c2 = (self.channelVars[cid2] if cid2 >= 0 and cid2 < len(self.channelVars) else None)
                                return _hx_AnonObject({'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(hxsl_TGlobal.Texel), 'p': e.p, 't': hxsl_Type.TVoid}),[_hx_AnonObject({'e': hxsl_TExprDef.TVar(c2), 't': c2.type, 'p': e.p}), self.mapExpr(pos,True)]), 't': hxsl_Type.TVoid, 'p': e.p})
                            else:
                                def _hx_local_35():
                                    def _hx_local_34(e19):
                                        return _gthis.mapExpr(e19,True)
                                    return hxsl_Tools.map(e,_hx_local_34)
                                return _hx_local_35()
                        else:
                            def _hx_local_37():
                                def _hx_local_36(e20):
                                    return _gthis.mapExpr(e20,True)
                                return hxsl_Tools.map(e,_hx_local_36)
                            return _hx_local_37()
                    else:
                        def _hx_local_39():
                            def _hx_local_38(e21):
                                return _gthis.mapExpr(e21,True)
                            return hxsl_Tools.map(e,_hx_local_38)
                        return _hx_local_39()
                elif (tmp4 == 66):
                    if (len(_g35) == 4):
                        _g68 = (_g35[3] if 3 < len(_g35) else None)
                        _g65 = (_g35[0] if 0 < len(_g35) else None)
                        _g71 = _g68.t
                        _g70 = _g68.p
                        _g69 = _g68.e
                        if (_g69.index == 0):
                            _g72 = _g69.params[0]
                            if (_g72.index == 2):
                                pos1 = (_g35[1] if 1 < len(_g35) else None)
                                lod1 = (_g35[2] if 2 < len(_g35) else None)
                                cid3 = _g72.params[0]
                                c3 = (self.channelVars[cid3] if cid3 >= 0 and cid3 < len(self.channelVars) else None)
                                return _hx_AnonObject({'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(hxsl_TGlobal.Texel), 'p': e.p, 't': hxsl_Type.TVoid}),[_hx_AnonObject({'e': hxsl_TExprDef.TVar(c3), 't': c3.type, 'p': e.p}), self.mapExpr(pos1,True), self.mapExpr(lod1,True)]), 't': hxsl_Type.TVoid, 'p': e.p})
                            else:
                                def _hx_local_41():
                                    def _hx_local_40(e22):
                                        return _gthis.mapExpr(e22,True)
                                    return hxsl_Tools.map(e,_hx_local_40)
                                return _hx_local_41()
                        else:
                            def _hx_local_43():
                                def _hx_local_42(e23):
                                    return _gthis.mapExpr(e23,True)
                                return hxsl_Tools.map(e,_hx_local_42)
                            return _hx_local_43()
                    else:
                        def _hx_local_45():
                            def _hx_local_44(e24):
                                return _gthis.mapExpr(e24,True)
                            return hxsl_Tools.map(e,_hx_local_44)
                        return _hx_local_45()
                else:
                    def _hx_local_47():
                        def _hx_local_46(e25):
                            return _gthis.mapExpr(e25,True)
                        return hxsl_Tools.map(e,_hx_local_46)
                    return _hx_local_47()
            else:
                def _hx_local_49():
                    def _hx_local_48(e26):
                        return _gthis.mapExpr(e26,True)
                    return hxsl_Tools.map(e,_hx_local_48)
                return _hx_local_49()
        elif (tmp == 10):
            eelse = _g.params[2]
            econd = _g.params[1]
            e27 = _g.params[0]
            e28 = self.mapExpr(e27,True)
            econd1 = self.mapExpr(econd,isVar)
            eelse1 = (None if ((eelse is None)) else self.mapExpr(eelse,isVar))
            if (((not isVar) and (not hxsl_Tools.hasSideEffect(econd1))) and (((eelse1 is None) or (not hxsl_Tools.hasSideEffect(eelse1))))):
                return _hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CNull), 't': e28.t, 'p': e28.p})
            return _hx_AnonObject({'e': hxsl_TExprDef.TIf(e28,econd1,eelse1), 'p': e28.p, 't': e28.t})
        elif (tmp == 13):
            loop = _g.params[2]
            it = _g.params[1]
            v5 = _g.params[0]
            it1 = self.mapExpr(it,True)
            loop1 = self.mapExpr(loop,False)
            if (not hxsl_Tools.hasSideEffect(loop1)):
                return _hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CNull), 't': e.t, 'p': e.p})
            return _hx_AnonObject({'e': hxsl_TExprDef.TFor(v5,it1,loop1), 'p': e.p, 't': e.t})
        else:
            def _hx_local_51():
                def _hx_local_50(e29):
                    return _gthis.mapExpr(e29,True)
                return hxsl_Tools.map(e,_hx_local_50)
            return _hx_local_51()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.used = None
        _hx_o.channelVars = None
        _hx_o.markAsKeep = None
hxsl_Dce._hx_class = hxsl_Dce
_hx_classes["hxsl.Dce"] = hxsl_Dce


class hxsl_Eval:
    _hx_class_name = "hxsl.Eval"
    _hx_is_interface = "False"
    __slots__ = ("varMap", "inlineCalls", "unrollLoops", "eliminateConditionals", "constants", "funMap", "curFun", "markReturn")
    _hx_fields = ["varMap", "inlineCalls", "unrollLoops", "eliminateConditionals", "constants", "funMap", "curFun", "markReturn"]
    _hx_methods = ["setConstant", "mapVar", "eval", "hasReturn", "hasReturnLoop", "handleReturn", "handleReturnDef", "evalCall", "constantsToString", "ifBlock", "evalExpr"]

    def __init__(self):
        self.markReturn = None
        self.curFun = None
        self.eliminateConditionals = None
        self.unrollLoops = None
        self.inlineCalls = None
        self.varMap = haxe_ds_ObjectMap()
        self.funMap = haxe_ds_ObjectMap()
        self.constants = haxe_ds_IntMap()

    def setConstant(self,v,c):
        self.constants.set(v.id,hxsl_TExprDef.TConst(c))

    def mapVar(self,v):
        v2 = self.varMap.h.get(v,None)
        if (v2 is not None):
            if (v == v2):
                return v2
            else:
                return self.mapVar(v2)
        if (Reflect.field(v,"parent") is not None):
            self.mapVar(Reflect.field(v,"parent"))
            v2 = self.varMap.h.get(v,None)
            if (v2 is not None):
                if (v == v2):
                    return v2
                else:
                    return self.mapVar(v2)
        _g = v.type
        v21 = None
        if (_g.index == 17):
            _g1 = _g.params[0]
            v21 = True
        else:
            v21 = False
        v2 = _hx_AnonObject({'id': (v.id if v21 else hxsl_Tools.allocVarId()), 'name': v.name, 'type': v.type, 'kind': v.kind})
        if (Reflect.field(v,"parent") is not None):
            Reflect.setField(v2,"parent",self.mapVar(Reflect.field(v,"parent")))
        if (Reflect.field(v,"qualifiers") is not None):
            Reflect.setField(v2,"qualifiers",list(Reflect.field(v,"qualifiers")))
        self.varMap.set(v,v2)
        self.varMap.set(v2,v2)
        _g2 = v2.type
        tmp = _g2.index
        if (tmp == 13):
            vl = _g2.params[0]
            _g21 = []
            _g3 = 0
            while (_g3 < len(vl)):
                v1 = (vl[_g3] if _g3 >= 0 and _g3 < len(vl) else None)
                _g3 = (_g3 + 1)
                x = self.mapVar(v1)
                _g21.append(x)
            v2.type = hxsl_Type.TStruct(_g21)
        elif (tmp == 15):
            _g8 = _g2.params[1]
            if (_g8.index == 1):
                t = _g2.params[0]
                vs = _g8.params[0]
                c = self.constants.h.get(vs.id,None)
                if (c is not None):
                    if (c is None):
                        hxsl_Error.t(("Integer value expected for array size constant " + HxOverrides.stringOrNull(vs.name)),None)
                    elif (c.index == 0):
                        _g22 = c.params[0]
                        if (_g22.index == 2):
                            v3 = _g22.params[0]
                            _g23 = v2.type
                            tmp1 = None
                            if (_g23.index == 15):
                                _g4 = _g23.params[1]
                                _g31 = _g23.params[0]
                                tmp1 = True
                            else:
                                tmp1 = False
                            v2.type = (hxsl_Type.TArray(t,hxsl_SizeDecl.SConst(v3)) if tmp1 else hxsl_Type.TBuffer(t,hxsl_SizeDecl.SConst(v3)))
                        else:
                            hxsl_Error.t(("Integer value expected for array size constant " + HxOverrides.stringOrNull(vs.name)),None)
                    else:
                        hxsl_Error.t(("Integer value expected for array size constant " + HxOverrides.stringOrNull(vs.name)),None)
                else:
                    vs2 = self.mapVar(vs)
                    _g24 = v2.type
                    tmp2 = None
                    if (_g24.index == 15):
                        _g41 = _g24.params[1]
                        _g32 = _g24.params[0]
                        tmp2 = True
                    else:
                        tmp2 = False
                    v2.type = (hxsl_Type.TArray(t,hxsl_SizeDecl.SVar(vs2)) if tmp2 else hxsl_Type.TBuffer(t,hxsl_SizeDecl.SVar(vs2)))
        elif (tmp == 16):
            _g5 = _g2.params[1]
            if (_g5.index == 1):
                t1 = _g2.params[0]
                vs1 = _g5.params[0]
                c1 = self.constants.h.get(vs1.id,None)
                if (c1 is not None):
                    if (c1 is None):
                        hxsl_Error.t(("Integer value expected for array size constant " + HxOverrides.stringOrNull(vs1.name)),None)
                    elif (c1.index == 0):
                        _g25 = c1.params[0]
                        if (_g25.index == 2):
                            v4 = _g25.params[0]
                            _g26 = v2.type
                            tmp3 = None
                            if (_g26.index == 15):
                                _g42 = _g26.params[1]
                                _g33 = _g26.params[0]
                                tmp3 = True
                            else:
                                tmp3 = False
                            v2.type = (hxsl_Type.TArray(t1,hxsl_SizeDecl.SConst(v4)) if tmp3 else hxsl_Type.TBuffer(t1,hxsl_SizeDecl.SConst(v4)))
                        else:
                            hxsl_Error.t(("Integer value expected for array size constant " + HxOverrides.stringOrNull(vs1.name)),None)
                    else:
                        hxsl_Error.t(("Integer value expected for array size constant " + HxOverrides.stringOrNull(vs1.name)),None)
                else:
                    vs21 = self.mapVar(vs1)
                    _g27 = v2.type
                    tmp4 = None
                    if (_g27.index == 15):
                        _g43 = _g27.params[1]
                        _g34 = _g27.params[0]
                        tmp4 = True
                    else:
                        tmp4 = False
                    v2.type = (hxsl_Type.TArray(t1,hxsl_SizeDecl.SVar(vs21)) if tmp4 else hxsl_Type.TBuffer(t1,hxsl_SizeDecl.SVar(vs21)))
        else:
            pass
        return v2

    def eval(self,s):
        funs = []
        _g = 0
        _g1 = s.funs
        while (_g < len(_g1)):
            f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            f1 = f.kind
            f2 = self.mapVar(f.ref)
            _g2 = []
            _g11 = 0
            _g21 = f.args
            while (_g11 < len(_g21)):
                a = (_g21[_g11] if _g11 >= 0 and _g11 < len(_g21) else None)
                _g11 = (_g11 + 1)
                x = self.mapVar(a)
                _g2.append(x)
            f21 = _hx_AnonObject({'kind': f1, 'ref': f2, 'args': _g2, 'ret': f.ret, 'expr': f.expr})
            if ((not self.inlineCalls) or ((f.kind != hxsl_FunctionKind.Helper))):
                funs.append(f21)
            self.funMap.set(f21.ref,f)
        _g22 = 0
        _g3 = len(funs)
        while (_g22 < _g3):
            i = _g22
            _g22 = (_g22 + 1)
            self.curFun = (funs[i] if i >= 0 and i < len(funs) else None)
            self.curFun.expr = self.evalExpr(self.curFun.expr,False)
        s1 = s.name
        _g4 = []
        _g5 = 0
        _g6 = s.vars
        while (_g5 < len(_g6)):
            v = (_g6[_g5] if _g5 >= 0 and _g5 < len(_g6) else None)
            _g5 = (_g5 + 1)
            x1 = self.mapVar(v)
            _g4.append(x1)
        return _hx_AnonObject({'name': s1, 'vars': _g4, 'funs': funs})

    def hasReturn(self,e):
        self.markReturn = False
        self.hasReturnLoop(e)
        return self.markReturn

    def hasReturnLoop(self,e):
        _g = e.e
        if (_g.index == 12):
            _g1 = _g.params[0]
            self.markReturn = True
        elif (not self.markReturn):
            hxsl_Tools.iter(e,self.hasReturnLoop)

    def handleReturn(self,e,isFinal = None):
        if (isFinal is None):
            isFinal = False
        _g = e.e
        tmp = _g.index
        if (tmp == 3):
            v = _g.params[0]
            v1 = self.handleReturn(v,isFinal)
            return _hx_AnonObject({'e': hxsl_TExprDef.TParenthesis(v1), 't': v1.t, 'p': e.p})
        elif (tmp == 4):
            el = _g.params[0]
            i = 0
            last = len(el)
            out = []
            while (i < last):
                e1 = i
                i = (i + 1)
                e2 = (el[e1] if e1 >= 0 and e1 < len(el) else None)
                if (i == last):
                    x = self.handleReturn(e2,isFinal)
                    out.append(x)
                else:
                    _g1 = e2.e
                    tmp1 = _g1.index
                    if (tmp1 == 10):
                        if (_g1.params[2] is None):
                            econd = _g1.params[0]
                            eif = _g1.params[1]
                            if (isFinal and self.hasReturn(eif)):
                                x1 = self.handleReturn(_hx_AnonObject({'e': hxsl_TExprDef.TIf(econd,eif,_hx_AnonObject({'e': hxsl_TExprDef.TBlock(el[i:None]), 't': e2.t, 'p': e2.p})), 't': e2.t, 'p': e2.p}))
                                out.append(x1)
                                break
                            else:
                                x2 = self.handleReturn(e2)
                                out.append(x2)
                        else:
                            x3 = self.handleReturn(e2)
                            out.append(x3)
                    elif (tmp1 == 12):
                        e3 = _g1.params[0]
                        x4 = self.handleReturn(e3,isFinal)
                        out.append(x4)
                        break
                    else:
                        x5 = self.handleReturn(e2)
                        out.append(x5)
            t = (python_internal_ArrayImpl._get(out, (len(out) - 1)).t if isFinal else e.t)
            return _hx_AnonObject({'e': hxsl_TExprDef.TBlock(out), 't': t, 'p': e.p})
        elif (tmp == 10):
            eelse = _g.params[2]
            eif1 = _g.params[1]
            cond = _g.params[0]
            if ((eelse is not None) and isFinal):
                cond1 = self.handleReturn(cond)
                eif2 = self.handleReturn(eif1,isFinal)
                return _hx_AnonObject({'e': hxsl_TExprDef.TIf(cond1,eif2,self.handleReturn(eelse,isFinal)), 't': eif2.t, 'p': e.p})
            else:
                return hxsl_Tools.map(e,self.handleReturnDef)
        elif (tmp == 12):
            v2 = _g.params[0]
            if (not isFinal):
                hxsl_Error.t("Cannot inline not final return",e.p)
            if (v2 is None):
                return _hx_AnonObject({'e': hxsl_TExprDef.TBlock([]), 't': hxsl_Type.TVoid, 'p': e.p})
            return self.handleReturn(v2,True)
        else:
            return hxsl_Tools.map(e,self.handleReturnDef)

    def handleReturnDef(self,e):
        return self.handleReturn(e)

    def evalCall(self,g,args,oldArgs,pos):
        tmp = g.index
        if (tmp == 38):
            if (len(args) == 1):
                _g = (args[0] if 0 < len(args) else None)
                _g3 = _g.t
                _g2 = _g.p
                _g1 = _g.e
                if (_g1.index == 0):
                    _g4 = _g1.params[0]
                    if (_g4.index == 2):
                        i = _g4.params[0]
                        return hxsl_TExprDef.TConst(hxsl_Const.CFloat(i))
                    else:
                        return None
                else:
                    return None
            else:
                return None
        elif ((tmp == 64) or ((tmp == 63))):
            i1 = None
            _g5 = (args[0] if 0 < len(args) else None).e
            if (_g5.index == 0):
                _g11 = _g5.params[0]
                if (_g11.index == 2):
                    i2 = _g11.params[0]
                    i1 = i2
                else:
                    hxsl_Error.t(((("Cannot eval complex channel " + HxOverrides.stringOrNull(hxsl_Printer.toString((args[0] if 0 < len(args) else None),True))) + " ") + HxOverrides.stringOrNull(self.constantsToString())),pos)
                    raise _HxException("assert")
            else:
                hxsl_Error.t(((("Cannot eval complex channel " + HxOverrides.stringOrNull(hxsl_Printer.toString((args[0] if 0 < len(args) else None),True))) + " ") + HxOverrides.stringOrNull(self.constantsToString())),pos)
                raise _HxException("assert")
            channel = (oldArgs[0] if 0 < len(oldArgs) else None)
            _g31 = channel.e
            channel1 = None
            if (_g31.index == 1):
                v = _g31.params[0]
                channel1 = hxsl_TExprDef.TVar(self.mapVar(v))
            else:
                raise _HxException("assert")
            channel = _hx_AnonObject({'e': channel1, 't': channel.t, 'p': channel.p})
            count = None
            _g51 = channel.t
            if (_g51.index == 17):
                i3 = _g51.params[0]
                count = i3
            else:
                raise _HxException("assert")
            channelMode = Type.createEnumIndex(hxsl_Channel,(i1 & 7),None)
            targs = [channel]
            _g7 = 1
            _g8 = len(args)
            while (_g7 < _g8):
                i4 = _g7
                _g7 = (_g7 + 1)
                targs.append((args[i4] if i4 >= 0 and i4 < len(args) else None))
            targs.append(_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt((i1 >> 3))), 't': hxsl_Type.TInt, 'p': pos}))
            tget = _hx_AnonObject({'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(g), 't': hxsl_Type.TVoid, 'p': pos}),targs), 't': hxsl_Type.TVoid, 'p': pos})
            tmp1 = channelMode.index
            if (tmp1 == 0):
                zero = _hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CFloat(0.)), 't': hxsl_Type.TFloat, 'p': pos})
                if (count == 1):
                    return zero.e
                return hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(python_internal_ArrayImpl._get([hxsl_TGlobal.Vec2, hxsl_TGlobal.Vec3, hxsl_TGlobal.Vec4], (count - 2))), 't': hxsl_Type.TVoid, 'p': pos}),[zero])
            elif ((((tmp1 == 4) or ((tmp1 == 3))) or ((tmp1 == 2))) or ((tmp1 == 1))):
                tmp2 = None
                count1 = count
                if (count1 == 1):
                    tmp3 = channelMode.index
                    if (tmp3 == 1):
                        tmp2 = [hxsl_Component.X]
                    elif (tmp3 == 2):
                        tmp2 = [hxsl_Component.Y]
                    elif (tmp3 == 3):
                        tmp2 = [hxsl_Component.Z]
                    elif (tmp3 == 4):
                        tmp2 = [hxsl_Component.W]
                    else:
                        raise _HxException((((("Invalid channel value " + Std.string(channelMode)) + " for ") + Std.string(count)) + " channels"))
                elif (count1 == 2):
                    tmp4 = channelMode.index
                    if (tmp4 == 1):
                        tmp2 = [hxsl_Component.X, hxsl_Component.Y]
                    elif (tmp4 == 2):
                        tmp2 = [hxsl_Component.Y, hxsl_Component.Z]
                    elif (tmp4 == 3):
                        tmp2 = [hxsl_Component.Z, hxsl_Component.W]
                    else:
                        raise _HxException((((("Invalid channel value " + Std.string(channelMode)) + " for ") + Std.string(count)) + " channels"))
                elif (count1 == 3):
                    tmp5 = channelMode.index
                    if (tmp5 == 1):
                        tmp2 = [hxsl_Component.X, hxsl_Component.Y, hxsl_Component.Z]
                    elif (tmp5 == 2):
                        tmp2 = [hxsl_Component.Y, hxsl_Component.Z, hxsl_Component.W]
                    else:
                        raise _HxException((((("Invalid channel value " + Std.string(channelMode)) + " for ") + Std.string(count)) + " channels"))
                else:
                    raise _HxException((((("Invalid channel value " + Std.string(channelMode)) + " for ") + Std.string(count)) + " channels"))
                return hxsl_TExprDef.TSwiz(tget,tmp2)
            elif (tmp1 == 5):
                return hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(hxsl_TGlobal.Unpack), 't': hxsl_Type.TVoid, 'p': pos}),[tget])
            elif (tmp1 == 6):
                return hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(hxsl_TGlobal.UnpackNormal), 't': hxsl_Type.TVoid, 'p': pos}),[tget])
            else:
                pass
        elif (tmp == 67):
            args1 = args
            _g6 = 0
            while (_g6 < len(args1)):
                a = (args1[_g6] if _g6 >= 0 and _g6 < len(args1) else None)
                _g6 = (_g6 + 1)
                haxe_Log.trace(hxsl_Printer.toString(a),_hx_AnonObject({'fileName': a.p.file, 'lineNumber': 0, 'className': None, 'methodName': None}))
            return hxsl_TExprDef.TBlock([])
        else:
            return None

    def constantsToString(self):
        _g = []
        c = self.constants.keys()
        while c.hasNext():
            c1 = c.next()
            x = ((Std.string(c1) + " => ") + HxOverrides.stringOrNull(hxsl_Printer.toString(_hx_AnonObject({'e': self.constants.h.get(c1,None), 't': hxsl_Type.TVoid, 'p': None}),True)))
            _g.append(x)
        return (("[" + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in _g]))) + "]")

    def ifBlock(self,e):
        tmp = None
        if (e is not None):
            _g = e.e
            tmp1 = None
            if (_g.index == 10):
                _g3 = _g.params[2]
                _g2 = _g.params[1]
                _g1 = _g.params[0]
                tmp1 = True
            else:
                tmp1 = False
            tmp = (not tmp1)
        else:
            tmp = True
        if tmp:
            return e
        return _hx_AnonObject({'e': hxsl_TExprDef.TBlock([e]), 't': e.t, 'p': e.p})

    def evalExpr(self,e,isVal = None):
        if (isVal is None):
            isVal = True
        _gthis = self
        d = None
        _g = e.e
        d1 = _g.index
        if (d1 == 0):
            _g26 = _g.params[0]
            d = e.e
        elif (d1 == 1):
            v = _g.params[0]
            c = self.constants.h.get(v.id,None)
            if (c is not None):
                d = c
            else:
                v2 = self.mapVar(v)
                d = hxsl_TExprDef.TVar(v2)
        elif (d1 == 2):
            _g4 = _g.params[0]
            d = e.e
        elif (d1 == 3):
            e1 = _g.params[0]
            e2 = self.evalExpr(e1,isVal)
            _g1 = e2.e
            if (_g1.index == 0):
                _g11 = _g1.params[0]
                d = e2.e
            else:
                d = hxsl_TExprDef.TParenthesis(e2)
        elif (d1 == 4):
            el = _g.params[0]
            out = []
            last = (len(el) - 1)
            _g2 = 0
            _g12 = len(el)
            while (_g2 < _g12):
                i = _g2
                _g2 = (_g2 + 1)
                isVal1 = (isVal and ((i == last)))
                e3 = self.evalExpr((el[i] if i >= 0 and i < len(el) else None),isVal1)
                _g3 = e3.e
                d2 = _g3.index
                if (d2 == 0):
                    _g21 = _g3.params[0]
                    if (not ((not isVal1))):
                        out.append(e3)
                elif (d2 == 1):
                    _g13 = _g3.params[0]
                    if (not ((not isVal1))):
                        out.append(e3)
                else:
                    out.append(e3)
            d = ((out[0] if 0 < len(out) else None).e if (((len(out) == 1) and ((self.curFun.kind != hxsl_FunctionKind.Init)))) else hxsl_TExprDef.TBlock(out))
        elif (d1 == 5):
            e21 = _g.params[2]
            e11 = _g.params[1]
            op = _g.params[0]
            e12 = self.evalExpr(e11)
            e22 = self.evalExpr(e21)
            d3 = op.index
            if (d3 == 0):
                _g5 = e22.e
                _g14 = e12.e
                if (_g14.index == 0):
                    _g22 = _g14.params[0]
                    d4 = _g22.index
                    if (d4 == 2):
                        if (_g5.index == 0):
                            _g7 = _g5.params[0]
                            if (_g7.index == 2):
                                a = _g22.params[0]
                                b = _g7.params[0]
                                x = (a + b)
                                d5 = None
                                try:
                                    d5 = int(x)
                                except Exception as _hx_e:
                                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                                    e4 = _hx_e1
                                    d5 = None
                                d = hxsl_TExprDef.TConst(hxsl_Const.CInt(d5))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e12,e22)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e12,e22)
                    elif (d4 == 3):
                        if (_g5.index == 0):
                            _g41 = _g5.params[0]
                            if (_g41.index == 3):
                                a1 = _g22.params[0]
                                b1 = _g41.params[0]
                                d = hxsl_TExprDef.TConst(hxsl_Const.CFloat((a1 + b1)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e12,e22)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e12,e22)
                    else:
                        d = hxsl_TExprDef.TBinop(op,e12,e22)
                else:
                    d = hxsl_TExprDef.TBinop(op,e12,e22)
            elif (d3 == 1):
                _g6 = e22.e
                _g15 = e12.e
                if (_g15.index == 0):
                    _g23 = _g15.params[0]
                    d6 = _g23.index
                    if (d6 == 2):
                        if (_g6.index == 0):
                            _g71 = _g6.params[0]
                            if (_g71.index == 2):
                                a2 = _g23.params[0]
                                b2 = _g71.params[0]
                                x1 = (a2 * b2)
                                d7 = None
                                try:
                                    d7 = int(x1)
                                except Exception as _hx_e:
                                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                                    e5 = _hx_e1
                                    d7 = None
                                d = hxsl_TExprDef.TConst(hxsl_Const.CInt(d7))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e12,e22)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e12,e22)
                    elif (d6 == 3):
                        if (_g6.index == 0):
                            _g42 = _g6.params[0]
                            if (_g42.index == 3):
                                a3 = _g23.params[0]
                                b3 = _g42.params[0]
                                d = hxsl_TExprDef.TConst(hxsl_Const.CFloat((a3 * b3)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e12,e22)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e12,e22)
                    else:
                        d = hxsl_TExprDef.TBinop(op,e12,e22)
                else:
                    d = hxsl_TExprDef.TBinop(op,e12,e22)
            elif (d3 == 2):
                _g8 = e22.e
                _g16 = e12.e
                if (_g16.index == 0):
                    _g24 = _g16.params[0]
                    d8 = _g24.index
                    if (d8 == 2):
                        if (_g8.index == 0):
                            _g72 = _g8.params[0]
                            if (_g72.index == 2):
                                a4 = _g24.params[0]
                                b4 = _g72.params[0]
                                x2 = (a4 / b4)
                                d9 = None
                                try:
                                    d9 = int(x2)
                                except Exception as _hx_e:
                                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                                    e6 = _hx_e1
                                    d9 = None
                                d = hxsl_TExprDef.TConst(hxsl_Const.CInt(d9))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e12,e22)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e12,e22)
                    elif (d8 == 3):
                        if (_g8.index == 0):
                            _g43 = _g8.params[0]
                            if (_g43.index == 3):
                                a5 = _g24.params[0]
                                b5 = _g43.params[0]
                                d = hxsl_TExprDef.TConst(hxsl_Const.CFloat((a5 / b5)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e12,e22)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e12,e22)
                    else:
                        d = hxsl_TExprDef.TBinop(op,e12,e22)
                else:
                    d = hxsl_TExprDef.TBinop(op,e12,e22)
            elif (d3 == 3):
                _g9 = e22.e
                _g17 = e12.e
                if (_g17.index == 0):
                    _g25 = _g17.params[0]
                    d10 = _g25.index
                    if (d10 == 2):
                        if (_g9.index == 0):
                            _g73 = _g9.params[0]
                            if (_g73.index == 2):
                                a6 = _g25.params[0]
                                b6 = _g73.params[0]
                                x3 = (a6 - b6)
                                d11 = None
                                try:
                                    d11 = int(x3)
                                except Exception as _hx_e:
                                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                                    e7 = _hx_e1
                                    d11 = None
                                d = hxsl_TExprDef.TConst(hxsl_Const.CInt(d11))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e12,e22)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e12,e22)
                    elif (d10 == 3):
                        if (_g9.index == 0):
                            _g44 = _g9.params[0]
                            if (_g44.index == 3):
                                a7 = _g25.params[0]
                                b7 = _g44.params[0]
                                d = hxsl_TExprDef.TConst(hxsl_Const.CFloat((a7 - b7)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e12,e22)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e12,e22)
                    else:
                        d = hxsl_TExprDef.TBinop(op,e12,e22)
                else:
                    d = hxsl_TExprDef.TBinop(op,e12,e22)
            elif ((d3 == 21) or ((d3 == 4))):
                d = hxsl_TExprDef.TBinop(op,e12,e22)
            elif (d3 == 5):
                _g10 = e22.e
                _g18 = e12.e
                if (_g18.index == 0):
                    _g27 = _g18.params[0]
                    d12 = _g27.index
                    if (d12 == 0):
                        d = ((hxsl_TExprDef.TConst(hxsl_Const.CBool(True)) if ((_g10.params[0].index == 0)) else hxsl_TExprDef.TConst(hxsl_Const.CBool(False))) if ((_g10.index == 0)) else hxsl_TExprDef.TBinop(op,e12,e22))
                    elif (d12 == 1):
                        _g91 = _g27.params[0]
                        if (_g10.index == 0):
                            _g101 = _g10.params[0]
                            d13 = _g101.index
                            if (d13 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(False))
                            elif (d13 == 1):
                                a8 = _g91
                                b8 = _g101.params[0]
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool((((0 if ((a8 == b8)) else 1)) == 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e12,e22)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e12,e22)
                    elif (d12 == 2):
                        _g121 = _g27.params[0]
                        if (_g10.index == 0):
                            _g131 = _g10.params[0]
                            d14 = _g131.index
                            if (d14 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(False))
                            elif (d14 == 2):
                                a9 = _g121
                                b9 = _g131.params[0]
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(((a9 - b9) == 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e12,e22)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e12,e22)
                    elif (d12 == 3):
                        _g61 = _g27.params[0]
                        if (_g10.index == 0):
                            _g74 = _g10.params[0]
                            d15 = _g74.index
                            if (d15 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(False))
                            elif (d15 == 3):
                                a10 = _g61
                                b10 = _g74.params[0]
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool((((1 if ((a10 > b10)) else (0 if ((a10 == b10)) else -1))) == 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e12,e22)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e12,e22)
                    elif (d12 == 4):
                        _g31 = _g27.params[0]
                        if (_g10.index == 0):
                            _g45 = _g10.params[0]
                            d16 = _g45.index
                            if (d16 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(False))
                            elif (d16 == 4):
                                a11 = _g31
                                b11 = _g45.params[0]
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool((((1 if ((a11 > b11)) else (0 if ((a11 == b11)) else -1))) == 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e12,e22)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e12,e22)
                    else:
                        pass
                else:
                    d = hxsl_TExprDef.TBinop(op,e12,e22)
            elif (d3 == 6):
                _g19 = e22.e
                _g110 = e12.e
                if (_g110.index == 0):
                    _g28 = _g110.params[0]
                    d17 = _g28.index
                    if (d17 == 0):
                        d = ((hxsl_TExprDef.TConst(hxsl_Const.CBool(False)) if ((_g19.params[0].index == 0)) else hxsl_TExprDef.TConst(hxsl_Const.CBool(True))) if ((_g19.index == 0)) else hxsl_TExprDef.TBinop(op,e12,e22))
                    elif (d17 == 1):
                        _g92 = _g28.params[0]
                        if (_g19.index == 0):
                            _g102 = _g19.params[0]
                            d18 = _g102.index
                            if (d18 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(True))
                            elif (d18 == 1):
                                a12 = _g92
                                b12 = _g102.params[0]
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool((((0 if ((a12 == b12)) else 1)) != 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e12,e22)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e12,e22)
                    elif (d17 == 2):
                        _g122 = _g28.params[0]
                        if (_g19.index == 0):
                            _g132 = _g19.params[0]
                            d19 = _g132.index
                            if (d19 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(True))
                            elif (d19 == 2):
                                a13 = _g122
                                b13 = _g132.params[0]
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(((a13 - b13) != 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e12,e22)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e12,e22)
                    elif (d17 == 3):
                        _g62 = _g28.params[0]
                        if (_g19.index == 0):
                            _g75 = _g19.params[0]
                            d20 = _g75.index
                            if (d20 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(True))
                            elif (d20 == 3):
                                a14 = _g62
                                b14 = _g75.params[0]
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool((((1 if ((a14 > b14)) else (0 if ((a14 == b14)) else -1))) != 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e12,e22)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e12,e22)
                    elif (d17 == 4):
                        _g32 = _g28.params[0]
                        if (_g19.index == 0):
                            _g46 = _g19.params[0]
                            d21 = _g46.index
                            if (d21 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(True))
                            elif (d21 == 4):
                                a15 = _g32
                                b15 = _g46.params[0]
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool((((1 if ((a15 > b15)) else (0 if ((a15 == b15)) else -1))) != 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e12,e22)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e12,e22)
                    else:
                        pass
                else:
                    d = hxsl_TExprDef.TBinop(op,e12,e22)
            elif (d3 == 7):
                _g20 = e22.e
                _g111 = e12.e
                if (_g111.index == 0):
                    _g29 = _g111.params[0]
                    d22 = _g29.index
                    if (d22 == 0):
                        d = ((hxsl_TExprDef.TConst(hxsl_Const.CBool(False)) if ((_g20.params[0].index == 0)) else hxsl_TExprDef.TConst(hxsl_Const.CBool(False))) if ((_g20.index == 0)) else hxsl_TExprDef.TBinop(op,e12,e22))
                    elif (d22 == 1):
                        _g93 = _g29.params[0]
                        if (_g20.index == 0):
                            _g103 = _g20.params[0]
                            d23 = _g103.index
                            if (d23 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(True))
                            elif (d23 == 1):
                                a16 = _g93
                                b16 = _g103.params[0]
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool((((0 if ((a16 == b16)) else 1)) > 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e12,e22)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e12,e22)
                    elif (d22 == 2):
                        _g123 = _g29.params[0]
                        if (_g20.index == 0):
                            _g133 = _g20.params[0]
                            d24 = _g133.index
                            if (d24 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(True))
                            elif (d24 == 2):
                                a17 = _g123
                                b17 = _g133.params[0]
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(((a17 - b17) > 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e12,e22)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e12,e22)
                    elif (d22 == 3):
                        _g63 = _g29.params[0]
                        if (_g20.index == 0):
                            _g76 = _g20.params[0]
                            d25 = _g76.index
                            if (d25 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(True))
                            elif (d25 == 3):
                                a18 = _g63
                                b18 = _g76.params[0]
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool((((1 if ((a18 > b18)) else (0 if ((a18 == b18)) else -1))) > 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e12,e22)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e12,e22)
                    elif (d22 == 4):
                        _g33 = _g29.params[0]
                        if (_g20.index == 0):
                            _g47 = _g20.params[0]
                            d26 = _g47.index
                            if (d26 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(True))
                            elif (d26 == 4):
                                a19 = _g33
                                b19 = _g47.params[0]
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool((((1 if ((a19 > b19)) else (0 if ((a19 == b19)) else -1))) > 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e12,e22)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e12,e22)
                    else:
                        pass
                else:
                    d = hxsl_TExprDef.TBinop(op,e12,e22)
            elif (d3 == 8):
                _g30 = e22.e
                _g112 = e12.e
                if (_g112.index == 0):
                    _g210 = _g112.params[0]
                    d27 = _g210.index
                    if (d27 == 0):
                        d = ((hxsl_TExprDef.TConst(hxsl_Const.CBool(True)) if ((_g30.params[0].index == 0)) else hxsl_TExprDef.TConst(hxsl_Const.CBool(False))) if ((_g30.index == 0)) else hxsl_TExprDef.TBinop(op,e12,e22))
                    elif (d27 == 1):
                        _g94 = _g210.params[0]
                        if (_g30.index == 0):
                            _g104 = _g30.params[0]
                            d28 = _g104.index
                            if (d28 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(True))
                            elif (d28 == 1):
                                a20 = _g94
                                b20 = _g104.params[0]
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool((((0 if ((a20 == b20)) else 1)) >= 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e12,e22)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e12,e22)
                    elif (d27 == 2):
                        _g124 = _g210.params[0]
                        if (_g30.index == 0):
                            _g134 = _g30.params[0]
                            d29 = _g134.index
                            if (d29 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(True))
                            elif (d29 == 2):
                                a21 = _g124
                                b21 = _g134.params[0]
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(((a21 - b21) >= 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e12,e22)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e12,e22)
                    elif (d27 == 3):
                        _g64 = _g210.params[0]
                        if (_g30.index == 0):
                            _g77 = _g30.params[0]
                            d30 = _g77.index
                            if (d30 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(True))
                            elif (d30 == 3):
                                a22 = _g64
                                b22 = _g77.params[0]
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool((((1 if ((a22 > b22)) else (0 if ((a22 == b22)) else -1))) >= 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e12,e22)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e12,e22)
                    elif (d27 == 4):
                        _g34 = _g210.params[0]
                        if (_g30.index == 0):
                            _g48 = _g30.params[0]
                            d31 = _g48.index
                            if (d31 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(True))
                            elif (d31 == 4):
                                a23 = _g34
                                b23 = _g48.params[0]
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool((((1 if ((a23 > b23)) else (0 if ((a23 == b23)) else -1))) >= 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e12,e22)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e12,e22)
                    else:
                        pass
                else:
                    d = hxsl_TExprDef.TBinop(op,e12,e22)
            elif (d3 == 9):
                _g35 = e22.e
                _g113 = e12.e
                if (_g113.index == 0):
                    _g211 = _g113.params[0]
                    d32 = _g211.index
                    if (d32 == 0):
                        d = ((hxsl_TExprDef.TConst(hxsl_Const.CBool(False)) if ((_g35.params[0].index == 0)) else hxsl_TExprDef.TConst(hxsl_Const.CBool(True))) if ((_g35.index == 0)) else hxsl_TExprDef.TBinop(op,e12,e22))
                    elif (d32 == 1):
                        _g95 = _g211.params[0]
                        if (_g35.index == 0):
                            _g105 = _g35.params[0]
                            d33 = _g105.index
                            if (d33 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(False))
                            elif (d33 == 1):
                                a24 = _g95
                                b24 = _g105.params[0]
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool((((0 if ((a24 == b24)) else 1)) < 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e12,e22)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e12,e22)
                    elif (d32 == 2):
                        _g125 = _g211.params[0]
                        if (_g35.index == 0):
                            _g135 = _g35.params[0]
                            d34 = _g135.index
                            if (d34 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(False))
                            elif (d34 == 2):
                                a25 = _g125
                                b25 = _g135.params[0]
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(((a25 - b25) < 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e12,e22)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e12,e22)
                    elif (d32 == 3):
                        _g65 = _g211.params[0]
                        if (_g35.index == 0):
                            _g78 = _g35.params[0]
                            d35 = _g78.index
                            if (d35 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(False))
                            elif (d35 == 3):
                                a26 = _g65
                                b26 = _g78.params[0]
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool((((1 if ((a26 > b26)) else (0 if ((a26 == b26)) else -1))) < 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e12,e22)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e12,e22)
                    elif (d32 == 4):
                        _g36 = _g211.params[0]
                        if (_g35.index == 0):
                            _g49 = _g35.params[0]
                            d36 = _g49.index
                            if (d36 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(False))
                            elif (d36 == 4):
                                a27 = _g36
                                b27 = _g49.params[0]
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool((((1 if ((a27 > b27)) else (0 if ((a27 == b27)) else -1))) < 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e12,e22)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e12,e22)
                    else:
                        pass
                else:
                    d = hxsl_TExprDef.TBinop(op,e12,e22)
            elif (d3 == 10):
                _g37 = e22.e
                _g114 = e12.e
                if (_g114.index == 0):
                    _g212 = _g114.params[0]
                    d37 = _g212.index
                    if (d37 == 0):
                        d = ((hxsl_TExprDef.TConst(hxsl_Const.CBool(True)) if ((_g37.params[0].index == 0)) else hxsl_TExprDef.TConst(hxsl_Const.CBool(True))) if ((_g37.index == 0)) else hxsl_TExprDef.TBinop(op,e12,e22))
                    elif (d37 == 1):
                        _g96 = _g212.params[0]
                        if (_g37.index == 0):
                            _g106 = _g37.params[0]
                            d38 = _g106.index
                            if (d38 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(False))
                            elif (d38 == 1):
                                a28 = _g96
                                b28 = _g106.params[0]
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool((((0 if ((a28 == b28)) else 1)) <= 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e12,e22)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e12,e22)
                    elif (d37 == 2):
                        _g126 = _g212.params[0]
                        if (_g37.index == 0):
                            _g136 = _g37.params[0]
                            d39 = _g136.index
                            if (d39 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(False))
                            elif (d39 == 2):
                                a29 = _g126
                                b29 = _g136.params[0]
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(((a29 - b29) <= 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e12,e22)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e12,e22)
                    elif (d37 == 3):
                        _g66 = _g212.params[0]
                        if (_g37.index == 0):
                            _g79 = _g37.params[0]
                            d40 = _g79.index
                            if (d40 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(False))
                            elif (d40 == 3):
                                a30 = _g66
                                b30 = _g79.params[0]
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool((((1 if ((a30 > b30)) else (0 if ((a30 == b30)) else -1))) <= 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e12,e22)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e12,e22)
                    elif (d37 == 4):
                        _g38 = _g212.params[0]
                        if (_g37.index == 0):
                            _g410 = _g37.params[0]
                            d41 = _g410.index
                            if (d41 == 0):
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool(False))
                            elif (d41 == 4):
                                a31 = _g38
                                b31 = _g410.params[0]
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool((((1 if ((a31 > b31)) else (0 if ((a31 == b31)) else -1))) <= 0)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e12,e22)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e12,e22)
                    else:
                        pass
                else:
                    d = hxsl_TExprDef.TBinop(op,e12,e22)
            elif (d3 == 11):
                _g39 = e22.e
                _g115 = e12.e
                if (_g115.index == 0):
                    _g213 = _g115.params[0]
                    if (_g213.index == 2):
                        if (_g39.index == 0):
                            _g411 = _g39.params[0]
                            if (_g411.index == 2):
                                a32 = _g213.params[0]
                                b32 = _g411.params[0]
                                d = hxsl_TExprDef.TConst(hxsl_Const.CInt((a32 & b32)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e12,e22)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e12,e22)
                    else:
                        d = hxsl_TExprDef.TBinop(op,e12,e22)
                else:
                    d = hxsl_TExprDef.TBinop(op,e12,e22)
            elif (d3 == 12):
                _g40 = e22.e
                _g116 = e12.e
                if (_g116.index == 0):
                    _g214 = _g116.params[0]
                    if (_g214.index == 2):
                        if (_g40.index == 0):
                            _g412 = _g40.params[0]
                            if (_g412.index == 2):
                                a33 = _g214.params[0]
                                b33 = _g412.params[0]
                                d = hxsl_TExprDef.TConst(hxsl_Const.CInt((a33 | b33)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e12,e22)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e12,e22)
                    else:
                        d = hxsl_TExprDef.TBinop(op,e12,e22)
                else:
                    d = hxsl_TExprDef.TBinop(op,e12,e22)
            elif (d3 == 13):
                _g50 = e22.e
                _g117 = e12.e
                if (_g117.index == 0):
                    _g215 = _g117.params[0]
                    if (_g215.index == 2):
                        if (_g50.index == 0):
                            _g413 = _g50.params[0]
                            if (_g413.index == 2):
                                a34 = _g215.params[0]
                                b34 = _g413.params[0]
                                d = hxsl_TExprDef.TConst(hxsl_Const.CInt((a34 ^ b34)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e12,e22)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e12,e22)
                    else:
                        d = hxsl_TExprDef.TBinop(op,e12,e22)
                else:
                    d = hxsl_TExprDef.TBinop(op,e12,e22)
            elif (d3 == 14):
                _g51 = e22.e
                _g118 = e12.e
                if (_g118.index == 0):
                    _g216 = _g118.params[0]
                    if (_g216.index == 1):
                        _g310 = _g216.params[0]
                        if (_g51.index == 0):
                            _g414 = _g51.params[0]
                            if (_g414.index == 1):
                                a35 = _g310
                                b35 = _g414.params[0]
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool((a35 and b35)))
                            else:
                                a36 = _g310
                                d = (hxsl_TExprDef.TConst(hxsl_Const.CBool(a36)) if ((a36 == False)) else e22.e)
                        else:
                            a37 = _g310
                            d = (hxsl_TExprDef.TConst(hxsl_Const.CBool(a37)) if ((a37 == False)) else e22.e)
                    elif (_g51.index == 0):
                        _g67 = _g51.params[0]
                        if (_g67.index == 1):
                            a38 = _g67.params[0]
                            d = (hxsl_TExprDef.TConst(hxsl_Const.CBool(a38)) if ((a38 == False)) else e12.e)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e12,e22)
                    else:
                        d = hxsl_TExprDef.TBinop(op,e12,e22)
                elif (_g51.index == 0):
                    _g81 = _g51.params[0]
                    if (_g81.index == 1):
                        a39 = _g81.params[0]
                        d = (hxsl_TExprDef.TConst(hxsl_Const.CBool(a39)) if ((a39 == False)) else e12.e)
                    else:
                        d = hxsl_TExprDef.TBinop(op,e12,e22)
                else:
                    d = hxsl_TExprDef.TBinop(op,e12,e22)
            elif (d3 == 15):
                _g52 = e22.e
                _g119 = e12.e
                if (_g119.index == 0):
                    _g217 = _g119.params[0]
                    if (_g217.index == 1):
                        _g311 = _g217.params[0]
                        if (_g52.index == 0):
                            _g415 = _g52.params[0]
                            if (_g415.index == 1):
                                a40 = _g311
                                b36 = _g415.params[0]
                                d = hxsl_TExprDef.TConst(hxsl_Const.CBool((a40 or b36)))
                            else:
                                a41 = _g311
                                d = (hxsl_TExprDef.TConst(hxsl_Const.CBool(a41)) if ((a41 == True)) else e22.e)
                        else:
                            a42 = _g311
                            d = (hxsl_TExprDef.TConst(hxsl_Const.CBool(a42)) if ((a42 == True)) else e22.e)
                    elif (_g52.index == 0):
                        _g68 = _g52.params[0]
                        if (_g68.index == 1):
                            a43 = _g68.params[0]
                            d = (hxsl_TExprDef.TConst(hxsl_Const.CBool(a43)) if ((a43 == True)) else e12.e)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e12,e22)
                    else:
                        d = hxsl_TExprDef.TBinop(op,e12,e22)
                elif (_g52.index == 0):
                    _g82 = _g52.params[0]
                    if (_g82.index == 1):
                        a44 = _g82.params[0]
                        d = (hxsl_TExprDef.TConst(hxsl_Const.CBool(a44)) if ((a44 == True)) else e12.e)
                    else:
                        d = hxsl_TExprDef.TBinop(op,e12,e22)
                else:
                    d = hxsl_TExprDef.TBinop(op,e12,e22)
            elif (d3 == 16):
                _g53 = e22.e
                _g120 = e12.e
                if (_g120.index == 0):
                    _g218 = _g120.params[0]
                    if (_g218.index == 2):
                        if (_g53.index == 0):
                            _g416 = _g53.params[0]
                            if (_g416.index == 2):
                                a45 = _g218.params[0]
                                b37 = _g416.params[0]
                                d = hxsl_TExprDef.TConst(hxsl_Const.CInt((a45 << b37)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e12,e22)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e12,e22)
                    else:
                        d = hxsl_TExprDef.TBinop(op,e12,e22)
                else:
                    d = hxsl_TExprDef.TBinop(op,e12,e22)
            elif (d3 == 17):
                _g54 = e22.e
                _g127 = e12.e
                if (_g127.index == 0):
                    _g219 = _g127.params[0]
                    if (_g219.index == 2):
                        if (_g54.index == 0):
                            _g417 = _g54.params[0]
                            if (_g417.index == 2):
                                a46 = _g219.params[0]
                                b38 = _g417.params[0]
                                d = hxsl_TExprDef.TConst(hxsl_Const.CInt((a46 >> b38)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e12,e22)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e12,e22)
                    else:
                        d = hxsl_TExprDef.TBinop(op,e12,e22)
                else:
                    d = hxsl_TExprDef.TBinop(op,e12,e22)
            elif (d3 == 18):
                _g55 = e22.e
                _g128 = e12.e
                if (_g128.index == 0):
                    _g220 = _g128.params[0]
                    if (_g220.index == 2):
                        if (_g55.index == 0):
                            _g418 = _g55.params[0]
                            if (_g418.index == 2):
                                a47 = _g220.params[0]
                                b39 = _g418.params[0]
                                d = hxsl_TExprDef.TConst(hxsl_Const.CInt(HxOverrides.rshift(a47, b39)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e12,e22)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e12,e22)
                    else:
                        d = hxsl_TExprDef.TBinop(op,e12,e22)
                else:
                    d = hxsl_TExprDef.TBinop(op,e12,e22)
            elif (d3 == 19):
                _g56 = e22.e
                _g129 = e12.e
                if (_g129.index == 0):
                    _g221 = _g129.params[0]
                    d42 = _g221.index
                    if (d42 == 2):
                        if (_g56.index == 0):
                            _g710 = _g56.params[0]
                            if (_g710.index == 2):
                                a48 = _g221.params[0]
                                b40 = _g710.params[0]
                                x4 = HxOverrides.mod(a48, b40)
                                d43 = None
                                try:
                                    d43 = int(x4)
                                except Exception as _hx_e:
                                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                                    e8 = _hx_e1
                                    d43 = None
                                d = hxsl_TExprDef.TConst(hxsl_Const.CInt(d43))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e12,e22)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e12,e22)
                    elif (d42 == 3):
                        if (_g56.index == 0):
                            _g419 = _g56.params[0]
                            if (_g419.index == 3):
                                a49 = _g221.params[0]
                                b41 = _g419.params[0]
                                d = hxsl_TExprDef.TConst(hxsl_Const.CFloat(HxOverrides.modf(a49, b41)))
                            else:
                                d = hxsl_TExprDef.TBinop(op,e12,e22)
                        else:
                            d = hxsl_TExprDef.TBinop(op,e12,e22)
                    else:
                        d = hxsl_TExprDef.TBinop(op,e12,e22)
                else:
                    d = hxsl_TExprDef.TBinop(op,e12,e22)
            elif (d3 == 20):
                _g57 = op.params[0]
                d = hxsl_TExprDef.TBinop(op,e12,e22)
            elif (d3 == 22):
                raise _HxException("assert")
            elif (d3 == 23):
                raise _HxException("assert")
            else:
                pass
        elif (d1 == 6):
            e9 = _g.params[1]
            op1 = _g.params[0]
            e10 = self.evalExpr(e9)
            _g58 = e10.e
            if (_g58.index == 0):
                c1 = _g58.params[0]
                d44 = op1.index
                if (d44 == 2):
                    if (c1.index == 1):
                        b42 = c1.params[0]
                        d = hxsl_TExprDef.TConst(hxsl_Const.CBool((not b42)))
                    else:
                        d = hxsl_TExprDef.TUnop(op1,e10)
                elif (d44 == 3):
                    d45 = c1.index
                    if (d45 == 2):
                        i1 = c1.params[0]
                        d = hxsl_TExprDef.TConst(hxsl_Const.CInt(-i1))
                    elif (d45 == 3):
                        f = c1.params[0]
                        d = hxsl_TExprDef.TConst(hxsl_Const.CFloat(-f))
                    else:
                        d = hxsl_TExprDef.TUnop(op1,e10)
                else:
                    d = hxsl_TExprDef.TUnop(op1,e10)
            else:
                d = hxsl_TExprDef.TUnop(op1,e10)
        elif (d1 == 7):
            init = _g.params[1]
            v1 = _g.params[0]
            d = hxsl_TExprDef.TVarDecl(self.mapVar(v1),(None if ((init is None)) else self.evalExpr(init)))
        elif (d1 == 8):
            eargs = _g.params[1]
            c2 = _g.params[0]
            c3 = self.evalExpr(c2)
            _g59 = []
            _g130 = 0
            while (_g130 < len(eargs)):
                a50 = (eargs[_g130] if _g130 >= 0 and _g130 < len(eargs) else None)
                _g130 = (_g130 + 1)
                x5 = self.evalExpr(a50)
                _g59.append(x5)
            args = _g59
            _g222 = c3.e
            d46 = _g222.index
            if (d46 == 1):
                if (not self.inlineCalls):
                    d = hxsl_TExprDef.TCall(c3,args)
                else:
                    v3 = _g222.params[0]
                    if (v3 in self.funMap.h):
                        f1 = self.funMap.h.get(v3,None)
                        outExprs = []
                        undo = []
                        _g223 = 0
                        _g312 = len(f1.args)
                        while (_g223 < _g312):
                            i2 = _g223
                            _g223 = (_g223 + 1)
                            v4 = [(f1.args[i2] if i2 >= 0 and i2 < len(f1.args) else None)]
                            e13 = (args[i2] if i2 >= 0 and i2 < len(args) else None)
                            _g224 = e13.e
                            d47 = _g224.index
                            if (d47 == 0):
                                _g107 = _g224.params[0]
                                old = [self.constants.h.get((v4[0] if 0 < len(v4) else None).id,None)]
                                def _hx_local_2(old1,v5):
                                    def _hx_local_1():
                                        if ((old1[0] if 0 < len(old1) else None) is None):
                                            _gthis.constants.remove((v5[0] if 0 < len(v5) else None).id)
                                        else:
                                            _gthis.constants.set((v5[0] if 0 < len(v5) else None).id,(old1[0] if 0 < len(old1) else None))
                                    return _hx_local_1
                                undo.append(_hx_local_2(old,v4))
                                self.constants.set((v4[0] if 0 < len(v4) else None).id,e13.e)
                            elif (d47 == 1):
                                _g313 = _g224.params[0]
                                _g97 = _g313.type
                                _g83 = Reflect.field(_g313,"qualifiers")
                                _g711 = Reflect.field(_g313,"parent")
                                _g69 = _g313.name
                                _g420 = _g313.id
                                d48 = _g313.kind.index
                                if (((d48 == 2) or ((d48 == 1))) or ((d48 == 0))):
                                    old2 = [self.constants.h.get((v4[0] if 0 < len(v4) else None).id,None)]
                                    def _hx_local_4(old3,v6):
                                        def _hx_local_3():
                                            if ((old3[0] if 0 < len(old3) else None) is None):
                                                _gthis.constants.remove((v6[0] if 0 < len(v6) else None).id)
                                            else:
                                                _gthis.constants.set((v6[0] if 0 < len(v6) else None).id,(old3[0] if 0 < len(old3) else None))
                                        return _hx_local_3
                                    undo.append(_hx_local_4(old2,v4))
                                    self.constants.set((v4[0] if 0 < len(v4) else None).id,e13.e)
                                else:
                                    old4 = [self.varMap.h.get((v4[0] if 0 < len(v4) else None),None)]
                                    if ((old4[0] if 0 < len(old4) else None) is None):
                                        def _hx_local_6(v7):
                                            def _hx_local_5():
                                                _gthis.varMap.remove((v7[0] if 0 < len(v7) else None))
                                            return _hx_local_5
                                        undo.append(_hx_local_6(v4))
                                    else:
                                        self.varMap.remove((v4[0] if 0 < len(v4) else None))
                                        def _hx_local_8(old5,v8):
                                            def _hx_local_7():
                                                _gthis.varMap.set((v8[0] if 0 < len(v8) else None),(old5[0] if 0 < len(old5) else None))
                                            return _hx_local_7
                                        undo.append(_hx_local_8(old4,v4))
                                    v21 = self.mapVar((v4[0] if 0 < len(v4) else None))
                                    x6 = _hx_AnonObject({'e': hxsl_TExprDef.TVarDecl(v21,e13), 't': hxsl_Type.TVoid, 'p': e13.p})
                                    outExprs.append(x6)
                            else:
                                old6 = [self.varMap.h.get((v4[0] if 0 < len(v4) else None),None)]
                                if ((old6[0] if 0 < len(old6) else None) is None):
                                    def _hx_local_10(v9):
                                        def _hx_local_9():
                                            _gthis.varMap.remove((v9[0] if 0 < len(v9) else None))
                                        return _hx_local_9
                                    undo.append(_hx_local_10(v4))
                                else:
                                    self.varMap.remove((v4[0] if 0 < len(v4) else None))
                                    def _hx_local_12(old7,v10):
                                        def _hx_local_11():
                                            _gthis.varMap.set((v10[0] if 0 < len(v10) else None),(old7[0] if 0 < len(old7) else None))
                                        return _hx_local_11
                                    undo.append(_hx_local_12(old6,v4))
                                v22 = self.mapVar((v4[0] if 0 < len(v4) else None))
                                x7 = _hx_AnonObject({'e': hxsl_TExprDef.TVarDecl(v22,e13), 't': hxsl_Type.TVoid, 'p': e13.p})
                                outExprs.append(x7)
                        e14 = self.handleReturn(self.evalExpr(f1.expr,False),True)
                        _g421 = 0
                        while (_g421 < len(undo)):
                            u = (undo[_g421] if _g421 >= 0 and _g421 < len(undo) else None)
                            _g421 = (_g421 + 1)
                            u()
                        _g510 = e14.e
                        if (_g510.index == 4):
                            el1 = _g510.params[0]
                            _g511 = 0
                            while (_g511 < len(el1)):
                                e15 = (el1[_g511] if _g511 >= 0 and _g511 < len(el1) else None)
                                _g511 = (_g511 + 1)
                                outExprs.append(e15)
                        else:
                            outExprs.append(e14)
                        d = hxsl_TExprDef.TBlock(outExprs)
                    else:
                        d = hxsl_Error.t((("Cannot eval non-static call expresssion '" + HxOverrides.stringOrNull(hxsl_Printer().exprString(c3))) + "'"),c3.p)
            elif (d46 == 2):
                g = _g222.params[0]
                v11 = self.evalCall(g,args,eargs,e.p)
                d = (v11 if ((v11 is not None)) else hxsl_TExprDef.TCall(c3,args))
            else:
                d = hxsl_Error.t((("Cannot eval non-static call expresssion '" + HxOverrides.stringOrNull(hxsl_Printer().exprString(c3))) + "'"),c3.p)
        elif (d1 == 9):
            r = _g.params[1]
            e16 = _g.params[0]
            d = hxsl_TExprDef.TSwiz(self.evalExpr(e16),list(r))
        elif (d1 == 10):
            eelse = _g.params[2]
            eif = _g.params[1]
            econd = _g.params[0]
            econd1 = self.evalExpr(econd)
            _g60 = econd1.e
            if (_g60.index == 0):
                _g137 = _g60.params[0]
                if (_g137.index == 1):
                    b43 = _g137.params[0]
                    d = (self.evalExpr(eif,isVal).e if b43 else (hxsl_TExprDef.TConst(hxsl_Const.CNull) if ((eelse is None)) else self.evalExpr(eelse,isVal).e))
                elif ((isVal and ((eelse is not None))) and self.eliminateConditionals):
                    d = hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(hxsl_TGlobal.Mix), 't': e.t, 'p': e.p}),[self.evalExpr(eelse,True), self.evalExpr(eif,True), _hx_AnonObject({'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(hxsl_TGlobal.ToFloat), 't': hxsl_Type.TFun([]), 'p': econd1.p}),[econd1]), 't': hxsl_Type.TFloat, 'p': e.p})])
                else:
                    eif = self.evalExpr(eif,isVal)
                    if (eelse is not None):
                        eelse = self.evalExpr(eelse,isVal)
                        _g70 = eelse.e
                        if ((_g70.index == 0) and ((_g70.params[0].index == 0))):
                            eelse = None
                    eif = self.ifBlock(eif)
                    eelse = self.ifBlock(eelse)
                    d = hxsl_TExprDef.TIf(econd1,eif,eelse)
            elif ((isVal and ((eelse is not None))) and self.eliminateConditionals):
                d = hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(hxsl_TGlobal.Mix), 't': e.t, 'p': e.p}),[self.evalExpr(eelse,True), self.evalExpr(eif,True), _hx_AnonObject({'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(hxsl_TGlobal.ToFloat), 't': hxsl_Type.TFun([]), 'p': econd1.p}),[econd1]), 't': hxsl_Type.TFloat, 'p': e.p})])
            else:
                eif = self.evalExpr(eif,isVal)
                if (eelse is not None):
                    eelse = self.evalExpr(eelse,isVal)
                    _g80 = eelse.e
                    if ((_g80.index == 0) and ((_g80.params[0].index == 0))):
                        eelse = None
                eif = self.ifBlock(eif)
                eelse = self.ifBlock(eelse)
                d = hxsl_TExprDef.TIf(econd1,eif,eelse)
        elif (d1 == 11):
            d = hxsl_TExprDef.TDiscard
        elif (d1 == 12):
            e17 = _g.params[0]
            d = hxsl_TExprDef.TReturn((None if ((e17 is None)) else self.evalExpr(e17)))
        elif (d1 == 13):
            loop = _g.params[2]
            it = _g.params[1]
            v12 = _g.params[0]
            v23 = self.mapVar(v12)
            it1 = self.evalExpr(it)
            e18 = None
            _g84 = it1.e
            if (_g84.index == 5):
                _g314 = _g84.params[2]
                _g225 = _g84.params[1]
                if (_g84.params[0].index == 21):
                    _g610 = _g225.t
                    _g512 = _g225.p
                    _g422 = _g225.e
                    if (_g422.index == 0):
                        _g712 = _g422.params[0]
                        if (_g712.index == 2):
                            _g1110 = _g314.t
                            _g108 = _g314.p
                            _g98 = _g314.e
                            if (_g98.index == 0):
                                _g1210 = _g98.params[0]
                                if (_g1210.index == 2):
                                    start = _g712.params[0]
                                    _hx_len = _g1210.params[0]
                                    if self.unrollLoops:
                                        out1 = []
                                        _g85 = start
                                        _g138 = _hx_len
                                        while (_g85 < _g138):
                                            i3 = _g85
                                            _g85 = (_g85 + 1)
                                            self.constants.set(v12.id,hxsl_TExprDef.TConst(hxsl_Const.CInt(i3)))
                                            x8 = self.evalExpr(loop,False)
                                            out1.append(x8)
                                        self.constants.remove(v12.id)
                                        e18 = hxsl_TExprDef.TBlock(out1)
                                    else:
                                        e18 = hxsl_TExprDef.TFor(v23,it1,self.ifBlock(self.evalExpr(loop,False)))
                                else:
                                    e18 = hxsl_TExprDef.TFor(v23,it1,self.ifBlock(self.evalExpr(loop,False)))
                            else:
                                e18 = hxsl_TExprDef.TFor(v23,it1,self.ifBlock(self.evalExpr(loop,False)))
                        else:
                            e18 = hxsl_TExprDef.TFor(v23,it1,self.ifBlock(self.evalExpr(loop,False)))
                    else:
                        e18 = hxsl_TExprDef.TFor(v23,it1,self.ifBlock(self.evalExpr(loop,False)))
                else:
                    e18 = hxsl_TExprDef.TFor(v23,it1,self.ifBlock(self.evalExpr(loop,False)))
            else:
                e18 = hxsl_TExprDef.TFor(v23,it1,self.ifBlock(self.evalExpr(loop,False)))
            self.varMap.remove(v12)
            d = e18
        elif (d1 == 14):
            d = hxsl_TExprDef.TContinue
        elif (d1 == 15):
            d = hxsl_TExprDef.TBreak
        elif (d1 == 16):
            e23 = _g.params[1]
            e19 = _g.params[0]
            e110 = self.evalExpr(e19)
            e24 = self.evalExpr(e23)
            _g86 = e24.e
            _g139 = e110.e
            if (_g139.index == 17):
                if (_g86.index == 0):
                    _g315 = _g86.params[0]
                    if (_g315.index == 2):
                        el2 = _g139.params[0]
                        i4 = _g315.params[0]
                        d = ((el2[i4] if i4 >= 0 and i4 < len(el2) else None).e if (((i4 >= 0) and ((i4 < len(el2))))) else hxsl_TExprDef.TArray(e110,e24))
                    else:
                        d = hxsl_TExprDef.TArray(e110,e24)
                else:
                    d = hxsl_TExprDef.TArray(e110,e24)
            else:
                d = hxsl_TExprDef.TArray(e110,e24)
        elif (d1 == 17):
            el3 = _g.params[0]
            _g87 = []
            _g140 = 0
            while (_g140 < len(el3)):
                e20 = (el3[_g140] if _g140 >= 0 and _g140 < len(el3) else None)
                _g140 = (_g140 + 1)
                x9 = self.evalExpr(e20)
                _g87.append(x9)
            d = hxsl_TExprDef.TArrayDecl(_g87)
        elif (d1 == 18):
            _hx_def = _g.params[2]
            cases = _g.params[1]
            e25 = _g.params[0]
            e26 = self.evalExpr(e25)
            _g88 = []
            _g141 = 0
            while (_g141 < len(cases)):
                c4 = (cases[_g141] if _g141 >= 0 and _g141 < len(cases) else None)
                _g141 = (_g141 + 1)
                _g142 = []
                _g226 = 0
                _g316 = c4.values
                while (_g226 < len(_g316)):
                    v13 = (_g316[_g226] if _g226 >= 0 and _g226 < len(_g316) else None)
                    _g226 = (_g226 + 1)
                    x10 = self.evalExpr(v13)
                    _g142.append(x10)
                x11 = _hx_AnonObject({'values': _g142, 'expr': self.evalExpr(c4.expr,isVal)})
                _g88.append(x11)
            cases1 = _g88
            def1 = (None if ((_hx_def is None)) else self.evalExpr(_hx_def,isVal))
            hasCase = False
            _g227 = e26.e
            if (_g227.index == 0):
                c5 = _g227.params[0]
                if (c5.index == 2):
                    val = c5.params[0]
                    _g228 = 0
                    while (_g228 < len(cases1)):
                        c6 = (cases1[_g228] if _g228 >= 0 and _g228 < len(cases1) else None)
                        _g228 = (_g228 + 1)
                        _g229 = 0
                        _g317 = c6.values
                        while (_g229 < len(_g317)):
                            v14 = (_g317[_g229] if _g229 >= 0 and _g229 < len(_g317) else None)
                            _g229 = (_g229 + 1)
                            _g230 = v14.e
                            if (_g230.index == 0):
                                cst = _g230.params[0]
                                d49 = cst.index
                                if (d49 == 2):
                                    k = cst.params[0]
                                    if (k == val):
                                        return c6.expr
                                elif (d49 == 3):
                                    k1 = cst.params[0]
                                    if (k1 == val):
                                        return c6.expr
                                else:
                                    pass
                            else:
                                hasCase = True
                else:
                    raise _HxException(("Unsupported switch constant " + Std.string(c5)))
            else:
                hasCase = True
            d = (hxsl_TExprDef.TSwitch(e26,cases1,def1) if hasCase else (hxsl_TExprDef.TBlock([]) if ((def1 is None)) else def1.e))
        elif (d1 == 19):
            normalWhile = _g.params[2]
            loop1 = _g.params[1]
            cond = _g.params[0]
            cond1 = self.evalExpr(cond)
            loop2 = self.evalExpr(loop1,False)
            d = hxsl_TExprDef.TWhile(cond1,self.ifBlock(loop2),normalWhile)
        elif (d1 == 20):
            e27 = _g.params[2]
            args1 = _g.params[1]
            name = _g.params[0]
            e28 = None
            if (name == "unroll"):
                old8 = self.unrollLoops
                self.unrollLoops = True
                e28 = self.evalExpr(e27,isVal)
                self.unrollLoops = False
            else:
                e28 = self.evalExpr(e27,isVal)
            d = hxsl_TExprDef.TMeta(name,args1,e28)
        else:
            pass
        return _hx_AnonObject({'e': d, 't': e.t, 'p': e.p})

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.varMap = None
        _hx_o.inlineCalls = None
        _hx_o.unrollLoops = None
        _hx_o.eliminateConditionals = None
        _hx_o.constants = None
        _hx_o.funMap = None
        _hx_o.curFun = None
        _hx_o.markReturn = None
hxsl_Eval._hx_class = hxsl_Eval
_hx_classes["hxsl.Eval"] = hxsl_Eval


class hxsl__Flatten_Alloc:
    _hx_class_name = "hxsl._Flatten.Alloc"
    _hx_is_interface = "False"
    __slots__ = ("t", "pos", "size", "g", "v")
    _hx_fields = ["t", "pos", "size", "g", "v"]

    def __init__(self,g,t,pos,size):
        self.v = None
        self.g = g
        self.t = t
        self.pos = pos
        self.size = size

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.t = None
        _hx_o.pos = None
        _hx_o.size = None
        _hx_o.g = None
        _hx_o.v = None
hxsl__Flatten_Alloc._hx_class = hxsl__Flatten_Alloc
_hx_classes["hxsl._Flatten.Alloc"] = hxsl__Flatten_Alloc

class hxsl_ARead(Enum):
    __slots__ = ()
    _hx_class_name = "hxsl.ARead"
    _hx_constructs = ["AIndex", "AOffset"]

    @staticmethod
    def AIndex(a):
        return hxsl_ARead("AIndex", 0, (a,))

    @staticmethod
    def AOffset(a,stride,delta):
        return hxsl_ARead("AOffset", 1, (a,stride,delta))
hxsl_ARead._hx_class = hxsl_ARead
_hx_classes["hxsl.ARead"] = hxsl_ARead


class hxsl_Flatten:
    _hx_class_name = "hxsl.Flatten"
    _hx_is_interface = "False"
    __slots__ = ("globals", "params", "outVars", "varMap", "econsts", "consts", "allocData")
    _hx_fields = ["globals", "params", "outVars", "varMap", "econsts", "consts", "allocData"]
    _hx_methods = ["flatten", "mapFun", "mapExpr", "mapConsts", "allocConst", "allocConsts", "mkInt", "readIndex", "readOffset", "access", "optimize", "packTextures", "packBuffers", "pack", "varSize", "gatherVar"]

    def __init__(self):
        self.allocData = None
        self.consts = None
        self.econsts = None
        self.varMap = None
        self.outVars = None
        self.params = None
        self.globals = None

    def flatten(self,s,kind,constsToGlobal):
        self.globals = []
        self.params = []
        self.outVars = []
        if constsToGlobal:
            self.consts = []
            p = (s.funs[0] if 0 < len(s.funs) else None).expr.p
            gc = _hx_AnonObject({'id': hxsl_Tools.allocVarId(), 'name': "__consts__", 'kind': hxsl_VarKind.Global, 'type': None})
            self.econsts = _hx_AnonObject({'e': hxsl_TExprDef.TVar(gc), 't': None, 'p': p})
            s1 = s.name
            s2 = list(s.vars)
            _g = []
            _g1 = 0
            _g2 = s.funs
            while (_g1 < len(_g2)):
                f = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
                _g1 = (_g1 + 1)
                x = self.mapFun(f,self.mapConsts)
                _g.append(x)
            s = _hx_AnonObject({'name': s1, 'vars': s2, 'funs': _g})
            _g3 = 0
            _g4 = s.vars
            while (_g3 < len(_g4)):
                v = (_g4[_g3] if _g3 >= 0 and _g3 < len(_g4) else None)
                _g3 = (_g3 + 1)
                _g31 = v.type
                if (_g31.index == 9):
                    _g41 = _g31.params[0]
                    self.allocConst(255,p)
            if (len(self.consts) > 0):
                def _hx_local_2():
                    self.econsts.t = hxsl_Type.TArray(hxsl_Type.TFloat,hxsl_SizeDecl.SConst(len(self.consts)))
                    return self.econsts.t
                gc.type = _hx_local_2()
                _this = s.vars
                _this.append(gc)
        self.varMap = haxe_ds_ObjectMap()
        self.allocData = haxe_ds_ObjectMap()
        _g5 = 0
        _g11 = s.vars
        while (_g5 < len(_g11)):
            v1 = (_g11[_g5] if _g5 >= 0 and _g5 < len(_g11) else None)
            _g5 = (_g5 + 1)
            self.gatherVar(v1)
        prefix = None
        prefix1 = kind.index
        if (prefix1 == 0):
            prefix = "vertex"
        elif (prefix1 == 1):
            prefix = "fragment"
        else:
            raise _HxException("assert")
        self.pack((("null" if prefix is None else prefix) + "Globals"),hxsl_VarKind.Global,self.globals,hxsl_VecType.VFloat)
        self.pack((("null" if prefix is None else prefix) + "Params"),hxsl_VarKind.Param,self.params,hxsl_VecType.VFloat)
        allVars = (self.globals + self.params)
        textures = ((self.packTextures((("null" if prefix is None else prefix) + "Textures"),allVars,hxsl_Type.TSampler2D) + self.packTextures((("null" if prefix is None else prefix) + "TexturesCube"),allVars,hxsl_Type.TSamplerCube)) + self.packTextures((("null" if prefix is None else prefix) + "TexturesArray"),allVars,hxsl_Type.TSampler2DArray))
        self.packBuffers(allVars)
        _g21 = []
        _g32 = 0
        _g42 = s.funs
        while (_g32 < len(_g42)):
            f1 = (_g42[_g32] if _g32 >= 0 and _g32 < len(_g42) else None)
            _g32 = (_g32 + 1)
            x1 = self.mapFun(f1,self.mapExpr)
            _g21.append(x1)
        funs = _g21
        _g51 = 0
        while (_g51 < len(textures)):
            t = (textures[_g51] if _g51 >= 0 and _g51 < len(textures) else None)
            _g51 = (_g51 + 1)
            t.pos = (t.pos >> 2)
        return _hx_AnonObject({'name': s.name, 'vars': self.outVars, 'funs': funs})

    def mapFun(self,f,mapExpr):
        return _hx_AnonObject({'kind': f.kind, 'ret': f.ret, 'args': f.args, 'ref': f.ref, 'expr': mapExpr(f.expr)})

    def mapExpr(self,e):
        _g = e.e
        e1 = _g.index
        if (e1 == 1):
            v = _g.params[0]
            a = self.varMap.h.get(v,None)
            e = (e if ((a is None)) else self.access(a,v.type,e.p,hxsl_ARead.AIndex(a)))
        elif (e1 == 16):
            _g1 = _g.params[0]
            _g5 = _g1.t
            _g3 = _g1.e
            if (_g3.index == 1):
                eindex = _g.params[1]
                vp = _g1.p
                v1 = _g3.params[0]
                _g2 = eindex.e
                e2 = None
                if (_g2.index == 0):
                    _g11 = _g2.params[0]
                    if (_g11.index == 2):
                        _g21 = _g11.params[0]
                        e2 = True
                    else:
                        e2 = False
                else:
                    e2 = False
                if (not e2):
                    a1 = self.varMap.h.get(v1,None)
                    if (a1 is None):
                        e = e
                    else:
                        _g31 = v1.type
                        if (_g31.index == 15):
                            _g51 = _g31.params[1]
                            t = _g31.params[0]
                            stride = self.varSize(t,a1.t)
                            if ((stride == 0) or ((((stride & 3)) != 0))):
                                raise _HxException(hxsl_Error("Dynamic access to an Array which size is not 4 components-aligned is not allowed",e.p))
                            stride = (stride >> 2)
                            eindex = self.mapExpr(eindex)
                            toInt = _hx_AnonObject({'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(hxsl_TGlobal.ToInt), 't': hxsl_Type.TFun([]), 'p': vp}),[eindex]), 't': hxsl_Type.TInt, 'p': vp})
                            e = self.access(a1,t,vp,hxsl_ARead.AOffset(a1,stride,(toInt if ((stride == 1)) else _hx_AnonObject({'e': hxsl_TExprDef.TBinop(haxe_macro_Binop.OpMult,toInt,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(stride)), 't': hxsl_Type.TInt, 'p': vp})), 't': hxsl_Type.TInt, 'p': vp}))))
                        else:
                            raise _HxException("assert")
                else:
                    e = hxsl_Tools.map(e,self.mapExpr)
            else:
                e = hxsl_Tools.map(e,self.mapExpr)
        else:
            e = hxsl_Tools.map(e,self.mapExpr)
        return self.optimize(e)

    def mapConsts(self,e):
        _g = e.e
        tmp = _g.index
        if (tmp == 0):
            c = _g.params[0]
            tmp1 = c.index
            if (tmp1 == 2):
                v = c.params[0]
                return self.allocConst(v,e.p)
            elif (tmp1 == 3):
                v1 = c.params[0]
                return self.allocConst(v1,e.p)
            else:
                return e
        elif (tmp == 2):
            g = _g.params[0]
            tmp2 = g.index
            if (tmp2 == 0):
                self.allocConst((Math.PI / 180),e.p)
            elif (tmp2 == 1):
                self.allocConst((180 / Math.PI),e.p)
            elif (tmp2 == 9):
                self.allocConst(1.4426950408889634,e.p)
            elif (tmp2 == 10):
                self.allocConst(0.6931471805599453,e.p)
            elif (tmp2 == 24):
                self.allocConst(1,e.p)
            elif (tmp2 == 26):
                self.allocConst(2.0,e.p)
                self.allocConst(3.0,e.p)
            elif (tmp2 == 54):
                self.allocConsts([1, 255, 65025, 16581375],e.p)
                self.allocConsts([0.00392156862745098, 0.00392156862745098, 0.00392156862745098, 0],e.p)
            elif (tmp2 == 55):
                self.allocConsts([1, 0.00392156862745098, 1.53787004998077679e-05, 6.03086294110108446e-08],e.p)
            elif (tmp2 == 56):
                self.allocConst(1,e.p)
                self.allocConst(0.5,e.p)
            elif (tmp2 == 57):
                self.allocConst(0.5,e.p)
            elif (tmp2 == 58):
                self.allocConsts([0.5, 0.5],e.p)
                self.allocConsts([0.5, -0.5],e.p)
            elif (tmp2 == 59):
                self.allocConsts([2, -2],e.p)
                self.allocConsts([-1, 1],e.p)
            else:
                pass
        elif (tmp == 5):
            _g12 = _g.params[2]
            _g11 = _g.params[1]
            if (_g.params[0].index == 1):
                _g14 = _g12.p
                _g13 = _g12.e
                if (_g12.t.index == 8):
                    self.allocConst(1,e.p)
        elif (tmp == 8):
            _g17 = _g.params[1]
            _g16 = _g.params[0]
            _g20 = _g16.t
            _g19 = _g16.p
            _g18 = _g16.e
            if (_g18.index == 2):
                if (_g18.params[0].index == 42):
                    if (len(_g17) == 2):
                        _g23 = (_g17[1] if 1 < len(_g17) else None)
                        _g22 = (_g17[0] if 0 < len(_g17) else None)
                        _g26 = _g22.t
                        _g25 = _g22.p
                        _g24 = _g22.e
                        if (_g24.index == 1):
                            _g27 = _g24.params[0]
                            _g33 = _g27.type
                            _g32 = Reflect.field(_g27,"qualifiers")
                            _g31 = Reflect.field(_g27,"parent")
                            _g30 = _g27.name
                            _g28 = _g27.id
                            tmp3 = _g27.kind.index
                            if (tmp3 == 0):
                                if (_g26.index == 5):
                                    if (_g26.params[0] == 3):
                                        if (_g26.params[1].index == 1):
                                            _g59 = _g23.t
                                            _g58 = _g23.p
                                            _g57 = _g23.e
                                            if (_g57.index == 0):
                                                _g60 = _g57.params[0]
                                                if (_g60.index == 2):
                                                    if (_g60.params[0] == 1):
                                                        return e
                            elif (tmp3 == 1):
                                if (_g26.index == 5):
                                    if (_g26.params[0] == 3):
                                        if (_g26.params[1].index == 1):
                                            _g38 = _g23.t
                                            _g37 = _g23.p
                                            _g36 = _g23.e
                                            if (_g36.index == 0):
                                                _g39 = _g36.params[0]
                                                if (_g39.index == 2):
                                                    if (_g39.params[0] == 1):
                                                        return e
                            elif (tmp3 == 2):
                                if (_g26.index == 5):
                                    if (_g26.params[0] == 3):
                                        if (_g26.params[1].index == 1):
                                            _g52 = _g23.t
                                            _g51 = _g23.p
                                            _g50 = _g23.e
                                            if (_g50.index == 0):
                                                _g53 = _g50.params[0]
                                                if (_g53.index == 2):
                                                    if (_g53.params[0] == 1):
                                                        return e
                            elif (tmp3 == 3):
                                if (_g26.index == 5):
                                    if (_g26.params[0] == 3):
                                        if (_g26.params[1].index == 1):
                                            _g45 = _g23.t
                                            _g44 = _g23.p
                                            _g43 = _g23.e
                                            if (_g43.index == 0):
                                                _g46 = _g43.params[0]
                                                if (_g46.index == 2):
                                                    if (_g46.params[0] == 1):
                                                        return e
                            else:
                                pass
        elif (tmp == 16):
            _g2 = _g.params[1]
            _g1 = _g.params[0]
            _g5 = _g2.t
            _g4 = _g2.p
            _g3 = _g2.e
            if (_g3.index == 0):
                _g6 = _g3.params[0]
                if (_g6.index == 2):
                    _g7 = _g6.params[0]
                    ea = _g1
                    eindex = _g2
                    return _hx_AnonObject({'e': hxsl_TExprDef.TArray(self.mapConsts(ea),eindex), 't': e.t, 'p': e.p})
                else:
                    ea1 = _g1
                    eindex1 = _g2
                    _g8 = ea1.t
                    if (_g8.index == 15):
                        _g21 = _g8.params[1]
                        t = _g8.params[0]
                        stride = (self.varSize(t,hxsl_VecType.VFloat) >> 2)
                        self.allocConst(stride,e.p)
            else:
                ea2 = _g1
                eindex2 = _g2
                _g9 = ea2.t
                if (_g9.index == 15):
                    _g29 = _g9.params[1]
                    t1 = _g9.params[0]
                    stride1 = (self.varSize(t1,hxsl_VecType.VFloat) >> 2)
                    self.allocConst(stride1,e.p)
        else:
            pass
        return hxsl_Tools.map(e,self.mapConsts)

    def allocConst(self,v,p):
        index = python_internal_ArrayImpl.indexOf(self.consts,v,None)
        if (index < 0):
            index = len(self.consts)
            _this = self.consts
            _this.append(v)
        return _hx_AnonObject({'e': hxsl_TExprDef.TArray(self.econsts,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), 't': hxsl_Type.TInt, 'p': p})), 't': hxsl_Type.TFloat, 'p': p})

    def allocConsts(self,va,p):
        _gthis = self
        pad = ((len(va) - 1) & 3)
        index = -1
        _g = 0
        _g1 = (len(self.consts) - ((len(va) - 1)))
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if ((i >> 2) != (((i + pad) >> 2))):
                continue
            found = True
            _g2 = 0
            _g11 = len(va)
            while (_g2 < _g11):
                j = _g2
                _g2 = (_g2 + 1)
                if (python_internal_ArrayImpl._get(self.consts, (i + j)) != (va[j] if j >= 0 and j < len(va) else None)):
                    found = False
                    break
            if found:
                index = i
                break
        if (index < 0):
            while ((len(self.consts) >> 2) != (((len(self.consts) + pad) >> 2))):
                _this = self.consts
                _this.append(0)
            index = len(self.consts)
            _g21 = 0
            while (_g21 < len(va)):
                v = (va[_g21] if _g21 >= 0 and _g21 < len(va) else None)
                _g21 = (_g21 + 1)
                _this1 = self.consts
                _this1.append(v)
        _g22 = len(va)
        if (_g22 == 1):
            return _hx_AnonObject({'e': hxsl_TExprDef.TArray(_gthis.econsts,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), 't': hxsl_Type.TInt, 'p': p})), 't': hxsl_Type.TFloat, 'p': p})
        elif (_g22 == 2):
            return _hx_AnonObject({'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(hxsl_TGlobal.Vec2), 't': hxsl_Type.TVoid, 'p': p}),[_hx_AnonObject({'e': hxsl_TExprDef.TArray(_gthis.econsts,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), 't': hxsl_Type.TInt, 'p': p})), 't': hxsl_Type.TFloat, 'p': p}), _hx_AnonObject({'e': hxsl_TExprDef.TArray(_gthis.econsts,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt((index + 1))), 't': hxsl_Type.TInt, 'p': p})), 't': hxsl_Type.TFloat, 'p': p})]), 't': hxsl_Type.TVec(2,hxsl_VecType.VFloat), 'p': p})
        elif (_g22 == 3):
            return _hx_AnonObject({'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(hxsl_TGlobal.Vec3), 't': hxsl_Type.TVoid, 'p': p}),[_hx_AnonObject({'e': hxsl_TExprDef.TArray(_gthis.econsts,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), 't': hxsl_Type.TInt, 'p': p})), 't': hxsl_Type.TFloat, 'p': p}), _hx_AnonObject({'e': hxsl_TExprDef.TArray(_gthis.econsts,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt((index + 1))), 't': hxsl_Type.TInt, 'p': p})), 't': hxsl_Type.TFloat, 'p': p}), _hx_AnonObject({'e': hxsl_TExprDef.TArray(_gthis.econsts,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt((index + 2))), 't': hxsl_Type.TInt, 'p': p})), 't': hxsl_Type.TFloat, 'p': p})]), 't': hxsl_Type.TVec(3,hxsl_VecType.VFloat), 'p': p})
        elif (_g22 == 4):
            return _hx_AnonObject({'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(hxsl_TGlobal.Vec4), 't': hxsl_Type.TVoid, 'p': p}),[_hx_AnonObject({'e': hxsl_TExprDef.TArray(_gthis.econsts,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), 't': hxsl_Type.TInt, 'p': p})), 't': hxsl_Type.TFloat, 'p': p}), _hx_AnonObject({'e': hxsl_TExprDef.TArray(_gthis.econsts,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt((index + 1))), 't': hxsl_Type.TInt, 'p': p})), 't': hxsl_Type.TFloat, 'p': p}), _hx_AnonObject({'e': hxsl_TExprDef.TArray(_gthis.econsts,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt((index + 3))), 't': hxsl_Type.TInt, 'p': p})), 't': hxsl_Type.TFloat, 'p': p}), _hx_AnonObject({'e': hxsl_TExprDef.TArray(_gthis.econsts,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt((index + 4))), 't': hxsl_Type.TInt, 'p': p})), 't': hxsl_Type.TFloat, 'p': p})]), 't': hxsl_Type.TVec(4,hxsl_VecType.VFloat), 'p': p})
        else:
            raise _HxException("assert")

    def mkInt(self,v,pos):
        return _hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(v)), 't': hxsl_Type.TInt, 'p': pos})

    def readIndex(self,a,index,pos):
        return _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a.g), 't': a.g.type, 'p': pos}),_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt((((a.pos >> 2)) + index))), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TVec(4,a.t), 'p': pos})

    def readOffset(self,a,stride,delta,index,pos):
        index1 = (((a.pos >> 2)) + index)
        offset = (delta if ((index1 == 0)) else _hx_AnonObject({'e': hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,delta,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(index1)), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TInt, 'p': pos}))
        return _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a.g), 't': a.g.type, 'p': pos}),offset), 't': hxsl_Type.TVec(4,a.t), 'p': pos})

    def access(self,a,t,pos,acc):
        _gthis = self
        tmp = t.index
        if (tmp == 6):
            tmp1 = self.access(a,hxsl_Type.TMat3x4,pos,acc)
            return _hx_AnonObject({'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(hxsl_TGlobal.Mat3), 't': hxsl_Type.TFun([]), 'p': pos}),[tmp1]), 't': hxsl_Type.TMat3, 'p': pos})
        elif (tmp == 7):
            tmp2 = hxsl_TExprDef.TGlobal(hxsl_TGlobal.Mat4)
            tmp3 = hxsl_Type.TFun([])
            tmp4 = None
            tmp5 = acc.index
            if (tmp5 == 0):
                a1 = acc.params[0]
                tmp4 = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a1.g), 't': a1.g.type, 'p': pos}),_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt((a1.pos >> 2))), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TVec(4,a1.t), 'p': pos})
            elif (tmp5 == 1):
                delta = acc.params[2]
                stride = acc.params[1]
                a2 = acc.params[0]
                index = (a2.pos >> 2)
                offset = (delta if ((index == 0)) else _hx_AnonObject({'e': hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,delta,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TInt, 'p': pos}))
                tmp4 = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a2.g), 't': a2.g.type, 'p': pos}),offset), 't': hxsl_Type.TVec(4,a2.t), 'p': pos})
            else:
                pass
            tmp6 = None
            tmp7 = acc.index
            if (tmp7 == 0):
                a3 = acc.params[0]
                tmp6 = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a3.g), 't': a3.g.type, 'p': pos}),_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt((((a3.pos >> 2)) + 1))), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TVec(4,a3.t), 'p': pos})
            elif (tmp7 == 1):
                delta1 = acc.params[2]
                stride1 = acc.params[1]
                a4 = acc.params[0]
                index1 = (((a4.pos >> 2)) + 1)
                offset1 = (delta1 if ((index1 == 0)) else _hx_AnonObject({'e': hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,delta1,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(index1)), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TInt, 'p': pos}))
                tmp6 = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a4.g), 't': a4.g.type, 'p': pos}),offset1), 't': hxsl_Type.TVec(4,a4.t), 'p': pos})
            else:
                pass
            tmp8 = None
            tmp9 = acc.index
            if (tmp9 == 0):
                a5 = acc.params[0]
                tmp8 = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a5.g), 't': a5.g.type, 'p': pos}),_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt((((a5.pos >> 2)) + 2))), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TVec(4,a5.t), 'p': pos})
            elif (tmp9 == 1):
                delta2 = acc.params[2]
                stride2 = acc.params[1]
                a6 = acc.params[0]
                index2 = (((a6.pos >> 2)) + 2)
                offset2 = (delta2 if ((index2 == 0)) else _hx_AnonObject({'e': hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,delta2,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(index2)), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TInt, 'p': pos}))
                tmp8 = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a6.g), 't': a6.g.type, 'p': pos}),offset2), 't': hxsl_Type.TVec(4,a6.t), 'p': pos})
            else:
                pass
            tmp10 = None
            tmp11 = acc.index
            if (tmp11 == 0):
                a7 = acc.params[0]
                tmp10 = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a7.g), 't': a7.g.type, 'p': pos}),_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt((((a7.pos >> 2)) + 3))), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TVec(4,a7.t), 'p': pos})
            elif (tmp11 == 1):
                delta3 = acc.params[2]
                stride3 = acc.params[1]
                a8 = acc.params[0]
                index3 = (((a8.pos >> 2)) + 3)
                offset3 = (delta3 if ((index3 == 0)) else _hx_AnonObject({'e': hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,delta3,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(index3)), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TInt, 'p': pos}))
                tmp10 = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a8.g), 't': a8.g.type, 'p': pos}),offset3), 't': hxsl_Type.TVec(4,a8.t), 'p': pos})
            else:
                pass
            return _hx_AnonObject({'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': tmp2, 't': tmp3, 'p': pos}),[tmp4, tmp6, tmp8, tmp10]), 't': hxsl_Type.TMat4, 'p': pos})
        elif (tmp == 8):
            tmp12 = hxsl_TExprDef.TGlobal(hxsl_TGlobal.Mat3x4)
            tmp13 = hxsl_Type.TFun([])
            tmp14 = None
            tmp15 = acc.index
            if (tmp15 == 0):
                a9 = acc.params[0]
                tmp14 = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a9.g), 't': a9.g.type, 'p': pos}),_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt((a9.pos >> 2))), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TVec(4,a9.t), 'p': pos})
            elif (tmp15 == 1):
                delta4 = acc.params[2]
                stride4 = acc.params[1]
                a10 = acc.params[0]
                index4 = (a10.pos >> 2)
                offset4 = (delta4 if ((index4 == 0)) else _hx_AnonObject({'e': hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,delta4,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(index4)), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TInt, 'p': pos}))
                tmp14 = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a10.g), 't': a10.g.type, 'p': pos}),offset4), 't': hxsl_Type.TVec(4,a10.t), 'p': pos})
            else:
                pass
            tmp16 = None
            tmp17 = acc.index
            if (tmp17 == 0):
                a11 = acc.params[0]
                tmp16 = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a11.g), 't': a11.g.type, 'p': pos}),_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt((((a11.pos >> 2)) + 1))), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TVec(4,a11.t), 'p': pos})
            elif (tmp17 == 1):
                delta5 = acc.params[2]
                stride5 = acc.params[1]
                a12 = acc.params[0]
                index5 = (((a12.pos >> 2)) + 1)
                offset5 = (delta5 if ((index5 == 0)) else _hx_AnonObject({'e': hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,delta5,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(index5)), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TInt, 'p': pos}))
                tmp16 = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a12.g), 't': a12.g.type, 'p': pos}),offset5), 't': hxsl_Type.TVec(4,a12.t), 'p': pos})
            else:
                pass
            tmp18 = None
            tmp19 = acc.index
            if (tmp19 == 0):
                a13 = acc.params[0]
                tmp18 = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a13.g), 't': a13.g.type, 'p': pos}),_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt((((a13.pos >> 2)) + 2))), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TVec(4,a13.t), 'p': pos})
            elif (tmp19 == 1):
                delta6 = acc.params[2]
                stride6 = acc.params[1]
                a14 = acc.params[0]
                index6 = (((a14.pos >> 2)) + 2)
                offset6 = (delta6 if ((index6 == 0)) else _hx_AnonObject({'e': hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,delta6,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(index6)), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TInt, 'p': pos}))
                tmp18 = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a14.g), 't': a14.g.type, 'p': pos}),offset6), 't': hxsl_Type.TVec(4,a14.t), 'p': pos})
            else:
                pass
            return _hx_AnonObject({'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': tmp12, 't': tmp13, 'p': pos}),[tmp14, tmp16, tmp18]), 't': hxsl_Type.TMat3x4, 'p': pos})
        elif (tmp == 15):
            _g1 = t.params[1]
            if (_g1.index == 0):
                t1 = t.params[0]
                _hx_len = _g1.params[0]
                x = (a.size / _hx_len)
                stride7 = None
                try:
                    stride7 = int(x)
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e = _hx_e1
                    stride7 = None
                _g = []
                _g11 = 0
                _g2 = _hx_len
                while (_g11 < _g2):
                    i = _g11
                    _g11 = (_g11 + 1)
                    a15 = hxsl__Flatten_Alloc(a.g,a.t,(a.pos + ((stride7 * i))),stride7)
                    x1 = self.access(a15,t1,pos,hxsl_ARead.AIndex(a15))
                    _g.append(x1)
                earr = _g
                return _hx_AnonObject({'e': hxsl_TExprDef.TArrayDecl(earr), 't': t1, 'p': pos})
            else:
                if hxsl_Tools.isSampler(t):
                    e1 = None
                    e2 = acc.index
                    if (e2 == 0):
                        a16 = acc.params[0]
                        e1 = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a16.g), 't': a16.g.type, 'p': pos}),_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt((a16.pos >> 2))), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TVec(4,a16.t), 'p': pos})
                    elif (e2 == 1):
                        delta7 = acc.params[2]
                        stride8 = acc.params[1]
                        a17 = acc.params[0]
                        index7 = (a17.pos >> 2)
                        offset7 = (delta7 if ((index7 == 0)) else _hx_AnonObject({'e': hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,delta7,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(index7)), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TInt, 'p': pos}))
                        e1 = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a17.g), 't': a17.g.type, 'p': pos}),offset7), 't': hxsl_Type.TVec(4,a17.t), 'p': pos})
                    else:
                        pass
                    e1.t = t
                    return e1
                size = self.varSize(t,a.t)
                if (size > 4):
                    return hxsl_Error.t(("Access not supported for " + HxOverrides.stringOrNull(hxsl_Tools.toString(t))),None)
                e3 = None
                e4 = acc.index
                if (e4 == 0):
                    a18 = acc.params[0]
                    e3 = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a18.g), 't': a18.g.type, 'p': pos}),_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt((a18.pos >> 2))), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TVec(4,a18.t), 'p': pos})
                elif (e4 == 1):
                    delta8 = acc.params[2]
                    stride9 = acc.params[1]
                    a19 = acc.params[0]
                    index8 = (a19.pos >> 2)
                    offset8 = (delta8 if ((index8 == 0)) else _hx_AnonObject({'e': hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,delta8,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(index8)), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TInt, 'p': pos}))
                    e3 = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a19.g), 't': a19.g.type, 'p': pos}),offset8), 't': hxsl_Type.TVec(4,a19.t), 'p': pos})
                else:
                    pass
                if (size == 4):
                    if (((a.pos & 3)) != 0):
                        raise _HxException("assert")
                else:
                    sw = []
                    _g3 = 0
                    _g12 = size
                    while (_g3 < _g12):
                        i1 = _g3
                        _g3 = (_g3 + 1)
                        x2 = python_internal_ArrayImpl._get(hxsl_Tools.SWIZ, (i1 + ((a.pos & 3))))
                        sw.append(x2)
                    e3 = _hx_AnonObject({'e': hxsl_TExprDef.TSwiz(e3,sw), 't': t, 'p': pos})
                tmp20 = t.index
                if (tmp20 == 1):
                    e3.t = hxsl_Type.TFloat
                    e3 = _hx_AnonObject({'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(hxsl_TGlobal.ToInt), 't': hxsl_Type.TFun([]), 'p': pos}),[e3]), 't': t, 'p': pos})
                elif (tmp20 == 5):
                    if (t.params[1].index == 0):
                        size1 = t.params[0]
                        e3.t = hxsl_Type.TVec(size1,hxsl_VecType.VFloat)
                        e3 = _hx_AnonObject({'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(python_internal_ArrayImpl._get([hxsl_TGlobal.IVec2, hxsl_TGlobal.IVec3, hxsl_TGlobal.IVec4], (size1 - 2))), 't': hxsl_Type.TFun([]), 'p': pos}),[e3]), 't': t, 'p': pos})
                else:
                    pass
                return e3
        else:
            if hxsl_Tools.isSampler(t):
                e5 = None
                e6 = acc.index
                if (e6 == 0):
                    a20 = acc.params[0]
                    e5 = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a20.g), 't': a20.g.type, 'p': pos}),_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt((a20.pos >> 2))), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TVec(4,a20.t), 'p': pos})
                elif (e6 == 1):
                    delta9 = acc.params[2]
                    stride10 = acc.params[1]
                    a21 = acc.params[0]
                    index9 = (a21.pos >> 2)
                    offset9 = (delta9 if ((index9 == 0)) else _hx_AnonObject({'e': hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,delta9,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(index9)), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TInt, 'p': pos}))
                    e5 = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a21.g), 't': a21.g.type, 'p': pos}),offset9), 't': hxsl_Type.TVec(4,a21.t), 'p': pos})
                else:
                    pass
                e5.t = t
                return e5
            size2 = self.varSize(t,a.t)
            if (size2 > 4):
                return hxsl_Error.t(("Access not supported for " + HxOverrides.stringOrNull(hxsl_Tools.toString(t))),None)
            e7 = None
            e8 = acc.index
            if (e8 == 0):
                a22 = acc.params[0]
                e7 = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a22.g), 't': a22.g.type, 'p': pos}),_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt((a22.pos >> 2))), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TVec(4,a22.t), 'p': pos})
            elif (e8 == 1):
                delta10 = acc.params[2]
                stride11 = acc.params[1]
                a23 = acc.params[0]
                index10 = (a23.pos >> 2)
                offset10 = (delta10 if ((index10 == 0)) else _hx_AnonObject({'e': hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,delta10,_hx_AnonObject({'e': hxsl_TExprDef.TConst(hxsl_Const.CInt(index10)), 't': hxsl_Type.TInt, 'p': pos})), 't': hxsl_Type.TInt, 'p': pos}))
                e7 = _hx_AnonObject({'e': hxsl_TExprDef.TArray(_hx_AnonObject({'e': hxsl_TExprDef.TVar(a23.g), 't': a23.g.type, 'p': pos}),offset10), 't': hxsl_Type.TVec(4,a23.t), 'p': pos})
            else:
                pass
            if (size2 == 4):
                if (((a.pos & 3)) != 0):
                    raise _HxException("assert")
            else:
                sw1 = []
                _g4 = 0
                _g13 = size2
                while (_g4 < _g13):
                    i2 = _g4
                    _g4 = (_g4 + 1)
                    x3 = python_internal_ArrayImpl._get(hxsl_Tools.SWIZ, (i2 + ((a.pos & 3))))
                    sw1.append(x3)
                e7 = _hx_AnonObject({'e': hxsl_TExprDef.TSwiz(e7,sw1), 't': t, 'p': pos})
            tmp21 = t.index
            if (tmp21 == 1):
                e7.t = hxsl_Type.TFloat
                e7 = _hx_AnonObject({'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(hxsl_TGlobal.ToInt), 't': hxsl_Type.TFun([]), 'p': pos}),[e7]), 't': t, 'p': pos})
            elif (tmp21 == 5):
                if (t.params[1].index == 0):
                    size3 = t.params[0]
                    e7.t = hxsl_Type.TVec(size3,hxsl_VecType.VFloat)
                    e7 = _hx_AnonObject({'e': hxsl_TExprDef.TCall(_hx_AnonObject({'e': hxsl_TExprDef.TGlobal(python_internal_ArrayImpl._get([hxsl_TGlobal.IVec2, hxsl_TGlobal.IVec3, hxsl_TGlobal.IVec4], (size3 - 2))), 't': hxsl_Type.TFun([]), 'p': pos}),[e7]), 't': t, 'p': pos})
            else:
                pass
            return e7

    def optimize(self,e):
        _g = e.e
        tmp = _g.index
        if (tmp == 8):
            _g13 = _g.params[1]
            _g12 = _g.params[0]
            _g16 = _g12.t
            _g15 = _g12.p
            _g14 = _g12.e
            if (_g14.index == 2):
                if (_g14.params[0].index == 52):
                    if (len(_g13) == 1):
                        _g18 = (_g13[0] if 0 < len(_g13) else None)
                        _g21 = _g18.t
                        _g20 = _g18.p
                        _g19 = _g18.e
                        if (_g19.index == 8):
                            _g22 = _g19.params[0]
                            _g26 = _g22.t
                            _g25 = _g22.p
                            _g24 = _g22.e
                            if (_g24.index == 2):
                                if (_g24.params[0].index == 51):
                                    args = _g19.params[1]
                                    rem = 0
                                    size = 0
                                    while (size < 4):
                                        t = python_internal_ArrayImpl._get(args, ((len(args) - 1) - rem)).t
                                        size = (size + self.varSize(t,hxsl_VecType.VFloat))
                                        rem = (rem + 1)
                                    if (size == 4):
                                        _g1 = 0
                                        _g11 = rem
                                        while (_g1 < _g11):
                                            i = _g1
                                            _g1 = (_g1 + 1)
                                            if (len(args) != 0):
                                                args.pop()
                                        emat = None
                                        _g2 = e.e
                                        if (_g2.index == 8):
                                            _g4 = _g2.params[1]
                                            e1 = _g2.params[0]
                                            emat = e1
                                        else:
                                            raise _HxException("assert")
                                        return _hx_AnonObject({'e': hxsl_TExprDef.TCall(emat,args), 't': e.t, 'p': e.p})
        elif (tmp == 16):
            _g23 = _g.params[1]
            _g17 = _g.params[0]
            _g5 = _g17.t
            _g41 = _g17.p
            _g3 = _g17.e
            if (_g3.index == 17):
                _g9 = _g23.t
                _g8 = _g23.p
                _g7 = _g23.e
                if (_g7.index == 0):
                    _g10 = _g7.params[0]
                    if (_g10.index == 2):
                        el = _g3.params[0]
                        i1 = _g10.params[0]
                        if ((i1 >= 0) and ((i1 < len(el)))):
                            return (el[i1] if i1 >= 0 and i1 < len(el) else None)
                        hxsl_Error.t("Reading outside array bounds",e.p)
        else:
            pass
        return e

    def packTextures(self,name,vars,t):
        alloc = list()
        g = _hx_AnonObject({'id': hxsl_Tools.allocVarId(), 'name': name, 'type': t, 'kind': hxsl_VarKind.Param})
        _g = 0
        while (_g < len(vars)):
            v = (vars[_g] if _g >= 0 and _g < len(vars) else None)
            _g = (_g + 1)
            if (v.type != t):
                tmp = None
                if (t == hxsl_Type.TSampler2D):
                    _g1 = v.type
                    if (_g1.index == 17):
                        _g11 = _g1.params[0]
                        tmp = True
                    else:
                        tmp = False
                else:
                    tmp = False
                if (not tmp):
                    continue
            a = hxsl__Flatten_Alloc(g,None,(len(alloc) << 2),1)
            a.v = v
            self.varMap.set(v,a)
            alloc.append(a)
        g.type = hxsl_Type.TArray(t,hxsl_SizeDecl.SConst(len(alloc)))
        if (len(alloc) > 0):
            _this = self.outVars
            _this.append(g)
            self.allocData.set(g,alloc)
        return alloc

    def packBuffers(self,vars):
        alloc = list()
        g = _hx_AnonObject({'id': hxsl_Tools.allocVarId(), 'name': "buffers", 'type': hxsl_Type.TVoid, 'kind': hxsl_VarKind.Param})
        _g = 0
        while (_g < len(vars)):
            v = (vars[_g] if _g >= 0 and _g < len(vars) else None)
            _g = (_g + 1)
            _g1 = v.type
            tmp = None
            if (_g1.index == 16):
                _g2 = _g1.params[1]
                _g11 = _g1.params[0]
                tmp = True
            else:
                tmp = False
            if tmp:
                a = hxsl__Flatten_Alloc(g,None,len(alloc),1)
                a.v = v
                alloc.append(a)
                _this = self.outVars
                _this.append(v)
        g.type = hxsl_Type.TArray(hxsl_Type.TBuffer(hxsl_Type.TVoid,hxsl_SizeDecl.SConst(0)),hxsl_SizeDecl.SConst(len(alloc)))
        self.allocData.set(g,alloc)

    def pack(self,name,kind,vars,t):
        alloc = list()
        apos = 0
        g = _hx_AnonObject({'id': hxsl_Tools.allocVarId(), 'name': name, 'type': hxsl_Type.TVec(0,t), 'kind': kind})
        _g = 0
        while (_g < len(vars)):
            v = (vars[_g] if _g >= 0 and _g < len(vars) else None)
            _g = (_g + 1)
            tmp = None
            if (not hxsl_Tools.isSampler(v.type)):
                _g1 = v.type
                if (_g1.index == 16):
                    _g2 = _g1.params[1]
                    _g11 = _g1.params[0]
                    tmp = True
                else:
                    tmp = False
            else:
                tmp = True
            if tmp:
                continue
            size = self.varSize(v.type,t)
            best = None
            _g3 = 0
            while (_g3 < len(alloc)):
                a = (alloc[_g3] if _g3 >= 0 and _g3 < len(alloc) else None)
                _g3 = (_g3 + 1)
                if (((a.v is None) and ((a.size >= size))) and (((best is None) or ((best.size > a.size))))):
                    best = a
            if (best is not None):
                free = (best.size - size)
                if (free > 0):
                    i = python_internal_ArrayImpl.indexOf(alloc,best,None)
                    a1 = hxsl__Flatten_Alloc(g,t,(best.pos + size),free)
                    alloc.insert((i + 1), a1)
                    best.size = size
                best.v = v
                self.varMap.set(v,best)
            else:
                a2 = hxsl__Flatten_Alloc(g,t,apos,size)
                apos = (apos + size)
                a2.v = v
                self.varMap.set(v,a2)
                alloc.append(a2)
                pad = HxOverrides.mod(((4 - (HxOverrides.mod(size, 4)))), 4)
                if (pad > 0):
                    a3 = hxsl__Flatten_Alloc(g,t,apos,pad)
                    apos = (apos + pad)
                    alloc.append(a3)
        g.type = hxsl_Type.TArray(hxsl_Type.TVec(4,t),hxsl_SizeDecl.SConst((apos >> 2)))
        if (apos > 0):
            _this = self.outVars
            _this.append(g)
            self.allocData.set(g,alloc)
        return g

    def varSize(self,v,t):
        tmp = v.index
        if ((tmp == 3) or ((tmp == 1))):
            if (t == hxsl_VecType.VFloat):
                return 1
            else:
                raise _HxException(((HxOverrides.stringOrNull(hxsl_Tools.toString(v)) + " size unknown for type ") + Std.string(t)))
        elif (tmp == 5):
            t2 = v.params[1]
            n = v.params[0]
            if (t == t2):
                return n
            else:
                raise _HxException(((HxOverrides.stringOrNull(hxsl_Tools.toString(v)) + " size unknown for type ") + Std.string(t)))
        elif (tmp == 7):
            if (t == hxsl_VecType.VFloat):
                return 16
            else:
                raise _HxException(((HxOverrides.stringOrNull(hxsl_Tools.toString(v)) + " size unknown for type ") + Std.string(t)))
        elif ((tmp == 8) or ((tmp == 6))):
            if (t == hxsl_VecType.VFloat):
                return 12
            else:
                raise _HxException(((HxOverrides.stringOrNull(hxsl_Tools.toString(v)) + " size unknown for type ") + Std.string(t)))
        elif (tmp == 15):
            _g3 = v.params[1]
            if (_g3.index == 0):
                at = v.params[0]
                n1 = _g3.params[0]
                return (self.varSize(at,t) * n1)
            else:
                raise _HxException(((HxOverrides.stringOrNull(hxsl_Tools.toString(v)) + " size unknown for type ") + Std.string(t)))
        else:
            raise _HxException(((HxOverrides.stringOrNull(hxsl_Tools.toString(v)) + " size unknown for type ") + Std.string(t)))

    def gatherVar(self,v):
        _g = v.type
        if (_g.index == 13):
            vl = _g.params[0]
            _g1 = 0
            while (_g1 < len(vl)):
                v1 = (vl[_g1] if _g1 >= 0 and _g1 < len(vl) else None)
                _g1 = (_g1 + 1)
                self.gatherVar(v1)
        else:
            tmp = v.kind.index
            if (tmp == 0):
                if hxsl_Tools.hasQualifier(v,hxsl_VarQualifier.PerObject):
                    _this = self.params
                    _this.append(v)
                else:
                    _this1 = self.globals
                    _this1.append(v)
            elif (tmp == 2):
                _this2 = self.params
                _this2.append(v)
            else:
                _this3 = self.outVars
                _this3.append(v)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.globals = None
        _hx_o.params = None
        _hx_o.outVars = None
        _hx_o.varMap = None
        _hx_o.econsts = None
        _hx_o.consts = None
        _hx_o.allocData = None
hxsl_Flatten._hx_class = hxsl_Flatten
_hx_classes["hxsl.Flatten"] = hxsl_Flatten


class hxsl__Globals_GlobalSlot_Impl_:
    _hx_class_name = "hxsl._Globals.GlobalSlot_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "toInt", "set", "get"]

    @staticmethod
    def _new(name):
        this1 = hxsl_Globals.allocID(name)
        return this1

    @staticmethod
    def toInt(this1):
        return this1

    @staticmethod
    def set(this1,globals,v):
        globals.map.set(this1,v)

    @staticmethod
    def get(this1,globals):
        return globals.map.h.get(this1,None)
hxsl__Globals_GlobalSlot_Impl_._hx_class = hxsl__Globals_GlobalSlot_Impl_
_hx_classes["hxsl._Globals.GlobalSlot_Impl_"] = hxsl__Globals_GlobalSlot_Impl_


class hxsl_Globals:
    _hx_class_name = "hxsl.Globals"
    _hx_is_interface = "False"
    __slots__ = ("map", "channels", "maxChannels")
    _hx_fields = ["map", "channels", "maxChannels"]
    _hx_methods = ["set", "get", "fastSet", "fastGet", "resetChannels", "allocChannelID"]
    _hx_statics = ["ALL", "MAP", "allocID", "getIDName"]

    def __init__(self):
        self.maxChannels = None
        self.channels = []
        self.map = haxe_ds_IntMap()

    def set(self,path,v):
        self.map.set(hxsl_Globals.allocID(path),v)

    def get(self,path):
        this1 = self.map
        key = hxsl_Globals.allocID(path)
        return this1.h.get(key,None)

    def fastSet(self,id,v):
        self.map.set(id,v)

    def fastGet(self,id):
        return self.map.h.get(id,None)

    def resetChannels(self):
        self.maxChannels = 0

    def allocChannelID(self,t):
        _g = 0
        _g1 = self.maxChannels
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if ((self.channels[i] if i >= 0 and i < len(self.channels) else None) == t):
                return i
        if (self.maxChannels == ((1 << hxsl_Tools.MAX_CHANNELS_BITS))):
            raise _HxException("Too many unique channels")
        i1 = self.maxChannels
        self.maxChannels = (self.maxChannels + 1)
        python_internal_ArrayImpl._set(self.channels, i1, t)
        return i1
    ALL = None
    MAP = None

    @staticmethod
    def allocID(path):
        if (hxsl_Globals.MAP is None):
            hxsl_Globals.MAP = haxe_ds_StringMap()
            hxsl_Globals.ALL = []
        id = hxsl_Globals.MAP.h.get(path,None)
        if (id is None):
            id = len(hxsl_Globals.ALL)
            _this = hxsl_Globals.ALL
            _this.append(path)
            hxsl_Globals.MAP.h[path] = id
        return id

    @staticmethod
    def getIDName(id):
        return python_internal_ArrayImpl._get(hxsl_Globals.ALL, id)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.map = None
        _hx_o.channels = None
        _hx_o.maxChannels = None
hxsl_Globals._hx_class = hxsl_Globals
_hx_classes["hxsl.Globals"] = hxsl_Globals


class hxsl__Linker_AllocatedVar:
    _hx_class_name = "hxsl._Linker.AllocatedVar"
    _hx_is_interface = "False"
    __slots__ = ("id", "v", "path", "merged", "kind", "parent", "instanceIndex")
    _hx_fields = ["id", "v", "path", "merged", "kind", "parent", "instanceIndex"]

    def __init__(self):
        self.instanceIndex = None
        self.parent = None
        self.kind = None
        self.merged = None
        self.path = None
        self.v = None
        self.id = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.id = None
        _hx_o.v = None
        _hx_o.path = None
        _hx_o.merged = None
        _hx_o.kind = None
        _hx_o.parent = None
        _hx_o.instanceIndex = None
hxsl__Linker_AllocatedVar._hx_class = hxsl__Linker_AllocatedVar
_hx_classes["hxsl._Linker.AllocatedVar"] = hxsl__Linker_AllocatedVar


class hxsl__Linker_ShaderInfos:
    _hx_class_name = "hxsl._Linker.ShaderInfos"
    _hx_is_interface = "False"
    __slots__ = ("uid", "name", "priority", "body", "usedFunctions", "deps", "read", "write", "processed", "vertex", "onStack", "hasDiscard", "marked")
    _hx_fields = ["uid", "name", "priority", "body", "usedFunctions", "deps", "read", "write", "processed", "vertex", "onStack", "hasDiscard", "marked"]
    _hx_statics = ["UID"]

    def __init__(self,n,v):
        self.marked = None
        self.hasDiscard = None
        self.onStack = None
        self.deps = None
        self.body = None
        self.priority = None
        self.name = n
        def _hx_local_2():
            _hx_local_0 = hxsl__Linker_ShaderInfos
            _hx_local_1 = _hx_local_0.UID
            _hx_local_0.UID = (_hx_local_1 + 1)
            return _hx_local_1
        self.uid = _hx_local_2()
        self.vertex = v
        self.processed = haxe_ds_IntMap()
        self.usedFunctions = []
        self.read = haxe_ds_IntMap()
        self.write = haxe_ds_IntMap()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.uid = None
        _hx_o.name = None
        _hx_o.priority = None
        _hx_o.body = None
        _hx_o.usedFunctions = None
        _hx_o.deps = None
        _hx_o.read = None
        _hx_o.write = None
        _hx_o.processed = None
        _hx_o.vertex = None
        _hx_o.onStack = None
        _hx_o.hasDiscard = None
        _hx_o.marked = None
hxsl__Linker_ShaderInfos._hx_class = hxsl__Linker_ShaderInfos
_hx_classes["hxsl._Linker.ShaderInfos"] = hxsl__Linker_ShaderInfos


class hxsl_Linker:
    _hx_class_name = "hxsl.Linker"
    _hx_is_interface = "False"
    __slots__ = ("allVars", "varMap", "curShader", "shaders", "varIdMap", "locals", "curInstance", "batchMode", "isBatchShader", "debugDepth")
    _hx_fields = ["allVars", "varMap", "curShader", "shaders", "varIdMap", "locals", "curInstance", "batchMode", "isBatchShader", "debugDepth"]
    _hx_methods = ["debug", "error", "mergeVar", "allocVar", "mapExprVar", "addShader", "sortByPriorityDesc", "buildDependency", "initDependencies", "collect", "uniqueLocals", "link"]

    def __init__(self,batchMode = None):
        if (batchMode is None):
            batchMode = False
        self.isBatchShader = None
        self.curInstance = None
        self.locals = None
        self.varIdMap = None
        self.shaders = None
        self.curShader = None
        self.varMap = None
        self.allVars = None
        self.debugDepth = 0
        self.batchMode = batchMode

    def debug(self,msg,pos = None):
        pass

    def error(self,msg,p):
        return hxsl_Error.t(msg,p)

    def mergeVar(self,path,v,v2,p):
        tmp = v.kind.index
        if (((((tmp == 5) or ((tmp == 4))) or ((tmp == 3))) or ((tmp == 1))) or ((tmp == 0))):
            pass
        elif ((tmp == 6) or ((tmp == 2))):
            raise _HxException("assert")
        else:
            pass
        if (((v.kind != v2.kind) and ((v.kind != hxsl_VarKind.Local))) and ((v2.kind != hxsl_VarKind.Local))):
            self.error(((((("'" + ("null" if path is None else path)) + "' kind does not match : ") + Std.string(v.kind)) + " should be ") + Std.string(v2.kind)),p)
        _g1 = v2.type
        _g2 = v.type
        if (_g2.index == 13):
            if (_g1.index == 13):
                fl1 = _g2.params[0]
                fl2 = _g1.params[0]
                _g11 = 0
                while (_g11 < len(fl1)):
                    f1 = (fl1[_g11] if _g11 >= 0 and _g11 < len(fl1) else None)
                    _g11 = (_g11 + 1)
                    ft = None
                    _g12 = 0
                    while (_g12 < len(fl2)):
                        f2 = (fl2[_g12] if _g12 >= 0 and _g12 < len(fl2) else None)
                        _g12 = (_g12 + 1)
                        if (f1.name == f2.name):
                            ft = f2
                            break
                    if (ft is None):
                        x = self.allocVar(f1,p).v
                        fl2.append(x)
                    else:
                        self.mergeVar(((("null" if path is None else path) + ".") + HxOverrides.stringOrNull(ft.name)),f1,ft,p)
            elif (not Type.enumEq(v.type,v2.type)):
                self.error(((((("'" + ("null" if path is None else path)) + "' type does not match : ") + HxOverrides.stringOrNull(hxsl_Tools.toString(v.type))) + " should be ") + HxOverrides.stringOrNull(hxsl_Tools.toString(v2.type))),p)
        elif (not Type.enumEq(v.type,v2.type)):
            self.error(((((("'" + ("null" if path is None else path)) + "' type does not match : ") + HxOverrides.stringOrNull(hxsl_Tools.toString(v.type))) + " should be ") + HxOverrides.stringOrNull(hxsl_Tools.toString(v2.type))),p)

    def allocVar(self,v,p,path = None,parent = None):
        _gthis = self
        if ((Reflect.field(v,"parent") is not None) and ((parent is None))):
            parent = self.allocVar(Reflect.field(v,"parent"),p)
            p1 = parent.v
            path = p1.name
            p1 = Reflect.field(p1,"parent")
            while (p1 is not None):
                path = ((HxOverrides.stringOrNull(p1.name) + ".") + ("null" if path is None else path))
                p1 = Reflect.field(p1,"parent")
        key = (v.name if ((path is None)) else ((("null" if path is None else path) + ".") + HxOverrides.stringOrNull(v.name)))
        if (Reflect.field(v,"qualifiers") is not None):
            _g = 0
            _g1 = Reflect.field(v,"qualifiers")
            while (_g < len(_g1)):
                q = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                if (q.index == 4):
                    n = q.params[0]
                    key = n
        v2 = self.varMap.h.get(key,None)
        vname = v.name
        if (v2 is not None):
            _g2 = 0
            _g11 = v2.merged
            while (_g2 < len(_g11)):
                vm = (_g11[_g2] if _g2 >= 0 and _g2 < len(_g11) else None)
                _g2 = (_g2 + 1)
                if (vm == v):
                    return v2
            tmp = None
            if (not ((((((v.kind == hxsl_VarKind.Param) and (not hxsl_Tools.hasQualifier(v,hxsl_VarQualifier.Shared))) and (not _gthis.isBatchShader)) or ((v.kind == hxsl_VarKind.Function))) or (((v.kind == hxsl_VarKind.Var) and hxsl_Tools.hasQualifier(v,hxsl_VarQualifier.Private)))))):
                v1 = v2.v
                tmp = (((((v1.kind == hxsl_VarKind.Param) and (not hxsl_Tools.hasQualifier(v1,hxsl_VarQualifier.Shared))) and (not _gthis.isBatchShader)) or ((v1.kind == hxsl_VarKind.Function))) or (((v1.kind == hxsl_VarKind.Var) and hxsl_Tools.hasQualifier(v1,hxsl_VarQualifier.Private))))
            else:
                tmp = True
            if (tmp or (((v.kind == hxsl_VarKind.Param) and ((v2.v.kind == hxsl_VarKind.Param))))):
                k = 2
                while True:
                    a = self.varMap.h.get((("null" if key is None else key) + Std.string(k)),None)
                    if (a is None):
                        break
                    _g21 = 0
                    _g3 = a.merged
                    while (_g21 < len(_g3)):
                        vm1 = (_g3[_g21] if _g21 >= 0 and _g21 < len(_g3) else None)
                        _g21 = (_g21 + 1)
                        if (vm1 == v):
                            return a
                    k = (k + 1)
                vname = (("null" if vname is None else vname) + Std.string(k))
                key = (("null" if key is None else key) + Std.string(k))
            else:
                _this = v2.merged
                _this.append(v)
                self.mergeVar(key,v,v2.v,p)
                self.varIdMap.set(v.id,v2.id)
                return v2
        vid = (len(self.allVars) + 1)
        v21 = _hx_AnonObject({'id': vid, 'name': vname, 'type': v.type, 'kind': v.kind, 'qualifiers': Reflect.field(v,"qualifiers"), 'parent': (None if ((parent is None)) else parent.v)})
        a1 = hxsl__Linker_AllocatedVar()
        a1.v = v21
        a1.merged = [v]
        a1.path = key
        a1.id = vid
        a1.parent = parent
        a1.instanceIndex = self.curInstance
        _this1 = self.allVars
        _this1.append(a1)
        self.varMap.h[key] = a1
        _g4 = v21.type
        if (_g4.index == 13):
            vl = _g4.params[0]
            _g5 = []
            _g12 = 0
            while (_g12 < len(vl)):
                v3 = (vl[_g12] if _g12 >= 0 and _g12 < len(vl) else None)
                _g12 = (_g12 + 1)
                x = self.allocVar(v3,p,key,a1).v
                _g5.append(x)
            v21.type = hxsl_Type.TStruct(_g5)
        return a1

    def mapExprVar(self,e):
        _g = e.e
        tmp = _g.index
        if (tmp == 1):
            v = _g.params[0]
            if (not (v.id in self.locals.h)):
                v1 = self.allocVar(v,e.p)
                if ((self.curShader is not None) and (not (v1.id in self.curShader.write.h))):
                    self.curShader.read.set(v1.id,v1)
                    if ((self.curShader.vertex is None) and ((v1.v.kind == hxsl_VarKind.Var))):
                        self.curShader.vertex = False
                return _hx_AnonObject({'e': hxsl_TExprDef.TVar(v1.v), 't': v1.v.type, 'p': e.p})
        elif (tmp == 5):
            e2 = _g.params[2]
            e1 = _g.params[1]
            op = _g.params[0]
            _g1 = e1.e
            tmp1 = op.index
            if (tmp1 == 4):
                tmp2 = _g1.index
                if (tmp2 == 1):
                    _g11 = _g1.params[0]
                    v2 = _g11
                    if (not (v2.id in self.locals.h)):
                        e21 = self.mapExprVar(e2)
                        v3 = self.allocVar(v2,e1.p)
                        if (self.curShader is not None):
                            self.curShader.write.set(v3.id,v3)
                        return _hx_AnonObject({'e': hxsl_TExprDef.TBinop(op,_hx_AnonObject({'e': hxsl_TExprDef.TVar(v3.v), 't': v3.v.type, 'p': e.p}),e21), 't': e.t, 'p': e.p})
                    else:
                        v4 = _g11
                        if (not (v4.id in self.locals.h)):
                            e11 = self.mapExprVar(e1)
                            e22 = self.mapExprVar(e2)
                            v5 = self.allocVar(v4,e11.p)
                            if (self.curShader is not None):
                                self.curShader.write.set(v5.id,v5)
                            return _hx_AnonObject({'e': hxsl_TExprDef.TBinop(op,e11,e22), 't': e.t, 'p': e.p})
                elif (tmp2 == 9):
                    _g3 = _g1.params[1]
                    _g2 = _g1.params[0]
                    _g6 = _g2.t
                    _g5 = _g2.p
                    _g4 = _g2.e
                    if (_g4.index == 1):
                        v6 = _g4.params[0]
                        if (not (v6.id in self.locals.h)):
                            e12 = self.mapExprVar(e1)
                            e23 = self.mapExprVar(e2)
                            v7 = self.allocVar(v6,e12.p)
                            if (self.curShader is not None):
                                self.curShader.write.set(v7.id,v7)
                            return _hx_AnonObject({'e': hxsl_TExprDef.TBinop(op,e12,e23), 't': e.t, 'p': e.p})
                else:
                    pass
            elif (tmp1 == 20):
                _g8 = op.params[0]
                tmp3 = _g1.index
                if (tmp3 == 1):
                    v8 = _g1.params[0]
                    if (not (v8.id in self.locals.h)):
                        e13 = self.mapExprVar(e1)
                        e24 = self.mapExprVar(e2)
                        v9 = self.allocVar(v8,e13.p)
                        if (self.curShader is not None):
                            self.curShader.write.set(v9.id,v9)
                        return _hx_AnonObject({'e': hxsl_TExprDef.TBinop(op,e13,e24), 't': e.t, 'p': e.p})
                elif (tmp3 == 9):
                    _g111 = _g1.params[1]
                    _g10 = _g1.params[0]
                    _g14 = _g10.t
                    _g13 = _g10.p
                    _g12 = _g10.e
                    if (_g12.index == 1):
                        v10 = _g12.params[0]
                        if (not (v10.id in self.locals.h)):
                            e14 = self.mapExprVar(e1)
                            e25 = self.mapExprVar(e2)
                            v11 = self.allocVar(v10,e14.p)
                            if (self.curShader is not None):
                                self.curShader.write.set(v11.id,v11)
                            return _hx_AnonObject({'e': hxsl_TExprDef.TBinop(op,e14,e25), 't': e.t, 'p': e.p})
                else:
                    pass
            else:
                pass
        elif (tmp == 7):
            _g61 = _g.params[1]
            v12 = _g.params[0]
            self.locals.set(v12.id,True)
        elif (tmp == 11):
            if (self.curShader is not None):
                self.curShader.vertex = False
                self.curShader.hasDiscard = True
        elif (tmp == 13):
            _g41 = _g.params[2]
            _g31 = _g.params[1]
            v13 = _g.params[0]
            self.locals.set(v13.id,True)
        else:
            pass
        return hxsl_Tools.map(e,self.mapExprVar)

    def addShader(self,name,vertex,e,p):
        s = hxsl__Linker_ShaderInfos(name,vertex)
        self.curShader = s
        s.priority = p
        s.body = self.mapExprVar(e)
        _this = self.shaders
        _this.append(s)
        self.curShader = None
        return s

    def sortByPriorityDesc(self,s1,s2):
        if (s1.priority == s2.priority):
            return (s1.uid - s2.uid)
        return (s2.priority - s1.priority)

    def buildDependency(self,s,v,isWritten):
        found = (not isWritten)
        _g = 0
        _g1 = self.shaders
        while (_g < len(_g1)):
            parent = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (parent == s):
                found = True
                continue
            elif (not found):
                continue
            if (not (v.id in parent.write.h)):
                continue
            if s.vertex:
                if (parent.vertex == False):
                    continue
                if (parent.vertex is None):
                    parent.vertex = True
            s.deps.set(parent,True)
            _hx_local_1 = self
            _hx_local_2 = _hx_local_1.debugDepth
            _hx_local_1.debugDepth = (_hx_local_2 + 1)
            _hx_local_2
            self.initDependencies(parent)
            _hx_local_3 = self
            _hx_local_4 = _hx_local_3.debugDepth
            _hx_local_3.debugDepth = (_hx_local_4 - 1)
            _hx_local_4
            if (not (v.id in parent.read.h)):
                return
        if (v.v.kind == hxsl_VarKind.Var):
            self.error((((("Variable " + HxOverrides.stringOrNull(v.path)) + " required by ") + HxOverrides.stringOrNull(s.name)) + " is missing initializer"),None)

    def initDependencies(self,s):
        if (s.deps is not None):
            return
        s.deps = haxe_ds_ObjectMap()
        r = s.read.iterator()
        while r.hasNext():
            r1 = r.next()
            self.buildDependency(s,r1,(r1.id in s.write.h))
        if (s.vertex is None):
            d = s.deps.keys()
            while d.hasNext():
                d1 = d.next()
                if (d1.vertex == False):
                    s.vertex = False
                    break
        if s.vertex:
            d2 = s.deps.keys()
            while d2.hasNext():
                d3 = d2.next()
                if (d3.vertex is None):
                    d3.vertex = True

    def collect(self,cur,out,vertex):
        if cur.onStack:
            self.error((("Loop in shader dependencies (" + HxOverrides.stringOrNull(cur.name)) + ")"),None)
        if (cur.marked == vertex):
            return
        cur.marked = vertex
        cur.onStack = True
        _g = []
        d = cur.deps.keys()
        while d.hasNext():
            d1 = d.next()
            _g.append(d1)
        deps = _g
        deps.sort(key= python_lib_Functools.cmp_to_key(self.sortByPriorityDesc))
        _g1 = 0
        while (_g1 < len(deps)):
            d2 = (deps[_g1] if _g1 >= 0 and _g1 < len(deps) else None)
            _g1 = (_g1 + 1)
            self.collect(d2,out,vertex)
        if (cur.vertex is None):
            cur.vertex = vertex
        if (cur.vertex == vertex):
            out.append(cur)
        cur.onStack = False

    def uniqueLocals(self,expr,locals):
        _g = expr.e
        tmp = _g.index
        if (tmp == 4):
            el = _g.params[0]
            _g1 = haxe_ds_StringMap()
            k = locals.keys()
            while k.hasNext():
                k1 = k.next()
                _g1.h[k1] = True
            locals1 = _g1
            _g11 = 0
            while (_g11 < len(el)):
                e = (el[_g11] if _g11 >= 0 and _g11 < len(el) else None)
                _g11 = (_g11 + 1)
                self.uniqueLocals(e,locals1)
        elif (tmp == 7):
            _g3 = _g.params[1]
            v = _g.params[0]
            if (v.name in locals.h):
                k2 = 2
                while ((HxOverrides.stringOrNull(v.name) + Std.string(k2)) in locals.h):
                    k2 = (k2 + 1)
                v.name = (HxOverrides.stringOrNull(v.name) + Std.string(k2))
            locals.h[v.name] = True
        else:
            f = self.uniqueLocals
            locals2 = locals
            def _hx_local_3(expr1):
                f(expr1,locals2)
            hxsl_Tools.iter(expr,_hx_local_3)

    def link(self,shadersData):
        _gthis = self
        self.varMap = haxe_ds_StringMap()
        self.varIdMap = haxe_ds_IntMap()
        self.allVars = list()
        self.shaders = []
        self.locals = haxe_ds_IntMap()
        dupShaders = haxe_ds_ObjectMap()
        _g = []
        _g1 = 0
        while (_g1 < len(shadersData)):
            s = (shadersData[_g1] if _g1 >= 0 and _g1 < len(shadersData) else None)
            _g1 = (_g1 + 1)
            s1 = s
            sreal = s1
            if (s1 in dupShaders.h):
                s1 = hxsl_Clone.shaderData(s1)
            dupShaders.set(s1,sreal)
            _g.append(s1)
        shadersData = _g
        self.curInstance = 0
        outVars = []
        _g2 = 0
        while (_g2 < len(shadersData)):
            s2 = (shadersData[_g2] if _g2 >= 0 and _g2 < len(shadersData) else None)
            _g2 = (_g2 + 1)
            self.isBatchShader = (self.batchMode and s2.name.startswith("batchShader_"))
            _g21 = 0
            _g3 = s2.vars
            while (_g21 < len(_g3)):
                v = (_g3[_g21] if _g21 >= 0 and _g21 < len(_g3) else None)
                _g21 = (_g21 + 1)
                v2 = self.allocVar(v,None)
                if ((self.isBatchShader and ((v2.v.kind == hxsl_VarKind.Param))) and (not v2.path.startswith("Batch_"))):
                    v2.v.kind = hxsl_VarKind.Local
                if (v.kind == hxsl_VarKind.Output):
                    outVars.append(v)
            _g4 = 0
            _g5 = s2.funs
            while (_g4 < len(_g5)):
                f = (_g5[_g4] if _g4 >= 0 and _g4 < len(_g5) else None)
                _g4 = (_g4 + 1)
                v1 = self.allocVar(f.ref,f.expr.p)
                v1.kind = f.kind
            _hx_local_4 = self
            _hx_local_5 = _hx_local_4.curInstance
            _hx_local_4.curInstance = (_hx_local_5 + 1)
            _hx_local_5
        priority = 0
        initPrio_init = [-3000]
        initPrio_vert = [-2000]
        initPrio_frag = [-1000]
        _g31 = 0
        while (_g31 < len(shadersData)):
            s3 = (shadersData[_g31] if _g31 >= 0 and _g31 < len(shadersData) else None)
            _g31 = (_g31 + 1)
            _g32 = 0
            _g41 = s3.funs
            while (_g32 < len(_g41)):
                f1 = (_g41[_g32] if _g32 >= 0 and _g32 < len(_g41) else None)
                _g32 = (_g32 + 1)
                v3 = self.allocVar(f1.ref,f1.expr.p)
                if (v3.kind is None):
                    raise _HxException("assert")
                tmp = v3.kind.index
                if ((tmp == 1) or ((tmp == 0))):
                    self.addShader(((HxOverrides.stringOrNull(s3.name) + ".") + HxOverrides.stringOrNull((("vertex" if ((v3.kind == hxsl_FunctionKind.Vertex)) else "fragment")))),(v3.kind == hxsl_FunctionKind.Vertex),f1.expr,priority)
                elif (tmp == 2):
                    prio = None
                    status = None
                    _g33 = f1.ref.name
                    _hx_local_8 = len(_g33)
                    if (_hx_local_8 == 16):
                        if (_g33 == "__init__fragment"):
                            prio = initPrio_frag
                            status = False
                        else:
                            prio = initPrio_init
                            status = None
                    elif (_hx_local_8 == 14):
                        if (_g33 == "__init__vertex"):
                            prio = initPrio_vert
                            status = True
                        else:
                            prio = initPrio_init
                            status = None
                    else:
                        prio = initPrio_init
                        status = None
                    _g42 = f1.expr.e
                    if (_g42.index == 4):
                        el = _g42.params[0]
                        index = 0
                        _g43 = 0
                        while (_g43 < len(el)):
                            e = (el[_g43] if _g43 >= 0 and _g43 < len(el) else None)
                            _g43 = (_g43 + 1)
                            tmp1 = index
                            index = (index + 1)
                            def _hx_local_13():
                                _hx_local_10 = prio
                                _hx_local_11 = 0
                                _hx_local_12 = (_hx_local_10[_hx_local_11] if _hx_local_11 >= 0 and _hx_local_11 < len(_hx_local_10) else None)
                                python_internal_ArrayImpl._set(_hx_local_10, _hx_local_11, (_hx_local_12 + 1))
                                return _hx_local_12
                            self.addShader((((HxOverrides.stringOrNull(s3.name) + ".") + HxOverrides.stringOrNull(f1.ref.name)) + Std.string(tmp1)),status,e,_hx_local_13())
                    else:
                        def _hx_local_17():
                            _hx_local_14 = prio
                            _hx_local_15 = 0
                            _hx_local_16 = (_hx_local_14[_hx_local_15] if _hx_local_15 >= 0 and _hx_local_15 < len(_hx_local_14) else None)
                            python_internal_ArrayImpl._set(_hx_local_14, _hx_local_15, (_hx_local_16 + 1))
                            return _hx_local_16
                        self.addShader(((HxOverrides.stringOrNull(s3.name) + ".") + HxOverrides.stringOrNull(f1.ref.name)),status,f1.expr,_hx_local_17())
                elif (tmp == 3):
                    raise _HxException(("Unexpected helper function in linker " + HxOverrides.stringOrNull(v3.v.name)))
                else:
                    pass
            priority = (priority + 1)
        self.shaders.sort(key= python_lib_Functools.cmp_to_key(self.sortByPriorityDesc))
        entry = hxsl__Linker_ShaderInfos("<entry>",False)
        entry.deps = haxe_ds_ObjectMap()
        _g44 = 0
        while (_g44 < len(outVars)):
            v4 = (outVars[_g44] if _g44 >= 0 and _g44 < len(outVars) else None)
            _g44 = (_g44 + 1)
            self.buildDependency(entry,self.allocVar(v4,None),False)
        _g51 = 0
        _g6 = self.shaders
        while (_g51 < len(_g6)):
            s4 = (_g6[_g51] if _g51 >= 0 and _g51 < len(_g6) else None)
            _g51 = (_g51 + 1)
            if s4.hasDiscard:
                self.initDependencies(s4)
                entry.deps.set(s4,True)
        _g7 = 0
        _g8 = self.shaders
        while (_g7 < len(_g8)):
            s5 = (_g8[_g7] if _g7 >= 0 and _g7 < len(_g8) else None)
            _g7 = (_g7 + 1)
            if (s5.vertex is not None):
                continue
            onlyParams = True
            r = s5.read.iterator()
            while r.hasNext():
                r1 = r.next()
                if (r1.v.kind != hxsl_VarKind.Param):
                    onlyParams = False
                    break
            if onlyParams:
                s5.vertex = False
        v5 = []
        f2 = []
        self.collect(entry,v5,True)
        self.collect(entry,f2,False)
        if (((None if ((len(f2) == 0)) else f2.pop())) != entry):
            raise _HxException("assert")
        _g9 = 0
        _g10 = self.shaders
        while (_g9 < len(_g10)):
            s6 = (_g10[_g9] if _g9 >= 0 and _g9 < len(_g10) else None)
            _g9 = (_g9 + 1)
            s6.marked = None
        _g11 = 0
        _g12 = (v5 + f2)
        while (_g11 < len(_g12)):
            s7 = (_g12[_g11] if _g11 >= 0 and _g11 < len(_g12) else None)
            _g11 = (_g11 + 1)
            d = s7.deps.keys()
            while d.hasNext():
                d1 = d.next()
                if (d1.marked is None):
                    self.error((((HxOverrides.stringOrNull(d1.name) + " needed by ") + HxOverrides.stringOrNull(s7.name)) + " is unreachable"),None)
            s7.marked = True
        outVars1 = []
        varMap = haxe_ds_IntMap()
        addVar = None
        def _hx_local_24(v6):
            if (v6.id in varMap.h):
                return
            varMap.set(v6.id,True)
            if (Reflect.field(v6.v,"parent") is not None):
                addVar(v6.parent)
            else:
                x = v6.v
                outVars1.append(x)
        addVar = _hx_local_24
        _g13 = 0
        _g14 = (v5 + f2)
        while (_g13 < len(_g14)):
            s8 = (_g14[_g13] if _g13 >= 0 and _g13 < len(_g14) else None)
            _g13 = (_g13 + 1)
            v7 = s8.read.iterator()
            while v7.hasNext():
                v8 = v7.next()
                addVar(v8)
            v9 = s8.write.iterator()
            while v9.hasNext():
                v10 = v9.next()
                addVar(v10)
        cleanVar = None
        def _hx_local_27(v11):
            _g15 = v11.type
            if (_g15.index == 13):
                vl = _g15.params[0]
                if (v11.kind != hxsl_VarKind.Input):
                    vout = []
                    _g151 = 0
                    while (_g151 < len(vl)):
                        v12 = (vl[_g151] if _g151 >= 0 and _g151 < len(vl) else None)
                        _g151 = (_g151 + 1)
                        if (v12.id in varMap.h):
                            cleanVar(v12)
                            vout.append(v12)
                    v11.type = hxsl_Type.TStruct(vout)
        cleanVar = _hx_local_27
        _g152 = 0
        while (_g152 < len(outVars1)):
            v13 = (outVars1[_g152] if _g152 >= 0 and _g152 < len(outVars1) else None)
            _g152 = (_g152 + 1)
            cleanVar(v13)
        def _hx_local_31(kind,name,a):
            v14 = _hx_AnonObject({'id': hxsl_Tools.allocVarId(), 'name': name, 'type': hxsl_Type.TFun([_hx_AnonObject({'ret': hxsl_Type.TVoid, 'args': []})]), 'kind': hxsl_VarKind.Function})
            outVars1.append(v14)
            exprs = []
            _g16 = 0
            while (_g16 < len(a)):
                s9 = (a[_g16] if _g16 >= 0 and _g16 < len(a) else None)
                _g16 = (_g16 + 1)
                _g161 = s9.body.e
                if (_g161.index == 4):
                    el1 = _g161.params[0]
                    _g162 = 0
                    while (_g162 < len(el1)):
                        e1 = (el1[_g162] if _g162 >= 0 and _g162 < len(el1) else None)
                        _g162 = (_g162 + 1)
                        exprs.append(e1)
                else:
                    x1 = s9.body
                    exprs.append(x1)
            expr = _hx_AnonObject({'e': hxsl_TExprDef.TBlock(exprs), 't': hxsl_Type.TVoid, 'p': (None if ((len(exprs) == 0)) else (exprs[0] if 0 < len(exprs) else None).p)})
            _gthis.uniqueLocals(expr,haxe_ds_StringMap())
            return _hx_AnonObject({'kind': kind, 'ref': v14, 'ret': hxsl_Type.TVoid, 'args': [], 'expr': expr})
        build = _hx_local_31
        funs = [build(hxsl_FunctionKind.Vertex,"vertex",v5), build(hxsl_FunctionKind.Fragment,"fragment",f2)]
        s10 = dupShaders.keys()
        while s10.hasNext():
            s11 = s10.next()
            sreal1 = dupShaders.h.get(s11,None)
            if (s11 == sreal1):
                continue
            _g163 = 0
            _g17 = len(s11.vars)
            while (_g163 < _g17):
                i = _g163
                _g163 = (_g163 + 1)
                _this = self.allocVar((s11.vars[i] if i >= 0 and i < len(s11.vars) else None),None).merged
                x2 = (sreal1.vars[i] if i >= 0 and i < len(sreal1.vars) else None)
                _this.insert(0, x2)
        return _hx_AnonObject({'name': "out", 'vars': outVars1, 'funs': funs})

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.allVars = None
        _hx_o.varMap = None
        _hx_o.curShader = None
        _hx_o.shaders = None
        _hx_o.varIdMap = None
        _hx_o.locals = None
        _hx_o.curInstance = None
        _hx_o.batchMode = None
        _hx_o.isBatchShader = None
        _hx_o.debugDepth = None
hxsl_Linker._hx_class = hxsl_Linker
_hx_classes["hxsl.Linker"] = hxsl_Linker

class hxsl_Output(Enum):
    __slots__ = ()
    _hx_class_name = "hxsl.Output"
    _hx_constructs = ["Const", "Value", "PackNormal", "PackFloat", "Vec2", "Vec3", "Vec4", "Swiz"]

    @staticmethod
    def Const(v):
        return hxsl_Output("Const", 0, (v,))

    @staticmethod
    def Value(v,size = None):
        return hxsl_Output("Value", 1, (v,size))

    @staticmethod
    def PackNormal(v):
        return hxsl_Output("PackNormal", 2, (v,))

    @staticmethod
    def PackFloat(v):
        return hxsl_Output("PackFloat", 3, (v,))

    @staticmethod
    def Vec2(a):
        return hxsl_Output("Vec2", 4, (a,))

    @staticmethod
    def Vec3(a):
        return hxsl_Output("Vec3", 5, (a,))

    @staticmethod
    def Vec4(a):
        return hxsl_Output("Vec4", 6, (a,))

    @staticmethod
    def Swiz(a,swiz):
        return hxsl_Output("Swiz", 7, (a,swiz))
hxsl_Output._hx_class = hxsl_Output
_hx_classes["hxsl.Output"] = hxsl_Output


class hxsl_Printer:
    _hx_class_name = "hxsl.Printer"
    _hx_is_interface = "False"
    __slots__ = ("buffer", "varId")
    _hx_fields = ["buffer", "varId"]
    _hx_methods = ["add", "shaderString", "varString", "funString", "exprString", "addVar", "addFun", "addVarName", "addConst", "addExpr"]
    _hx_statics = ["SWIZ", "opStr", "toString", "shaderToString", "check"]

    def __init__(self,varId = None):
        if (varId is None):
            varId = False
        self.buffer = None
        self.varId = varId

    def add(self,v):
        _this = self.buffer
        s = Std.string(v)
        _this.b.write(s)

    def shaderString(self,s):
        self.buffer = StringBuf()
        _g = 0
        _g1 = s.vars
        while (_g < len(_g1)):
            v = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            self.addVar(v,hxsl_VarKind.Var)
            _this = self.buffer
            s1 = Std.string(";\n")
            _this.b.write(s1)
        if (len(s.vars) > 0):
            _this1 = self.buffer
            s2 = Std.string("\n")
            _this1.b.write(s2)
        _g2 = 0
        _g3 = s.funs
        while (_g2 < len(_g3)):
            f = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
            _g2 = (_g2 + 1)
            self.addFun(f)
            _this2 = self.buffer
            s3 = Std.string("\n\n")
            _this2.b.write(s3)
        return self.buffer.b.getvalue()

    def varString(self,v):
        self.buffer = StringBuf()
        self.addVar(v,None)
        return self.buffer.b.getvalue()

    def funString(self,f):
        self.buffer = StringBuf()
        self.addFun(f)
        return self.buffer.b.getvalue()

    def exprString(self,e):
        self.buffer = StringBuf()
        self.addExpr(e,"")
        return self.buffer.b.getvalue()

    def addVar(self,v,defKind,tabs = None,parent = None):
        if (tabs is None):
            tabs = ""
        if (Reflect.field(v,"qualifiers") is not None):
            _g = 0
            _g1 = Reflect.field(v,"qualifiers")
            while (_g < len(_g1)):
                q = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                v1 = None
                v2 = q.index
                if (v2 == 0):
                    _hx_max = q.params[0]
                    v1 = ("const" + HxOverrides.stringOrNull((("" if ((_hx_max is None)) else (("(" + Std.string(_hx_max)) + ")")))))
                elif (v2 == 1):
                    v1 = "private"
                elif (v2 == 2):
                    v1 = "nullable"
                elif (v2 == 3):
                    v1 = "perObject"
                elif (v2 == 4):
                    n = q.params[0]
                    v1 = (("name('" + ("null" if n is None else n)) + "')")
                elif (v2 == 5):
                    v1 = "shared"
                elif (v2 == 6):
                    p = q.params[0]
                    v1 = (HxOverrides.stringOrNull(p.tag.lower()) + "p")
                elif (v2 == 7):
                    max1 = q.params[1]
                    _hx_min = q.params[0]
                    v1 = (((("range(" + Std.string(_hx_min)) + ",") + Std.string(max1)) + ")")
                elif (v2 == 8):
                    v1 = "ignore"
                elif (v2 == 9):
                    n1 = q.params[0]
                    v1 = (("perInstance(" + Std.string(n1)) + ")")
                else:
                    pass
                _this = self.buffer
                s = Std.string((("@" + ("null" if v1 is None else v1)) + " "))
                _this.b.write(s)
        if (v.kind != defKind):
            tmp = v.kind.index
            if (tmp == 0):
                _this1 = self.buffer
                s1 = Std.string("@global ")
                _this1.b.write(s1)
            elif (tmp == 1):
                _this2 = self.buffer
                s2 = Std.string("@input ")
                _this2.b.write(s2)
            elif (tmp == 2):
                _this3 = self.buffer
                s3 = Std.string("@param ")
                _this3.b.write(s3)
            elif (tmp == 3):
                _this4 = self.buffer
                s4 = Std.string("@var ")
                _this4.b.write(s4)
            elif (tmp == 4):
                _this5 = self.buffer
                s5 = Std.string("@local ")
                _this5.b.write(s5)
            elif (tmp == 5):
                _this6 = self.buffer
                s6 = Std.string("@output ")
                _this6.b.write(s6)
            elif (tmp == 6):
                _this7 = self.buffer
                s7 = Std.string("@function ")
                _this7.b.write(s7)
            else:
                pass
        _this8 = self.buffer
        s8 = Std.string("var ")
        _this8.b.write(s8)
        if (Reflect.field(v,"parent") == parent):
            _this9 = self.buffer
            s9 = Std.string((HxOverrides.stringOrNull(v.name) + HxOverrides.stringOrNull(((("@" + Std.string(v.id)) if (self.varId) else "")))))
            _this9.b.write(s9)
        else:
            self.addVarName(v)
        _this10 = self.buffer
        s10 = Std.string(" : ")
        _this10.b.write(s10)
        _g2 = v.type
        if (_g2.index == 13):
            vl = _g2.params[0]
            _this11 = self.buffer
            s11 = Std.string("{")
            _this11.b.write(s11)
            first = True
            _g3 = 0
            while (_g3 < len(vl)):
                v3 = (vl[_g3] if _g3 >= 0 and _g3 < len(vl) else None)
                _g3 = (_g3 + 1)
                if first:
                    first = False
                else:
                    _this12 = self.buffer
                    s12 = Std.string(", ")
                    _this12.b.write(s12)
                self.addVar(v3,v3.kind,tabs,v3)
            _this13 = self.buffer
            s13 = Std.string("}")
            _this13.b.write(s13)
        else:
            v4 = hxsl_Tools.toString(v.type)
            _this14 = self.buffer
            s14 = Std.string(v4)
            _this14.b.write(s14)

    def addFun(self,f):
        _this = self.buffer
        s = Std.string((("function " + HxOverrides.stringOrNull(f.ref.name)) + "("))
        _this.b.write(s)
        first = True
        _g = 0
        _g1 = f.args
        while (_g < len(_g1)):
            a = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if first:
                _this1 = self.buffer
                s1 = Std.string(" ")
                _this1.b.write(s1)
                first = False
            else:
                _this2 = self.buffer
                s2 = Std.string(", ")
                _this2.b.write(s2)
            self.addVar(a,hxsl_VarKind.Local)
        if (len(f.args) > 0):
            _this3 = self.buffer
            s3 = Std.string(" ")
            _this3.b.write(s3)
        v = ((") : " + HxOverrides.stringOrNull(hxsl_Tools.toString(f.ret))) + " ")
        _this4 = self.buffer
        s4 = Std.string(v)
        _this4.b.write(s4)
        self.addExpr(f.expr,"")

    def addVarName(self,v):
        if (Reflect.field(v,"parent") is not None):
            self.addVarName(Reflect.field(v,"parent"))
            _this = self.buffer
            s = Std.string(".")
            _this.b.write(s)
        _this1 = self.buffer
        s1 = Std.string(v.name)
        _this1.b.write(s1)
        if self.varId:
            _this2 = self.buffer
            s2 = Std.string(("@" + Std.string(v.id)))
            _this2.b.write(s2)

    def addConst(self,c):
        _this = self.buffer
        s = None
        s1 = c.index
        if (s1 == 0):
            s = "null"
        elif (s1 == 1):
            b = c.params[0]
            s = b
        elif (s1 == 2):
            i = c.params[0]
            s = i
        elif (s1 == 3):
            f = c.params[0]
            s = f
        elif (s1 == 4):
            s2 = c.params[0]
            s = (("\"" + ("null" if s2 is None else s2)) + "\"")
        else:
            pass
        s3 = Std.string(s)
        _this.b.write(s3)

    def addExpr(self,e,tabs):
        _g = e.e
        tmp = _g.index
        if (tmp == 0):
            c = _g.params[0]
            self.addConst(c)
        elif (tmp == 1):
            v = _g.params[0]
            self.addVarName(v)
        elif (tmp == 2):
            g = _g.params[0]
            v1 = hxsl_Tools2.toString(g)
            _this = self.buffer
            s = Std.string(v1)
            _this.b.write(s)
        elif (tmp == 3):
            e1 = _g.params[0]
            _this1 = self.buffer
            s1 = Std.string("(")
            _this1.b.write(s1)
            self.addExpr(e1,tabs)
            _this2 = self.buffer
            s2 = Std.string(")")
            _this2.b.write(s2)
        elif (tmp == 4):
            el = _g.params[0]
            _this3 = self.buffer
            s3 = Std.string("{")
            _this3.b.write(s3)
            tabs = (("null" if tabs is None else tabs) + "\t")
            _g1 = 0
            while (_g1 < len(el)):
                e2 = (el[_g1] if _g1 >= 0 and _g1 < len(el) else None)
                _g1 = (_g1 + 1)
                _this4 = self.buffer
                s4 = Std.string(("\n" + ("null" if tabs is None else tabs)))
                _this4.b.write(s4)
                self.addExpr(e2,tabs)
                _this5 = self.buffer
                s5 = Std.string(";")
                _this5.b.write(s5)
            tabs = HxString.substr(tabs,1,None)
            if (len(el) > 0):
                _this6 = self.buffer
                s6 = Std.string(("\n" + ("null" if tabs is None else tabs)))
                _this6.b.write(s6)
            _this7 = self.buffer
            s7 = Std.string("}")
            _this7.b.write(s7)
        elif (tmp == 5):
            e21 = _g.params[2]
            e11 = _g.params[1]
            op = _g.params[0]
            self.addExpr(e11,tabs)
            v2 = ((" " + HxOverrides.stringOrNull(hxsl_Printer.opStr(op))) + " ")
            _this8 = self.buffer
            s8 = Std.string(v2)
            _this8.b.write(s8)
            self.addExpr(e21,tabs)
        elif (tmp == 6):
            e3 = _g.params[1]
            op1 = _g.params[0]
            _this9 = self.buffer
            s9 = None
            s10 = op1.index
            if (s10 == 0):
                s9 = "++"
            elif (s10 == 1):
                s9 = "--"
            elif (s10 == 2):
                s9 = "!"
            elif (s10 == 3):
                s9 = "-"
            elif (s10 == 4):
                s9 = "~"
            else:
                pass
            s11 = Std.string(s9)
            _this9.b.write(s11)
            self.addExpr(e3,tabs)
        elif (tmp == 7):
            init = _g.params[1]
            v3 = _g.params[0]
            self.addVar(v3,hxsl_VarKind.Local,tabs)
            if (init is not None):
                _this10 = self.buffer
                s12 = Std.string(" = ")
                _this10.b.write(s12)
                self.addExpr(init,tabs)
        elif (tmp == 8):
            el1 = _g.params[1]
            e4 = _g.params[0]
            self.addExpr(e4,tabs)
            _this11 = self.buffer
            s13 = Std.string("(")
            _this11.b.write(s13)
            first = True
            _g2 = 0
            while (_g2 < len(el1)):
                e5 = (el1[_g2] if _g2 >= 0 and _g2 < len(el1) else None)
                _g2 = (_g2 + 1)
                if first:
                    first = False
                else:
                    _this12 = self.buffer
                    s14 = Std.string(", ")
                    _this12.b.write(s14)
                self.addExpr(e5,tabs)
            _this13 = self.buffer
            s15 = Std.string(")")
            _this13.b.write(s15)
        elif (tmp == 9):
            regs = _g.params[1]
            e6 = _g.params[0]
            self.addExpr(e6,tabs)
            _this14 = self.buffer
            s16 = Std.string(".")
            _this14.b.write(s16)
            _g3 = 0
            while (_g3 < len(regs)):
                r = (regs[_g3] if _g3 >= 0 and _g3 < len(regs) else None)
                _g3 = (_g3 + 1)
                _this15 = self.buffer
                s17 = Std.string(python_internal_ArrayImpl._get(hxsl_Printer.SWIZ, r.index))
                _this15.b.write(s17)
        elif (tmp == 10):
            eelse = _g.params[2]
            eif = _g.params[1]
            cond = _g.params[0]
            _this16 = self.buffer
            s18 = Std.string("if( ")
            _this16.b.write(s18)
            self.addExpr(cond,tabs)
            _this17 = self.buffer
            s19 = Std.string(" ) ")
            _this17.b.write(s19)
            self.addExpr(eif,tabs)
            if (eelse is not None):
                _this18 = self.buffer
                s20 = Std.string(" else ")
                _this18.b.write(s20)
                self.addExpr(eelse,tabs)
        elif (tmp == 11):
            _this19 = self.buffer
            s21 = Std.string("discard")
            _this19.b.write(s21)
        elif (tmp == 12):
            e7 = _g.params[0]
            _this20 = self.buffer
            s22 = Std.string("return")
            _this20.b.write(s22)
            if (e7 is not None):
                _this21 = self.buffer
                s23 = Std.string(" ")
                _this21.b.write(s23)
                self.addExpr(e7,tabs)
        elif (tmp == 13):
            loop = _g.params[2]
            it = _g.params[1]
            v4 = _g.params[0]
            _this22 = self.buffer
            s24 = Std.string("for( ")
            _this22.b.write(s24)
            self.addVarName(v4)
            _this23 = self.buffer
            s25 = Std.string(" in ")
            _this23.b.write(s25)
            self.addExpr(it,tabs)
            _this24 = self.buffer
            s26 = Std.string(" ) ")
            _this24.b.write(s26)
            self.addExpr(loop,tabs)
        elif (tmp == 14):
            _this25 = self.buffer
            s27 = Std.string("continue")
            _this25.b.write(s27)
        elif (tmp == 15):
            _this26 = self.buffer
            s28 = Std.string("break")
            _this26.b.write(s28)
        elif (tmp == 16):
            e22 = _g.params[1]
            e12 = _g.params[0]
            self.addExpr(e12,tabs)
            _this27 = self.buffer
            s29 = Std.string("[")
            _this27.b.write(s29)
            self.addExpr(e22,tabs)
            _this28 = self.buffer
            s30 = Std.string("]")
            _this28.b.write(s30)
        elif (tmp == 17):
            el2 = _g.params[0]
            _this29 = self.buffer
            s31 = Std.string("[")
            _this29.b.write(s31)
            first1 = True
            _g4 = 0
            while (_g4 < len(el2)):
                e8 = (el2[_g4] if _g4 >= 0 and _g4 < len(el2) else None)
                _g4 = (_g4 + 1)
                if first1:
                    first1 = False
                else:
                    _this30 = self.buffer
                    s32 = Std.string(", ")
                    _this30.b.write(s32)
                self.addExpr(e8,tabs)
            _this31 = self.buffer
            s33 = Std.string("]")
            _this31.b.write(s33)
        elif (tmp == 18):
            _hx_def = _g.params[2]
            cases = _g.params[1]
            e9 = _g.params[0]
            _this32 = self.buffer
            s34 = Std.string("switch( ")
            _this32.b.write(s34)
            self.addExpr(e9,tabs)
            _this33 = self.buffer
            s35 = Std.string(") {")
            _this33.b.write(s35)
            old = tabs
            _g5 = 0
            while (_g5 < len(cases)):
                c1 = (cases[_g5] if _g5 >= 0 and _g5 < len(cases) else None)
                _g5 = (_g5 + 1)
                _this34 = self.buffer
                s36 = Std.string(("\n" + ("null" if tabs is None else tabs)))
                _this34.b.write(s36)
                _this35 = self.buffer
                s37 = Std.string("case ")
                _this35.b.write(s37)
                first2 = True
                _g6 = 0
                _g11 = c1.values
                while (_g6 < len(_g11)):
                    v5 = (_g11[_g6] if _g6 >= 0 and _g6 < len(_g11) else None)
                    _g6 = (_g6 + 1)
                    if first2:
                        first2 = False
                    else:
                        _this36 = self.buffer
                        s38 = Std.string(", ")
                        _this36.b.write(s38)
                    self.addExpr(v5,tabs)
                tabs = (("null" if tabs is None else tabs) + "\t")
                _this37 = self.buffer
                s39 = Std.string((":\n" + ("null" if tabs is None else tabs)))
                _this37.b.write(s39)
                self.addExpr(c1.expr,tabs)
                tabs = old
            if (_hx_def is not None):
                _this38 = self.buffer
                s40 = Std.string(("\n" + ("null" if tabs is None else tabs)))
                _this38.b.write(s40)
                tabs = (("null" if tabs is None else tabs) + "\t")
                _this39 = self.buffer
                s41 = Std.string(("default:\n" + ("null" if tabs is None else tabs)))
                _this39.b.write(s41)
                self.addExpr(_hx_def,tabs)
                tabs = old
            _this40 = self.buffer
            s42 = Std.string((("\n" + ("null" if tabs is None else tabs)) + "}"))
            _this40.b.write(s42)
        elif (tmp == 19):
            _g111 = _g.params[1]
            _g10 = _g.params[0]
            if (_g.params[2] == False):
                e10 = _g10
                loop1 = _g111
                old1 = tabs
                tabs = (("null" if tabs is None else tabs) + "\t")
                _this41 = self.buffer
                s43 = Std.string(("do {\n" + ("null" if tabs is None else tabs)))
                _this41.b.write(s43)
                self.addExpr(loop1,tabs)
                tabs = old1
                _this42 = self.buffer
                s44 = Std.string((("\n" + ("null" if tabs is None else tabs)) + "} while( "))
                _this42.b.write(s44)
                self.addExpr(e10,tabs)
                _this43 = self.buffer
                s45 = Std.string(" )")
                _this43.b.write(s45)
            else:
                e13 = _g10
                loop2 = _g111
                _this44 = self.buffer
                s46 = Std.string("while( ")
                _this44.b.write(s46)
                self.addExpr(e13,tabs)
                old2 = tabs
                tabs = (("null" if tabs is None else tabs) + "\t")
                _this45 = self.buffer
                s47 = Std.string((" ) {\n" + ("null" if tabs is None else tabs)))
                _this45.b.write(s47)
                self.addExpr(loop2,tabs)
                tabs = old2
                _this46 = self.buffer
                s48 = Std.string((("\n" + ("null" if tabs is None else tabs)) + "}"))
                _this46.b.write(s48)
        elif (tmp == 20):
            e14 = _g.params[2]
            args = _g.params[1]
            m = _g.params[0]
            _this47 = self.buffer
            s49 = Std.string(m)
            _this47.b.write(s49)
            if (len(args) > 0):
                _this48 = self.buffer
                s50 = Std.string("(")
                _this48.b.write(s50)
                first3 = True
                _g7 = 0
                while (_g7 < len(args)):
                    c2 = (args[_g7] if _g7 >= 0 and _g7 < len(args) else None)
                    _g7 = (_g7 + 1)
                    if first3:
                        first3 = False
                    else:
                        _this49 = self.buffer
                        s51 = Std.string(", ")
                        _this49.b.write(s51)
                    self.addConst(c2)
                _this50 = self.buffer
                s52 = Std.string(")")
                _this50.b.write(s52)
            _this51 = self.buffer
            s53 = Std.string(" ")
            _this51.b.write(s53)
            self.addExpr(e14,tabs)
        else:
            pass

    @staticmethod
    def opStr(op):
        tmp = op.index
        if (tmp == 0):
            return "+"
        elif (tmp == 1):
            return "*"
        elif (tmp == 2):
            return "/"
        elif (tmp == 3):
            return "-"
        elif (tmp == 4):
            return "="
        elif (tmp == 5):
            return "=="
        elif (tmp == 6):
            return "!="
        elif (tmp == 7):
            return ">"
        elif (tmp == 8):
            return ">="
        elif (tmp == 9):
            return "<"
        elif (tmp == 10):
            return "<="
        elif (tmp == 11):
            return "&"
        elif (tmp == 12):
            return "|"
        elif (tmp == 13):
            return "^"
        elif (tmp == 14):
            return "&&"
        elif (tmp == 15):
            return "||"
        elif (tmp == 16):
            return "<<"
        elif (tmp == 17):
            return ">>"
        elif (tmp == 18):
            return ">>>"
        elif (tmp == 19):
            return "%"
        elif (tmp == 20):
            op1 = op.params[0]
            return (HxOverrides.stringOrNull(hxsl_Printer.opStr(op1)) + "=")
        elif (tmp == 21):
            return "..."
        elif (tmp == 22):
            return "=>"
        elif (tmp == 23):
            return " in "
        else:
            pass

    @staticmethod
    def toString(e,varId = None):
        if (varId is None):
            varId = False
        return hxsl_Printer(varId).exprString(e)

    @staticmethod
    def shaderToString(s,varId = None):
        if (varId is None):
            varId = False
        return hxsl_Printer(varId).shaderString(s)

    @staticmethod
    def check(s,_hx_from = None):
        try:
            vars = haxe_ds_IntMap()
            regVars = []
            regVar = None
            def _hx_local_1(v,reg):
                if reg:
                    if (v.id in vars.h):
                        raise _HxException(("Duplicate var " + Std.string(v.id)))
                    vars.set(v.id,v)
                    regVars.append(v)
                else:
                    vars.remove(v.id)
                _g = v.type
                if (_g.index == 13):
                    vl = _g.params[0]
                    _g1 = 0
                    while (_g1 < len(vl)):
                        v1 = (vl[_g1] if _g1 >= 0 and _g1 < len(vl) else None)
                        _g1 = (_g1 + 1)
                        regVar(v1,reg)
            regVar = _hx_local_1
            checkExpr = None
            def _hx_local_4(e):
                nonlocal regVars
                nonlocal regVars
                _g2 = e.e
                checkExpr1 = _g2.index
                if (checkExpr1 == 1):
                    v2 = _g2.params[0]
                    if (not (v2.id in vars.h)):
                        raise _HxException(((("Unbound var " + HxOverrides.stringOrNull(v2.name)) + "@") + Std.string(v2.id)))
                elif (checkExpr1 == 4):
                    el = _g2.params[0]
                    old = regVars
                    regVars = []
                    _g3 = 0
                    while (_g3 < len(el)):
                        e1 = (el[_g3] if _g3 >= 0 and _g3 < len(el) else None)
                        _g3 = (_g3 + 1)
                        checkExpr(e1)
                    _g11 = 0
                    while (_g11 < len(regVars)):
                        v3 = (regVars[_g11] if _g11 >= 0 and _g11 < len(regVars) else None)
                        _g11 = (_g11 + 1)
                        regVar(v3,False)
                    regVars = old
                elif (checkExpr1 == 7):
                    init = _g2.params[1]
                    v4 = _g2.params[0]
                    if (init is not None):
                        checkExpr(init)
                    regVar(v4,True)
                elif (checkExpr1 == 13):
                    loop = _g2.params[2]
                    it = _g2.params[1]
                    v5 = _g2.params[0]
                    checkExpr(it)
                    regVar(v5,True)
                    checkExpr(loop)
                    regVar(v5,False)
                else:
                    hxsl_Tools.iter(e,checkExpr)
            checkExpr = _hx_local_4
            _g4 = 0
            _g12 = s.vars
            while (_g4 < len(_g12)):
                v6 = (_g12[_g4] if _g4 >= 0 and _g4 < len(_g12) else None)
                _g4 = (_g4 + 1)
                regVar(v6,True)
            _g21 = 0
            _g31 = s.funs
            while (_g21 < len(_g31)):
                f = (_g31[_g21] if _g21 >= 0 and _g21 < len(_g31) else None)
                _g21 = (_g21 + 1)
                _g22 = 0
                _g32 = f.args
                while (_g22 < len(_g32)):
                    v7 = (_g32[_g22] if _g22 >= 0 and _g22 < len(_g32) else None)
                    _g22 = (_g22 + 1)
                    regVar(v7,True)
                checkExpr(f.expr)
                _g41 = 0
                _g5 = f.args
                while (_g41 < len(_g5)):
                    v8 = (_g5[_g41] if _g41 >= 0 and _g41 < len(_g5) else None)
                    _g41 = (_g41 + 1)
                    regVar(v8,False)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            if isinstance(_hx_e1, str):
                e2 = _hx_e1
                msg = ((("null" if e2 is None else e2) + "\n    in\n") + HxOverrides.stringOrNull(hxsl_Printer.shaderToString(s,True)))
                if (_hx_from is not None):
                    _g13 = []
                    _g23 = 0
                    while (_g23 < len(_hx_from)):
                        s1 = (_hx_from[_g23] if _g23 >= 0 and _g23 < len(_hx_from) else None)
                        _g23 = (_g23 + 1)
                        x = hxsl_Printer.shaderToString(s1,True)
                        _g13.append(x)
                    msg = (("null" if msg is None else msg) + HxOverrides.stringOrNull((("\n    from\n\n" + HxOverrides.stringOrNull("\n\n".join([python_Boot.toString1(x1,'') for x1 in _g13]))))))
                raise _HxException(msg)
            else:
                raise _hx_e

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.buffer = None
        _hx_o.varId = None
hxsl_Printer._hx_class = hxsl_Printer
_hx_classes["hxsl.Printer"] = hxsl_Printer


class hxsl_AllocParam:
    _hx_class_name = "hxsl.AllocParam"
    _hx_is_interface = "False"
    __slots__ = ("name", "pos", "instance", "index", "type", "perObjectGlobal", "next")
    _hx_fields = ["name", "pos", "instance", "index", "type", "perObjectGlobal", "next"]
    _hx_methods = ["clone"]

    def __init__(self,name,pos,instance,index,_hx_type):
        self.next = None
        self.perObjectGlobal = None
        self.name = name
        self.pos = pos
        self.instance = instance
        self.index = index
        self.type = _hx_type

    def clone(self,resetGID = None):
        if (resetGID is None):
            resetGID = False
        p = hxsl_AllocParam(self.name,self.pos,self.instance,self.index,self.type)
        if (self.perObjectGlobal is not None):
            p.perObjectGlobal = self.perObjectGlobal.clone(resetGID)
        if (self.next is not None):
            p.next = self.next.clone(resetGID)
        return p

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.name = None
        _hx_o.pos = None
        _hx_o.instance = None
        _hx_o.index = None
        _hx_o.type = None
        _hx_o.perObjectGlobal = None
        _hx_o.next = None
hxsl_AllocParam._hx_class = hxsl_AllocParam
_hx_classes["hxsl.AllocParam"] = hxsl_AllocParam


class hxsl_AllocGlobal:
    _hx_class_name = "hxsl.AllocGlobal"
    _hx_is_interface = "False"
    __slots__ = ("pos", "gid", "path", "type", "next")
    _hx_fields = ["pos", "gid", "path", "type", "next"]
    _hx_methods = ["clone"]

    def __init__(self,pos,path,_hx_type):
        self.next = None
        self.pos = pos
        self.path = path
        self.gid = hxsl_Globals.allocID(path)
        self.type = _hx_type

    def clone(self,resetGID = None):
        if (resetGID is None):
            resetGID = False
        g = hxsl_AllocGlobal(self.pos,self.path,self.type)
        if (self.next is not None):
            g.next = self.next.clone(resetGID)
        if resetGID:
            g.gid = 0
        return g

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.pos = None
        _hx_o.gid = None
        _hx_o.path = None
        _hx_o.type = None
        _hx_o.next = None
hxsl_AllocGlobal._hx_class = hxsl_AllocGlobal
_hx_classes["hxsl.AllocGlobal"] = hxsl_AllocGlobal


class hxsl_RuntimeShaderData:
    _hx_class_name = "hxsl.RuntimeShaderData"
    _hx_is_interface = "False"
    __slots__ = ("vertex", "data", "code", "params", "paramsSize", "globals", "globalsSize", "textures", "texturesCount", "buffers", "bufferCount", "consts")
    _hx_fields = ["vertex", "data", "code", "params", "paramsSize", "globals", "globalsSize", "textures", "texturesCount", "buffers", "bufferCount", "consts"]

    def __init__(self):
        self.consts = None
        self.bufferCount = None
        self.buffers = None
        self.texturesCount = None
        self.textures = None
        self.globalsSize = None
        self.globals = None
        self.paramsSize = None
        self.params = None
        self.code = None
        self.data = None
        self.vertex = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.vertex = None
        _hx_o.data = None
        _hx_o.code = None
        _hx_o.params = None
        _hx_o.paramsSize = None
        _hx_o.globals = None
        _hx_o.globalsSize = None
        _hx_o.textures = None
        _hx_o.texturesCount = None
        _hx_o.buffers = None
        _hx_o.bufferCount = None
        _hx_o.consts = None
hxsl_RuntimeShaderData._hx_class = hxsl_RuntimeShaderData
_hx_classes["hxsl.RuntimeShaderData"] = hxsl_RuntimeShaderData


class hxsl_ShaderInstanceDesc:
    _hx_class_name = "hxsl.ShaderInstanceDesc"
    _hx_is_interface = "False"
    __slots__ = ("shader", "bits", "index")
    _hx_fields = ["shader", "bits", "index"]

    def __init__(self,shader,bits):
        self.index = None
        self.shader = shader
        self.bits = bits

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.shader = None
        _hx_o.bits = None
        _hx_o.index = None
hxsl_ShaderInstanceDesc._hx_class = hxsl_ShaderInstanceDesc
_hx_classes["hxsl.ShaderInstanceDesc"] = hxsl_ShaderInstanceDesc


class hxsl_RuntimeShader:
    _hx_class_name = "hxsl.RuntimeShader"
    _hx_is_interface = "False"
    __slots__ = ("id", "vertex", "fragment", "globals", "signature", "batchMode", "spec")
    _hx_fields = ["id", "vertex", "fragment", "globals", "signature", "batchMode", "spec"]
    _hx_methods = ["hasGlobal"]
    _hx_statics = ["UID"]

    def __init__(self):
        self.spec = None
        self.batchMode = None
        self.signature = None
        self.globals = None
        self.fragment = None
        self.vertex = None
        def _hx_local_2():
            _hx_local_0 = hxsl_RuntimeShader
            _hx_local_1 = _hx_local_0.UID
            _hx_local_0.UID = (_hx_local_1 + 1)
            return _hx_local_1
        self.id = _hx_local_2()

    def hasGlobal(self,gid):
        return (gid in self.globals.h)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.id = None
        _hx_o.vertex = None
        _hx_o.fragment = None
        _hx_o.globals = None
        _hx_o.signature = None
        _hx_o.batchMode = None
        _hx_o.spec = None
hxsl_RuntimeShader._hx_class = hxsl_RuntimeShader
_hx_classes["hxsl.RuntimeShader"] = hxsl_RuntimeShader


class hxsl_Serializer:
    _hx_class_name = "hxsl.Serializer"
    _hx_is_interface = "False"
    __slots__ = ("out", "input", "varMap", "idMap", "typeIdMap", "types", "uid", "tid")
    _hx_fields = ["out", "input", "varMap", "idMap", "typeIdMap", "types", "uid", "tid"]
    _hx_methods = ["writeArr", "readArr", "readVarInt", "writeVarInt", "writeID", "readID", "writeTID", "writeType", "readType", "writeString", "readString", "writeVar", "writeFun", "writeConst", "writeExpr", "readConst", "readExpr", "readVar", "readFun", "unserialize", "serialize"]
    _hx_statics = ["TVECS", "BOPS", "UNOPS", "TGLOBALS", "TSWIZ", "REGS", "VKINDS", "PRECS", "FKIND", "SIGN", "run"]

    def __init__(self):
        self.types = None
        self.typeIdMap = None
        self.idMap = None
        self.varMap = None
        self.input = None
        self.out = None
        self.tid = 1
        self.uid = 1

    def writeArr(self,arr,f):
        self.writeVarInt(len(arr))
        _g = 0
        while (_g < len(arr)):
            v = (arr[_g] if _g >= 0 and _g < len(arr) else None)
            _g = (_g + 1)
            f(v)

    def readArr(self,f):
        _g = []
        _g1 = 0
        _g2 = self.readVarInt()
        while (_g1 < _g2):
            i = _g1
            _g1 = (_g1 + 1)
            x = f()
            _g.append(x)
        return _g

    def readVarInt(self):
        b = self.input.readByte()
        if (b < 128):
            return b
        if (b == 255):
            return self.input.readInt32()
        return ((((b & 127)) << 8) | self.input.readByte())

    def writeVarInt(self,id):
        if (id < 128):
            self.out.b.append(id)
        else:
            n = (id >> 8)
            if (n >= 127):
                self.out.b.append(255)
                self.out.addInt32(n)
            else:
                self.out.b.append((n | 128))
                self.out.b.append((id & 255))

    def writeID(self,id):
        id2 = self.idMap.h.get(id,None)
        if (id2 is None):
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.uid
                _hx_local_0.uid = (_hx_local_1 + 1)
                return _hx_local_1
            id2 = _hx_local_2()
            self.idMap.set(id,id2)
        self.writeVarInt(id2)

    def readID(self):
        return self.readVarInt()

    def writeTID(self,t):
        tid = self.typeIdMap.get(t)
        if (tid is not None):
            self.writeVarInt(tid)
            return False
        def _hx_local_2():
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.tid
            _hx_local_0.tid = (_hx_local_1 + 1)
            return _hx_local_1
        tid = _hx_local_2()
        self.typeIdMap.set(t,tid)
        self.writeVarInt(tid)
        return True

    def writeType(self,t):
        self.out.b.append(t.index)
        tmp = t.index
        if (tmp == 5):
            t1 = t.params[1]
            size = t.params[0]
            self.out.b.append((size | ((t1.index << 3))))
        elif (((((((((((tmp == 12) or ((tmp == 11))) or ((tmp == 10))) or ((tmp == 8))) or ((tmp == 7))) or ((tmp == 6))) or ((tmp == 4))) or ((tmp == 3))) or ((tmp == 2))) or ((tmp == 1))) or ((tmp == 0))):
            pass
        elif (tmp == 9):
            size1 = t.params[0]
            self.out.addInt32(size1)
        elif (tmp == 13):
            vl = t.params[0]
            if self.writeTID(t):
                f = self.writeVar
                self.writeVarInt(len(vl))
                _g = 0
                while (_g < len(vl)):
                    v = (vl[_g] if _g >= 0 and _g < len(vl) else None)
                    _g = (_g + 1)
                    f(v)
        elif (tmp == 14):
            variants = t.params[0]
        elif (tmp == 15):
            size2 = t.params[1]
            t2 = t.params[0]
            self.writeType(t2)
            tmp1 = size2.index
            if (tmp1 == 0):
                v1 = size2.params[0]
                self.out.b.append(0)
                self.writeVarInt(v1)
            elif (tmp1 == 1):
                v2 = size2.params[0]
                self.writeVar(v2)
            else:
                pass
        elif (tmp == 16):
            size3 = t.params[1]
            t3 = t.params[0]
            self.writeType(t3)
            tmp2 = size3.index
            if (tmp2 == 0):
                v3 = size3.params[0]
                self.out.b.append(0)
                self.writeVarInt(v3)
            elif (tmp2 == 1):
                v4 = size3.params[0]
                self.writeVar(v4)
            else:
                pass
        elif (tmp == 17):
            size4 = t.params[0]
            self.out.b.append(size4)
        else:
            pass

    def readType(self):
        _g = self.input.readByte()
        if (_g == 0):
            return hxsl_Type.TVoid
        elif (_g == 1):
            return hxsl_Type.TInt
        elif (_g == 2):
            return hxsl_Type.TBool
        elif (_g == 3):
            return hxsl_Type.TFloat
        elif (_g == 4):
            return hxsl_Type.TString
        elif (_g == 5):
            bits = self.input.readByte()
            v = hxsl_Serializer.TVECS.h.get(bits,None)
            if (v is None):
                v = hxsl_Type.TVec((bits & 7),Type.createEnumIndex(hxsl_VecType,(bits >> 3),None))
                hxsl_Serializer.TVECS.set(bits,v)
            return v
        elif (_g == 6):
            return hxsl_Type.TMat3
        elif (_g == 7):
            return hxsl_Type.TMat4
        elif (_g == 8):
            return hxsl_Type.TMat3x4
        elif (_g == 9):
            return hxsl_Type.TBytes(self.input.readInt32())
        elif (_g == 10):
            return hxsl_Type.TSampler2D
        elif (_g == 11):
            return hxsl_Type.TSampler2DArray
        elif (_g == 12):
            return hxsl_Type.TSamplerCube
        elif (_g == 13):
            id = self.readVarInt()
            t = (self.types[id] if id >= 0 and id < len(self.types) else None)
            if (t is not None):
                return t
            f = self.readVar
            _g1 = []
            _g11 = 0
            _g2 = self.readVarInt()
            while (_g11 < _g2):
                i = _g11
                _g11 = (_g11 + 1)
                x = f()
                _g1.append(x)
            t = hxsl_Type.TStruct(_g1)
            python_internal_ArrayImpl._set(self.types, id, t)
            return t
        elif (_g == 14):
            return hxsl_Type.TFun(None)
        elif (_g == 15):
            t1 = self.readType()
            v1 = self.readVar()
            return hxsl_Type.TArray(t1,(hxsl_SizeDecl.SConst(self.readVarInt()) if ((v1 is None)) else hxsl_SizeDecl.SVar(v1)))
        elif (_g == 16):
            t2 = self.readType()
            v2 = self.readVar()
            return hxsl_Type.TBuffer(t2,(hxsl_SizeDecl.SConst(self.readVarInt()) if ((v2 is None)) else hxsl_SizeDecl.SVar(v2)))
        elif (_g == 17):
            return hxsl_Type.TChannel(self.input.readByte())
        else:
            raise _HxException("assert")

    def writeString(self,s):
        _hx_bytes = haxe_io_Bytes.ofString(s)
        self.writeVarInt(_hx_bytes.length)
        self.out.b.extend(_hx_bytes.b)

    def readString(self):
        _hx_len = self.readVarInt()
        s = self.input.read(_hx_len).getString(0,_hx_len)
        return s

    def writeVar(self,v):
        if (v is None):
            self.out.b.append(0)
            return
        self.writeID(v.id)
        if (v.id in self.varMap.h):
            return
        self.varMap.set(v.id,v)
        self.writeString(v.name)
        self.writeType(v.type)
        self.out.b.append(v.kind.index)
        self.writeVar(Reflect.field(v,"parent"))
        if (Reflect.field(v,"qualifiers") is None):
            self.out.b.append(0)
        else:
            self.out.b.append(len(Reflect.field(v,"qualifiers")))
            _g = 0
            _g1 = Reflect.field(v,"qualifiers")
            while (_g < len(_g1)):
                q = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                self.out.b.append(q.index)
                tmp = q.index
                if (tmp == 0):
                    _hx_max = q.params[0]
                    self.out.addInt32((0 if ((_hx_max is None)) else _hx_max))
                elif (((((tmp == 8) or ((tmp == 5))) or ((tmp == 3))) or ((tmp == 2))) or ((tmp == 1))):
                    pass
                elif (tmp == 4):
                    n = q.params[0]
                    self.writeString(n)
                elif (tmp == 6):
                    p = q.params[0]
                    self.out.b.append(p.index)
                elif (tmp == 7):
                    max1 = q.params[1]
                    _hx_min = q.params[0]
                    self.out.addInt64(haxe_io_FPHelper.doubleToI64(_hx_min))
                    self.out.addInt64(haxe_io_FPHelper.doubleToI64(max1))
                elif (tmp == 9):
                    v1 = q.params[0]
                    self.out.addInt32(v1)
                else:
                    pass

    def writeFun(self,f):
        self.out.b.append(f.kind.index)
        self.writeVar(f.ref)
        arr = f.args
        f1 = self.writeVar
        self.writeVarInt(len(arr))
        _g = 0
        while (_g < len(arr)):
            v = (arr[_g] if _g >= 0 and _g < len(arr) else None)
            _g = (_g + 1)
            f1(v)
        self.writeType(f.ret)
        self.writeExpr(f.expr)

    def writeConst(self,c):
        self.out.b.append(c.index)
        tmp = c.index
        if (tmp == 0):
            pass
        elif (tmp == 1):
            b = c.params[0]
            self.out.b.append((1 if b else 0))
        elif (tmp == 2):
            v = c.params[0]
            self.out.addInt32(v)
        elif (tmp == 3):
            v1 = c.params[0]
            self.out.addInt64(haxe_io_FPHelper.doubleToI64(v1))
        elif (tmp == 4):
            v2 = c.params[0]
            self.writeString(v2)
        else:
            pass

    def writeExpr(self,e):
        _gthis = self
        if (e is None):
            self.out.b.append(0)
            return
        self.out.b.append((e.e.index + 1))
        _g = e.e
        tmp = _g.index
        if (tmp == 0):
            c = _g.params[0]
            self.writeConst(c)
        elif (tmp == 1):
            v = _g.params[0]
            self.writeVar(v)
        elif (tmp == 2):
            g = _g.params[0]
            self.out.b.append(g.index)
        elif (tmp == 3):
            e1 = _g.params[0]
            self.writeExpr(e1)
        elif (tmp == 4):
            el = _g.params[0]
            f = self.writeExpr
            self.writeVarInt(len(el))
            _g1 = 0
            while (_g1 < len(el)):
                v1 = (el[_g1] if _g1 >= 0 and _g1 < len(el) else None)
                _g1 = (_g1 + 1)
                f(v1)
        elif (tmp == 5):
            e2 = _g.params[2]
            e11 = _g.params[1]
            op = _g.params[0]
            if (op.index == 20):
                op1 = op.params[0]
                self.out.b.append((op1.index | 128))
            else:
                self.out.b.append(op.index)
            self.writeExpr(e11)
            self.writeExpr(e2)
        elif (tmp == 6):
            e12 = _g.params[1]
            op2 = _g.params[0]
            self.out.b.append(op2.index)
            self.writeExpr(e12)
        elif (tmp == 7):
            init = _g.params[1]
            v2 = _g.params[0]
            self.writeVar(v2)
            self.writeExpr(init)
        elif (tmp == 8):
            args = _g.params[1]
            e3 = _g.params[0]
            self.writeExpr(e3)
            f1 = self.writeExpr
            self.writeVarInt(len(args))
            _g2 = 0
            while (_g2 < len(args)):
                v3 = (args[_g2] if _g2 >= 0 and _g2 < len(args) else None)
                _g2 = (_g2 + 1)
                f1(v3)
        elif (tmp == 9):
            regs = _g.params[1]
            e4 = _g.params[0]
            self.writeExpr(e4)
            if (len(regs) == 0):
                raise _HxException("assert")
            bits = (len(regs) - 1)
            k = 2
            _g3 = 0
            while (_g3 < len(regs)):
                r = (regs[_g3] if _g3 >= 0 and _g3 < len(regs) else None)
                _g3 = (_g3 + 1)
                bits = (bits | ((r.index << k)))
                k = (k + 2)
            self.out.b.append((bits & 255))
            self.out.b.append((bits >> 8))
        elif (tmp == 10):
            eelse = _g.params[2]
            eif = _g.params[1]
            econd = _g.params[0]
            self.writeExpr(econd)
            self.writeExpr(eif)
            self.writeExpr(eelse)
        elif (tmp == 11):
            pass
        elif (tmp == 12):
            e5 = _g.params[0]
            self.writeExpr(e5)
        elif (tmp == 13):
            loop = _g.params[2]
            it = _g.params[1]
            v4 = _g.params[0]
            self.writeVar(v4)
            self.writeExpr(it)
            self.writeExpr(loop)
        elif (tmp == 14):
            pass
        elif (tmp == 15):
            pass
        elif (tmp == 16):
            index = _g.params[1]
            e6 = _g.params[0]
            self.writeExpr(e6)
            self.writeExpr(index)
        elif (tmp == 17):
            el1 = _g.params[0]
            f2 = self.writeExpr
            self.writeVarInt(len(el1))
            _g4 = 0
            while (_g4 < len(el1)):
                v5 = (el1[_g4] if _g4 >= 0 and _g4 < len(el1) else None)
                _g4 = (_g4 + 1)
                f2(v5)
        elif (tmp == 18):
            _hx_def = _g.params[2]
            cases = _g.params[1]
            e7 = _g.params[0]
            self.writeExpr(e7)
            self.writeVarInt(len(cases))
            _g5 = 0
            while (_g5 < len(cases)):
                v6 = (cases[_g5] if _g5 >= 0 and _g5 < len(cases) else None)
                _g5 = (_g5 + 1)
                arr = v6.values
                f3 = _gthis.writeExpr
                _gthis.writeVarInt(len(arr))
                _g6 = 0
                while (_g6 < len(arr)):
                    v7 = (arr[_g6] if _g6 >= 0 and _g6 < len(arr) else None)
                    _g6 = (_g6 + 1)
                    f3(v7)
                _gthis.writeExpr(v6.expr)
            self.writeExpr(_hx_def)
        elif (tmp == 19):
            normalWhile = _g.params[2]
            loop1 = _g.params[1]
            e8 = _g.params[0]
            self.writeExpr(e8)
            self.writeExpr(loop1)
            self.out.b.append((1 if normalWhile else 0))
        elif (tmp == 20):
            e9 = _g.params[2]
            args1 = _g.params[1]
            m = _g.params[0]
            self.writeString(m)
            f4 = self.writeConst
            self.writeVarInt(len(args1))
            _g7 = 0
            while (_g7 < len(args1)):
                v8 = (args1[_g7] if _g7 >= 0 and _g7 < len(args1) else None)
                _g7 = (_g7 + 1)
                f4(v8)
            self.writeExpr(e9)
        else:
            pass
        self.writeType(e.t)

    def readConst(self):
        _g = self.input.readByte()
        if (_g == 0):
            return hxsl_Const.CNull
        elif (_g == 1):
            return hxsl_Const.CBool((self.input.readByte() != 0))
        elif (_g == 2):
            return hxsl_Const.CInt(self.input.readInt32())
        elif (_g == 3):
            return hxsl_Const.CFloat(self.input.readDouble())
        elif (_g == 4):
            return hxsl_Const.CString(self.readString())
        else:
            raise _HxException("assert")

    def readExpr(self):
        _gthis = self
        k = self.input.readByte()
        tmp = k
        k = (k - 1)
        if (tmp == 0):
            return None
        e = None
        k1 = k
        if (k1 == 0):
            e = hxsl_TExprDef.TConst(self.readConst())
        elif (k1 == 1):
            e = hxsl_TExprDef.TVar(self.readVar())
        elif (k1 == 2):
            e = hxsl_TExprDef.TGlobal(python_internal_ArrayImpl._get(hxsl_Serializer.TGLOBALS, self.input.readByte()))
        elif (k1 == 3):
            e = hxsl_TExprDef.TParenthesis(self.readExpr())
        elif (k1 == 4):
            f = self.readExpr
            _g = []
            _g1 = 0
            _g2 = self.readVarInt()
            while (_g1 < _g2):
                i = _g1
                _g1 = (_g1 + 1)
                x = f()
                _g.append(x)
            e = hxsl_TExprDef.TBlock(_g)
        elif (k1 == 5):
            op = self.input.readByte()
            e = hxsl_TExprDef.TBinop((haxe_macro_Binop.OpAssignOp(python_internal_ArrayImpl._get(hxsl_Serializer.BOPS, (op & 127))) if ((op >= 128)) else python_internal_ArrayImpl._get(hxsl_Serializer.BOPS, op)),self.readExpr(),self.readExpr())
        elif (k1 == 6):
            e = hxsl_TExprDef.TUnop(python_internal_ArrayImpl._get(hxsl_Serializer.UNOPS, self.input.readByte()),self.readExpr())
        elif (k1 == 7):
            e = hxsl_TExprDef.TVarDecl(self.readVar(),self.readExpr())
        elif (k1 == 8):
            e1 = self.readExpr()
            f1 = self.readExpr
            _g3 = []
            _g11 = 0
            _g21 = self.readVarInt()
            while (_g11 < _g21):
                i1 = _g11
                _g11 = (_g11 + 1)
                x1 = f1()
                _g3.append(x1)
            e = hxsl_TExprDef.TCall(e1,_g3)
        elif (k1 == 9):
            e2 = self.readExpr()
            bits = self.input.readUInt16()
            swiz = hxsl_Serializer.TSWIZ.h.get(bits,None)
            if (swiz is None):
                _g4 = []
                _g12 = 0
                _g22 = (((bits & 3)) + 1)
                while (_g12 < _g22):
                    i2 = _g12
                    _g12 = (_g12 + 1)
                    x2 = python_internal_ArrayImpl._get(hxsl_Serializer.REGS, ((bits >> (((i2 * 2) + 2))) & 3))
                    _g4.append(x2)
                swiz = _g4
                hxsl_Serializer.TSWIZ.set(bits,swiz)
            e = hxsl_TExprDef.TSwiz(e2,swiz)
        elif (k1 == 10):
            e = hxsl_TExprDef.TIf(self.readExpr(),self.readExpr(),self.readExpr())
        elif (k1 == 11):
            e = hxsl_TExprDef.TDiscard
        elif (k1 == 12):
            e = hxsl_TExprDef.TReturn(self.readExpr())
        elif (k1 == 13):
            e = hxsl_TExprDef.TFor(self.readVar(),self.readExpr(),self.readExpr())
        elif (k1 == 14):
            e = hxsl_TExprDef.TContinue
        elif (k1 == 15):
            e = hxsl_TExprDef.TBreak
        elif (k1 == 16):
            e = hxsl_TExprDef.TArray(self.readExpr(),self.readExpr())
        elif (k1 == 17):
            f2 = self.readExpr
            _g5 = []
            _g13 = 0
            _g23 = self.readVarInt()
            while (_g13 < _g23):
                i3 = _g13
                _g13 = (_g13 + 1)
                x3 = f2()
                _g5.append(x3)
            e = hxsl_TExprDef.TArrayDecl(_g5)
        elif (k1 == 18):
            e3 = self.readExpr()
            _g6 = []
            _g14 = 0
            _g24 = self.readVarInt()
            while (_g14 < _g24):
                i4 = _g14
                _g14 = (_g14 + 1)
                f3 = _gthis.readExpr
                _g7 = []
                _g15 = 0
                _g25 = _gthis.readVarInt()
                while (_g15 < _g25):
                    i5 = _g15
                    _g15 = (_g15 + 1)
                    x4 = f3()
                    _g7.append(x4)
                x5 = _hx_AnonObject({'values': _g7, 'expr': _gthis.readExpr()})
                _g6.append(x5)
            e = hxsl_TExprDef.TSwitch(e3,_g6,self.readExpr())
        elif (k1 == 19):
            e = hxsl_TExprDef.TWhile(self.readExpr(),self.readExpr(),(self.input.readByte() != 0))
        elif (k1 == 20):
            e4 = self.readString()
            f4 = self.readConst
            _g8 = []
            _g16 = 0
            _g26 = self.readVarInt()
            while (_g16 < _g26):
                i6 = _g16
                _g16 = (_g16 + 1)
                x6 = f4()
                _g8.append(x6)
            e = hxsl_TExprDef.TMeta(e4,_g8,self.readExpr())
        else:
            raise _HxException("assert")
        return _hx_AnonObject({'e': e, 't': self.readType(), 'p': None})

    def readVar(self):
        id = self.readVarInt()
        if (id == 0):
            return None
        v = self.varMap.h.get(id,None)
        if (v is not None):
            return v
        v = _hx_AnonObject({'id': hxsl_Tools.allocVarId(), 'name': self.readString(), 'type': None, 'kind': None})
        self.varMap.set(id,v)
        v.type = self.readType()
        v.kind = python_internal_ArrayImpl._get(hxsl_Serializer.VKINDS, self.input.readByte())
        Reflect.setField(v,"parent",self.readVar())
        nq = self.input.readByte()
        if (nq > 0):
            Reflect.setField(v,"qualifiers",[])
            _g = 0
            _g1 = nq
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                qid = self.input.readByte()
                q = None
                qid1 = qid
                if (qid1 == 0):
                    n = self.input.readInt32()
                    q = hxsl_VarQualifier.Const((None if ((n == 0)) else n))
                elif (qid1 == 1):
                    q = hxsl_VarQualifier.Private
                elif (qid1 == 2):
                    q = hxsl_VarQualifier.Nullable
                elif (qid1 == 3):
                    q = hxsl_VarQualifier.PerObject
                elif (qid1 == 4):
                    q = hxsl_VarQualifier.Name(self.readString())
                elif (qid1 == 5):
                    q = hxsl_VarQualifier.Shared
                elif (qid1 == 6):
                    q = hxsl_VarQualifier.Precision(python_internal_ArrayImpl._get(hxsl_Serializer.PRECS, self.input.readByte()))
                elif (qid1 == 7):
                    q = hxsl_VarQualifier.Range(self.input.readDouble(),self.input.readDouble())
                elif (qid1 == 8):
                    q = hxsl_VarQualifier.Ignore
                elif (qid1 == 9):
                    q = hxsl_VarQualifier.PerInstance(self.input.readInt32())
                else:
                    raise _HxException("assert")
                _this = Reflect.field(v,"qualifiers")
                _this.append(q)
        return v

    def readFun(self):
        tmp = python_internal_ArrayImpl._get(hxsl_Serializer.FKIND, self.input.readByte())
        tmp1 = self.readVar()
        f = self.readVar
        _g = []
        _g1 = 0
        _g2 = self.readVarInt()
        while (_g1 < _g2):
            i = _g1
            _g1 = (_g1 + 1)
            x = f()
            _g.append(x)
        return _hx_AnonObject({'kind': tmp, 'ref': tmp1, 'args': _g, 'ret': self.readType(), 'expr': self.readExpr()})

    def unserialize(self,data):
        self.input = haxe_io_BytesInput(haxe_crypto_Base64.decode(data,False))
        if (((self.input.readByte() != ((hxsl_Serializer.SIGN & 255))) or ((self.input.readByte() != (((hxsl_Serializer.SIGN >> 8) & 255))))) or ((self.input.readByte() != (((hxsl_Serializer.SIGN >> 16) & 255))))):
            raise _HxException("Invalid HXSL data")
        self.varMap = haxe_ds_IntMap()
        self.types = []
        tmp = self.readString()
        f = self.readVar
        _g = []
        _g1 = 0
        _g2 = self.readVarInt()
        while (_g1 < _g2):
            i = _g1
            _g1 = (_g1 + 1)
            x = f()
            _g.append(x)
        tmp1 = _g
        f1 = self.readFun
        _g3 = []
        _g11 = 0
        _g21 = self.readVarInt()
        while (_g11 < _g21):
            i1 = _g11
            _g11 = (_g11 + 1)
            x1 = f1()
            _g3.append(x1)
        return _hx_AnonObject({'name': tmp, 'vars': tmp1, 'funs': _g3})

    def serialize(self,s):
        self.varMap = haxe_ds_IntMap()
        self.idMap = haxe_ds_IntMap()
        self.typeIdMap = haxe_ds_EnumValueMap()
        self.out = haxe_io_BytesBuffer()
        self.out.b.append((hxsl_Serializer.SIGN & 255))
        self.out.b.append(((hxsl_Serializer.SIGN >> 8) & 255))
        self.out.b.append(((hxsl_Serializer.SIGN >> 16) & 255))
        self.writeString(s.name)
        arr = s.vars
        f = self.writeVar
        self.writeVarInt(len(arr))
        _g = 0
        while (_g < len(arr)):
            v = (arr[_g] if _g >= 0 and _g < len(arr) else None)
            _g = (_g + 1)
            f(v)
        arr1 = s.funs
        f1 = self.writeFun
        self.writeVarInt(len(arr1))
        _g1 = 0
        while (_g1 < len(arr1)):
            v1 = (arr1[_g1] if _g1 >= 0 and _g1 < len(arr1) else None)
            _g1 = (_g1 + 1)
            f1(v1)
        return haxe_crypto_Base64.encode(self.out.getBytes(),False)

    @staticmethod
    def run(s):
        return hxsl_Serializer().serialize(s)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.out = None
        _hx_o.input = None
        _hx_o.varMap = None
        _hx_o.idMap = None
        _hx_o.typeIdMap = None
        _hx_o.types = None
        _hx_o.uid = None
        _hx_o.tid = None
hxsl_Serializer._hx_class = hxsl_Serializer
_hx_classes["hxsl.Serializer"] = hxsl_Serializer


class hxsl_ShaderList:
    _hx_class_name = "hxsl.ShaderList"
    _hx_is_interface = "False"
    __slots__ = ("s", "next")
    _hx_fields = ["s", "next"]
    _hx_methods = ["clone", "iterator", "iterateTo"]
    _hx_statics = ["addSort"]

    def __init__(self,s,n = None):
        self.s = s
        self.next = n

    def clone(self):
        return hxsl_ShaderList(self.s.clone(),(None if ((self.next is None)) else self.next.clone()))

    def iterator(self):
        return hxsl__ShaderList_ShaderIterator(self,None)

    def iterateTo(self,s):
        return hxsl__ShaderList_ShaderIterator(self,s)

    @staticmethod
    def addSort(s,shaders):
        prev = None
        hd = shaders
        while ((hd is not None) and ((hd.s.priority < s.priority))):
            prev = hd
            hd = hd.next
        if (prev is None):
            return hxsl_ShaderList(s,shaders)
        prev.next = hxsl_ShaderList(s,prev.next)
        return shaders

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.s = None
        _hx_o.next = None
hxsl_ShaderList._hx_class = hxsl_ShaderList
_hx_classes["hxsl.ShaderList"] = hxsl_ShaderList


class hxsl__ShaderList_ShaderIterator:
    _hx_class_name = "hxsl._ShaderList.ShaderIterator"
    _hx_is_interface = "False"
    __slots__ = ("l", "last")
    _hx_fields = ["l", "last"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,l,last):
        self.l = l
        self.last = last

    def hasNext(self):
        return (self.l != self.last)

    def next(self):
        s = self.l.s
        self.l = self.l.next
        return s

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.l = None
        _hx_o.last = None
hxsl__ShaderList_ShaderIterator._hx_class = hxsl__ShaderList_ShaderIterator
_hx_classes["hxsl._ShaderList.ShaderIterator"] = hxsl__ShaderList_ShaderIterator


class hxsl_ShaderInstance:
    _hx_class_name = "hxsl.ShaderInstance"
    _hx_is_interface = "False"
    __slots__ = ("id", "shader", "params")
    _hx_fields = ["id", "shader", "params"]

    def __init__(self,shader):
        self.id = hxsl_Tools.allocVarId()
        self.shader = shader
        self.params = haxe_ds_IntMap()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.id = None
        _hx_o.shader = None
        _hx_o.params = None
hxsl_ShaderInstance._hx_class = hxsl_ShaderInstance
_hx_classes["hxsl.ShaderInstance"] = hxsl_ShaderInstance


class hxsl_ShaderGlobal:
    _hx_class_name = "hxsl.ShaderGlobal"
    _hx_is_interface = "False"
    __slots__ = ("v", "globalId")
    _hx_fields = ["v", "globalId"]

    def __init__(self,v,gid):
        self.v = v
        self.globalId = gid

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.v = None
        _hx_o.globalId = None
hxsl_ShaderGlobal._hx_class = hxsl_ShaderGlobal
_hx_classes["hxsl.ShaderGlobal"] = hxsl_ShaderGlobal


class hxsl_ShaderConst:
    _hx_class_name = "hxsl.ShaderConst"
    _hx_is_interface = "False"
    __slots__ = ("v", "pos", "bits", "globalId", "next")
    _hx_fields = ["v", "pos", "bits", "globalId", "next"]

    def __init__(self,v,pos,bits):
        self.next = None
        self.globalId = None
        self.v = v
        self.pos = pos
        self.bits = bits

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.v = None
        _hx_o.pos = None
        _hx_o.bits = None
        _hx_o.globalId = None
        _hx_o.next = None
hxsl_ShaderConst._hx_class = hxsl_ShaderConst
_hx_classes["hxsl.ShaderConst"] = hxsl_ShaderConst


class hxsl_SharedShader:
    _hx_class_name = "hxsl.SharedShader"
    _hx_is_interface = "False"
    __slots__ = ("data", "globals", "consts", "instanceCache", "paramsCount")
    _hx_fields = ["data", "globals", "consts", "instanceCache", "paramsCount"]
    _hx_methods = ["initialize", "getInstance", "makeInstance", "addSelfParam", "addParam", "browseVar"]
    _hx_statics = ["UNROLL_LOOPS"]

    def __init__(self,src):
        self.paramsCount = None
        self.instanceCache = haxe_ds_IntMap()
        self.consts = None
        self.globals = []
        if (src == ""):
            return
        self.data = hxsl_Serializer().unserialize(src)
        self.initialize()

    def initialize(self):
        _g = 0
        _g1 = self.data.vars
        while (_g < len(_g1)):
            v = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            self.browseVar(v)

    def getInstance(self,constBits):
        i = self.instanceCache.h.get(constBits,None)
        if (i is None):
            return self.makeInstance(constBits)
        else:
            return i

    def makeInstance(self,constBits):
        eval = hxsl_Eval()
        c = self.consts
        while (c is not None):
            c1 = c.v
            _g = c.v.type
            tmp = None
            tmp1 = _g.index
            if (tmp1 == 1):
                tmp = hxsl_Const.CInt((HxOverrides.rshift(constBits, c.pos) & ((((1 << c.bits)) - 1))))
            elif (tmp1 == 2):
                tmp = hxsl_Const.CBool((((HxOverrides.rshift(constBits, c.pos) & 1)) != 0))
            elif (tmp1 == 17):
                _g1 = _g.params[0]
                tmp = hxsl_Const.CInt((HxOverrides.rshift(constBits, c.pos) & ((((1 << c.bits)) - 1))))
            else:
                raise _HxException("assert")
            eval.setConstant(c1,tmp)
            c = c.next
        eval.inlineCalls = True
        eval.unrollLoops = hxsl_SharedShader.UNROLL_LOOPS
        i = hxsl_ShaderInstance(eval.eval(self.data))
        self.paramsCount = 0
        _g2 = 0
        _g11 = self.data.vars
        while (_g2 < len(_g11)):
            v = (_g11[_g2] if _g2 >= 0 and _g2 < len(_g11) else None)
            _g2 = (_g2 + 1)
            self.addParam(eval,i,v)
        self.instanceCache.set(constBits,i)
        return i

    def addSelfParam(self,i,v):
        _g = v.type
        if (_g.index == 13):
            vl = _g.params[0]
            _g1 = 0
            while (_g1 < len(vl)):
                v1 = (vl[_g1] if _g1 >= 0 and _g1 < len(vl) else None)
                _g1 = (_g1 + 1)
                self.addSelfParam(i,v1)
        elif (v.kind == hxsl_VarKind.Param):
            i.params.set(v.id,self.paramsCount)
            _hx_local_1 = self
            _hx_local_2 = _hx_local_1.paramsCount
            _hx_local_1.paramsCount = (_hx_local_2 + 1)
            _hx_local_2

    def addParam(self,eval,i,v):
        _g = v.type
        if (_g.index == 13):
            vl = _g.params[0]
            _g1 = 0
            while (_g1 < len(vl)):
                v1 = (vl[_g1] if _g1 >= 0 and _g1 < len(vl) else None)
                _g1 = (_g1 + 1)
                self.addParam(eval,i,v1)
        elif (v.kind == hxsl_VarKind.Param):
            i.params.set(eval.varMap.h.get(v,None).id,self.paramsCount)
            _hx_local_1 = self
            _hx_local_2 = _hx_local_1.paramsCount
            _hx_local_1.paramsCount = (_hx_local_2 + 1)
            _hx_local_2

    def browseVar(self,v,path = None):
        v.id = hxsl_Tools.allocVarId()
        if (path is None):
            path = hxsl_Tools.getName(v)
        else:
            path = (("null" if path is None else path) + HxOverrides.stringOrNull((("." + HxOverrides.stringOrNull(v.name)))))
        _g = v.type
        if (_g.index == 13):
            vl = _g.params[0]
            _g1 = 0
            while (_g1 < len(vl)):
                vs = (vl[_g1] if _g1 >= 0 and _g1 < len(vl) else None)
                _g1 = (_g1 + 1)
                self.browseVar(vs,path)
        else:
            globalId = 0
            if (v.kind == hxsl_VarKind.Global):
                globalId = hxsl_Globals.allocID(path)
                _this = self.globals
                x = hxsl_ShaderGlobal(v,globalId)
                _this.append(x)
            if (not hxsl_Tools.isConst(v)):
                return
            bits = hxsl_Tools.getConstBits(v)
            if (bits > 0):
                pos = (0 if ((self.consts is None)) else (self.consts.pos + self.consts.bits))
                c = hxsl_ShaderConst(v,pos,bits)
                c.globalId = globalId
                c.next = self.consts
                self.consts = c

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.data = None
        _hx_o.globals = None
        _hx_o.consts = None
        _hx_o.instanceCache = None
        _hx_o.paramsCount = None
hxsl_SharedShader._hx_class = hxsl_SharedShader
_hx_classes["hxsl.SharedShader"] = hxsl_SharedShader


class hxsl__Splitter_VarProps:
    _hx_class_name = "hxsl._Splitter.VarProps"
    _hx_is_interface = "False"
    __slots__ = ("v", "read", "write", "local", "requireInit")
    _hx_fields = ["v", "read", "write", "local", "requireInit"]

    def __init__(self,v):
        self.requireInit = None
        self.local = None
        self.v = v
        self.read = 0
        self.write = 0

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.v = None
        _hx_o.read = None
        _hx_o.write = None
        _hx_o.local = None
        _hx_o.requireInit = None
hxsl__Splitter_VarProps._hx_class = hxsl__Splitter_VarProps
_hx_classes["hxsl._Splitter.VarProps"] = hxsl__Splitter_VarProps


class hxsl_Splitter:
    _hx_class_name = "hxsl.Splitter"
    _hx_is_interface = "False"
    __slots__ = ("vars", "varNames", "varMap")
    _hx_fields = ["vars", "varNames", "varMap"]
    _hx_methods = ["split", "addExpr", "checkVar", "mapVars", "get", "uniqueName", "checkExpr"]

    def __init__(self):
        self.varMap = None
        self.varNames = None
        self.vars = None

    def split(self,s):
        vfun = None
        vvars = haxe_ds_IntMap()
        ffun = None
        fvars = haxe_ds_IntMap()
        self.varNames = haxe_ds_StringMap()
        self.varMap = haxe_ds_ObjectMap()
        _g = 0
        _g1 = s.funs
        while (_g < len(_g1)):
            f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            tmp = f.kind.index
            if (tmp == 0):
                self.vars = vvars
                vfun = f
                self.checkExpr(f.expr)
            elif (tmp == 1):
                self.vars = fvars
                ffun = f
                self.checkExpr(f.expr)
            else:
                raise _HxException("assert")
        vfun = _hx_AnonObject({'ret': vfun.ret, 'ref': vfun.ref, 'kind': vfun.kind, 'args': vfun.args, 'expr': self.mapVars(vfun.expr)})
        _g2 = 0
        _g3 = Lambda.array(vvars)
        while (_g2 < len(_g3)):
            inf = (_g3[_g2] if _g2 >= 0 and _g2 < len(_g3) else None)
            _g2 = (_g2 + 1)
            v = inf.v
            tmp1 = v.kind.index
            if ((tmp1 == 4) or ((tmp1 == 3))):
                v.kind = (hxsl_VarKind.Var if ((v.id in fvars.h)) else hxsl_VarKind.Local)
            else:
                pass
            tmp2 = v.kind.index
            if ((tmp2 == 5) or ((tmp2 == 3))):
                if ((inf.read > 0) or ((inf.write > 1))):
                    nv = _hx_AnonObject({'id': hxsl_Tools.allocVarId(), 'name': v.name, 'kind': v.kind, 'type': v.type})
                    self.vars = vvars
                    ninf = self.get(nv)
                    v.kind = hxsl_VarKind.Local
                    p = vfun.expr.p
                    e = _hx_AnonObject({'e': hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAssign,_hx_AnonObject({'e': hxsl_TExprDef.TVar(nv), 't': nv.type, 'p': p}),_hx_AnonObject({'e': hxsl_TExprDef.TVar(v), 't': v.type, 'p': p})), 't': nv.type, 'p': p})
                    self.addExpr(vfun,e)
                    self.checkExpr(e)
                    if (nv.kind == hxsl_VarKind.Var):
                        old = fvars.h.get(v.id,None)
                        self.varMap.set(v,nv)
                        fvars.remove(v.id)
                        np = hxsl__Splitter_VarProps(nv)
                        np.read = old.read
                        np.write = old.write
                        fvars.set(nv.id,np)
            else:
                pass
        finits = []
        todo = []
        inf1 = fvars.iterator()
        while inf1.hasNext():
            inf2 = inf1.next()
            v1 = inf2.v
            tmp3 = v1.kind.index
            if (tmp3 == 1):
                nv1 = _hx_AnonObject({'id': hxsl_Tools.allocVarId(), 'name': v1.name, 'kind': hxsl_VarKind.Var, 'type': v1.type})
                self.uniqueName(nv1)
                i = vvars.h.get(v1.id,None)
                if (i is None):
                    i = hxsl__Splitter_VarProps(v1)
                    vvars.set(v1.id,i)
                i.read = (i.read + 1)
                vp = hxsl__Splitter_VarProps(nv1)
                vp.write = 1
                vvars.set(nv1.id,vp)
                fp = hxsl__Splitter_VarProps(nv1)
                fp.read = 1
                todo.append(fp)
                self.addExpr(vfun,_hx_AnonObject({'e': hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAssign,_hx_AnonObject({'e': hxsl_TExprDef.TVar(nv1), 't': v1.type, 'p': vfun.expr.p}),_hx_AnonObject({'e': hxsl_TExprDef.TVar(v1), 't': v1.type, 'p': vfun.expr.p})), 't': v1.type, 'p': vfun.expr.p}))
                self.varMap.set(v1,nv1)
                inf2.local = True
            elif (tmp3 == 3):
                if (inf2.write > 0):
                    nv2 = _hx_AnonObject({'id': hxsl_Tools.allocVarId(), 'name': v1.name, 'kind': hxsl_VarKind.Local, 'type': v1.type})
                    self.uniqueName(nv2)
                    x = _hx_AnonObject({'e': hxsl_TExprDef.TVarDecl(nv2,_hx_AnonObject({'e': hxsl_TExprDef.TVar(v1), 't': v1.type, 'p': ffun.expr.p})), 't': hxsl_Type.TVoid, 'p': ffun.expr.p})
                    finits.append(x)
                    self.varMap.set(v1,nv2)
            else:
                pass
        _g4 = 0
        while (_g4 < len(todo)):
            v2 = (todo[_g4] if _g4 >= 0 and _g4 < len(todo) else None)
            _g4 = (_g4 + 1)
            fvars.set(v2.v.id,v2)
        v3 = vvars.iterator()
        while v3.hasNext():
            v4 = v3.next()
            self.checkVar(v4,True,vvars,vfun.expr.p)
        v5 = fvars.iterator()
        while v5.hasNext():
            v6 = v5.next()
            self.checkVar(v6,False,vvars,ffun.expr.p)
        v7 = self.varMap.keys()
        while v7.hasNext():
            v8 = v7.next()
            this1 = self.varMap
            key = self.varMap.h.get(v8,None)
            v21 = this1.h.get(key,None)
            if (v21 is not None):
                self.varMap.set(v8,v21)
        ffun = _hx_AnonObject({'ret': ffun.ret, 'ref': ffun.ref, 'kind': ffun.kind, 'args': ffun.args, 'expr': self.mapVars(ffun.expr)})
        _g5 = ffun.expr.e
        if (_g5.index == 4):
            el = _g5.params[0]
            _g51 = 0
            while (_g51 < len(finits)):
                e1 = (finits[_g51] if _g51 >= 0 and _g51 < len(finits) else None)
                _g51 = (_g51 + 1)
                el.insert(0, e1)
        else:
            x1 = ffun.expr
            finits.append(x1)
            ffun.expr = _hx_AnonObject({'e': hxsl_TExprDef.TBlock(finits), 't': hxsl_Type.TVoid, 'p': ffun.expr.p})
        _g7 = []
        v9 = vvars.iterator()
        while v9.hasNext():
            v10 = v9.next()
            if (not v10.local):
                x2 = v10.v
                _g7.append(x2)
        vvars1 = _g7
        _g8 = []
        v11 = fvars.iterator()
        while v11.hasNext():
            v12 = v11.next()
            if (not v12.local):
                x3 = v12.v
                _g8.append(x3)
        fvars1 = _g8
        def _hx_local_5(v13,v22):
            return (v13.id - v22.id)
        vvars1.sort(key= python_lib_Functools.cmp_to_key(_hx_local_5))
        def _hx_local_6(v14,v23):
            return (v14.id - v23.id)
        fvars1.sort(key= python_lib_Functools.cmp_to_key(_hx_local_6))
        return _hx_AnonObject({'vertex': _hx_AnonObject({'name': "vertex", 'vars': vvars1, 'funs': [vfun]}), 'fragment': _hx_AnonObject({'name': "fragment", 'vars': fvars1, 'funs': [ffun]})})

    def addExpr(self,f,e):
        _g = f.expr.e
        if (_g.index == 4):
            el = _g.params[0]
            el.append(e)
        else:
            f.expr = _hx_AnonObject({'e': hxsl_TExprDef.TBlock([f.expr, e]), 't': hxsl_Type.TVoid, 'p': f.expr.p})

    def checkVar(self,v,vertex,vvars,p):
        tmp = v.v.kind.index
        if (tmp == 3):
            if (not vertex):
                i = vvars.h.get(v.v.id,None)
                if ((i is None) or ((i.write == 0))):
                    raise _HxException(hxsl_Error((("Varying " + HxOverrides.stringOrNull(v.v.name)) + " is not written by vertex shader"),p))
        elif (tmp == 4):
            if v.requireInit:
                raise _HxException(hxsl_Error((("Variable " + HxOverrides.stringOrNull(v.v.name)) + " is used without being initialized"),p))
        else:
            pass

    def mapVars(self,e):
        _g = e.e
        tmp = _g.index
        if (tmp == 1):
            v = _g.params[0]
            v2 = self.varMap.h.get(v,None)
            if (v2 is None):
                return e
            else:
                return _hx_AnonObject({'e': hxsl_TExprDef.TVar(v2), 't': e.t, 'p': e.p})
        elif (tmp == 7):
            init = _g.params[1]
            v1 = _g.params[0]
            v21 = self.varMap.h.get(v1,None)
            if (v21 is None):
                return hxsl_Tools.map(e,self.mapVars)
            else:
                return _hx_AnonObject({'e': hxsl_TExprDef.TVarDecl(v21,self.mapVars(init)), 't': e.t, 'p': e.p})
        elif (tmp == 13):
            loop = _g.params[2]
            it = _g.params[1]
            v3 = _g.params[0]
            v22 = self.varMap.h.get(v3,None)
            if (v22 is None):
                return hxsl_Tools.map(e,self.mapVars)
            else:
                return _hx_AnonObject({'e': hxsl_TExprDef.TFor(v22,self.mapVars(it),self.mapVars(loop)), 't': e.t, 'p': e.p})
        else:
            return hxsl_Tools.map(e,self.mapVars)

    def get(self,v):
        i = self.vars.h.get(v.id,None)
        if (i is None):
            v2 = self.varMap.h.get(v,None)
            if (v2 is not None):
                return self.get(v2)
            oldName = v.name
            self.uniqueName(v)
            if ((v.kind == hxsl_VarKind.Local) and ((oldName != v.name))):
                nv = _hx_AnonObject({'id': hxsl_Tools.allocVarId(), 'name': v.name, 'kind': v.kind, 'type': v.type})
                self.varMap.set(v,nv)
                v.name = oldName
                v = nv
            i = hxsl__Splitter_VarProps(v)
            self.vars.set(v.id,i)
        return i

    def uniqueName(self,v):
        if (((v.kind == hxsl_VarKind.Global) or ((v.kind == hxsl_VarKind.Output))) or ((v.kind == hxsl_VarKind.Input))):
            return
        Reflect.setField(v,"parent",None)
        n = self.varNames.h.get(v.name,None)
        if ((n is not None) and ((n != v))):
            prefix = v.name
            while ((HxString.charCodeAt(prefix,(len(prefix) - 1)) >= 48) and ((HxString.charCodeAt(prefix,(len(prefix) - 1)) <= 57))):
                prefix = HxString.substr(prefix,0,-1)
            k = (2 if ((prefix == v.name)) else Std.parseInt(HxString.substr(v.name,len(prefix),None)))
            while ((("null" if prefix is None else prefix) + Std.string(k)) in self.varNames.h):
                k = (k + 1)
            v.name = (("null" if prefix is None else prefix) + Std.string(k))
        self.varNames.h[v.name] = v

    def checkExpr(self,e):
        _g = e.e
        tmp = _g.index
        if (tmp == 1):
            v = _g.params[0]
            inf = self.get(v)
            if (inf.write == 0):
                inf.requireInit = True
            inf.read = (inf.read + 1)
        elif (tmp == 5):
            _g9 = _g.params[2]
            _g8 = _g.params[1]
            _g7 = _g.params[0]
            tmp1 = _g7.index
            if (tmp1 == 4):
                _g12 = _g8.t
                _g11 = _g8.p
                _g10 = _g8.e
                tmp2 = _g10.index
                if (tmp2 == 1):
                    e1 = _g9
                    v1 = _g10.params[0]
                    inf1 = self.get(v1)
                    inf1.write = (inf1.write + 1)
                    self.checkExpr(e1)
                elif (tmp2 == 9):
                    _g15 = _g10.params[1]
                    _g14 = _g10.params[0]
                    _g18 = _g14.t
                    _g17 = _g14.p
                    _g16 = _g14.e
                    if (_g16.index == 1):
                        e2 = _g9
                        v2 = _g16.params[0]
                        inf2 = self.get(v2)
                        inf2.write = (inf2.write + 1)
                        self.checkExpr(e2)
                    else:
                        hxsl_Tools.iter(e,self.checkExpr)
                else:
                    hxsl_Tools.iter(e,self.checkExpr)
            elif (tmp1 == 20):
                _g20 = _g7.params[0]
                _g23 = _g8.t
                _g22 = _g8.p
                _g21 = _g8.e
                tmp3 = _g21.index
                if (tmp3 == 1):
                    e3 = _g9
                    v3 = _g21.params[0]
                    inf3 = self.get(v3)
                    if (inf3.write == 0):
                        inf3.requireInit = True
                    inf3.read = (inf3.read + 1)
                    inf3.write = (inf3.write + 1)
                    self.checkExpr(e3)
                elif (tmp3 == 9):
                    _g26 = _g21.params[1]
                    _g25 = _g21.params[0]
                    _g29 = _g25.t
                    _g28 = _g25.p
                    _g27 = _g25.e
                    if (_g27.index == 1):
                        e4 = _g9
                        v4 = _g27.params[0]
                        inf4 = self.get(v4)
                        if (inf4.write == 0):
                            inf4.requireInit = True
                        inf4.read = (inf4.read + 1)
                        inf4.write = (inf4.write + 1)
                        self.checkExpr(e4)
                    else:
                        hxsl_Tools.iter(e,self.checkExpr)
                else:
                    hxsl_Tools.iter(e,self.checkExpr)
            else:
                hxsl_Tools.iter(e,self.checkExpr)
        elif (tmp == 7):
            init = _g.params[1]
            v5 = _g.params[0]
            inf5 = self.get(v5)
            inf5.local = True
            if (init is not None):
                self.checkExpr(init)
                inf5.write = (inf5.write + 1)
        elif (tmp == 13):
            loop = _g.params[2]
            it = _g.params[1]
            v6 = _g.params[0]
            self.checkExpr(it)
            inf6 = self.get(v6)
            inf6.local = True
            inf6.write = (inf6.write + 1)
            self.checkExpr(loop)
        else:
            hxsl_Tools.iter(e,self.checkExpr)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.vars = None
        _hx_o.varNames = None
        _hx_o.varMap = None
hxsl_Splitter._hx_class = hxsl_Splitter
_hx_classes["hxsl.Splitter"] = hxsl_Splitter


class hxsl_ChannelTools:
    _hx_class_name = "hxsl.ChannelTools"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["isPackedFormat"]

    @staticmethod
    def isPackedFormat(c):
        return (c.format == h3d_mat_Texture.nativeFormat)
hxsl_ChannelTools._hx_class = hxsl_ChannelTools
_hx_classes["hxsl.ChannelTools"] = hxsl_ChannelTools


class python__KwArgs_KwArgs_Impl_:
    _hx_class_name = "python._KwArgs.KwArgs_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["fromT"]

    @staticmethod
    def fromT(d):
        this1 = python_Lib.anonAsDict(d)
        return this1
python__KwArgs_KwArgs_Impl_._hx_class = python__KwArgs_KwArgs_Impl_
_hx_classes["python._KwArgs.KwArgs_Impl_"] = python__KwArgs_KwArgs_Impl_


class python_Lib:
    _hx_class_name = "python.Lib"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["lineEnd", "printString", "dictToAnon", "anonToDict", "anonAsDict"]
    __name__ = None

    @staticmethod
    def printString(_hx_str):
        encoding = "utf-8"
        if (encoding is None):
            encoding = "utf-8"
        python_lib_Sys.stdout.buffer.write(_hx_str.encode(encoding, "strict"))
        python_lib_Sys.stdout.flush()

    @staticmethod
    def dictToAnon(v):
        return _hx_AnonObject(v.copy())

    @staticmethod
    def anonToDict(o):
        if isinstance(o,_hx_AnonObject):
            return o.__dict__.copy()
        else:
            return None

    @staticmethod
    def anonAsDict(o):
        if isinstance(o,_hx_AnonObject):
            return o.__dict__
        else:
            return None
python_Lib._hx_class = python_Lib
_hx_classes["python.Lib"] = python_Lib


class _HxException(Exception):
    _hx_class_name = "_HxException"
    _hx_is_interface = "False"
    __slots__ = ("val",)
    _hx_fields = ["val"]
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = Exception


    def __init__(self,val):
        self.val = None
        message = str(val)
        super().__init__(message)
        self.val = val

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.val = None
_HxException._hx_class = _HxException
_hx_classes["_HxException"] = _HxException


class HxOverrides:
    _hx_class_name = "HxOverrides"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["iterator", "eq", "stringOrNull", "split", "rshift", "modf", "mod", "mapKwArgs"]

    @staticmethod
    def iterator(x):
        if isinstance(x,list):
            return python_HaxeIterator(x.__iter__())
        return x.iterator()

    @staticmethod
    def eq(a,b):
        if (isinstance(a,list) or isinstance(b,list)):
            return a is b
        return (a == b)

    @staticmethod
    def stringOrNull(s):
        if (s is None):
            return "null"
        else:
            return s

    @staticmethod
    def split(x,delimiter):
        if isinstance(x,str):
            _this = x
            if (delimiter == ""):
                return list(_this)
            else:
                return _this.split(delimiter)
        return x.split(delimiter)

    @staticmethod
    def rshift(val,n):
        return ((val % 0x100000000) >> n)

    @staticmethod
    def modf(a,b):
        if (b == 0.0):
            return float('nan')
        elif (a < 0):
            if (b < 0):
                return -(-a % (-b))
            else:
                return -(-a % b)
        elif (b < 0):
            return a % (-b)
        else:
            return a % b

    @staticmethod
    def mod(a,b):
        if (a < 0):
            if (b < 0):
                return -(-a % (-b))
            else:
                return -(-a % b)
        elif (b < 0):
            return a % (-b)
        else:
            return a % b

    @staticmethod
    def mapKwArgs(a,v):
        a1 = _hx_AnonObject(python_Lib.anonToDict(a))
        k = python_HaxeIterator(iter(v.keys()))
        while k.hasNext():
            k1 = k.next()
            val = v.get(k1)
            if a1._hx_hasattr(k1):
                x = getattr(a1,k1)
                setattr(a1,val,x)
                delattr(a1,k1)
        return a1
HxOverrides._hx_class = HxOverrides
_hx_classes["HxOverrides"] = HxOverrides


class python_io_NativeInput(haxe_io_Input):
    _hx_class_name = "python.io.NativeInput"
    _hx_is_interface = "False"
    __slots__ = ("stream", "wasEof")
    _hx_fields = ["stream", "wasEof"]
    _hx_methods = ["close", "tell", "throwEof", "readinto", "readBytes"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Input


    def __init__(self,s):
        self.wasEof = None
        self.stream = s
        self.set_bigEndian(False)
        self.wasEof = False
        if (not self.stream.readable()):
            raise _HxException("Write-only stream")

    def close(self):
        self.stream.close()

    def tell(self):
        return self.stream.tell()

    def throwEof(self):
        self.wasEof = True
        raise _HxException(haxe_io_Eof())

    def readinto(self,b):
        raise _HxException("abstract method, should be overridden")

    def readBytes(self,s,pos,_hx_len):
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > s.length))):
            raise _HxException(haxe_io_Error.OutsideBounds)
        ba = bytearray(_hx_len)
        ret = self.readinto(ba)
        if (ret == 0):
            self.throwEof()
        s.blit(pos,haxe_io_Bytes.ofData(ba),0,_hx_len)
        return ret

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.stream = None
        _hx_o.wasEof = None
        _hx_o.canSeek = None
python_io_NativeInput._hx_class = python_io_NativeInput
_hx_classes["python.io.NativeInput"] = python_io_NativeInput


class python_io_IInput:
    _hx_class_name = "python.io.IInput"
    _hx_is_interface = "True"
    __slots__ = ("bigEndian",)
    _hx_fields = ["bigEndian"]
    _hx_methods = ["set_bigEndian", "readByte", "readBytes", "close", "readFullBytes", "read", "readUntil", "readFloat", "readDouble", "readInt16", "readUInt16", "readUInt24", "readInt32", "readString"]
python_io_IInput._hx_class = python_io_IInput
_hx_classes["python.io.IInput"] = python_io_IInput


class python_io_NativeBytesInput(python_io_NativeInput):
    _hx_class_name = "python.io.NativeBytesInput"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["readByte", "seek", "readinto"]
    _hx_statics = []
    _hx_interfaces = [python_io_IInput]
    _hx_super = python_io_NativeInput


    def __init__(self,stream):
        super().__init__(stream)

    def readByte(self):
        ret = self.stream.read(1)
        if (len(ret) == 0):
            self.throwEof()
        return ret[0]

    def seek(self,p,pos):
        self.wasEof = False
        python_io_IoTools.seekInBinaryMode(self.stream,p,pos)
        return

    def readinto(self,b):
        return self.stream.readinto(b)

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
python_io_NativeBytesInput._hx_class = python_io_NativeBytesInput
_hx_classes["python.io.NativeBytesInput"] = python_io_NativeBytesInput


class python_io_IFileInput:
    _hx_class_name = "python.io.IFileInput"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_methods = ["seek", "tell"]
    _hx_interfaces = [python_io_IInput]
python_io_IFileInput._hx_class = python_io_IFileInput
_hx_classes["python.io.IFileInput"] = python_io_IFileInput


class python_io_FileBytesInput(python_io_NativeBytesInput):
    _hx_class_name = "python.io.FileBytesInput"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = [python_io_IFileInput]
    _hx_super = python_io_NativeBytesInput


    def __init__(self,stream):
        super().__init__(stream)
python_io_FileBytesInput._hx_class = python_io_FileBytesInput
_hx_classes["python.io.FileBytesInput"] = python_io_FileBytesInput


class python_io_NativeOutput(haxe_io_Output):
    _hx_class_name = "python.io.NativeOutput"
    _hx_is_interface = "False"
    __slots__ = ("stream",)
    _hx_fields = ["stream"]
    _hx_methods = ["close", "flush"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Output


    def __init__(self,stream):
        self.stream = None
        self.set_bigEndian(False)
        self.stream = stream
        if (not stream.writable()):
            raise _HxException("Read only stream")

    def close(self):
        self.stream.close()

    def flush(self):
        self.stream.flush()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.stream = None
        _hx_o.canSeek = None
python_io_NativeOutput._hx_class = python_io_NativeOutput
_hx_classes["python.io.NativeOutput"] = python_io_NativeOutput


class python_io_NativeBytesOutput(python_io_NativeOutput):
    _hx_class_name = "python.io.NativeBytesOutput"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["writeByte", "writeBytes"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = python_io_NativeOutput


    def __init__(self,stream):
        super().__init__(stream)

    def writeByte(self,c):
        self.stream.write(bytearray([c]))

    def writeBytes(self,s,pos,_hx_len):
        return self.stream.write(s.b[pos:(pos + _hx_len)])

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
python_io_NativeBytesOutput._hx_class = python_io_NativeBytesOutput
_hx_classes["python.io.NativeBytesOutput"] = python_io_NativeBytesOutput


class python_io_IOutput:
    _hx_class_name = "python.io.IOutput"
    _hx_is_interface = "True"
    __slots__ = ("bigEndian",)
    _hx_fields = ["bigEndian"]
    _hx_methods = ["set_bigEndian", "writeByte", "writeBytes", "flush", "close", "write", "writeFullBytes", "writeFloat", "writeInt16", "writeUInt16", "writeInt32", "writeString"]
python_io_IOutput._hx_class = python_io_IOutput
_hx_classes["python.io.IOutput"] = python_io_IOutput


class python_io_IFileOutput:
    _hx_class_name = "python.io.IFileOutput"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_interfaces = [python_io_IOutput]
python_io_IFileOutput._hx_class = python_io_IFileOutput
_hx_classes["python.io.IFileOutput"] = python_io_IFileOutput


class python_io_FileBytesOutput(python_io_NativeBytesOutput):
    _hx_class_name = "python.io.FileBytesOutput"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = [python_io_IFileOutput]
    _hx_super = python_io_NativeBytesOutput


    def __init__(self,stream):
        super().__init__(stream)
python_io_FileBytesOutput._hx_class = python_io_FileBytesOutput
_hx_classes["python.io.FileBytesOutput"] = python_io_FileBytesOutput


class python_io_NativeTextInput(python_io_NativeInput):
    _hx_class_name = "python.io.NativeTextInput"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["readByte", "seek", "readinto"]
    _hx_statics = []
    _hx_interfaces = [python_io_IInput]
    _hx_super = python_io_NativeInput


    def __init__(self,stream):
        super().__init__(stream)

    def readByte(self):
        ret = self.stream.buffer.read(1)
        if (len(ret) == 0):
            self.throwEof()
        return ret[0]

    def seek(self,p,pos):
        self.wasEof = False
        python_io_IoTools.seekInTextMode(self.stream,self.tell,p,pos)

    def readinto(self,b):
        return self.stream.buffer.readinto(b)

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
python_io_NativeTextInput._hx_class = python_io_NativeTextInput
_hx_classes["python.io.NativeTextInput"] = python_io_NativeTextInput


class python_io_FileTextInput(python_io_NativeTextInput):
    _hx_class_name = "python.io.FileTextInput"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = [python_io_IFileInput]
    _hx_super = python_io_NativeTextInput


    def __init__(self,stream):
        super().__init__(stream)
python_io_FileTextInput._hx_class = python_io_FileTextInput
_hx_classes["python.io.FileTextInput"] = python_io_FileTextInput


class python_io_NativeTextOutput(python_io_NativeOutput):
    _hx_class_name = "python.io.NativeTextOutput"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["writeBytes", "writeByte"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = python_io_NativeOutput


    def __init__(self,stream):
        super().__init__(stream)
        if (not stream.writable()):
            raise _HxException("Read only stream")

    def writeBytes(self,s,pos,_hx_len):
        return self.stream.buffer.write(s.b[pos:(pos + _hx_len)])

    def writeByte(self,c):
        self.stream.write("".join(map(chr,[c])))

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
python_io_NativeTextOutput._hx_class = python_io_NativeTextOutput
_hx_classes["python.io.NativeTextOutput"] = python_io_NativeTextOutput


class python_io_FileTextOutput(python_io_NativeTextOutput):
    _hx_class_name = "python.io.FileTextOutput"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = [python_io_IFileOutput]
    _hx_super = python_io_NativeTextOutput


    def __init__(self,stream):
        super().__init__(stream)
python_io_FileTextOutput._hx_class = python_io_FileTextOutput
_hx_classes["python.io.FileTextOutput"] = python_io_FileTextOutput


class python_io_IoTools:
    _hx_class_name = "python.io.IoTools"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["createFileInputFromText", "createFileInputFromBytes", "createFileOutputFromText", "createFileOutputFromBytes", "seekInTextMode", "seekInBinaryMode"]

    @staticmethod
    def createFileInputFromText(t):
        return sys_io_FileInput(python_io_FileTextInput(t))

    @staticmethod
    def createFileInputFromBytes(t):
        return sys_io_FileInput(python_io_FileBytesInput(t))

    @staticmethod
    def createFileOutputFromText(t):
        return sys_io_FileOutput(python_io_FileTextOutput(t))

    @staticmethod
    def createFileOutputFromBytes(t):
        return sys_io_FileOutput(python_io_FileBytesOutput(t))

    @staticmethod
    def seekInTextMode(stream,tell,p,pos):
        pos1 = None
        pos2 = pos.index
        if (pos2 == 0):
            pos1 = 0
        elif (pos2 == 1):
            p = (tell() + p)
            pos1 = 0
        elif (pos2 == 2):
            stream.seek(0,2)
            p = (tell() + p)
            pos1 = 0
        else:
            pass
        stream.seek(p,pos1)

    @staticmethod
    def seekInBinaryMode(stream,p,pos):
        pos1 = None
        pos2 = pos.index
        if (pos2 == 0):
            pos1 = 0
        elif (pos2 == 1):
            pos1 = 1
        elif (pos2 == 2):
            pos1 = 2
        else:
            pass
        stream.seek(p,pos1)
python_io_IoTools._hx_class = python_io_IoTools
_hx_classes["python.io.IoTools"] = python_io_IoTools


class sys_io_File:
    _hx_class_name = "sys.io.File"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["getContent", "saveContent", "getBytes", "saveBytes", "read", "append"]

    @staticmethod
    def getContent(path):
        f = python_lib_Builtins.open(path,"r",-1,"utf-8",None,"")
        content = f.read(-1)
        f.close()
        return content

    @staticmethod
    def saveContent(path,content):
        f = python_lib_Builtins.open(path,"w",-1,"utf-8",None,"")
        f.write(content)
        f.close()

    @staticmethod
    def getBytes(path):
        f = python_lib_Builtins.open(path,"rb",-1)
        size = f.read(-1)
        b = haxe_io_Bytes.ofData(size)
        f.close()
        return b

    @staticmethod
    def saveBytes(path,_hx_bytes):
        f = python_lib_Builtins.open(path,"wb",-1)
        f.write(_hx_bytes.b)
        f.close()

    @staticmethod
    def read(path,binary = None):
        if (binary is None):
            binary = True
        mode = ("rb" if binary else "r")
        f = python_lib_Builtins.open(path,mode,-1,None,None,(None if binary else ""))
        if binary:
            return python_io_IoTools.createFileInputFromBytes(f)
        else:
            return python_io_IoTools.createFileInputFromText(f)

    @staticmethod
    def append(path,binary = None):
        if (binary is None):
            binary = True
        mode = ("ab" if binary else "a")
        f = python_lib_Builtins.open(path,mode,-1,None,None,(None if binary else ""))
        if binary:
            return python_io_IoTools.createFileOutputFromBytes(f)
        else:
            return python_io_IoTools.createFileOutputFromText(f)
sys_io_File._hx_class = sys_io_File
_hx_classes["sys.io.File"] = sys_io_File


class sys_io_FileInput(haxe_io_Input):
    _hx_class_name = "sys.io.FileInput"
    _hx_is_interface = "False"
    __slots__ = ("impl",)
    _hx_fields = ["impl"]
    _hx_methods = ["set_bigEndian", "seek", "tell", "readByte", "readBytes", "close", "readFullBytes", "read", "readUntil", "readFloat", "readDouble", "readInt16", "readUInt16", "readUInt24", "readInt32", "readString"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Input


    def __init__(self,impl):
        self.impl = impl

    def set_bigEndian(self,b):
        return self.impl.set_bigEndian(b)

    def seek(self,p,pos):
        self.impl.seek(p,pos)
        return

    def tell(self):
        return self.impl.tell()

    def readByte(self):
        return self.impl.readByte()

    def readBytes(self,s,pos,_hx_len):
        return self.impl.readBytes(s,pos,_hx_len)

    def close(self):
        self.impl.close()

    def readFullBytes(self,s,pos,_hx_len):
        self.impl.readFullBytes(s,pos,_hx_len)

    def read(self,nbytes):
        return self.impl.read(nbytes)

    def readUntil(self,end):
        return self.impl.readUntil(end)

    def readFloat(self):
        return self.impl.readFloat()

    def readDouble(self):
        return self.impl.readDouble()

    def readInt16(self):
        return self.impl.readInt16()

    def readUInt16(self):
        return self.impl.readUInt16()

    def readUInt24(self):
        return self.impl.readUInt24()

    def readInt32(self):
        return self.impl.readInt32()

    def readString(self,_hx_len,encoding = None):
        return self.impl.readString(_hx_len)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.impl = None
sys_io_FileInput._hx_class = sys_io_FileInput
_hx_classes["sys.io.FileInput"] = sys_io_FileInput


class sys_io_FileOutput(haxe_io_Output):
    _hx_class_name = "sys.io.FileOutput"
    _hx_is_interface = "False"
    __slots__ = ("impl",)
    _hx_fields = ["impl"]
    _hx_methods = ["set_bigEndian", "writeByte", "writeBytes", "flush", "close", "write", "writeFullBytes", "writeFloat", "writeInt16", "writeUInt16", "writeInt32", "writeString"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Output


    def __init__(self,impl):
        self.impl = impl

    def set_bigEndian(self,b):
        return self.impl.set_bigEndian(b)

    def writeByte(self,c):
        self.impl.writeByte(c)

    def writeBytes(self,s,pos,_hx_len):
        return self.impl.writeBytes(s,pos,_hx_len)

    def flush(self):
        self.impl.flush()

    def close(self):
        self.impl.close()

    def write(self,s):
        self.impl.write(s)

    def writeFullBytes(self,s,pos,_hx_len):
        self.impl.writeFullBytes(s,pos,_hx_len)

    def writeFloat(self,x):
        self.impl.writeFloat(x)

    def writeInt16(self,x):
        self.impl.writeInt16(x)

    def writeUInt16(self,x):
        self.impl.writeUInt16(x)

    def writeInt32(self,x):
        self.impl.writeInt32(x)

    def writeString(self,s,encoding = None):
        self.impl.writeString(s)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.impl = None
sys_io_FileOutput._hx_class = sys_io_FileOutput
_hx_classes["sys.io.FileOutput"] = sys_io_FileOutput

class sys_io_FileSeek(Enum):
    __slots__ = ()
    _hx_class_name = "sys.io.FileSeek"
    _hx_constructs = ["SeekBegin", "SeekCur", "SeekEnd"]
sys_io_FileSeek.SeekBegin = sys_io_FileSeek("SeekBegin", 0, ())
sys_io_FileSeek.SeekCur = sys_io_FileSeek("SeekCur", 1, ())
sys_io_FileSeek.SeekEnd = sys_io_FileSeek("SeekEnd", 2, ())
sys_io_FileSeek._hx_class = sys_io_FileSeek
_hx_classes["sys.io.FileSeek"] = sys_io_FileSeek

Math.NEGATIVE_INFINITY = float("-inf")
Math.POSITIVE_INFINITY = float("inf")
Math.NaN = float("nan")
Math.PI = python_lib_Math.pi

def _hx_init_Sys_environ():
    def _hx_local_0():
        Sys.environ = haxe_ds_StringMap()
        env = python_lib_Os.environ
        key = python_HaxeIterator(iter(env.keys()))
        while key.hasNext():
            key1 = key.next()
            _this = Sys.environ
            value = env.get(key1,None)
            _this.h[key1] = value
        return Sys.environ
    return _hx_local_0()
Sys.environ = _hx_init_Sys_environ()
Sys._programPath = sys_FileSystem.fullPath(python_lib_Inspect.getsourcefile(Sys))
Xml.Element = 0
Xml.PCData = 1
Xml.CData = 2
Xml.Comment = 3
Xml.DocType = 4
Xml.ProcessingInstruction = 5
Xml.Document = 6
format_gif_Tools.LN2 = python_lib_Math.log(2)
format_mp3_MPEG.V1 = 3
format_mp3_MPEG.V2 = 2
format_mp3_MPEG.V25 = 0
format_mp3_MPEG.Reserved = 1
format_mp3_MPEG.V1_Bitrates = [[format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad], [format_mp3_Bitrate.BR_Free, format_mp3_Bitrate.BR_32, format_mp3_Bitrate.BR_40, format_mp3_Bitrate.BR_48, format_mp3_Bitrate.BR_56, format_mp3_Bitrate.BR_64, format_mp3_Bitrate.BR_80, format_mp3_Bitrate.BR_96, format_mp3_Bitrate.BR_112, format_mp3_Bitrate.BR_128, format_mp3_Bitrate.BR_160, format_mp3_Bitrate.BR_192, format_mp3_Bitrate.BR_224, format_mp3_Bitrate.BR_256, format_mp3_Bitrate.BR_320, format_mp3_Bitrate.BR_Bad], [format_mp3_Bitrate.BR_Free, format_mp3_Bitrate.BR_32, format_mp3_Bitrate.BR_48, format_mp3_Bitrate.BR_56, format_mp3_Bitrate.BR_64, format_mp3_Bitrate.BR_80, format_mp3_Bitrate.BR_96, format_mp3_Bitrate.BR_112, format_mp3_Bitrate.BR_128, format_mp3_Bitrate.BR_160, format_mp3_Bitrate.BR_192, format_mp3_Bitrate.BR_224, format_mp3_Bitrate.BR_256, format_mp3_Bitrate.BR_320, format_mp3_Bitrate.BR_384, format_mp3_Bitrate.BR_Bad], [format_mp3_Bitrate.BR_Free, format_mp3_Bitrate.BR_32, format_mp3_Bitrate.BR_64, format_mp3_Bitrate.BR_96, format_mp3_Bitrate.BR_128, format_mp3_Bitrate.BR_160, format_mp3_Bitrate.BR_192, format_mp3_Bitrate.BR_224, format_mp3_Bitrate.BR_256, format_mp3_Bitrate.BR_288, format_mp3_Bitrate.BR_320, format_mp3_Bitrate.BR_352, format_mp3_Bitrate.BR_384, format_mp3_Bitrate.BR_416, format_mp3_Bitrate.BR_448, format_mp3_Bitrate.BR_Bad]]
format_mp3_MPEG.V2_Bitrates = [[format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad, format_mp3_Bitrate.BR_Bad], [format_mp3_Bitrate.BR_Free, format_mp3_Bitrate.BR_8, format_mp3_Bitrate.BR_16, format_mp3_Bitrate.BR_24, format_mp3_Bitrate.BR_32, format_mp3_Bitrate.BR_40, format_mp3_Bitrate.BR_48, format_mp3_Bitrate.BR_56, format_mp3_Bitrate.BR_64, format_mp3_Bitrate.BR_80, format_mp3_Bitrate.BR_96, format_mp3_Bitrate.BR_112, format_mp3_Bitrate.BR_128, format_mp3_Bitrate.BR_144, format_mp3_Bitrate.BR_160, format_mp3_Bitrate.BR_Bad], [format_mp3_Bitrate.BR_Free, format_mp3_Bitrate.BR_8, format_mp3_Bitrate.BR_16, format_mp3_Bitrate.BR_24, format_mp3_Bitrate.BR_32, format_mp3_Bitrate.BR_40, format_mp3_Bitrate.BR_48, format_mp3_Bitrate.BR_56, format_mp3_Bitrate.BR_64, format_mp3_Bitrate.BR_80, format_mp3_Bitrate.BR_96, format_mp3_Bitrate.BR_112, format_mp3_Bitrate.BR_128, format_mp3_Bitrate.BR_144, format_mp3_Bitrate.BR_160, format_mp3_Bitrate.BR_Bad], [format_mp3_Bitrate.BR_Free, format_mp3_Bitrate.BR_32, format_mp3_Bitrate.BR_48, format_mp3_Bitrate.BR_56, format_mp3_Bitrate.BR_64, format_mp3_Bitrate.BR_80, format_mp3_Bitrate.BR_96, format_mp3_Bitrate.BR_112, format_mp3_Bitrate.BR_128, format_mp3_Bitrate.BR_144, format_mp3_Bitrate.BR_160, format_mp3_Bitrate.BR_176, format_mp3_Bitrate.BR_192, format_mp3_Bitrate.BR_224, format_mp3_Bitrate.BR_256, format_mp3_Bitrate.BR_Bad]]
format_mp3_MPEG.SamplingRates = [[format_mp3_SamplingRate.SR_11025, format_mp3_SamplingRate.SR_12000, format_mp3_SamplingRate.SR_8000, format_mp3_SamplingRate.SR_Bad], [format_mp3_SamplingRate.SR_Bad, format_mp3_SamplingRate.SR_Bad, format_mp3_SamplingRate.SR_Bad, format_mp3_SamplingRate.SR_Bad], [format_mp3_SamplingRate.SR_22050, format_mp3_SamplingRate.SR_24000, format_mp3_SamplingRate.SR_12000, format_mp3_SamplingRate.SR_Bad], [format_mp3_SamplingRate.SR_44100, format_mp3_SamplingRate.SR_48000, format_mp3_SamplingRate.SR_32000, format_mp3_SamplingRate.SR_Bad]]
format_mp3_CLayer.LReserved = 0
format_mp3_CLayer.LLayer3 = 1
format_mp3_CLayer.LLayer2 = 2
format_mp3_CLayer.LLayer1 = 3
format_mp3_CChannelMode.CStereo = 0
format_mp3_CChannelMode.CJointStereo = 1
format_mp3_CChannelMode.CDualChannel = 2
format_mp3_CChannelMode.CMono = 3
format_mp3_CEmphasis.ENone = 0
format_mp3_CEmphasis.EMs50_15 = 1
format_mp3_CEmphasis.EReserved = 2
format_mp3_CEmphasis.ECCIT_J17 = 3
h2d_RenderContext.BUFFERING = False
h2d_col_Matrix.tmp = h2d_col_Matrix()
h3d_Buffer.GUID = 0
h3d_Engine.SOFTWARE_DRIVER = False
h3d_Engine.ANTIALIASING = 0
h3d_Engine.CURRENT = None
h3d_Matrix.tmp = h3d_Matrix()
h3d_Matrix.lumR = 0.212671
h3d_Matrix.lumG = 0.71516
h3d_Matrix.lumB = 0.072169
h3d_Matrix.SQ13 = 0.57735026918962576450914878050196
h3d_anim_Animation.EPSILON = 0.000001
h3d_col_ObjectCollider.TMP_RAY = h3d_col_Ray()
h3d_col_ObjectCollider.TMP_MAT = h3d_Matrix()
h3d_impl_InputNames.UID = 0
h3d_impl_InputNames.CACHE = haxe_ds_StringMap()
python_Boot.keywords = set(["and", "del", "from", "not", "with", "as", "elif", "global", "or", "yield", "assert", "else", "if", "pass", "None", "break", "except", "import", "raise", "True", "class", "exec", "in", "return", "False", "continue", "finally", "is", "try", "def", "for", "lambda", "while"])
python_Boot.prefixLength = len("_hx_")
h3d_impl_MemoryManager.MAX_MEMORY = 4294967296.
h3d_impl_MemoryManager.MAX_BUFFERS = 65536
h3d_impl_MemoryManager.SIZE = 65533
h3d_impl_MemoryManager.ALL_FLAGS = Type.allEnums(h3d_BufferFlag)
h3d_mat_Defaults.defaultKillAlphaThreshold = 0.5
h3d_mat_Defaults.loadingTextureColor = -65281
h3d_mat_MaterialSetup.current = h3d_mat_MaterialSetup("Default")
h3d_mat_Pass.enableLights_bits = 1
h3d_mat_Pass.enableLights_offset = 0
h3d_mat_Pass.enableLights_mask = 1
h3d_mat_Pass.dynamicParameters_bits = 1
h3d_mat_Pass.dynamicParameters_offset = 1
h3d_mat_Pass.dynamicParameters_mask = 2
h3d_mat_Pass.isStatic_bits = 1
h3d_mat_Pass.isStatic_offset = 2
h3d_mat_Pass.isStatic_mask = 4
h3d_mat_Pass.batchMode_bits = 1
h3d_mat_Pass.batchMode_offset = 3
h3d_mat_Pass.batchMode_mask = 8
h3d_mat_Pass.culling_bits = 2
h3d_mat_Pass.culling_offset = 0
h3d_mat_Pass.culling_mask = 3
h3d_mat_Pass.depthWrite_bits = 1
h3d_mat_Pass.depthWrite_offset = 2
h3d_mat_Pass.depthWrite_mask = 4
h3d_mat_Pass.depthTest_bits = 3
h3d_mat_Pass.depthTest_offset = 3
h3d_mat_Pass.depthTest_mask = 56
h3d_mat_Pass.blendSrc_bits = 4
h3d_mat_Pass.blendSrc_offset = 6
h3d_mat_Pass.blendSrc_mask = 960
h3d_mat_Pass.blendDst_bits = 4
h3d_mat_Pass.blendDst_offset = 10
h3d_mat_Pass.blendDst_mask = 15360
h3d_mat_Pass.blendAlphaSrc_bits = 4
h3d_mat_Pass.blendAlphaSrc_offset = 14
h3d_mat_Pass.blendAlphaSrc_mask = 245760
h3d_mat_Pass.blendAlphaDst_bits = 4
h3d_mat_Pass.blendAlphaDst_offset = 18
h3d_mat_Pass.blendAlphaDst_mask = 3932160
h3d_mat_Pass.blendOp_bits = 3
h3d_mat_Pass.blendOp_offset = 22
h3d_mat_Pass.blendOp_mask = 29360128
h3d_mat_Pass.blendAlphaOp_bits = 3
h3d_mat_Pass.blendAlphaOp_offset = 25
h3d_mat_Pass.blendAlphaOp_mask = 234881024
h3d_mat_Pass.wireframe_bits = 1
h3d_mat_Pass.wireframe_offset = 28
h3d_mat_Pass.wireframe_mask = 268435456
h3d_mat_Pass.reserved_bits = 1
h3d_mat_Pass.reserved_offset = 29
h3d_mat_Pass.reserved_mask = 536870912
h3d_mat_Stencil.readMask_bits = 8
h3d_mat_Stencil.readMask_offset = 0
h3d_mat_Stencil.readMask_mask = 255
h3d_mat_Stencil.writeMask_bits = 8
h3d_mat_Stencil.writeMask_offset = 8
h3d_mat_Stencil.writeMask_mask = 65280
h3d_mat_Stencil.reference_bits = 8
h3d_mat_Stencil.reference_offset = 16
h3d_mat_Stencil.reference_mask = 16711680
h3d_mat_Stencil.frontTest_bits = 3
h3d_mat_Stencil.frontTest_offset = 0
h3d_mat_Stencil.frontTest_mask = 7
h3d_mat_Stencil.frontPass_bits = 3
h3d_mat_Stencil.frontPass_offset = 3
h3d_mat_Stencil.frontPass_mask = 56
h3d_mat_Stencil.frontSTfail_bits = 3
h3d_mat_Stencil.frontSTfail_offset = 6
h3d_mat_Stencil.frontSTfail_mask = 448
h3d_mat_Stencil.frontDPfail_bits = 3
h3d_mat_Stencil.frontDPfail_offset = 9
h3d_mat_Stencil.frontDPfail_mask = 3584
h3d_mat_Stencil.backTest_bits = 3
h3d_mat_Stencil.backTest_offset = 12
h3d_mat_Stencil.backTest_mask = 28672
h3d_mat_Stencil.backPass_bits = 3
h3d_mat_Stencil.backPass_offset = 15
h3d_mat_Stencil.backPass_mask = 229376
h3d_mat_Stencil.backSTfail_bits = 3
h3d_mat_Stencil.backSTfail_offset = 18
h3d_mat_Stencil.backSTfail_mask = 1835008
h3d_mat_Stencil.backDPfail_bits = 3
h3d_mat_Stencil.backDPfail_offset = 21
h3d_mat_Stencil.backDPfail_mask = 14680064
h3d_mat_Texture.UID = 0
h3d_mat_Texture.PREVENT_AUTO_DISPOSE = 2147483647
h3d_mat_Texture.nativeFormat = hxd_PixelFormat.RGBA
h3d_mat_Texture.checkerTextureKeys = haxe_ds_IntMap()
h3d_mat_Texture.noiseTextureKeys = haxe_ds_IntMap()
h3d_mat_Texture.genTextureKeys = haxe_ds_StringMap()
h3d_pass_Blur.__meta__ = _hx_AnonObject({'obj': _hx_AnonObject({'ignore': ["shader"]})})
h3d_shader_ScreenShader.SRC = "HXSLF2gzZC5zaGFkZXIuU2NyZWVuU2hhZGVyBwEFaW5wdXQNAQICCHBvc2l0aW9uBQoBAQADAnV2BQoBAQABAAAEBWZsaXBZAwIAAAUGb3V0cHV0DQICBghwb3NpdGlvbgUMBAUABwVjb2xvcgUMBAUABAAACApwaXhlbENvbG9yBQwEAAAJDGNhbGN1bGF0ZWRVVgUKBAAACghfX2luaXRfXw4GAAALBnZlcnRleA4GAAACAgoAAAUCBgQCBwUMAggFDAUMBgQCCQUKAgMFCgUKAAALAAAFAQYEAgYFDAkDKg4ECgICBQoAAAMGAQoCAgUKBAADAgQDAwEDAAAAAAAAAAADAQMAAAAAAADwPwMFDAUMAA"
h3d_pass__Border_BorderShader.SRC = "HXSLHWgzZC5wYXNzLl9Cb3JkZXIuQm9yZGVyU2hhZGVyCQEFaW5wdXQNAQICCHBvc2l0aW9uBQoBAQADAnV2BQoBAQABAAAEBWZsaXBZAwIAAAUGb3V0cHV0DQICBghwb3NpdGlvbgUMBAUABwVjb2xvcgUMBAUABAAACApwaXhlbENvbG9yBQwEAAAJDGNhbGN1bGF0ZWRVVgUKBAAACgVjb2xvcgUMAgAACwhfX2luaXRfXw4GAAAMBnZlcnRleA4GAAANCGZyYWdtZW50DgYAAAMCCwAABQIGBAIHBQwCCAUMBQwGBAIJBQoCAwUKBQoAAAwAAAUBBgQCBgUMCQMqDgQKAgIFCgAAAwYBCgICBQoEAAMCBAMDAQMAAAAAAAAAAAMBAwAAAAAAAPA/AwUMBQwAAQ0AAAUBBgQCCAUMAgoFDAUMAA"
h3d_pass__Copy_ArrayCopyShader.SRC = "HXSLHmgzZC5wYXNzLl9Db3B5LkFycmF5Q29weVNoYWRlcgoBBWlucHV0DQECAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEAAQAABAVmbGlwWQMCAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgKcGl4ZWxDb2xvcgUMBAAACQxjYWxjdWxhdGVkVVYFCgQAAAoHdGV4dHVyZQsCAAALBWxheWVyAQIAAAwIX19pbml0X18OBgAADQZ2ZXJ0ZXgOBgAADghmcmFnbWVudA4GAAADAgwAAAUCBgQCBwUMAggFDAUMBgQCCQUKAgMFCgUKAAANAAAFAQYEAgYFDAkDKg4ECgICBQoAAAMGAQoCAgUKBAADAgQDAwEDAAAAAAAAAAADAQMAAAAAAADwPwMFDAUMAAEOAAAFAQYEAggFDAkDIQ4CAgoLCQMpDgICCQUKCQMmDgECCwEDBQsFDAUMAA"
h3d_pass__Copy_CopyShader.SRC = "HXSLGWgzZC5wYXNzLl9Db3B5LkNvcHlTaGFkZXIJAQVpbnB1dA0BAgIIcG9zaXRpb24FCgEBAAMCdXYFCgEBAAEAAAQFZmxpcFkDAgAABQZvdXRwdXQNAgIGCHBvc2l0aW9uBQwEBQAHBWNvbG9yBQwEBQAEAAAICnBpeGVsQ29sb3IFDAQAAAkMY2FsY3VsYXRlZFVWBQoEAAAKB3RleHR1cmUKAgAACwhfX2luaXRfXw4GAAAMBnZlcnRleA4GAAANCGZyYWdtZW50DgYAAAMCCwAABQIGBAIHBQwCCAUMBQwGBAIJBQoCAwUKBQoAAAwAAAUBBgQCBgUMCQMqDgQKAgIFCgAAAwYBCgICBQoEAAMCBAMDAQMAAAAAAAAAAAMBAwAAAAAAAPA/AwUMBQwAAQ0AAAUBBgQCCAUMCQMhDgICCgoCCQUKBQwFDAA"
h3d_pass__CubeCopy_CubeCopyShader.SRC = "HXSLIWgzZC5wYXNzLl9DdWJlQ29weS5DdWJlQ29weVNoYWRlcgoBBWlucHV0DQECAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEAAQAABAVmbGlwWQMCAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgKcGl4ZWxDb2xvcgUMBAAACQxjYWxjdWxhdGVkVVYFCgQAAAoHdGV4dHVyZQwCAAALA21hdAYCAAAMCF9faW5pdF9fDgYAAA0GdmVydGV4DgYAAA4IZnJhZ21lbnQOBgAAAwIMAAAFAgYEAgcFDAIIBQwFDAYEAgkFCgIDBQoFCgAADQAABQEGBAIGBQwJAyoOBAoCAgUKAAADBgEKAgIFCgQAAwIEAwMBAwAAAAAAAAAAAwEDAAAAAAAA8D8DBQwFDAABDgAABQIIDwJ1dgUKBAAABgMGAQIJBQoBAwAAAAAAAABAAwUKAQMAAAAAAADwPwMFCgAGBAIIBQwJAyEOAgIKDAkDHw4BBgEJAykOAgIPBQoBAwAAAAAAAPA/AwULAgsGBQsFCwUMBQwA"
h3d_pass_Default.__meta__ = _hx_AnonObject({'fields': _hx_AnonObject({'cameraView': _hx_AnonObject({'_hx_global': ["camera.view"]}), 'cameraNear': _hx_AnonObject({'_hx_global': ["camera.zNear"]}), 'cameraFar': _hx_AnonObject({'_hx_global': ["camera.zFar"]}), 'cameraProj': _hx_AnonObject({'_hx_global': ["camera.proj"]}), 'cameraPos': _hx_AnonObject({'_hx_global': ["camera.position"]}), 'cameraProjDiag': _hx_AnonObject({'_hx_global': ["camera.projDiag"]}), 'cameraProjFlip': _hx_AnonObject({'_hx_global': ["camera.projFlip"]}), 'cameraViewProj': _hx_AnonObject({'_hx_global': ["camera.viewProj"]}), 'cameraInverseViewProj': _hx_AnonObject({'_hx_global': ["camera.inverseViewProj"]}), 'globalTime': _hx_AnonObject({'_hx_global': ["global.time"]}), 'pixelSize': _hx_AnonObject({'_hx_global': ["global.pixelSize"]}), 'globalModelView': _hx_AnonObject({'_hx_global': ["global.modelView"]}), 'globalModelViewInverse': _hx_AnonObject({'_hx_global': ["global.modelViewInverse"]})})})
h3d_pass__HardwarePick_FixedColor.SRC = "HXSLIWgzZC5wYXNzLl9IYXJkd2FyZVBpY2suRml4ZWRDb2xvcgUBB2NvbG9ySUQFDAIAAAIIdmlld3BvcnQFDAIAAAMGb3V0cHV0DQECBAhwb3NpdGlvbgUMBAMABQdjb2xvcklEBQwEAwAEAAAGBnZlcnRleA4GAAAHCGZyYWdtZW50DgYAAAIABgAABQEGBAIEBQwGAQQGAAIEBQwGAQkDKg4DCgICBQwRAAUKAQMAAAAAAAAAAAMBAwAAAAAAAAAAAwUMCgIEBQwMAAMFDAUMBQwJAyoOAwoCAgUMOQAFCgEDAAAAAAAA8D8DAQMAAAAAAADwPwMFDAUMBQwAAQcAAAUBBgQCBQUMAgEFDAUMAA"
h3d_pass_ShaderManager.STRICT = True
h3d_scene_Object.ROT2RAD = -0.017453292519943295769236907684886
h3d_scene_Object.tmpMat = h3d_Matrix()
h3d_scene_Object.tmpVec = h3d_Vector()
h3d_scene__Object_ObjectFlags_Impl_.FPosChanged = 1
h3d_scene__Object_ObjectFlags_Impl_.FVisible = 2
h3d_scene__Object_ObjectFlags_Impl_.FCulled = 4
h3d_scene__Object_ObjectFlags_Impl_.FFollowPositionOnly = 8
h3d_scene__Object_ObjectFlags_Impl_.FLightCameraCenter = 16
h3d_scene__Object_ObjectFlags_Impl_.FAllocated = 32
h3d_scene__Object_ObjectFlags_Impl_.FAlwaysSync = 64
h3d_scene__Object_ObjectFlags_Impl_.FInheritCulled = 128
h3d_scene__Object_ObjectFlags_Impl_.FNoSerialize = 256
h3d_scene__Object_ObjectFlags_Impl_.FIgnoreBounds = 512
h3d_scene__Object_ObjectFlags_Impl_.FIgnoreCollide = 1024
h3d_scene__Object_ObjectFlags_Impl_.FIgnoreParentTransform = 2048
h3d_scene__Object_ObjectFlags_Impl_.FCullingColliderInherited = 4096
h3d_shader_AmbientLight.SRC = "HXSLF2gzZC5zaGFkZXIuQW1iaWVudExpZ2h0CgEGZ2xvYmFsDQECAgxhbWJpZW50TGlnaHQFCwABAAMQcGVyUGl4ZWxMaWdodGluZwIAAQEAAAAAAAAAAAQKcGl4ZWxDb2xvcgUMBAAABQ9saWdodFBpeGVsQ29sb3IFCwQAAAYKbGlnaHRDb2xvcgULBAAABwhhZGRpdGl2ZQICAAEAAAAAAAgIX19pbml0X18OBgAACRBfX2luaXRfX2ZyYWdtZW50DgYAAAoJY2FsY0xpZ2h0DgYAAAsGdmVydGV4DgYAAAwIZnJhZ21lbnQOBgAABQIIAAAFAQYEAgYFCwsCBwICAgULCQMpDgEBAwAAAAAAAAAAAwULBQsFCwACCQAABQEGBAIFBQsLAgcCAgIFCwkDKQ4BAQMAAAAAAAAAAAMFCwULBQsAAwoBDQpsaWdodENvbG9yBQsEAAAFCwUBDQsCBwICDQULBAYAAgIFCwYBCQMWDgIEBgMBAwAAAAAAAPA/AwICBQsFCwULAQMAAAAAAAAAAAMFCwINBQsFCwULBQsFCwAAAAsAAAUBCwcCAgMCAgaBCgIEBQySAAULCQIKDgECBgULBQsFCwAAAAEMAAAFAQsCAwIGgQoCBAUMkgAFCwkCCg4BAgUFCwULBQsAAAA"
h3d_shader_Base2d.SRC = "HXSLEWgzZC5zaGFkZXIuQmFzZTJkGgEFaW5wdXQNAQMCCHBvc2l0aW9uBQoBAQADAnV2BQoBAQAEBWNvbG9yBQwBAQABAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgEdGltZQMAAAAJBnpWYWx1ZQMCAAAKB3RleHR1cmUKAgAACw5zcHJpdGVQb3NpdGlvbgUMBAAADBBhYnNvbHV0ZVBvc2l0aW9uBQwEAAANCnBpeGVsQ29sb3IFDAQAAA4MdGV4dHVyZUNvbG9yBQwEAAAPDGNhbGN1bGF0ZWRVVgUKAwAAEAppc1JlbGF0aXZlAgIAAQAAAAAAEQVjb2xvcgUMAgAAEg9hYnNvbHV0ZU1hdHJpeEEFCwIAABMPYWJzb2x1dGVNYXRyaXhCBQsCAAAUDWZpbHRlck1hdHJpeEEFCwIAABUNZmlsdGVyTWF0cml4QgULAgAAFghoYXNVVlBvcwICAAEAAAAAABcFdXZQb3MFDAIAABgJa2lsbEFscGhhAgIAAQAAAAAAGQpwaXhlbEFsaWduAgIAAQAAAAAAGhBoYWxmUGl4ZWxJbnZlcnNlBQoCAAAbCHZpZXdwb3J0BQwCAAAcDm91dHB1dFBvc2l0aW9uBQwEAAAdCF9faW5pdF9fDgYAAB4GdmVydGV4DgYAAB8IZnJhZ21lbnQOBgAAAwIdAAAFBgYEAgsFDAkDKg4DAgIFCgIJAwEDAAAAAAAA8D8DBQwFDAsCEAIFAwYECgIMBQwAAAMJAx0OAgkDKQ4CCgILBQwRAAUKAQMAAAAAAADwPwMFCwISBQsDAwYECgIMBQwEAAMJAx0OAgkDKQ4CCgILBQwRAAUKAQMAAAAAAADwPwMFCwITBQsDAwYECgIMBQw5AAUKCgILBQw5AAUKBQoABgQCDAUMAgsFDAUMAAYEAg8FCgsCFgIGAAYBAgMFCgoCFwUMOQAFCgUKCgIXBQwRAAUKBQoCAwUKBQoFCgYEAg0FDAsCEAIGAQIRBQwCBAUMBQwCBAUMBQwFDAYEAg4FDAkDIQ4CAgoKAg8FCgUMBQwGgQINBQwCDgUMBQwAAB4AAAUFCCADdG1wBQsEAAAJAykOAgoCDAUMEQAFCgEDAAAAAAAA8D8DBQsABgQCHAUMCQMqDgMJAx0OAgIgBQsCFAULAwkDHQ4CAiAFCwIVBQsDCgIMBQw5AAUKBQwFDAYECgIcBQwRAAUKBgEEBgAKAhwFDBEABQoKAhsFDBEABQoFCgUKCgIbBQw5AAUKBQoFCgsCGQIGgwoCHAUMEQAFCgIaBQoFCgAABgQCBgUMAhwFDAUMAAEfAAAFAgsGDgIYAgYJCgINBQwMAAMBA/yp8dJNYlA/AwICDAAAAAYEAgcFDAINBQwFDAA"
h3d_shader_BaseMesh.SRC = "HXSLE2gzZC5zaGFkZXIuQmFzZU1lc2gXAQZjYW1lcmENAQoCBHZpZXcHAAEAAwRwcm9qBwABAAQIcG9zaXRpb24FCwABAAUIcHJvakZsaXADAAEABghwcm9qRGlhZwULAAEABwh2aWV3UHJvagcAAQAID2ludmVyc2VWaWV3UHJvagcAAQAJBXpOZWFyAwABAAoEekZhcgMAAQALA2RpcgULAwEAAAAADAZnbG9iYWwNAgQNBHRpbWUDAAwADglwaXhlbFNpemUFCgAMAA8JbW9kZWxWaWV3BwAMAQMQEG1vZGVsVmlld0ludmVyc2UHAAwBAwAAABEFaW5wdXQNAwISCHBvc2l0aW9uBQsBEQATBm5vcm1hbAULAREAAQAAFAZvdXRwdXQNBAUVCHBvc2l0aW9uBQwEFAAWBWNvbG9yBQwEFAAXBWRlcHRoAwQUABgGbm9ybWFsBQsEFAAZCXdvcmxkRGlzdAMEFAAEAAAaEHJlbGF0aXZlUG9zaXRpb24FCwQAABsTdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAAHBhwaXhlbFRyYW5zZm9ybWVkUG9zaXRpb24FCwQAAB0RdHJhbnNmb3JtZWROb3JtYWwFCwQAAB4RcHJvamVjdGVkUG9zaXRpb24FDAQAAB8KcGl4ZWxDb2xvcgUMBAAAIAVkZXB0aAMEAAAhCHNjcmVlblVWBQoEAAAiCXNwZWNQb3dlcgMEAAAjCXNwZWNDb2xvcgULBAAAJAl3b3JsZERpc3QDBAAAJQVjb2xvcgUMAgAAJg1zcGVjdWxhclBvd2VyAwIAAQcAAAAAAAAAAAAAAAAAAFlAJw5zcGVjdWxhckFtb3VudAMCAAEHAAAAAAAAAAAAAAAAAAAkQCgNc3BlY3VsYXJDb2xvcgULAgAAKQhfX2luaXRfXw4GAAAqEF9faW5pdF9fZnJhZ21lbnQOBgAAKwZ2ZXJ0ZXgOBgAALAhmcmFnbWVudA4GAAAEAikAAAULBgQCGgULAhIFCwULBgQCGwULBgECGgULCQM0DgECDwcIBQsFCwYEAh4FDAYBCQMqDgICGwULAQMAAAAAAADwPwMFDAIHBwUMBQwGBAIdBQsJAx8OAQQGAQITBQsJAzIOAQIPBwYFCwULBQsFCwYEAgsFCwkDHw4BBAYDAgQFCwIbBQsFCwULBQsFCwYEAh8FDAIlBQwFDAYEAiIDAiYDAwYEAiMFCwYBAigFCwInAwULBQsGBAIhBQoJAzoOAQYCCgIeBQwRAAUKCgIeBQwMAAMFCgUKBQoGBAIgAwYCCgIeBQwIAAMKAh4FDAwAAwMDBgQCJAMGAgkDGw4BBgMCGwULAgQFCwULAwIKAwMDAAIqAAAFBQYEAh0FCwkDHw4BAh0FCwULBQsGBAIhBQoJAzoOAQYCCgIeBQwRAAUKCgIeBQwMAAMFCgUKBQoGBAIgAwYCCgIeBQwIAAMKAh4FDAwAAwMDBgQCIgMCJgMDBgQCIwULBgECKAULAicDBQsFCwAAKwAABQIGBAIVBQwGAQIeBQwJAyoOBAEDAAAAAAAA8D8DAgUDAQMAAAAAAADwPwMBAwAAAAAAAPA/AwUMBQwFDAYEAhwFCwIbBQsFCwABLAAABQQGBAIWBQwCHwUMBQwGBAIXAwIgAwMGBAIYBQsCHQULBQsGBAIZAwIkAwMA"
h3d_shader_Blur.SRC = "HXSLD2gzZC5zaGFkZXIuQmx1choBBWlucHV0DQECAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEAAQAABAVmbGlwWQMCAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgKcGl4ZWxDb2xvcgUMBAAACQxjYWxjdWxhdGVkVVYFCgQAAAoVY2FtZXJhSW52ZXJzZVZpZXdQcm9qBwIAAAsHdGV4dHVyZQoCAAAMDGRlcHRoVGV4dHVyZQoCAAANB1F1YWxpdHkBAgABAAAAAAAOB2lzRGVwdGgCAgABAAAAAAAPBnZhbHVlcw8DDQIAABAHb2Zmc2V0cw8DDQIAABEFcGl4ZWwFCgIAABINaGFzRml4ZWRDb2xvcgICAAEAAAAAABMQc21vb3RoRml4ZWRDb2xvcgICAAEAAAAAABQKZml4ZWRDb2xvcgUMAgAAFRBpc0RlcHRoRGVwZW5kYW50AgIAAQAAAAAAFgloYXNOb3JtYWwCAgABAAAAAAAXDW5vcm1hbFRleHR1cmUKAgAAGAZpc0N1YmUCAgABAAAAAAAZC2N1YmVUZXh0dXJlDAIAABoHY3ViZURpcgYCAAAbCF9faW5pdF9fDgYAABwGdmVydGV4DgYAAB0IZnJhZ21lbnQOBgAAHgtnZXRQb3NpdGlvbg4GAAAEAhsAAAUCBgQCBwUMAggFDAUMBgQCCQUKAgMFCgUKAAAcAAAFAQYEAgYFDAkDKg4ECgICBQoAAAMGAQoCAgUKBAADAgQDAwEDAAAAAAAAAAADAQMAAAAAAADwPwMFDAUMAAEdAAAFAgsCFQIFBggfBHBjdXIFCwQAAAkCHg4BAgMFCgULAAggBGNjdXIFDAQAAAkDIQ4CAgsKAgMFCgUMAAghBWNvbG9yBQwEAAAJAyoOBAEDAAAAAAAAAAADAQMAAAAAAAAAAAMBAwAAAAAAAAAAAwEDAAAAAAAAAAADBQwACCIEbmN1cgULBAAACQM5DgEJAyEOAgIXCgIDBQoFDAULABUGdW5yb2xsAA4jAWkBBAAABhUGAAcDAg0BAQECAQAAAAEBAg0BDwEAAAUICCQCdXYFCgQAAAYAAgMFCgYBAhEFChECEA8DDQsGCQIjAQECAAAAAAECBwMCIwEBAiMBAQMFCgUKAAglAWMFDAQAAAkDIQ4CAgsKAiQFCgUMAAgmAXAFCwQAAAkCHg4BAiQFCgULAAgnAWQDBAAACQMdDgIEBgMCJgULAh8FCwULBQsGAwImBQsCHwULBQsDAAgoAW4FCwQAAAkDOQ4BCQMhDgICFwoCJAUKBQwFCwAGBAIlBQwJAxgOAwIgBQwCJQUMCQMdDgICIgULAigFCwMFDAUMBgQCJQUMCQMYDgMCJQUMAiAFDAkDFQ4CBAYBCQMWDgIEBgMCJwMBA/yp8dJNYlA/AwMDAQMAAAAAAAAAAAMDAQMAAAAAAGr4QAMDAwEDAAAAAAAA8D8DAwUMBQwGgAIhBQwGAQIlBQwRAg8PAw0LBgkCIwEBAgAAAAABAgcDAiMBAQIjAQEDBQwFDAAAAAYEAggFDAIhBQwFDAALAg4CBQMIKQN2YWwDBAAAAQMAAAAAAAAAAAMAFQZ1bnJvbGwADioBaQEEAAAGFQYABwMCDQEBAQIBAAAAAQECDQEPAQAABQELAhgCBoACKQMGAQkDNw4BCQMhDgICGQwGAQkDKQ4CBgMGAQQGAAIDBQoGAQYBAhEFChECEA8DDQsGCQIqAQECAAAAAAECBwMCKgEBAioBAQMFCgkDJg4BAioBAwUKBQoFCgEDAAAAAAAAAEADBQoBAwAAAAAAAPA/AwUKAQMAAAAAAADwPwMFCwIaBgULBQwDEQIPDwMNCwYJAioBAQIAAAAAAQIHAwIqAQECKgEBAwMDBoACKQMGAQkDNw4BCQMhDgICCwoGAAIDBQoGAQYBAhEFChECEA8DDQsGCQIqAQECAAAAAAECBwMCKgEBAioBAQMFCgkDJg4BAioBAwUKBQoFDAMRAg8PAw0LBgkCKgEBAgAAAAABAgcDAioBAQIqAQEDAwMAAAAABgQCCAUMCQM2DgEJAxUOAgIpAwEDyxpQyv//7z8DAwUMBQwABQMIKwVjb2xvcgUMBAAACQMqDgQBAwAAAAAAAAAAAwEDAAAAAAAAAAADAQMAAAAAAAAAAAMBAwAAAAAAAAAAAwUMABUGdW5yb2xsAA4sAWkBBAAABhUGAAcDAg0BAQECAQAAAAEBAg0BDwEAAAUBCwIYAgaAAisFDAYBCQMhDgICGQwGAQkDKQ4CBgMGAQQGAAIDBQoGAQYBAhEFChECEA8DDQsGCQIsAQECAAAAAAECBwMCLAEBAiwBAQMFCgkDJg4BAiwBAwUKBQoFCgEDAAAAAAAAAEADBQoBAwAAAAAAAPA/AwUKAQMAAAAAAADwPwMFCwIaBgULBQwRAg8PAw0LBgkCLAEBAgAAAAABAgcDAiwBAQIsAQEDBQwFDAaAAisFDAYBCQMhDgICCwoGAAIDBQoGAQYBAhEFChECEA8DDQsGCQIsAQECAAAAAAECBwMCLAEBAiwBAQMFCgkDJg4BAiwBAwUKBQoFDBECDw8DDQsGCQIsAQECAAAAAAECBwMCLAEBAiwBAQMFDAUMAAAAAAYEAggFDAIrBQwFDAAAAAsCEgIFAgsCEwIGgQoCCAUMDAADCgIUBQwMAAMDBgQKAggFDAwAAwYBCgIUBQwMAAMJAyYOAQYHCgIIBQwMAAMBAwAAAAAAAAAAAwIDAwMABgQKAggFDJIABQsGAQoCFAUMkgAFCwoCCAUMDAADBQsFCwAAAAADHgEtAnV2BQoEAAAFCwUECC4FZGVwdGgDBAAACQM3DgEJAyEOAgIMCgItBQoFDAMACC8EdGVtcAUMBAAABgEJAyoOAwkDOw4BAi0FCgUKAi4DAQMAAAAAAADwPwMFDAIKBwUMAAgwCG9yaWdpbldTBQsEAAAGAgoCLwUMkgAFCwoCLwUMDAADBQsADQIwBQsAAA"
h3d_shader_ColorAdd.SRC = "HXSLE2gzZC5zaGFkZXIuQ29sb3JBZGQDAQpwaXhlbENvbG9yBQwEAAACBWNvbG9yBQsCAAADCGZyYWdtZW50DgYAAAEBAwAABQEGgAoCAQUMkgAFCwICBQsFCwA"
h3d_shader_ColorKey.SRC = "HXSLE2gzZC5zaGFkZXIuQ29sb3JLZXkDAQhjb2xvcktleQUMAgAAAgx0ZXh0dXJlQ29sb3IFDAQAAAMIZnJhZ21lbnQOBgAAAQEDAAAFAggEBWNkaWZmBQwEAAAGAwICBQwCAQUMBQwACwYJCQMdDgICBAUMAgQFDAMBA/Fo44i1+OQ+AwIMAAAAAA"
h3d_shader_ColorMatrix.SRC = "HXSLFmgzZC5zaGFkZXIuQ29sb3JNYXRyaXgDAQpwaXhlbENvbG9yBQwEAAACBm1hdHJpeAcCAAADCGZyYWdtZW50DgYAAAEBAwAABQEGBAIBBQwJAyoOAgoEBgEJAyoOAgoCAQUMkgAFCwEDAAAAAAAA8D8DBQwCAgcFDAUMkgAFCwoEBgECAQUMAgIHBQwFDAwAAwUMBQwA"
h3d_shader_ColorMult.SRC = "HXSLFGgzZC5zaGFkZXIuQ29sb3JNdWx0AwEKcGl4ZWxDb2xvcgUMBAAAAgVjb2xvcgUMAgAAAwhmcmFnbWVudA4GAAABAQMAAAUBBoECAQUMAgIFDAUMAA"
h3d_shader_DirLight.SRC = "HXSLE2gzZC5zaGFkZXIuRGlyTGlnaHQNAQVjb2xvcgULAgAAAglkaXJlY3Rpb24FCwIAAAMOZW5hYmxlU3BlY3VsYXICAgABAAAAAAAEBmNhbWVyYQ0BAQUIcG9zaXRpb24FCwAEAAAAAAYKbGlnaHRDb2xvcgULBAAABw9saWdodFBpeGVsQ29sb3IFCwQAAAgRdHJhbnNmb3JtZWROb3JtYWwFCwQAAAkTdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAACglzcGVjUG93ZXIDBAAACwlzcGVjQ29sb3IFCwQAAAwMY2FsY0xpZ2h0aW5nDgYAAA0GdmVydGV4DgYAAA4IZnJhZ21lbnQOBgAAAwMMAAULBQUIDwRkaWZmAwQAAAkDFg4CCQMdDgICCAULBwMCAgULBQsDAQMAAAAAAAAAAAMDAAsHAgIDAgINBgECAQULAg8DBQsAAAAIEAFyBQsEAAAJAx8OAQkDIA4CAgIFCwIIBQsFCwULAAgRCXNwZWNWYWx1ZQMEAAAJAxYOAgkDHQ4CAhAFCwkDHw4BBAYDAgUFCwIJBQsFCwULBQsDAQMAAAAAAAAAAAMDAA0GAQIBBQsEBgACDwMGAQILBQsJAwgOAgIRAwIKAwMFCwULBQsFCwAAAA0AAAUBBoAKAgYFC5IABQsJAgwOAAULBQsAAQ4AAAUBBoAKAgcFC5IABQsJAgwOAAULBQsA"
h3d_shader_DirShadow.SRC = "HXSLFGgzZC5zaGFkZXIuRGlyU2hhZG93EgEGZW5hYmxlAgIAAQAAAAAAAgdVU0VfRVNNAgIAAQAAAAAAAwtzaGFkb3dQb3dlcgMCAAAEB1VTRV9QQ0YCAgABAAAAAAAFCnBjZlF1YWxpdHkBAgABAAAAAAAGCHBjZlNjYWxlAwIAAAcJc2hhZG93UmVzBQoCAAAICXNoYWRvd01hcBEBAgAACQpzaGFkb3dQcm9qCAIAAAoKc2hhZG93QmlhcwMCAAALE3RyYW5zZm9ybWVkUG9zaXRpb24FCwQAAAwGc2hhZG93AwQAAA0JZGlyU2hhZG93AwQAAA4OcG9pc3NvbkRpc2tMb3cPBQwABAIAAA8PcG9pc3NvbkRpc2tIaWdoDwUMAAwCAAAQE3BvaXNzb25EaXNrVmVyeUhpZ2gPBQwAQAIAABEEcmFuZA4GAAASCGZyYWdtZW50DgYAAAIDEQETAXYDBAAAAwUCCBQCZHADBAAACQMdDgIJAyoOAQITAwUMCQMqDgQBA18pyxDH+ilAAwED9P3UeOmOU0ADAQOiRbbz/ZRGQAMBA1CNl24Sq1dAAwUMAwANCQMTDgEGAQkDAg4BAhQDAwEDUPwYc9Fd5UADAwMAAAESAAAFAgsCAQIFAQsCBAIFBwYEAgwDAQMAAAAAAADwPwMDCBUJdGV4ZWxTaXplBQoEAAAGAgEDAAAAAAAA8D8DAgcFCgUKAAgWCXNoYWRvd1BvcwULBAAABgECCwULAgkIBQsACBcIc2hhZG93VXYFCgQAAAkDOg4BCgIWBQsRAAUKBQoACBgEek1heAMEAAAJAzUOAQoCFgULCAADAwAIGQNyb3QDBAAABgEGAQkCEQ4BBgAGAAoCCwULAAADCgILBQsEAAMDCgILBQsIAAMDAwEDH4XrUbgeCUADAwEDAAAAAAAAAEADAwATBAIFAQEDAQECAQAAAAEFAggaDnNhbXBsZVN0cmVuZ3RoAwQAAAYCAQMAAAAAAADwPwMBAwAAAAAAABBAAwMADhsBaQEEAAAGFQECAAAAAAEBAgQAAAABDwEAAAUECBwGb2Zmc2V0BQoEAAAGAQYBChECDg8FDAAEAhsBBQwRAAUKAhUFCgUKAgYDBQoABgQCHAUKCQMoDgIGAwYBCQMDDgECGQMDCgIcBQoAAAMDBgEJAwIOAQIZAwMKAhwFCgQAAwMDBgAGAQkDAw4BAhkDAwoCHAUKBAADAwYBCQMCDgECGQMDCgIcBQoAAAMDAwUKBQoIHQVkZXB0aAMEAAAJA0AOAwIIEQEGAAIXBQoCHAUKBQoBAwAAAAAAAAAAAwMACwYHBgMCGAMCCgMDAh0DAgaDAgwDAhoDAwAAAAAAAQECAgAAAAEFAggeDnNhbXBsZVN0cmVuZ3RoAwQAAAYCAQMAAAAAAADwPwMBAwAAAAAAAChAAwMADh8BaQEEAAAGFQECAAAAAAEBAgwAAAABDwEAAAUECCAGb2Zmc2V0BQoEAAAGAQYBChECDw8FDAAMAh8BBQwRAAUKAhUFCgUKAgYDBQoABgQCIAUKCQMoDgIGAwYBCQMDDgECGQMDCgIgBQoAAAMDBgEJAwIOAQIZAwMKAiAFCgQAAwMDBgAGAQkDAw4BAhkDAwoCIAUKBAADAwYBCQMCDgECGQMDCgIgBQoAAAMDAwUKBQoIIQVkZXB0aAMEAAAJA0AOAwIIEQEGAAIXBQoCIAUKBQoBAwAAAAAAAAAAAwMACwYHBgMCGAMCCgMDAiEDAgaDAgwDAh4DAwAAAAAAAQECAwAAAAEFAggiDnNhbXBsZVN0cmVuZ3RoAwQAAAYCAQMAAAAAAADwPwMBAwAAAAAAAFBAAwMADiMBaQEEAAAGFQECAAAAAAEBAkAAAAABDwEAAAUECCQGb2Zmc2V0BQoEAAAGAQYBChECEA8FDABAAiMBBQwRAAUKAhUFCgUKAgYDBQoABgQCJAUKCQMoDgIGAwYBCQMDDgECGQMDCgIkBQoAAAMDBgEJAwIOAQIZAwMKAiQFCgQAAwMDBgAGAQkDAw4BAhkDAwoCJAUKBAADAwYBCQMCDgECGQMDCgIkBQoAAAMDAwUKBQoIJQVkZXB0aAMEAAAJA0AOAwIIEQEGAAIXBQoCJAUKBQoBAwAAAAAAAAAAAwMACwYHBgMCGAMCCgMDAiUDAgaDAgwDAiIDAwAAAAAAAAAACwICAgUFCCYJc2hhZG93UG9zBQsEAAAGAQILBQsCCQgFCwAIJwVkZXB0aAMEAAAJAz8OAgIIEQEJAzoOAQoCJgULEQAFCgUKAwAIKAR6TWF4AwQAAAkDNQ4BCgImBQsIAAMDAAgpBWRlbHRhAwQAAAYDCQMVDgIEBgACJwMCCgMDAwIoAwMCKAMDAAYEAgwDCQM1DgEJAwkOAQYBAgMDAikDAwMDAwAFBAgqCXNoYWRvd1BvcwULBAAABgECCwULAgkIBQsACCsIc2hhZG93VXYFCgQAAAkDOg4BCgIqBQsRAAUKBQoACCwFZGVwdGgDBAAACQM/DgICCBEBCgIrBQoRAAUKAwAGBAIMAwsGBwYDCgIqBQsIAAMCCgMDAiwDAgEDAAAAAAAAAAADAQMAAAAAAADwPwMDAwAAAAAAAAYEAg0DAgwDAwA"
h3d_shader_GenTexture.SRC = "HXSLFWgzZC5zaGFkZXIuR2VuVGV4dHVyZQoBBWlucHV0DQECAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEAAQAABAVmbGlwWQMCAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgKcGl4ZWxDb2xvcgUMBAAACQxjYWxjdWxhdGVkVVYFCgQAAAoEbW9kZQECAAEAAAAAAAsFY29sb3IFDAIAAAwIX19pbml0X18OBgAADQZ2ZXJ0ZXgOBgAADghmcmFnbWVudA4GAAADAgwAAAUCBgQCBwUMAggFDAUMBgQCCQUKAgMFCgUKAAANAAAFAQYEAgYFDAkDKg4ECgICBQoAAAMGAQoCAgUKBAADAgQDAwEDAAAAAAAAAAADAQMAAAAAAADwPwMFDAUMAAEOAAAFARMEAgoBAQEBAQIAAAAAAQUBBgQCCAUMCwYHCQMbDgEKAgYFDBEABQoDAQMAAAAAAADwPwMCCQMqDgEBAwAAAAAAAAAAAwUMAgsFDAUMBQwAAAAA"
h3d_shader_LineShader.SRC = "HXSLFWgzZC5zaGFkZXIuTGluZVNoYWRlcgwBBmNhbWVyYQ0BAwIEdmlldwcAAQADBHByb2oHAAEABAh2aWV3UHJvagcAAQAAAAAFBmdsb2JhbA0CAgYJcGl4ZWxTaXplBQoABQAHCW1vZGVsVmlldwcABQEDAAAACAVpbnB1dA0DAwkIcG9zaXRpb24FCwEIAAoGbm9ybWFsBQsBCAALAnV2BQoBCAABAAAMBm91dHB1dA0EAQ0IcG9zaXRpb24FDAQMAAQAAA4RdHJhbnNmb3JtZWROb3JtYWwFCwQAAA8TdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAAEBFwcm9qZWN0ZWRQb3NpdGlvbgUMBAAAEQtsZW5ndGhTY2FsZQMCAAASBXdpZHRoAwIAABMEcGRpcgUMBAAAFAhfX2luaXRfXw4GAAAVBnZlcnRleA4GAAACAhQAAAUBBQUIFgNkaXIFCwQAAAYBAgoFCwkDMg4BAgcHBgULAAYEAhMFDAYBCQMqDgIGAQIWBQsJAzIOAQICBwYFCwEDAAAAAAAA8D8DBQwCAwcFDAUMBoEKAhMFDBEABQoGAgEDAAAAAAAA8D8DCQMNDgEGAAYBCgITBQwAAAMKAhMFDAAAAwMGAQoCEwUMBAADCgITBQwEAAMDAwMDBQoGgAIPBQsGAQYBAhYFCwoCCwUKAAADBQsCEQMFCwULBgQCDgULCQMfDgECFgULBQsFCwAAABUAAAUBBoAKAhAFDBEABQoGAQYBBgEGAQQGAQoCEwUMBQAFCgkDKA4CAQMAAAAAAADwPwMBAwAAAAAAAPC/AwUKBQoFCgQGAwoCCwUKBAADAQMAAAAAAADgPwMDAwUKCgIQBQwIAAMFCgIGBQoFCgISAwUKBQoA"
h3d_shader_MinMaxShader.SRC = "HXSLF2gzZC5zaGFkZXIuTWluTWF4U2hhZGVyCwEFaW5wdXQNAQICCHBvc2l0aW9uBQoBAQADAnV2BQoBAQABAAAEBWZsaXBZAwIAAAUGb3V0cHV0DQICBghwb3NpdGlvbgUMBAUABwVjb2xvcgUMBAUABAAACApwaXhlbENvbG9yBQwEAAAJDGNhbGN1bGF0ZWRVVgUKBAAACgR0ZXhBCgIAAAsEdGV4QgoCAAAMBWlzTWF4AgIAAQAAAAAADQhfX2luaXRfXw4GAAAOBnZlcnRleA4GAAAPCGZyYWdtZW50DgYAAAMCDQAABQIGBAIHBQwCCAUMBQwGBAIJBQoCAwUKBQoAAA4AAAUBBgQCBgUMCQMqDgQKAgIFCgAAAwYBCgICBQoEAAMCBAMDAQMAAAAAAAAAAAMBAwAAAAAAAPA/AwUMBQwAAQ8AAAUDCBABYQUMBAAACQMhDgICCgoCCQUKBQwACBEBYgUMBAAACQMhDgICCwoCCQUKBQwABgQCCAUMCwIMAgkDFg4CAhAFDAIRBQwFDAkDFQ4CAhAFDAIRBQwFDAUMBQwA"
h3d_shader_CubeMinMaxShader.SRC = "HXSLG2gzZC5zaGFkZXIuQ3ViZU1pbk1heFNoYWRlcgwBBWlucHV0DQECAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEAAQAABAVmbGlwWQMCAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgKcGl4ZWxDb2xvcgUMBAAACQxjYWxjdWxhdGVkVVYFCgQAAAoEdGV4QQwCAAALBHRleEIMAgAADAVpc01heAICAAEAAAAAAA0DbWF0BgIAAA4IX19pbml0X18OBgAADwZ2ZXJ0ZXgOBgAAEAhmcmFnbWVudA4GAAADAg4AAAUCBgQCBwUMAggFDAUMBgQCCQUKAgMFCgUKAAAPAAAFAQYEAgYFDAkDKg4ECgICBQoAAAMGAQoCAgUKBAADAgQDAwEDAAAAAAAAAAADAQMAAAAAAADwPwMFDAUMAAEQAAAFBQgRAnV2BQoEAAAGAwYBAgkFCgEDAAAAAAAAAEADBQoBAwAAAAAAAPA/AwUKAAgSA2RpcgULBAAABgEJAykOAgIRBQoBAwAAAAAAAPA/AwULAg0GBQsACBMBYQUMBAAACQMhDgICCgwCEgULBQwACBQBYgUMBAAACQMhDgICCwwCEgULBQwABgQCCAUMCwIMAgkDFg4CAhMFDAIUBQwFDAkDFQ4CAhMFDAIUBQwFDAUMBQwA"
h3d_shader_NormalMap.SRC = "HXSLFGgzZC5zaGFkZXIuTm9ybWFsTWFwCgEGY2FtZXJhDQECAghwb3NpdGlvbgULAAEAAwNkaXIFCwMBAAAAAAQGZ2xvYmFsDQIBBQltb2RlbFZpZXcHAAQBAwAAAAYFaW5wdXQNAwIHBm5vcm1hbAULAQYACAd0YW5nZW50BQsBBgABAAAJB3RleHR1cmUKAgAACgxjYWxjdWxhdGVkVVYFCgQAAAsTdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAADBF0cmFuc2Zvcm1lZE5vcm1hbAULBAAADRJ0cmFuc2Zvcm1lZFRhbmdlbnQFDAMAAA4OX19pbml0X192ZXJ0ZXgOBgAADwhmcmFnbWVudA4GAAACAg4AAAUBBgQCDQUMCQMqDgIGAQIIBQsJAzIOAQIFBwYFCwsGBwkDHQ4CAggFCwIIBQsDAQMAAAAAAADgPwMCAQMAAAAAAADwPwMBAwAAAAAAAPC/AwMFDAUMAAEPAAAFBQgQAW4FCwQAAAIMBQsACBECbmYFCwQAAAkDOQ4BCQMhDgICCQoCCgUKBQwFCwAIEgR0YW5YBQsEAAAJAx8OAQoCDQUMkgAFCwULAAgTBHRhblkFCwQAAAYBCQMeDgICEAULAhIFCwULBwMKAg0FDAwAAwMFCwAGBAIMBQsJAx8OAQQGAAYABgEKAhEFCwAAAwISBQsFCwYBCgIRBQsEAAMCEwULBQsFCwYBCgIRBQsIAAMCEAULBQsFCwULBQsFCwA"
h3d_shader_Shadow.SRC = "HXSLEWgzZC5zaGFkZXIuU2hhZG93BgEGc2hhZG93DQEFAgNtYXARAQABAAMEcHJvaggAAQAEBWNvbG9yBQsAAQAFBXBvd2VyAwABAAYEYmlhcwMAAQAAAAAHCnBpeGVsQ29sb3IFDAQAAAgTdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAACRhwaXhlbFRyYW5zZm9ybWVkUG9zaXRpb24FCwQAAAoJc2hhZG93UG9zBQsDAAEBCwhmcmFnbWVudA4GAAABAQsAAAUGCAwJc2hhZG93UG9zBQsEAAAGAQIJBQsCAwgFCwAIDQVkZXB0aAMEAAAJAz8OAgICEQEJAzoOAQoCDAULEQAFCgUKAwAIDgR6TWF4AwQAAAkDNQ4BCgIMBQsIAAMDAAgPBWRlbHRhAwQAAAYDCQMVDgIEBgACDQMCBgMDAwIOAwMCDgMDAAgQBXNoYWRlAwQAAAkDNQ4BCQMJDgEGAQIFAwIPAwMDAwAGgQoCBwUMkgAFCwYABgEEBgMBAwAAAAAAAPA/AwIQAwMDCgIEBQuSAAULBQsCEAMFCwULAA"
h3d_shader_SkinBase.SRC = "HXSLE2gzZC5zaGFkZXIuU2tpbkJhc2UFARByZWxhdGl2ZVBvc2l0aW9uBQsEAAACE3RyYW5zZm9ybWVkUG9zaXRpb24FCwQAAAMRdHJhbnNmb3JtZWROb3JtYWwFCwQAAAQITWF4Qm9uZXMBAgABAAAAAAAFDWJvbmVzTWF0cml4ZXMPCAQCAAEIAA"
h3d_shader_Skin.SRC = "HXSLD2gzZC5zaGFkZXIuU2tpbggBEHJlbGF0aXZlUG9zaXRpb24FCwQAAAITdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAAAxF0cmFuc2Zvcm1lZE5vcm1hbAULBAAABAhNYXhCb25lcwECAAEAAAAAAAUNYm9uZXNNYXRyaXhlcw8IBAIAAQgGBWlucHV0DQEEBwhwb3NpdGlvbgULAQYACAZub3JtYWwFCwEGAAkHd2VpZ2h0cwULAQYACgdpbmRleGVzCQQAAAABBgABAAALEnRyYW5zZm9ybWVkVGFuZ2VudAUMBAAADAZ2ZXJ0ZXgOBgAAAQAMAAAFAgYEAgIFCwYABgAGAQQGAQIBBQsRAgUPCAQKAgoJBAAAAAAAAQgFCwULCgIJBQsAAAMFCwYBBAYBAgEFCxECBQ8IBAoCCgkEAAAABAABCAULBQsKAgkFCwQAAwULBQsGAQQGAQIBBQsRAgUPCAQKAgoJBAAAAAgAAQgFCwULCgIJBQsIAAMFCwULBQsGBAIDBQsJAx8OAQYABgAGAQQGAQIIBQsJAzIOARECBQ8IBAoCCgkEAAAAAAABCAYFCwULCgIJBQsAAAMFCwYBBAYBAggFCwkDMg4BEQIFDwgECgIKCQQAAAAEAAEIBgULBQsKAgkFCwQAAwULBQsGAQQGAQIIBQsJAzIOARECBQ8IBAoCCgkEAAAACAABCAYFCwULCgIJBQsIAAMFCwULBQsFCwA"
h3d_shader_SkinTangent.SRC = "HXSLFmgzZC5zaGFkZXIuU2tpblRhbmdlbnQIARByZWxhdGl2ZVBvc2l0aW9uBQsEAAACE3RyYW5zZm9ybWVkUG9zaXRpb24FCwQAAAMRdHJhbnNmb3JtZWROb3JtYWwFCwQAAAQITWF4Qm9uZXMBAgABAAAAAAAFDWJvbmVzTWF0cml4ZXMPCAQCAAEIBgVpbnB1dA0BBQcIcG9zaXRpb24FCwEGAAgGbm9ybWFsBQsBBgAJB3RhbmdlbnQFCwEGAAoHd2VpZ2h0cwULAQYACwdpbmRleGVzCQQAAAABBgABAAAMEnRyYW5zZm9ybWVkVGFuZ2VudAUMBAAADQZ2ZXJ0ZXgOBgAAAQANAAAFAwYEAgIFCwYABgAGAQQGAQIBBQsRAgUPCAQKAgsJBAAAAAAAAQgFCwULCgIKBQsAAAMFCwYBBAYBAgEFCxECBQ8IBAoCCwkEAAAABAABCAULBQsKAgoFCwQAAwULBQsGAQQGAQIBBQsRAgUPCAQKAgsJBAAAAAgAAQgFCwULCgIKBQsIAAMFCwULBQsGBAIDBQsJAx8OAQYABgAGAQQGAQIIBQsJAzIOARECBQ8IBAoCCwkEAAAAAAABCAYFCwULCgIKBQsAAAMFCwYBBAYBAggFCwkDMg4BEQIFDwgECgILCQQAAAAEAAEIBgULBQsKAgoFCwQAAwULBQsGAQQGAQIIBQsJAzIOARECBQ8IBAoCCwkEAAAACAABCAYFCwULCgIKBQsIAAMFCwULBQsFCwYEAgwFDAkDKg4CCQMfDgEGAAYABgEEBgEKAgkFC5IABQsJAzIOARECBQ8IBAoCCwkEAAAAAAABCAYFCwULCgIKBQsAAAMFCwYBBAYBCgIJBQuSAAULCQMyDgERAgUPCAQKAgsJBAAAAAQAAQgGBQsFCwoCCgULBAADBQsFCwYBBAYBCgIJBQuSAAULCQMyDgERAgUPCAQKAgsJBAAAAAgAAQgGBQsFCwoCCgULCAADBQsFCwULCgIMBQwMAAMFDAUMAA"
h3d_shader_SpecularTexture.SRC = "HXSLGmgzZC5zaGFkZXIuU3BlY3VsYXJUZXh0dXJlBAEHdGV4dHVyZQoCAAACDGNhbGN1bGF0ZWRVVgUKBAAAAwlzcGVjQ29sb3IFCwQAAAQIZnJhZ21lbnQOBgAAAQEEAAAFAQaBAgMFCwoJAyEOAgIBCgICBQoFDJIABQsFCwA"
h3d_shader_Texture.SRC = "HXSLEmgzZC5zaGFkZXIuVGV4dHVyZQsBBWlucHV0DQEBAgJ1dgUKAQEAAQAAAwhhZGRpdGl2ZQICAAEAAAAAAAQJa2lsbEFscGhhAgIAAQAAAAAABQ1zcGVjdWxhckFscGhhAgIAAQAAAAAABhJraWxsQWxwaGFUaHJlc2hvbGQDAgABBwAAAAAAAAAAAAAAAAAA8D8HB3RleHR1cmUKAgAACAxjYWxjdWxhdGVkVVYFCgQAAAkKcGl4ZWxDb2xvcgUMBAAACglzcGVjQ29sb3IFCwQAAAsGdmVydGV4DgYAAAwIZnJhZ21lbnQOBgAAAgALAAAFAQYEAggFCgICBQoFCgABDAAABQQIDQFjBQwEAAAJAyEOAgIHCgIIBQoFDAALBg4CBAIGCQYDCgINBQwMAAMCBgMDAQMAAAAAAAAAAAMCAgwAAAALAgMCBoACCQUMAg0FDAUMBoECCQUMAg0FDAUMAAsCBQIGgQIKBQsKAg0FDP4ABQsFCwAAAA"
h3d_shader_UVDelta.SRC = "HXSLEmgzZC5zaGFkZXIuVVZEZWx0YQQBB3V2RGVsdGEFCgIAAAIHdXZTY2FsZQUKAgAAAwxjYWxjdWxhdGVkVVYFCgQAAAQGdmVydGV4DgYAAAEABAAABQEGBAIDBQoGAAYBAgMFCgICBQoFCgIBBQoFCgUKAA"
h3d_shader_VertexColorAlpha.SRC = "HXSLG2gzZC5zaGFkZXIuVmVydGV4Q29sb3JBbHBoYQQBBWlucHV0DQEBAgVjb2xvcgUMAQEAAQAAAwpwaXhlbENvbG9yBQwEAAAECGFkZGl0aXZlAgIAAQAAAAAABQhmcmFnbWVudA4GAAABAQUAAAUBCwIEAgaAAgMFDAICBQwFDAaBAgMFDAICBQwFDAAA"
h3d_shader_VolumeDecal.SRC = "HXSLFmgzZC5zaGFkZXIuVm9sdW1lRGVjYWwYAQZjYW1lcmENAQoCBHZpZXcHAAEAAwRwcm9qBwABAAQIcG9zaXRpb24FCwABAAUIcHJvakZsaXADAAEABghwcm9qRGlhZwULAAEABwh2aWV3UHJvagcAAQAID2ludmVyc2VWaWV3UHJvagcAAQAJBXpOZWFyAwABAAoEekZhcgMAAQALA2RpcgULAwEAAAAADAZnbG9iYWwNAgQNBHRpbWUDAAwADglwaXhlbFNpemUFCgAMAA8JbW9kZWxWaWV3BwAMAQMQEG1vZGVsVmlld0ludmVyc2UHAAwBAwAAABEFaW5wdXQNAwISCHBvc2l0aW9uBQsBEQATBm5vcm1hbAULAREAAQAAFAZvdXRwdXQNBAUVCHBvc2l0aW9uBQwEFAAWBWNvbG9yBQwEFAAXBWRlcHRoAwQUABgGbm9ybWFsBQsEFAAZCXdvcmxkRGlzdAMEFAAEAAAaEHJlbGF0aXZlUG9zaXRpb24FCwQAABsTdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAAHBhwaXhlbFRyYW5zZm9ybWVkUG9zaXRpb24FCwQAAB0RdHJhbnNmb3JtZWROb3JtYWwFCwQAAB4RcHJvamVjdGVkUG9zaXRpb24FDAQAAB8KcGl4ZWxDb2xvcgUMBAAAIAVkZXB0aAMEAAAhCHNjcmVlblVWBQoEAAAiCXNwZWNQb3dlcgMEAAAjCXNwZWNDb2xvcgULBAAAJAl3b3JsZERpc3QDBAAAJQhkZXB0aE1hcBEBAAAAJgVzY2FsZQUKAgAAJwZub3JtYWwFCwIAACgHdGFuZ2VudAULAgAAKQppc0NlbnRlcmVkAgIAAQAAAAAAKgxjYWxjdWxhdGVkVVYFCgQAACsSdHJhbnNmb3JtZWRUYW5nZW50BQwEAAAsDl9faW5pdF9fdmVydGV4DgYAAC0IZnJhZ21lbnQOBgAAAgIsAAAFAgYEAh0FCwkDHw4BBAYBAicFCwkDMg4BAg8HBgULBQsFCwULBgQCKwUMCQMqDgIJAx8OAQQGAQIoBQsJAzIOAQIPBwYFCwULBQsBAwAAAAAAAPA/AwUMBQwAAS0AAAUJCC4GbWF0cml4BwQAAAYBAggHAhAHBwAILwlzY3JlZW5Qb3MFCgQAAAYCCgIeBQwRAAUKCgIeBQwMAAMFCgAIMANydXYFDAQAAAkDKg4DAi8FCgkDPw4CAiURAQkDOg4BAi8FCgUKAwEDAAAAAAAA8D8DBQwACDEEd3BvcwUMBAAABgECMAUMAi4HBQwACDIEcHBvcwUMBAAABgECMAUMAggHBQwABgQCHAULBgIKAjIFDJIABQsKAjIFDAwAAwULBQsGBAIqBQoGAQImBQoEBgIKAjEFDBEABQoKAjEFDAwAAwUKBQoFCgUKCwIpAgaAAioFCgEDAAAAAAAA4D8DBQoAAAsGCQkDFQ4CCQMVDgIKAioFCgAAAwoCKgUKBAADAwkDFQ4CBgMBAwAAAAAAAPA/AwoCKgUKAAADAwYDAQMAAAAAAADwPwMKAioFCgQAAwMDAwEDAAAAAAAAAAADAgwAAAAA"
haxe_EntryPoint.pending = list()
haxe_EntryPoint.threadCount = 0
haxe_Serializer.USE_CACHE = False
haxe_Serializer.USE_ENUM_INDEX = False
haxe_Serializer.BASE64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:"
haxe_Serializer.BASE64_CODES = None
haxe_Unserializer.DEFAULT_RESOLVER = haxe__Unserializer_DefaultResolver()
haxe_Unserializer.BASE64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:"
haxe_Unserializer.CODES = None
haxe_crypto_Base64.CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
haxe_crypto_Base64.BYTES = haxe_io_Bytes.ofString(haxe_crypto_Base64.CHARS)
def _hx_init_haxe_io_FPHelper_i64tmp():
    def _hx_local_0():
        this1 = haxe__Int64____Int64(0,0)
        return this1
    return _hx_local_0()
haxe_io_FPHelper.i64tmp = _hx_init_haxe_io_FPHelper_i64tmp()
def _hx_init_haxe_xml_Parser_escapes():
    def _hx_local_0():
        h = haxe_ds_StringMap()
        h.h["lt"] = "<"
        h.h["gt"] = ">"
        h.h["amp"] = "&"
        h.h["quot"] = "\""
        h.h["apos"] = "'"
        return h
    return _hx_local_0()
haxe_xml_Parser.escapes = _hx_init_haxe_xml_Parser_escapes()
haxe_zip_InflateImpl.LEN_EXTRA_BITS_TBL = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, -1, -1]
haxe_zip_InflateImpl.LEN_BASE_VAL_TBL = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258]
haxe_zip_InflateImpl.DIST_EXTRA_BITS_TBL = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, -1, -1]
haxe_zip_InflateImpl.DIST_BASE_VAL_TBL = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577]
haxe_zip_InflateImpl.CODE_LENGTHS_POS = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
haxe_zip_InflateImpl.FIXED_HUFFMAN = None
hxd_Charset.ASCII = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
hxd_Charset.LATIN1 = "-"
hxd_Charset.CYRILLIC = ""
hxd_Charset.POLISH = ""
hxd_Charset.TURKISH = "I"
hxd_Charset.JP_KANA = ""
hxd_Charset.UNICODE_SPECIALS = ""
hxd_Charset.DEFAULT_CHARS = (HxOverrides.stringOrNull(hxd_Charset.ASCII) + HxOverrides.stringOrNull(hxd_Charset.LATIN1))
hxd_Key.BACKSPACE = 8
hxd_Key.TAB = 9
hxd_Key.ENTER = 13
hxd_Key.SHIFT = 16
hxd_Key.CTRL = 17
hxd_Key.ALT = 18
hxd_Key.ESCAPE = 27
hxd_Key.SPACE = 32
hxd_Key.PGUP = 33
hxd_Key.PGDOWN = 34
hxd_Key.END = 35
hxd_Key.HOME = 36
hxd_Key.LEFT = 37
hxd_Key.UP = 38
hxd_Key.RIGHT = 39
hxd_Key.DOWN = 40
hxd_Key.INSERT = 45
hxd_Key.DELETE = 46
hxd_Key.QWERTY_EQUALS = 187
hxd_Key.QWERTY_MINUS = 189
hxd_Key.QWERTY_TILDE = 192
hxd_Key.QWERTY_BRACKET_LEFT = 219
hxd_Key.QWERTY_BRACKET_RIGHT = 221
hxd_Key.QWERTY_SEMICOLON = 186
hxd_Key.QWERTY_QUOTE = 222
hxd_Key.QWERTY_BACKSLASH = 220
hxd_Key.QWERTY_COMMA = 188
hxd_Key.QWERTY_PERIOD = 190
hxd_Key.QWERTY_SLASH = 191
hxd_Key.INTL_BACKSLASH = 226
hxd_Key.LEFT_WINDOW_KEY = 91
hxd_Key.RIGHT_WINDOW_KEY = 92
hxd_Key.CONTEXT_MENU = 93
hxd_Key.PAUSE_BREAK = 19
hxd_Key.CAPS_LOCK = 20
hxd_Key.NUM_LOCK = 144
hxd_Key.SCROLL_LOCK = 145
hxd_Key.NUMBER_0 = 48
hxd_Key.NUMBER_1 = 49
hxd_Key.NUMBER_2 = 50
hxd_Key.NUMBER_3 = 51
hxd_Key.NUMBER_4 = 52
hxd_Key.NUMBER_5 = 53
hxd_Key.NUMBER_6 = 54
hxd_Key.NUMBER_7 = 55
hxd_Key.NUMBER_8 = 56
hxd_Key.NUMBER_9 = 57
hxd_Key.NUMPAD_0 = 96
hxd_Key.NUMPAD_1 = 97
hxd_Key.NUMPAD_2 = 98
hxd_Key.NUMPAD_3 = 99
hxd_Key.NUMPAD_4 = 100
hxd_Key.NUMPAD_5 = 101
hxd_Key.NUMPAD_6 = 102
hxd_Key.NUMPAD_7 = 103
hxd_Key.NUMPAD_8 = 104
hxd_Key.NUMPAD_9 = 105
hxd_Key.A = 65
hxd_Key.B = 66
hxd_Key.C = 67
hxd_Key.D = 68
hxd_Key.E = 69
hxd_Key.F = 70
hxd_Key.G = 71
hxd_Key.H = 72
hxd_Key.I = 73
hxd_Key.J = 74
hxd_Key.K = 75
hxd_Key.L = 76
hxd_Key.M = 77
hxd_Key.N = 78
hxd_Key.O = 79
hxd_Key.P = 80
hxd_Key.Q = 81
hxd_Key.R = 82
hxd_Key.S = 83
hxd_Key.T = 84
hxd_Key.U = 85
hxd_Key.V = 86
hxd_Key.W = 87
hxd_Key.X = 88
hxd_Key.Y = 89
hxd_Key.Z = 90
hxd_Key.F1 = 112
hxd_Key.F2 = 113
hxd_Key.F3 = 114
hxd_Key.F4 = 115
hxd_Key.F5 = 116
hxd_Key.F6 = 117
hxd_Key.F7 = 118
hxd_Key.F8 = 119
hxd_Key.F9 = 120
hxd_Key.F10 = 121
hxd_Key.F11 = 122
hxd_Key.F12 = 123
hxd_Key.F13 = 124
hxd_Key.F14 = 125
hxd_Key.F15 = 126
hxd_Key.F16 = 127
hxd_Key.F17 = 128
hxd_Key.F18 = 129
hxd_Key.F19 = 130
hxd_Key.F20 = 131
hxd_Key.F21 = 132
hxd_Key.F22 = 133
hxd_Key.F23 = 134
hxd_Key.F24 = 135
hxd_Key.NUMPAD_MULT = 106
hxd_Key.NUMPAD_ADD = 107
hxd_Key.NUMPAD_ENTER = 108
hxd_Key.NUMPAD_SUB = 109
hxd_Key.NUMPAD_DOT = 110
hxd_Key.NUMPAD_DIV = 111
hxd_Key.MOUSE_LEFT = 0
hxd_Key.MOUSE_RIGHT = 1
hxd_Key.MOUSE_MIDDLE = 2
hxd_Key.MOUSE_BACK = 3
hxd_Key.MOUSE_FORWARD = 4
hxd_Key.MOUSE_WHEEL_UP = 5
hxd_Key.MOUSE_WHEEL_DOWN = 6
hxd_Key.LOC_LEFT = 256
hxd_Key.LOC_RIGHT = 512
hxd_Key.LSHIFT = 272
hxd_Key.RSHIFT = 528
hxd_Key.LCTRL = 273
hxd_Key.RCTRL = 529
hxd_Key.LALT = 274
hxd_Key.RALT = 530
hxd_Key.initDone = False
hxd_Key.keyPressed = []
hxd_Key.ALLOW_KEY_REPEAT = False
hxd_Math.PI = 3.14159265358979323
hxd_Math.EPSILON = 1e-10
hxd__Pixels_Channel_Impl_.R = 0
hxd__Pixels_Channel_Impl_.G = 1
hxd__Pixels_Channel_Impl_.B = 2
hxd__Pixels_Channel_Impl_.A = 3
hxd_Pixels.S3TC_SIZES = [0, -1, 1, 1, -1, 1, 1, 1]
hxd_System.setCursor = hxd_System.setNativeCursor
hxd_Timer.wantedFPS = 60.
hxd_Timer.maxDeltaTime = 0.5
hxd_Timer.smoothFactor = 0.95
hxd_Timer.lastTimeStamp = python_lib_Timeit.default_timer()
hxd_Timer.elapsedTime = 0.
hxd_Timer.frameCount = 0
hxd_Timer.dt = (1 / hxd_Timer.wantedFPS)
hxd_Timer.currentDT = (1 / hxd_Timer.wantedFPS)
hxd_Window.inst = None
hxd_fmt_bfnt_Writer.VERSION = 1
hxd_fmt_hmd__Data_GeometryDataFormat_Impl_.DFloat = 1
hxd_fmt_hmd__Data_GeometryDataFormat_Impl_.DVec2 = 2
hxd_fmt_hmd__Data_GeometryDataFormat_Impl_.DVec3 = 3
hxd_fmt_hmd__Data_GeometryDataFormat_Impl_.DVec4 = 4
hxd_fmt_hmd__Data_GeometryDataFormat_Impl_.DBytes4 = 9
hxd_fmt_hmd_Position.QTMP = h3d_Quat()
hxd_fmt_hmd_Data.CURRENT_VERSION = 3
hxd_fmt_hmd_Reader.BLEND = Type.allEnums(h2d_BlendMode)
hxd_fmt_hmd_Reader.CULLING = Type.allEnums(h3d_mat_Face)
hxd_fs_Convert.converts = haxe_ds_StringMap()
hxd_fs_ConvertFBX2HMD._ = hxd_fs_Convert.register(hxd_fs_ConvertFBX2HMD())
hxd_fs_ConvertWAV2MP3._ = hxd_fs_Convert.register(hxd_fs_ConvertWAV2MP3())
hxd_fs_ConvertWAV2OGG._ = hxd_fs_Convert.register(hxd_fs_ConvertWAV2OGG())
hxd_fs_ConvertTGA2PNG._ = hxd_fs_Convert.register(hxd_fs_ConvertTGA2PNG())
hxd_fs_ConvertFNT2BFNT._ = hxd_fs_Convert.register(hxd_fs_ConvertFNT2BFNT())
hxd_fs_CompressIMG._ = hxd_fs_Convert.register(hxd_fs_CompressIMG("png,tga,jpg,jpeg","dds"))
hxd_fs_DummyConvert._ = [hxd_fs_Convert.register(hxd_fs_DummyConvert(None,"dummy")), hxd_fs_Convert.register(hxd_fs_DummyConvert(None,"remove"))]
hxd_fs_EmbedFileSystem.invalidChars = EReg("[^A-Za-z0-9_]","g")
hxd_fs_FileConverter.extraConfigs = []
hxd_fs_LocalEntry.WATCH_INDEX = 0
hxd_fs_LocalEntry.WATCH_LIST = None
hxd_fs_LocalEntry.tmpDir = None
hxd_fs_LocalFileSystem.isWindows = (Sys.systemName() == "Windows")
hxd_impl__Allocator_BufferFlags_Impl_.Dynamic = 0
hxd_impl__Allocator_BufferFlags_Impl_.UniformDynamic = 1
hxd_res_Resource.LIVE_UPDATE = False
hxd_res__Image_ImageFormat_Impl_.Jpg = 0
hxd_res__Image_ImageFormat_Impl_.Png = 1
hxd_res__Image_ImageFormat_Impl_.Gif = 2
hxd_res__Image_ImageFormat_Impl_.Tga = 3
hxd_res__Image_ImageFormat_Impl_.Dds = 4
hxd_res_Image.ALLOW_NPOT = True
hxd_res_Image.DEFAULT_FILTER = h3d_mat_Filter.Linear
hxd_res_Image.DEFAULT_ASYNC = False
hxd_res_Image.ENABLE_AUTO_WATCH = True
hxd_res_NanoJpeg.BLOCKSIZE = 64
hxd_res_NanoJpeg.W1 = 2841
hxd_res_NanoJpeg.W2 = 2676
hxd_res_NanoJpeg.W3 = 2408
hxd_res_NanoJpeg.W5 = 1609
hxd_res_NanoJpeg.W6 = 1108
hxd_res_NanoJpeg.W7 = 565
hxd_res_NanoJpeg.CF4A = -9
hxd_res_NanoJpeg.CF4B = 111
hxd_res_NanoJpeg.CF4C = 29
hxd_res_NanoJpeg.CF4D = -3
hxd_res_NanoJpeg.CF3A = 28
hxd_res_NanoJpeg.CF3B = 109
hxd_res_NanoJpeg.CF3C = -9
hxd_res_NanoJpeg.CF3X = 104
hxd_res_NanoJpeg.CF3Y = 27
hxd_res_NanoJpeg.CF3Z = -3
hxd_res_NanoJpeg.CF2A = 139
hxd_res_NanoJpeg.CF2B = -11
hxd_res_NanoJpeg.inst = None
hxd_res_Sound.ENABLE_AUTO_WATCH = True
hxd_snd_Channel.ID = 0
hxd_snd_Source.ID = 0
hxd_snd_Manager.STREAM_DURATION = 5.
hxd_snd_Manager.STREAM_BUFFER_SAMPLE_COUNT = 44100
hxd_snd_Manager.BUFFER_QUEUE_LENGTH = 2
hxd_snd_Manager.MAX_SOURCES = 16
hxd_snd_Manager.SOUND_BUFFER_CACHE_SIZE = 256
hxd_snd_Manager.VIRTUAL_VOLUME_THRESHOLD = 1e-5
hxd_snd_Manager.BUFFER_STREAM_SPLIT = 16
hxd_snd_openal__Emulator_Channel.FADE_START = 10
hxd_snd_openal_Source.STOP_DELAY = 0
hxd_snd_openal_Source.CHANNEL_BUFSIZE = 4096
hxd_snd_openal_Source.ID = 0
hxd_snd_openal_Source.all = haxe_ds_IntMap()
hxd_snd_openal_Buffer.ID = 0
hxd_snd_openal_Buffer.all = haxe_ds_IntMap()
hxd_snd_openal_Emulator.FORMAT_MONOF32 = 4368
hxd_snd_openal_Emulator.FORMAT_STEREOF32 = 4369
hxd_snd_openal_Emulator.NONE = 0
hxd_snd_openal_Emulator.FALSE = 0
hxd_snd_openal_Emulator.TRUE = 1
hxd_snd_openal_Emulator.SOURCE_RELATIVE = 514
hxd_snd_openal_Emulator.CONE_INNER_ANGLE = 4097
hxd_snd_openal_Emulator.CONE_OUTER_ANGLE = 4098
hxd_snd_openal_Emulator.PITCH = 4099
hxd_snd_openal_Emulator.POSITION = 4100
hxd_snd_openal_Emulator.DIRECTION = 4101
hxd_snd_openal_Emulator.VELOCITY = 4102
hxd_snd_openal_Emulator.LOOPING = 4103
hxd_snd_openal_Emulator.BUFFER = 4105
hxd_snd_openal_Emulator.GAIN = 4106
hxd_snd_openal_Emulator.MIN_GAIN = 4109
hxd_snd_openal_Emulator.MAX_GAIN = 4110
hxd_snd_openal_Emulator.ORIENTATION = 4111
hxd_snd_openal_Emulator.SOURCE_STATE = 4112
hxd_snd_openal_Emulator.INITIAL = 4113
hxd_snd_openal_Emulator.PLAYING = 4114
hxd_snd_openal_Emulator.PAUSED = 4115
hxd_snd_openal_Emulator.STOPPED = 4116
hxd_snd_openal_Emulator.BUFFERS_QUEUED = 4117
hxd_snd_openal_Emulator.BUFFERS_PROCESSED = 4118
hxd_snd_openal_Emulator.REFERENCE_DISTANCE = 4128
hxd_snd_openal_Emulator.ROLLOFF_FACTOR = 4129
hxd_snd_openal_Emulator.CONE_OUTER_GAIN = 4130
hxd_snd_openal_Emulator.MAX_DISTANCE = 4131
hxd_snd_openal_Emulator.SEC_OFFSET = 4132
hxd_snd_openal_Emulator.SAMPLE_OFFSET = 4133
hxd_snd_openal_Emulator.BYTE_OFFSET = 4134
hxd_snd_openal_Emulator.SOURCE_TYPE = 4135
hxd_snd_openal_Emulator.STATIC = 4136
hxd_snd_openal_Emulator.STREAMING = 4137
hxd_snd_openal_Emulator.UNDETERMINED = 4144
hxd_snd_openal_Emulator.FORMAT_MONO8 = 4352
hxd_snd_openal_Emulator.FORMAT_MONO16 = 4353
hxd_snd_openal_Emulator.FORMAT_STEREO8 = 4354
hxd_snd_openal_Emulator.FORMAT_STEREO16 = 4355
hxd_snd_openal_Emulator.FREQUENCY = 8193
hxd_snd_openal_Emulator.BITS = 8194
hxd_snd_openal_Emulator.CHANNELS = 8195
hxd_snd_openal_Emulator.SIZE = 8196
hxd_snd_openal_Emulator.UNUSED = 8208
hxd_snd_openal_Emulator.PENDING = 8209
hxd_snd_openal_Emulator.PROCESSED = 8210
hxd_snd_openal_Emulator.NO_ERROR = 0
hxd_snd_openal_Emulator.INVALID_NAME = 40961
hxd_snd_openal_Emulator.INVALID_ENUM = 40962
hxd_snd_openal_Emulator.INVALID_VALUE = 40963
hxd_snd_openal_Emulator.INVALID_OPERATION = 40964
hxd_snd_openal_Emulator.OUT_OF_MEMORY = 40965
hxd_snd_openal_Emulator.VENDOR = 45057
hxd_snd_openal_Emulator.VERSION = 45058
hxd_snd_openal_Emulator.RENDERER = 45059
hxd_snd_openal_Emulator.EXTENSIONS = 45060
hxd_snd_openal_Emulator.DOPPLER_FACTOR = 49152
hxd_snd_openal_Emulator.DOPPLER_VELOCITY = 49153
hxd_snd_openal_Emulator.SPEED_OF_SOUND = 49155
hxd_snd_openal_Emulator.DISTANCE_MODEL = 53248
hxd_snd_openal_Emulator.INVERSE_DISTANCE = 53249
hxd_snd_openal_Emulator.INVERSE_DISTANCE_CLAMPED = 53250
hxd_snd_openal_Emulator.LINEAR_DISTANCE = 53251
hxd_snd_openal_Emulator.LINEAR_DISTANCE_CLAMPED = 53252
hxd_snd_openal_Emulator.EXPONENT_DISTANCE = 53253
hxd_snd_openal_Emulator.EXPONENT_DISTANCE_CLAMPED = 53254
hxd_snd_openal_ALC.ctx = None
hxd_snd_openal_ALC.FALSE = 0
hxd_snd_openal_ALC.TRUE = 1
hxd_snd_openal_ALC.FREQUENCY = 4103
hxd_snd_openal_ALC.REFRESH = 4104
hxd_snd_openal_ALC.SYNC = 4105
hxd_snd_openal_ALC.MONO_SOURCES = 4112
hxd_snd_openal_ALC.STEREO_SOURCES = 4113
hxd_snd_openal_ALC.NO_ERROR = 0
hxd_snd_openal_ALC.INVALID_DEVICE = 40961
hxd_snd_openal_ALC.INVALID_CONTEXT = 40962
hxd_snd_openal_ALC.INVALID_ENUM = 40963
hxd_snd_openal_ALC.INVALID_VALUE = 40964
hxd_snd_openal_ALC.OUT_OF_MEMORY = 40965
hxd_snd_openal_ALC.MAJOR_VERSION = 4096
hxd_snd_openal_ALC.MINOR_VERSION = 4097
hxd_snd_openal_ALC.ATTRIBUTES_SIZE = 4098
hxd_snd_openal_ALC.ALL_ATTRIBUTES = 4099
hxd_snd_openal_ALC.DEFAULT_DEVICE_SPECIFIER = 4100
hxd_snd_openal_ALC.DEVICE_SPECIFIER = 4101
hxd_snd_openal_ALC.EXTENSIONS = 4102
hxd_snd_openal_ALC.EXT_CAPTURE = 1
hxd_snd_openal_ALC.CAPTURE_DEVICE_SPECIFIER = 784
hxd_snd_openal_ALC.CAPTURE_DEFAULT_DEVICE_SPECIFIER = 785
hxd_snd_openal_ALC.CAPTURE_SAMPLES = 786
hxd_snd_openal_ALC.ENUMERATE_ALL_EXT = 1
hxd_snd_openal_ALC.DEFAULT_ALL_DEVICES_SPECIFIER = 4114
hxd_snd_openal_ALC.ALL_DEVICES_SPECIFIER = 4115
hxd_snd_openal_EFX.EFX_MAJOR_VERSION = 131073
hxd_snd_openal_EFX.EFX_MINOR_VERSION = 131074
hxd_snd_openal_EFX.MAX_AUXILIARY_SENDS = 131075
hxd_snd_openal_EFX.METERS_PER_UNIT = 131076
hxd_snd_openal_EFX.DIRECT_FILTER = 131077
hxd_snd_openal_EFX.FILTER_NULL = 0
hxsl_Tools.UID = 0
hxsl_Tools.SWIZ = Type.allEnums(hxsl_Component)
hxsl_Tools.MAX_CHANNELS_BITS = 3
hxsl_BatchShader.SRC = "HXSLEGh4c2wuQmF0Y2hTaGFkZXICAQtCYXRjaF9Db3VudAECAAEAAAABAAIMQmF0Y2hfQnVmZmVyEAUMAQIAAAA"
hxsl__Linker_ShaderInfos.UID = 0
hxsl_Printer.SWIZ = ["x", "y", "z", "w"]
hxsl_RuntimeShader.UID = 0
hxsl_Serializer.TVECS = haxe_ds_IntMap()
def _hx_init_hxsl_Serializer_BOPS():
    def _hx_local_0():
        ops = Type.allEnums(haxe_macro_Binop)
        pos = haxe_macro_Binop.OpAssignOp(None).index
        ops.insert(pos, None)
        return ops
    return _hx_local_0()
hxsl_Serializer.BOPS = _hx_init_hxsl_Serializer_BOPS()
hxsl_Serializer.UNOPS = Type.allEnums(haxe_macro_Unop)
hxsl_Serializer.TGLOBALS = Type.allEnums(hxsl_TGlobal)
hxsl_Serializer.TSWIZ = haxe_ds_IntMap()
hxsl_Serializer.REGS = [hxsl_Component.X, hxsl_Component.Y, hxsl_Component.Z, hxsl_Component.W]
hxsl_Serializer.VKINDS = Type.allEnums(hxsl_VarKind)
hxsl_Serializer.PRECS = Type.allEnums(hxsl_Prec)
hxsl_Serializer.FKIND = Type.allEnums(hxsl_FunctionKind)
hxsl_Serializer.SIGN = 9139229
hxsl_SharedShader.UNROLL_LOOPS = False
python_Lib.lineEnd = ("\r\n" if ((Sys.systemName() == "Windows")) else "\n")

Main.main()
haxe_EntryPoint.run()
